! This file is automatically generated by cfwrapper.py 
! Please do not modify 
! GNU General Public License version 3 

!   GType atk_state_set_get_type (void);
function atk_state_set_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_state_set_get_type
end function

!  AtkStateSet* atk_state_set_new (void);
function atk_state_set_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_state_set_new
end function

! gboolean atk_state_set_is_empty (AtkStateSet *set);
function atk_state_set_is_empty(set) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: atk_state_set_is_empty
  type(c_ptr), value :: set
end function

! gboolean atk_state_set_add_state (AtkStateSet *set, AtkStateType type);
function atk_state_set_add_state(set, type) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_state_set_add_state
  type(c_ptr), value :: set
  integer(c_int), value :: type
end function

! void atk_state_set_add_states (AtkStateSet *set, AtkStateType *types, gint n_types);
subroutine atk_state_set_add_states(set, types, n_types) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: set
  integer(c_int), value :: types
  integer(c_int), value :: n_types
end subroutine

! void atk_state_set_clear_states (AtkStateSet *set);
subroutine atk_state_set_clear_states(set) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: set
end subroutine

! gboolean atk_state_set_contains_state (AtkStateSet *set, AtkStateType type);
function atk_state_set_contains_state(set, type) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_state_set_contains_state
  type(c_ptr), value :: set
  integer(c_int), value :: type
end function

! gboolean atk_state_set_contains_states (AtkStateSet *set, AtkStateType *types, gint n_types);
function atk_state_set_contains_states(set, types, n_types) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_state_set_contains_states
  type(c_ptr), value :: set
  integer(c_int), value :: types
  integer(c_int), value :: n_types
end function

! gboolean atk_state_set_remove_state (AtkStateSet *set, AtkStateType type);
function atk_state_set_remove_state(set, type) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_state_set_remove_state
  type(c_ptr), value :: set
  integer(c_int), value :: type
end function

! AtkStateSet* atk_state_set_and_sets (AtkStateSet *set, AtkStateSet *compare_set);
function atk_state_set_and_sets(set, compare_set) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_state_set_and_sets
  type(c_ptr), value :: set
  type(c_ptr), value :: compare_set
end function

! AtkStateSet* atk_state_set_or_sets (AtkStateSet *set, AtkStateSet *compare_set);
function atk_state_set_or_sets(set, compare_set) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_state_set_or_sets
  type(c_ptr), value :: set
  type(c_ptr), value :: compare_set
end function

! AtkStateSet* atk_state_set_xor_sets (AtkStateSet *set, AtkStateSet *compare_set);
function atk_state_set_xor_sets(set, compare_set) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_state_set_xor_sets
  type(c_ptr), value :: set
  type(c_ptr), value :: compare_set
end function

!   GType atk_relation_set_get_type (void);
function atk_relation_set_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_relation_set_get_type
end function

!  AtkRelationSet* atk_relation_set_new (void);
function atk_relation_set_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_relation_set_new
end function

! gboolean atk_relation_set_contains (AtkRelationSet *set, AtkRelationType relationship);
function atk_relation_set_contains(set, relationship) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_relation_set_contains
  type(c_ptr), value :: set
  integer(c_int), value :: relationship
end function

! void atk_relation_set_remove (AtkRelationSet *set, AtkRelation *relation);
subroutine atk_relation_set_remove(set, relation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: set
  type(c_ptr), value :: relation
end subroutine

! void atk_relation_set_add (AtkRelationSet *set, AtkRelation *relation);
subroutine atk_relation_set_add(set, relation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: set
  type(c_ptr), value :: relation
end subroutine

! gint atk_relation_set_get_n_relations (AtkRelationSet *set);
function atk_relation_set_get_n_relations(set) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_relation_set_get_n_relations
  type(c_ptr), value :: set
end function

! AtkRelation* atk_relation_set_get_relation (AtkRelationSet *set, gint i);
function atk_relation_set_get_relation(set, i) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_relation_set_get_relation
  type(c_ptr), value :: set
  integer(c_int), value :: i
end function

! AtkRelation* atk_relation_set_get_relation_by_type (AtkRelationSet *set, AtkRelationType relationship);
function atk_relation_set_get_relation_by_type(set, relationship) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_relation_set_get_relation_by_type
  type(c_ptr), value :: set
  integer(c_int), value :: relationship
end function

! void atk_relation_set_add_relation_by_type (AtkRelationSet *set, AtkRelationType relationship, AtkObject *target);
subroutine atk_relation_set_add_relation_by_type(set, relationship, target) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: set
  integer(c_int), value :: relationship
  type(c_ptr), value :: target
end subroutine

!   GType atk_table_get_type (void);
function atk_table_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_table_get_type
end function

!  AtkObject* atk_table_ref_at (AtkTable *table, gint row, gint column);
function atk_table_ref_at(table, row, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_table_ref_at
  type(c_ptr), value :: table
  integer(c_int), value :: row
  integer(c_int), value :: column
end function

! gint atk_table_get_index_at (AtkTable *table, gint row, gint column);
function atk_table_get_index_at(table, row, column) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_table_get_index_at
  type(c_ptr), value :: table
  integer(c_int), value :: row
  integer(c_int), value :: column
end function

! gint atk_table_get_column_at_index (AtkTable *table, gint index_);
function atk_table_get_column_at_index(table, index_) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_table_get_column_at_index
  type(c_ptr), value :: table
  integer(c_int), value :: index_
end function

! gint atk_table_get_row_at_index (AtkTable *table, gint index_);
function atk_table_get_row_at_index(table, index_) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_table_get_row_at_index
  type(c_ptr), value :: table
  integer(c_int), value :: index_
end function

! gint atk_table_get_n_columns (AtkTable *table);
function atk_table_get_n_columns(table) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_table_get_n_columns
  type(c_ptr), value :: table
end function

! gint atk_table_get_n_rows (AtkTable *table);
function atk_table_get_n_rows(table) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_table_get_n_rows
  type(c_ptr), value :: table
end function

! gint atk_table_get_column_extent_at (AtkTable *table, gint row, gint column);
function atk_table_get_column_extent_at(table, row, column) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_table_get_column_extent_at
  type(c_ptr), value :: table
  integer(c_int), value :: row
  integer(c_int), value :: column
end function

! gint atk_table_get_row_extent_at (AtkTable *table, gint row, gint column);
function atk_table_get_row_extent_at(table, row, column) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_table_get_row_extent_at
  type(c_ptr), value :: table
  integer(c_int), value :: row
  integer(c_int), value :: column
end function

! AtkObject* atk_table_get_caption (AtkTable *table);
function atk_table_get_caption(table) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_table_get_caption
  type(c_ptr), value :: table
end function

! G_CONST_RETURN gchar* atk_table_get_column_description (AtkTable *table, gint column);
function atk_table_get_column_description(table, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_table_get_column_description
  type(c_ptr), value :: table
  integer(c_int), value :: column
end function

! AtkObject* atk_table_get_column_header (AtkTable *table, gint column);
function atk_table_get_column_header(table, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_table_get_column_header
  type(c_ptr), value :: table
  integer(c_int), value :: column
end function

! G_CONST_RETURN gchar* atk_table_get_row_description (AtkTable *table, gint row);
function atk_table_get_row_description(table, row) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_table_get_row_description
  type(c_ptr), value :: table
  integer(c_int), value :: row
end function

! AtkObject* atk_table_get_row_header (AtkTable *table, gint row);
function atk_table_get_row_header(table, row) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_table_get_row_header
  type(c_ptr), value :: table
  integer(c_int), value :: row
end function

! AtkObject* atk_table_get_summary (AtkTable *table);
function atk_table_get_summary(table) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_table_get_summary
  type(c_ptr), value :: table
end function

! void atk_table_set_caption (AtkTable *table, AtkObject *caption);
subroutine atk_table_set_caption(table, caption) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: table
  type(c_ptr), value :: caption
end subroutine

! void atk_table_set_column_description (AtkTable *table, gint column, const gchar *description);
subroutine atk_table_set_column_description(table, column, description) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: table
  integer(c_int), value :: column
  character(kind=c_char), dimension(*) :: description
end subroutine

! void atk_table_set_column_header (AtkTable *table, gint column, AtkObject *header);
subroutine atk_table_set_column_header(table, column, header) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: table
  integer(c_int), value :: column
  type(c_ptr), value :: header
end subroutine

! void atk_table_set_row_description (AtkTable *table, gint row, const gchar *description);
subroutine atk_table_set_row_description(table, row, description) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: table
  integer(c_int), value :: row
  character(kind=c_char), dimension(*) :: description
end subroutine

! void atk_table_set_row_header (AtkTable *table, gint row, AtkObject *header);
subroutine atk_table_set_row_header(table, row, header) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: table
  integer(c_int), value :: row
  type(c_ptr), value :: header
end subroutine

! void atk_table_set_summary (AtkTable *table, AtkObject *accessible);
subroutine atk_table_set_summary(table, accessible) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: table
  type(c_ptr), value :: accessible
end subroutine

! gint atk_table_get_selected_columns (AtkTable *table, gint **selected);
function atk_table_get_selected_columns(table, selected) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_table_get_selected_columns
  type(c_ptr), value :: table
  type(c_ptr), value :: selected
end function

! gint atk_table_get_selected_rows (AtkTable *table, gint **selected);
function atk_table_get_selected_rows(table, selected) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_table_get_selected_rows
  type(c_ptr), value :: table
  type(c_ptr), value :: selected
end function

! gboolean atk_table_is_column_selected (AtkTable *table, gint column);
function atk_table_is_column_selected(table, column) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_table_is_column_selected
  type(c_ptr), value :: table
  integer(c_int), value :: column
end function

! gboolean atk_table_is_row_selected (AtkTable *table, gint row);
function atk_table_is_row_selected(table, row) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_table_is_row_selected
  type(c_ptr), value :: table
  integer(c_int), value :: row
end function

! gboolean atk_table_is_selected (AtkTable *table, gint row, gint column);
function atk_table_is_selected(table, row, column) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_table_is_selected
  type(c_ptr), value :: table
  integer(c_int), value :: row
  integer(c_int), value :: column
end function

! gboolean atk_table_add_row_selection (AtkTable *table, gint row);
function atk_table_add_row_selection(table, row) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_table_add_row_selection
  type(c_ptr), value :: table
  integer(c_int), value :: row
end function

! gboolean atk_table_remove_row_selection (AtkTable *table, gint row);
function atk_table_remove_row_selection(table, row) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_table_remove_row_selection
  type(c_ptr), value :: table
  integer(c_int), value :: row
end function

! gboolean atk_table_add_column_selection (AtkTable *table, gint column);
function atk_table_add_column_selection(table, column) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_table_add_column_selection
  type(c_ptr), value :: table
  integer(c_int), value :: column
end function

! gboolean atk_table_remove_column_selection (AtkTable *table, gint column);
function atk_table_remove_column_selection(table, column) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_table_remove_column_selection
  type(c_ptr), value :: table
  integer(c_int), value :: column
end function

!   AtkTextAttribute atk_text_attribute_register (const gchar *name);
function atk_text_attribute_register(name) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: atk_text_attribute_register
  character(kind=c_char), dimension(*) :: name
end function

!  GType atk_text_get_type (void);
function atk_text_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_text_get_type
end function

!  gchar* atk_text_get_text (AtkText *text, gint start_offset, gint end_offset);
function atk_text_get_text(text, start_offset, end_offset) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_text_get_text
  type(c_ptr), value :: text
  integer(c_int), value :: start_offset
  integer(c_int), value :: end_offset
end function

! gunichar atk_text_get_character_at_offset (AtkText *text, gint offset);
function atk_text_get_character_at_offset(text, offset) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr, c_int
  integer(c_int32_t) :: atk_text_get_character_at_offset
  type(c_ptr), value :: text
  integer(c_int), value :: offset
end function

! gchar* atk_text_get_text_after_offset (AtkText *text, gint offset, AtkTextBoundary boundary_type, gint *start_offset, gint *end_offset);
function atk_text_get_text_after_offset(text, offset, boundary_type, start_offse&
      &t, end_offset) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_text_get_text_after_offset
  type(c_ptr), value :: text
  integer(c_int), value :: offset
  integer(c_int), value :: boundary_type
  type(c_ptr), value :: start_offset
  type(c_ptr), value :: end_offset
end function

! gchar* atk_text_get_text_at_offset (AtkText *text, gint offset, AtkTextBoundary boundary_type, gint *start_offset, gint *end_offset);
function atk_text_get_text_at_offset(text, offset, boundary_type, start_offset, &
      &end_offset) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_text_get_text_at_offset
  type(c_ptr), value :: text
  integer(c_int), value :: offset
  integer(c_int), value :: boundary_type
  type(c_ptr), value :: start_offset
  type(c_ptr), value :: end_offset
end function

! gchar* atk_text_get_text_before_offset (AtkText *text, gint offset, AtkTextBoundary boundary_type, gint *start_offset, gint *end_offset);
function atk_text_get_text_before_offset(text, offset, boundary_type, start_offs&
      &et, end_offset) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_text_get_text_before_offset
  type(c_ptr), value :: text
  integer(c_int), value :: offset
  integer(c_int), value :: boundary_type
  type(c_ptr), value :: start_offset
  type(c_ptr), value :: end_offset
end function

! gint atk_text_get_caret_offset (AtkText *text);
function atk_text_get_caret_offset(text) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_text_get_caret_offset
  type(c_ptr), value :: text
end function

! void atk_text_get_character_extents (AtkText *text, gint offset, gint *x, gint *y, gint *width, gint *height, AtkCoordType coords);
subroutine atk_text_get_character_extents(text, offset, x, y, width, height, coo&
      &rds) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text
  integer(c_int), value :: offset
  type(c_ptr), value :: x
  type(c_ptr), value :: y
  type(c_ptr), value :: width
  type(c_ptr), value :: height
  integer(c_int), value :: coords
end subroutine

! AtkAttributeSet* atk_text_get_run_attributes (AtkText *text, gint offset, gint *start_offset, gint *end_offset);
function atk_text_get_run_attributes(text, offset, start_offset, end_offset) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_text_get_run_attributes
  type(c_ptr), value :: text
  integer(c_int), value :: offset
  type(c_ptr), value :: start_offset
  type(c_ptr), value :: end_offset
end function

! AtkAttributeSet* atk_text_get_default_attributes (AtkText *text);
function atk_text_get_default_attributes(text) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_text_get_default_attributes
  type(c_ptr), value :: text
end function

! gint atk_text_get_character_count (AtkText *text);
function atk_text_get_character_count(text) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_text_get_character_count
  type(c_ptr), value :: text
end function

! gint atk_text_get_offset_at_point (AtkText *text, gint x, gint y, AtkCoordType coords);
function atk_text_get_offset_at_point(text, x, y, coords) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_text_get_offset_at_point
  type(c_ptr), value :: text
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: coords
end function

! gint atk_text_get_n_selections (AtkText *text);
function atk_text_get_n_selections(text) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_text_get_n_selections
  type(c_ptr), value :: text
end function

! gchar* atk_text_get_selection (AtkText *text, gint selection_num, gint *start_offset, gint *end_offset);
function atk_text_get_selection(text, selection_num, start_offset, end_offset) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_text_get_selection
  type(c_ptr), value :: text
  integer(c_int), value :: selection_num
  type(c_ptr), value :: start_offset
  type(c_ptr), value :: end_offset
end function

! gboolean atk_text_add_selection (AtkText *text, gint start_offset, gint end_offset);
function atk_text_add_selection(text, start_offset, end_offset) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_text_add_selection
  type(c_ptr), value :: text
  integer(c_int), value :: start_offset
  integer(c_int), value :: end_offset
end function

! gboolean atk_text_remove_selection (AtkText *text, gint selection_num);
function atk_text_remove_selection(text, selection_num) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_text_remove_selection
  type(c_ptr), value :: text
  integer(c_int), value :: selection_num
end function

! gboolean atk_text_set_selection (AtkText *text, gint selection_num, gint start_offset, gint end_offset);
function atk_text_set_selection(text, selection_num, start_offset, end_offset) b&
      &ind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_text_set_selection
  type(c_ptr), value :: text
  integer(c_int), value :: selection_num
  integer(c_int), value :: start_offset
  integer(c_int), value :: end_offset
end function

! gboolean atk_text_set_caret_offset (AtkText *text, gint offset);
function atk_text_set_caret_offset(text, offset) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_text_set_caret_offset
  type(c_ptr), value :: text
  integer(c_int), value :: offset
end function

! void atk_text_get_range_extents (AtkText *text,  gint start_offset, gint end_offset, AtkCoordType coord_type, AtkTextRectangle *rect);
subroutine atk_text_get_range_extents(text, start_offset, end_offset, coord_type&
      &, rect) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text
  integer(c_int), value :: start_offset
  integer(c_int), value :: end_offset
  integer(c_int), value :: coord_type
  type(c_ptr), value :: rect
end subroutine

! AtkTextRange** atk_text_get_bounded_ranges (AtkText *text, AtkTextRectangle *rect, AtkCoordType coord_type, AtkTextClipType x_clip_type, AtkTextClipType y_clip_type);
function atk_text_get_bounded_ranges(text, rect, coord_type, x_clip_type, y_clip&
      &_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_text_get_bounded_ranges
  type(c_ptr), value :: text
  type(c_ptr), value :: rect
  integer(c_int), value :: coord_type
  integer(c_int), value :: x_clip_type
  integer(c_int), value :: y_clip_type
end function

! void atk_text_free_ranges (AtkTextRange **ranges);
subroutine atk_text_free_ranges(ranges) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ranges
end subroutine

! void atk_attribute_set_free (AtkAttributeSet *attrib_set);
subroutine atk_attribute_set_free(attrib_set) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: attrib_set
end subroutine

! G_CONST_RETURN gchar* atk_text_attribute_get_name (AtkTextAttribute attr);
function atk_text_attribute_get_name(attr) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_text_attribute_get_name
  integer(c_int), value :: attr
end function

! AtkTextAttribute atk_text_attribute_for_name (const gchar *name);
function atk_text_attribute_for_name(name) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: atk_text_attribute_for_name
  character(kind=c_char), dimension(*) :: name
end function

! G_CONST_RETURN gchar* atk_text_attribute_get_value (AtkTextAttribute attr, gint index_);
function atk_text_attribute_get_value(attr, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_text_attribute_get_value
  integer(c_int), value :: attr
  integer(c_int), value :: index_
end function

!   GType atk_hyperlink_impl_get_type (void);
function atk_hyperlink_impl_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_hyperlink_impl_get_type
end function

!  AtkHyperlink *atk_hyperlink_impl_get_hyperlink (AtkHyperlinkImpl *obj);
function atk_hyperlink_impl_get_hyperlink(obj) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_hyperlink_impl_get_hyperlink
  type(c_ptr), value :: obj
end function

!   GType atk_action_get_type (void);
function atk_action_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_action_get_type
end function

!  gboolean atk_action_do_action (AtkAction *action, gint i);
function atk_action_do_action(action, i) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_action_do_action
  type(c_ptr), value :: action
  integer(c_int), value :: i
end function

! gint atk_action_get_n_actions (AtkAction *action);
function atk_action_get_n_actions(action) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_action_get_n_actions
  type(c_ptr), value :: action
end function

! G_CONST_RETURN gchar* atk_action_get_description (AtkAction *action, gint i);
function atk_action_get_description(action, i) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_action_get_description
  type(c_ptr), value :: action
  integer(c_int), value :: i
end function

! G_CONST_RETURN gchar* atk_action_get_name (AtkAction *action, gint i);
function atk_action_get_name(action, i) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_action_get_name
  type(c_ptr), value :: action
  integer(c_int), value :: i
end function

! G_CONST_RETURN gchar* atk_action_get_keybinding (AtkAction *action, gint i);
function atk_action_get_keybinding(action, i) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_action_get_keybinding
  type(c_ptr), value :: action
  integer(c_int), value :: i
end function

! gboolean atk_action_set_description (AtkAction *action, gint i, const gchar *desc);
function atk_action_set_description(action, i, desc) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int, c_char
  logical(c_bool) :: atk_action_set_description
  type(c_ptr), value :: action
  integer(c_int), value :: i
  character(kind=c_char), dimension(*) :: desc
end function

!  G_CONST_RETURN gchar* atk_action_get_localized_name (AtkAction *action, gint i);
function atk_action_get_localized_name(action, i) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_action_get_localized_name
  type(c_ptr), value :: action
  integer(c_int), value :: i
end function

!   GType atk_value_get_type (void);
function atk_value_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_value_get_type
end function

!  void atk_value_get_current_value (AtkValue *obj, GValue *value);
subroutine atk_value_get_current_value(obj, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: obj
  type(c_ptr), value :: value
end subroutine

!  void atk_value_get_maximum_value (AtkValue *obj, GValue *value);
subroutine atk_value_get_maximum_value(obj, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: obj
  type(c_ptr), value :: value
end subroutine

!  void atk_value_get_minimum_value (AtkValue *obj, GValue *value);
subroutine atk_value_get_minimum_value(obj, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: obj
  type(c_ptr), value :: value
end subroutine

!  gboolean atk_value_set_current_value (AtkValue *obj, const GValue *value);
function atk_value_set_current_value(obj, value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: atk_value_set_current_value
  type(c_ptr), value :: obj
  type(c_ptr), value :: value
end function

!  void atk_value_get_minimum_increment (AtkValue *obj, GValue *value);
subroutine atk_value_get_minimum_increment(obj, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: obj
  type(c_ptr), value :: value
end subroutine

!   GType atk_streamable_content_get_type (void);
function atk_streamable_content_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_streamable_content_get_type
end function

!  gint atk_streamable_content_get_n_mime_types (AtkStreamableContent *streamable);
function atk_streamable_content_get_n_mime_types(streamable) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_streamable_content_get_n_mime_types
  type(c_ptr), value :: streamable
end function

!  G_CONST_RETURN gchar* atk_streamable_content_get_mime_type (AtkStreamableContent *streamable, gint i);
function atk_streamable_content_get_mime_type(streamable, i) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_streamable_content_get_mime_type
  type(c_ptr), value :: streamable
  integer(c_int), value :: i
end function

! GIOChannel* atk_streamable_content_get_stream (AtkStreamableContent *streamable, const gchar *mime_type);
function atk_streamable_content_get_stream(streamable, mime_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: atk_streamable_content_get_stream
  type(c_ptr), value :: streamable
  character(kind=c_char), dimension(*) :: mime_type
end function

!  gchar* atk_streamable_content_get_uri (AtkStreamableContent *streamable, const gchar *mime_type);
function atk_streamable_content_get_uri(streamable, mime_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: atk_streamable_content_get_uri
  type(c_ptr), value :: streamable
  character(kind=c_char), dimension(*) :: mime_type
end function

!   GType atk_gobject_accessible_get_type (void);
function atk_gobject_accessible_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_gobject_accessible_get_type
end function

!  AtkObject *atk_gobject_accessible_for_object (GObject *obj);
function atk_gobject_accessible_for_object(obj) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_gobject_accessible_for_object
  type(c_ptr), value :: obj
end function

! GObject *atk_gobject_accessible_get_object (AtkGObjectAccessible *obj);
function atk_gobject_accessible_get_object(obj) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_gobject_accessible_get_object
  type(c_ptr), value :: obj
end function

!   GType atk_no_op_object_factory_get_type(void);
function atk_no_op_object_factory_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_no_op_object_factory_get_type
end function

!  AtkObjectFactory *atk_no_op_object_factory_new(void);
function atk_no_op_object_factory_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_no_op_object_factory_new
end function

!   GType atk_editable_text_get_type (void);
function atk_editable_text_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_editable_text_get_type
end function

!  gboolean atk_editable_text_set_run_attributes (AtkEditableText *text, AtkAttributeSet *attrib_set, gint start_offset, gint end_offset);
function atk_editable_text_set_run_attributes(text, attrib_set, start_offset, en&
      &d_offset) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_editable_text_set_run_attributes
  type(c_ptr), value :: text
  type(c_ptr), value :: attrib_set
  integer(c_int), value :: start_offset
  integer(c_int), value :: end_offset
end function

! void atk_editable_text_set_text_contents (AtkEditableText *text, const gchar *string);
subroutine atk_editable_text_set_text_contents(text, string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: text
  character(kind=c_char), dimension(*) :: string
end subroutine

! void atk_editable_text_insert_text (AtkEditableText *text, const gchar *string, gint length, gint *position);
subroutine atk_editable_text_insert_text(text, string, length, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: text
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: length
  type(c_ptr), value :: position
end subroutine

! void atk_editable_text_copy_text (AtkEditableText *text, gint start_pos, gint end_pos);
subroutine atk_editable_text_copy_text(text, start_pos, end_pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text
  integer(c_int), value :: start_pos
  integer(c_int), value :: end_pos
end subroutine

! void atk_editable_text_cut_text (AtkEditableText *text, gint start_pos, gint end_pos);
subroutine atk_editable_text_cut_text(text, start_pos, end_pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text
  integer(c_int), value :: start_pos
  integer(c_int), value :: end_pos
end subroutine

! void atk_editable_text_delete_text (AtkEditableText *text, gint start_pos, gint end_pos);
subroutine atk_editable_text_delete_text(text, start_pos, end_pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text
  integer(c_int), value :: start_pos
  integer(c_int), value :: end_pos
end subroutine

! void atk_editable_text_paste_text (AtkEditableText *text, gint position);
subroutine atk_editable_text_paste_text(text, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text
  integer(c_int), value :: position
end subroutine

!   GType atk_plug_get_type (void);
function atk_plug_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_plug_get_type
end function

!  AtkObject* atk_plug_new (void);
function atk_plug_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_plug_new
end function

! gchar* atk_plug_get_id (AtkPlug* plug);
function atk_plug_get_id(plug) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_plug_get_id
  type(c_ptr), value :: plug
end function

!   GType atk_socket_get_type (void);
function atk_socket_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_socket_get_type
end function

!  AtkObject* atk_socket_new (void);
function atk_socket_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_socket_new
end function

! void atk_socket_embed (AtkSocket* obj, gchar* plug_id);
subroutine atk_socket_embed(obj, plug_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: obj
  character(kind=c_char), dimension(*) :: plug_id
end subroutine

! gboolean atk_socket_is_occupied (AtkSocket* obj);
function atk_socket_is_occupied(obj) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: atk_socket_is_occupied
  type(c_ptr), value :: obj
end function

!   GType atk_util_get_type (void);
function atk_util_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_util_get_type
end function

!  guint atk_add_focus_tracker (AtkEventListener focus_tracker);
function atk_add_focus_tracker(focus_tracker) bind(c) 
  use iso_c_binding, only: c_int, c_funptr
  integer(c_int) :: atk_add_focus_tracker
  type(c_funptr), value :: focus_tracker
end function

!  void atk_remove_focus_tracker (guint tracker_id);
subroutine atk_remove_focus_tracker(tracker_id) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: tracker_id
end subroutine

!  void atk_focus_tracker_init (AtkEventListenerInit init);
subroutine atk_focus_tracker_init(init) bind(c) 
  use iso_c_binding, only: c_funptr
  type(c_funptr), value :: init
end subroutine

!  void atk_focus_tracker_notify (AtkObject *object);
subroutine atk_focus_tracker_notify(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
end subroutine

!  guint atk_add_global_event_listener (GSignalEmissionHook listener, const gchar *event_type);
function atk_add_global_event_listener(listener, event_type) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_char
  integer(c_int) :: atk_add_global_event_listener
  type(c_funptr), value :: listener
  character(kind=c_char), dimension(*) :: event_type
end function

!  void atk_remove_global_event_listener (guint listener_id);
subroutine atk_remove_global_event_listener(listener_id) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: listener_id
end subroutine

!  guint atk_add_key_event_listener (AtkKeySnoopFunc listener, gpointer data);
function atk_add_key_event_listener(listener, data) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: atk_add_key_event_listener
  type(c_funptr), value :: listener
  type(c_ptr), value :: data
end function

!  void atk_remove_key_event_listener (guint listener_id);
subroutine atk_remove_key_event_listener(listener_id) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: listener_id
end subroutine

!  AtkObject* atk_get_root(void);
function atk_get_root() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_get_root
end function

!  AtkObject* atk_get_focus_object (void);
function atk_get_focus_object() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_get_focus_object
end function

!  G_CONST_RETURN gchar *atk_get_toolkit_name (void);
function atk_get_toolkit_name() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_get_toolkit_name
end function

!  G_CONST_RETURN gchar *atk_get_toolkit_version (void);
function atk_get_toolkit_version() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_get_toolkit_version
end function

!  G_CONST_RETURN gchar *atk_get_version (void);
function atk_get_version() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_get_version
end function

!   GType atk_document_get_type (void);
function atk_document_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_document_get_type
end function

!  G_CONST_RETURN gchar* atk_document_get_document_type (AtkDocument *document);
function atk_document_get_document_type(document) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_document_get_document_type
  type(c_ptr), value :: document
end function

! gpointer atk_document_get_document (AtkDocument *document);
function atk_document_get_document(document) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_document_get_document
  type(c_ptr), value :: document
end function

! G_CONST_RETURN gchar* atk_document_get_locale (AtkDocument *document);
function atk_document_get_locale(document) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_document_get_locale
  type(c_ptr), value :: document
end function

! AtkAttributeSet* atk_document_get_attributes (AtkDocument *document);
function atk_document_get_attributes(document) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_document_get_attributes
  type(c_ptr), value :: document
end function

! G_CONST_RETURN gchar* atk_document_get_attribute_value (AtkDocument *document, const gchar *attribute_name);
function atk_document_get_attribute_value(document, attribute_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: atk_document_get_attribute_value
  type(c_ptr), value :: document
  character(kind=c_char), dimension(*) :: attribute_name
end function

! gboolean atk_document_set_attribute_value (AtkDocument *document, const gchar *attribute_name, const gchar *attribute_value);
function atk_document_set_attribute_value(document, attribute_name, attribute_va&
      &lue) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: atk_document_set_attribute_value
  type(c_ptr), value :: document
  character(kind=c_char), dimension(*) :: attribute_name
  character(kind=c_char), dimension(*) :: attribute_value
end function

!     AtkStateType atk_state_type_register (const gchar *name);
function atk_state_type_register(name) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: atk_state_type_register
  character(kind=c_char), dimension(*) :: name
end function

!  G_CONST_RETURN gchar* atk_state_type_get_name (AtkStateType type);
function atk_state_type_get_name(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_state_type_get_name
  integer(c_int), value :: type
end function

! AtkStateType atk_state_type_for_name (const gchar *name);
function atk_state_type_for_name(name) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: atk_state_type_for_name
  character(kind=c_char), dimension(*) :: name
end function

!   GType atk_object_factory_get_type(void);
function atk_object_factory_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_object_factory_get_type
end function

!  AtkObject* atk_object_factory_create_accessible (AtkObjectFactory *factory, GObject *obj);
function atk_object_factory_create_accessible(factory, obj) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_object_factory_create_accessible
  type(c_ptr), value :: factory
  type(c_ptr), value :: obj
end function

! void atk_object_factory_invalidate (AtkObjectFactory *factory);
subroutine atk_object_factory_invalidate(factory) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: factory
end subroutine

! GType atk_object_factory_get_accessible_type (AtkObjectFactory *factory);
function atk_object_factory_get_accessible_type(factory) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: atk_object_factory_get_accessible_type
  type(c_ptr), value :: factory
end function

!   GType atk_hypertext_get_type (void);
function atk_hypertext_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_hypertext_get_type
end function

!  AtkHyperlink* atk_hypertext_get_link (AtkHypertext *hypertext, gint link_index);
function atk_hypertext_get_link(hypertext, link_index) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_hypertext_get_link
  type(c_ptr), value :: hypertext
  integer(c_int), value :: link_index
end function

! gint atk_hypertext_get_n_links (AtkHypertext *hypertext);
function atk_hypertext_get_n_links(hypertext) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_hypertext_get_n_links
  type(c_ptr), value :: hypertext
end function

! gint atk_hypertext_get_link_index (AtkHypertext *hypertext, gint char_index);
function atk_hypertext_get_link_index(hypertext, char_index) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_hypertext_get_link_index
  type(c_ptr), value :: hypertext
  integer(c_int), value :: char_index
end function

!   GType atk_registry_get_type (void);
function atk_registry_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_registry_get_type
end function

! void atk_registry_set_factory_type (AtkRegistry *registry, GType type, GType factory_type);
subroutine atk_registry_set_factory_type(registry, type, factory_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: registry
  integer(c_size_t), value :: type
  integer(c_size_t), value :: factory_type
end subroutine

! GType atk_registry_get_factory_type (AtkRegistry *registry, GType type);
function atk_registry_get_factory_type(registry, type) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: atk_registry_get_factory_type
  type(c_ptr), value :: registry
  integer(c_size_t), value :: type
end function

! AtkObjectFactory* atk_registry_get_factory (AtkRegistry *registry, GType type);
function atk_registry_get_factory(registry, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: atk_registry_get_factory
  type(c_ptr), value :: registry
  integer(c_size_t), value :: type
end function

!  AtkRegistry* atk_get_default_registry (void);
function atk_get_default_registry() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_get_default_registry
end function

!   GType atk_image_get_type (void);
function atk_image_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_image_get_type
end function

!  G_CONST_RETURN gchar* atk_image_get_image_description (AtkImage *image);
function atk_image_get_image_description(image) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_image_get_image_description
  type(c_ptr), value :: image
end function

!  void atk_image_get_image_size (AtkImage *image, gint *width, gint *height);
subroutine atk_image_get_image_size(image, width, height) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: image
  type(c_ptr), value :: width
  type(c_ptr), value :: height
end subroutine

!  gboolean atk_image_set_image_description (AtkImage *image, const gchar *description);
function atk_image_set_image_description(image, description) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: atk_image_set_image_description
  type(c_ptr), value :: image
  character(kind=c_char), dimension(*) :: description
end function

! void atk_image_get_image_position (AtkImage *image, gint *x, gint *y, AtkCoordType coord_type);
subroutine atk_image_get_image_position(image, x, y, coord_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: image
  type(c_ptr), value :: x
  type(c_ptr), value :: y
  integer(c_int), value :: coord_type
end subroutine

!  G_CONST_RETURN gchar* atk_image_get_image_locale (AtkImage *image);
function atk_image_get_image_locale(image) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_image_get_image_locale
  type(c_ptr), value :: image
end function

!     GType atk_hyperlink_get_type (void);
function atk_hyperlink_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_hyperlink_get_type
end function

!  gchar* atk_hyperlink_get_uri (AtkHyperlink *link_, gint i);
function atk_hyperlink_get_uri(link_, i) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_hyperlink_get_uri
  type(c_ptr), value :: link_
  integer(c_int), value :: i
end function

!  AtkObject* atk_hyperlink_get_object (AtkHyperlink *link_, gint i);
function atk_hyperlink_get_object(link_, i) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_hyperlink_get_object
  type(c_ptr), value :: link_
  integer(c_int), value :: i
end function

!  gint atk_hyperlink_get_end_index (AtkHyperlink *link_);
function atk_hyperlink_get_end_index(link_) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_hyperlink_get_end_index
  type(c_ptr), value :: link_
end function

!  gint atk_hyperlink_get_start_index (AtkHyperlink *link_);
function atk_hyperlink_get_start_index(link_) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_hyperlink_get_start_index
  type(c_ptr), value :: link_
end function

!  gboolean atk_hyperlink_is_valid (AtkHyperlink *link_);
function atk_hyperlink_is_valid(link_) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: atk_hyperlink_is_valid
  type(c_ptr), value :: link_
end function

!  gboolean atk_hyperlink_is_inline (AtkHyperlink *link_);
function atk_hyperlink_is_inline(link_) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: atk_hyperlink_is_inline
  type(c_ptr), value :: link_
end function

!  gint atk_hyperlink_get_n_anchors (AtkHyperlink *link_);
function atk_hyperlink_get_n_anchors(link_) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_hyperlink_get_n_anchors
  type(c_ptr), value :: link_
end function

!  gboolean atk_hyperlink_is_selected_link (AtkHyperlink *link_);
function atk_hyperlink_is_selected_link(link_) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: atk_hyperlink_is_selected_link
  type(c_ptr), value :: link_
end function

!  GType atk_misc_get_type (void);
function atk_misc_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_misc_get_type
end function

!  void atk_misc_threads_enter (AtkMisc *misc);
subroutine atk_misc_threads_enter(misc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: misc
end subroutine

!  void atk_misc_threads_leave (AtkMisc *misc);
subroutine atk_misc_threads_leave(misc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: misc
end subroutine

!  const AtkMisc *atk_misc_get_instance (void);
function atk_misc_get_instance() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_misc_get_instance
end function

!   GType atk_selection_get_type (void);
function atk_selection_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_selection_get_type
end function

!  gboolean atk_selection_add_selection (AtkSelection *selection, gint i);
function atk_selection_add_selection(selection, i) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_selection_add_selection
  type(c_ptr), value :: selection
  integer(c_int), value :: i
end function

!  gboolean atk_selection_clear_selection (AtkSelection *selection);
function atk_selection_clear_selection(selection) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: atk_selection_clear_selection
  type(c_ptr), value :: selection
end function

!  AtkObject* atk_selection_ref_selection (AtkSelection *selection, gint i);
function atk_selection_ref_selection(selection, i) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_selection_ref_selection
  type(c_ptr), value :: selection
  integer(c_int), value :: i
end function

!  gint atk_selection_get_selection_count (AtkSelection *selection);
function atk_selection_get_selection_count(selection) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_selection_get_selection_count
  type(c_ptr), value :: selection
end function

!  gboolean atk_selection_is_child_selected (AtkSelection *selection, gint i);
function atk_selection_is_child_selected(selection, i) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_selection_is_child_selected
  type(c_ptr), value :: selection
  integer(c_int), value :: i
end function

!  gboolean atk_selection_remove_selection (AtkSelection *selection, gint i);
function atk_selection_remove_selection(selection, i) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_selection_remove_selection
  type(c_ptr), value :: selection
  integer(c_int), value :: i
end function

!  gboolean atk_selection_select_all_selection (AtkSelection *selection);
function atk_selection_select_all_selection(selection) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: atk_selection_select_all_selection
  type(c_ptr), value :: selection
end function

!   GType atk_hyperlink_state_flags_get_type (void);
function atk_hyperlink_state_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_hyperlink_state_flags_get_type
end function

!  GType atk_role_get_type (void);
function atk_role_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_role_get_type
end function

!  GType atk_layer_get_type (void);
function atk_layer_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_layer_get_type
end function

!  GType atk_relation_type_get_type (void);
function atk_relation_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_relation_type_get_type
end function

!  GType atk_state_type_get_type (void);
function atk_state_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_state_type_get_type
end function

!  GType atk_text_attribute_get_type (void);
function atk_text_attribute_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_text_attribute_get_type
end function

!  GType atk_text_boundary_get_type (void);
function atk_text_boundary_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_text_boundary_get_type
end function

!  GType atk_text_clip_type_get_type (void);
function atk_text_clip_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_text_clip_type_get_type
end function

!  GType atk_key_event_type_get_type (void);
function atk_key_event_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_key_event_type_get_type
end function

!  GType atk_coord_type_get_type (void);
function atk_coord_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_coord_type_get_type
end function

!   GType atk_rectangle_get_type (void);
function atk_rectangle_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_rectangle_get_type
end function

!  GType atk_component_get_type (void);
function atk_component_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_component_get_type
end function

!  guint atk_component_add_focus_handler (AtkComponent *component, AtkFocusHandler handler);
function atk_component_add_focus_handler(component, handler) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int) :: atk_component_add_focus_handler
  type(c_ptr), value :: component
  type(c_funptr), value :: handler
end function

! gboolean atk_component_contains (AtkComponent *component, gint x, gint y, AtkCoordType coord_type);
function atk_component_contains(component, x, y, coord_type) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_component_contains
  type(c_ptr), value :: component
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: coord_type
end function

! AtkObject* atk_component_ref_accessible_at_point(AtkComponent *component, gint x, gint y, AtkCoordType coord_type);
function atk_component_ref_accessible_at_point(component, x, y, coord_type) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_component_ref_accessible_at_point
  type(c_ptr), value :: component
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: coord_type
end function

! void atk_component_get_extents (AtkComponent *component, gint *x, gint *y, gint *width, gint *height, AtkCoordType coord_type);
subroutine atk_component_get_extents(component, x, y, width, height, coord_type)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: component
  type(c_ptr), value :: x
  type(c_ptr), value :: y
  type(c_ptr), value :: width
  type(c_ptr), value :: height
  integer(c_int), value :: coord_type
end subroutine

! void atk_component_get_position (AtkComponent *component, gint *x, gint *y, AtkCoordType coord_type);
subroutine atk_component_get_position(component, x, y, coord_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: component
  type(c_ptr), value :: x
  type(c_ptr), value :: y
  integer(c_int), value :: coord_type
end subroutine

! void atk_component_get_size (AtkComponent *component, gint *width, gint *height);
subroutine atk_component_get_size(component, width, height) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: component
  type(c_ptr), value :: width
  type(c_ptr), value :: height
end subroutine

! AtkLayer atk_component_get_layer (AtkComponent *component);
function atk_component_get_layer(component) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_component_get_layer
  type(c_ptr), value :: component
end function

! gint atk_component_get_mdi_zorder (AtkComponent *component);
function atk_component_get_mdi_zorder(component) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_component_get_mdi_zorder
  type(c_ptr), value :: component
end function

! gboolean atk_component_grab_focus (AtkComponent *component);
function atk_component_grab_focus(component) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: atk_component_grab_focus
  type(c_ptr), value :: component
end function

! void atk_component_remove_focus_handler (AtkComponent *component, guint handler_id);
subroutine atk_component_remove_focus_handler(component, handler_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: component
  integer(c_int), value :: handler_id
end subroutine

! gboolean atk_component_set_extents (AtkComponent *component, gint x, gint y, gint width, gint height, AtkCoordType coord_type);
function atk_component_set_extents(component, x, y, width, height, coord_type) b&
      &ind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_component_set_extents
  type(c_ptr), value :: component
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: coord_type
end function

! gboolean atk_component_set_position (AtkComponent *component, gint x, gint y, AtkCoordType coord_type);
function atk_component_set_position(component, x, y, coord_type) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_component_set_position
  type(c_ptr), value :: component
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: coord_type
end function

! gboolean atk_component_set_size (AtkComponent *component, gint width, gint height);
function atk_component_set_size(component, width, height) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_component_set_size
  type(c_ptr), value :: component
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

! gdouble atk_component_get_alpha (AtkComponent *component);
function atk_component_get_alpha(component) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: atk_component_get_alpha
  type(c_ptr), value :: component
end function

!   GType atk_no_op_object_get_type (void);
function atk_no_op_object_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_no_op_object_get_type
end function

!  AtkObject *atk_no_op_object_new (GObject *obj);
function atk_no_op_object_new(obj) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_no_op_object_new
  type(c_ptr), value :: obj
end function

!   AtkRole atk_role_register (const gchar *name);
function atk_role_register(name) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: atk_role_register
  character(kind=c_char), dimension(*) :: name
end function

!  GType atk_object_get_type (void);
function atk_object_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_object_get_type
end function

!  GType atk_implementor_get_type (void);
function atk_implementor_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_implementor_get_type
end function

!  AtkObject* atk_implementor_ref_accessible (AtkImplementor *implementor);
function atk_implementor_ref_accessible(implementor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_implementor_ref_accessible
  type(c_ptr), value :: implementor
end function

!  G_CONST_RETURN gchar* atk_object_get_name (AtkObject *accessible);
function atk_object_get_name(accessible) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_object_get_name
  type(c_ptr), value :: accessible
end function

! G_CONST_RETURN gchar* atk_object_get_description (AtkObject *accessible);
function atk_object_get_description(accessible) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_object_get_description
  type(c_ptr), value :: accessible
end function

! AtkObject* atk_object_get_parent (AtkObject *accessible);
function atk_object_get_parent(accessible) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_object_get_parent
  type(c_ptr), value :: accessible
end function

! gint atk_object_get_n_accessible_children (AtkObject *accessible);
function atk_object_get_n_accessible_children(accessible) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_object_get_n_accessible_children
  type(c_ptr), value :: accessible
end function

! AtkObject* atk_object_ref_accessible_child (AtkObject *accessible, gint i);
function atk_object_ref_accessible_child(accessible, i) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_object_ref_accessible_child
  type(c_ptr), value :: accessible
  integer(c_int), value :: i
end function

! AtkRelationSet* atk_object_ref_relation_set (AtkObject *accessible);
function atk_object_ref_relation_set(accessible) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_object_ref_relation_set
  type(c_ptr), value :: accessible
end function

! AtkRole atk_object_get_role (AtkObject *accessible);
function atk_object_get_role(accessible) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_object_get_role
  type(c_ptr), value :: accessible
end function

!  AtkLayer atk_object_get_layer (AtkObject *accessible);
function atk_object_get_layer(accessible) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_object_get_layer
  type(c_ptr), value :: accessible
end function

! gint atk_object_get_mdi_zorder (AtkObject *accessible);
function atk_object_get_mdi_zorder(accessible) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_object_get_mdi_zorder
  type(c_ptr), value :: accessible
end function

!  AtkAttributeSet* atk_object_get_attributes (AtkObject *accessible);
function atk_object_get_attributes(accessible) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_object_get_attributes
  type(c_ptr), value :: accessible
end function

! AtkStateSet* atk_object_ref_state_set (AtkObject *accessible);
function atk_object_ref_state_set(accessible) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_object_ref_state_set
  type(c_ptr), value :: accessible
end function

! gint atk_object_get_index_in_parent (AtkObject *accessible);
function atk_object_get_index_in_parent(accessible) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_object_get_index_in_parent
  type(c_ptr), value :: accessible
end function

! void atk_object_set_name (AtkObject *accessible, const gchar *name);
subroutine atk_object_set_name(accessible, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: accessible
  character(kind=c_char), dimension(*) :: name
end subroutine

! void atk_object_set_description (AtkObject *accessible, const gchar *description);
subroutine atk_object_set_description(accessible, description) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: accessible
  character(kind=c_char), dimension(*) :: description
end subroutine

! void atk_object_set_parent (AtkObject *accessible, AtkObject *parent);
subroutine atk_object_set_parent(accessible, parent) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: accessible
  type(c_ptr), value :: parent
end subroutine

! void atk_object_set_role (AtkObject *accessible, AtkRole role);
subroutine atk_object_set_role(accessible, role) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: accessible
  integer(c_int), value :: role
end subroutine

!  guint atk_object_connect_property_change_handler (AtkObject *accessible, AtkPropertyChangeHandler *handler);
function atk_object_connect_property_change_handler(accessible, handler) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int) :: atk_object_connect_property_change_handler
  type(c_ptr), value :: accessible
  type(c_funptr), value :: handler
end function

! void atk_object_remove_property_change_handler (AtkObject *accessible, guint handler_id);
subroutine atk_object_remove_property_change_handler(accessible, handler_id) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: accessible
  integer(c_int), value :: handler_id
end subroutine

!  void atk_object_notify_state_change (AtkObject *accessible, AtkState state, gboolean value);
subroutine atk_object_notify_state_change(accessible, state, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int64_t, c_bool
  type(c_ptr), value :: accessible
  integer(c_int64_t), value :: state
  logical(c_bool), value :: value
end subroutine

! void atk_object_initialize (AtkObject *accessible, gpointer data);
subroutine atk_object_initialize(accessible, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: accessible
  type(c_ptr), value :: data
end subroutine

!  G_CONST_RETURN gchar* atk_role_get_name (AtkRole role);
function atk_role_get_name(role) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_role_get_name
  integer(c_int), value :: role
end function

! AtkRole atk_role_for_name (const gchar *name);
function atk_role_for_name(name) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: atk_role_for_name
  character(kind=c_char), dimension(*) :: name
end function

!  gboolean atk_object_add_relationship (AtkObject *object, AtkRelationType relationship, AtkObject *target);
function atk_object_add_relationship(object, relationship, target) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_object_add_relationship
  type(c_ptr), value :: object
  integer(c_int), value :: relationship
  type(c_ptr), value :: target
end function

! gboolean atk_object_remove_relationship (AtkObject *object, AtkRelationType relationship, AtkObject *target);
function atk_object_remove_relationship(object, relationship, target) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: atk_object_remove_relationship
  type(c_ptr), value :: object
  integer(c_int), value :: relationship
  type(c_ptr), value :: target
end function

! G_CONST_RETURN gchar* atk_role_get_localized_name (AtkRole role);
function atk_role_get_localized_name(role) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_role_get_localized_name
  integer(c_int), value :: role
end function

!   GType atk_relation_get_type (void);
function atk_relation_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: atk_relation_get_type
end function

!  AtkRelationType atk_relation_type_register (const gchar *name);
function atk_relation_type_register(name) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: atk_relation_type_register
  character(kind=c_char), dimension(*) :: name
end function

! G_CONST_RETURN gchar* atk_relation_type_get_name (AtkRelationType type);
function atk_relation_type_get_name(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_relation_type_get_name
  integer(c_int), value :: type
end function

! AtkRelationType atk_relation_type_for_name (const gchar *name);
function atk_relation_type_for_name(name) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: atk_relation_type_for_name
  character(kind=c_char), dimension(*) :: name
end function

!  AtkRelation* atk_relation_new (AtkObject **targets, gint n_targets, AtkRelationType relationship);
function atk_relation_new(targets, n_targets, relationship) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: atk_relation_new
  type(c_ptr), value :: targets
  integer(c_int), value :: n_targets
  integer(c_int), value :: relationship
end function

!  AtkRelationType atk_relation_get_relation_type (AtkRelation *relation);
function atk_relation_get_relation_type(relation) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: atk_relation_get_relation_type
  type(c_ptr), value :: relation
end function

!  GPtrArray* atk_relation_get_target (AtkRelation *relation);
function atk_relation_get_target(relation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: atk_relation_get_target
  type(c_ptr), value :: relation
end function

! void atk_relation_add_target (AtkRelation *relation, AtkObject *target);
subroutine atk_relation_add_target(relation, target) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: relation
  type(c_ptr), value :: target
end subroutine

! gboolean atk_relation_remove_target (AtkRelation *relation, AtkObject *target);
function atk_relation_remove_target(relation, target) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: atk_relation_remove_target
  type(c_ptr), value :: relation
  type(c_ptr), value :: target
end function

!   gboolean g_module_supported (void) G_GNUC_CONST;
function g_module_supported() bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool) :: g_module_supported
end function

!  GModule* g_module_open (const gchar *file_name, GModuleFlags flags);
function g_module_open(file_name, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_module_open
  character(kind=c_char), dimension(*) :: file_name
  integer(c_int), value :: flags
end function

!  gboolean g_module_close (GModule *module);
function g_module_close(module) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_module_close
  type(c_ptr), value :: module
end function

!  void g_module_make_resident (GModule *module);
subroutine g_module_make_resident(module) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: module
end subroutine

!  G_CONST_RETURN gchar* g_module_error (void);
function g_module_error() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_module_error
end function

!  gboolean g_module_symbol (GModule *module, const gchar *symbol_name, gpointer *symbol);
function g_module_symbol(module, symbol_name, symbol) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_module_symbol
  type(c_ptr), value :: module
  character(kind=c_char), dimension(*) :: symbol_name
  type(c_ptr), value :: symbol
end function

!  G_CONST_RETURN gchar* g_module_name (GModule *module);
function g_module_name(module) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_module_name
  type(c_ptr), value :: module
end function

!  gchar* g_module_build_path (const gchar *directory, const gchar *module_name);
function g_module_build_path(directory, module_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_module_build_path
  character(kind=c_char), dimension(*) :: directory
  character(kind=c_char), dimension(*) :: module_name
end function

!   GType g_type_module_get_type (void) G_GNUC_CONST;
function g_type_module_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_type_module_get_type
end function

! gboolean g_type_module_use (GTypeModule *module);
function g_type_module_use(module) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_type_module_use
  type(c_ptr), value :: module
end function

! void g_type_module_unuse (GTypeModule *module);
subroutine g_type_module_unuse(module) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: module
end subroutine

! void g_type_module_set_name (GTypeModule *module, const gchar *name);
subroutine g_type_module_set_name(module, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: module
  character(kind=c_char), dimension(*) :: name
end subroutine

! GType g_type_module_register_type (GTypeModule *module, GType parent_type, const gchar *type_name, const GTypeInfo *type_info, GTypeFlags flags);
function g_type_module_register_type(module, parent_type, type_name, type_info, &
      &flags) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char, c_int
  integer(c_size_t) :: g_type_module_register_type
  type(c_ptr), value :: module
  integer(c_size_t), value :: parent_type
  character(kind=c_char), dimension(*) :: type_name
  type(c_ptr), value :: type_info
  integer(c_int), value :: flags
end function

! void g_type_module_add_interface (GTypeModule *module, GType instance_type, GType interface_type, const GInterfaceInfo *interface_info);
subroutine g_type_module_add_interface(module, instance_type, interface_type, in&
      &terface_info) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: module
  integer(c_size_t), value :: instance_type
  integer(c_size_t), value :: interface_type
  type(c_ptr), value :: interface_info
end subroutine

! GType g_type_module_register_enum (GTypeModule *module, const gchar *name, const GEnumValue *const_static_values);
function g_type_module_register_enum(module, name, const_static_values) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char
  integer(c_size_t) :: g_type_module_register_enum
  type(c_ptr), value :: module
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: const_static_values
end function

! GType g_type_module_register_flags (GTypeModule *module, const gchar *name, const GFlagsValue *const_static_values);
function g_type_module_register_flags(module, name, const_static_values) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char
  integer(c_size_t) :: g_type_module_register_flags
  type(c_ptr), value :: module
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: const_static_values
end function

!     GParamSpec* g_param_spec_ref (GParamSpec *pspec);
function g_param_spec_ref(pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_param_spec_ref
  type(c_ptr), value :: pspec
end function

! void g_param_spec_unref (GParamSpec *pspec);
subroutine g_param_spec_unref(pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pspec
end subroutine

! void g_param_spec_sink (GParamSpec *pspec);
subroutine g_param_spec_sink(pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pspec
end subroutine

! GParamSpec* g_param_spec_ref_sink (GParamSpec *pspec);
function g_param_spec_ref_sink(pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_param_spec_ref_sink
  type(c_ptr), value :: pspec
end function

! gpointer g_param_spec_get_qdata (GParamSpec *pspec, GQuark quark);
function g_param_spec_get_qdata(pspec, quark) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_param_spec_get_qdata
  type(c_ptr), value :: pspec
  integer(c_int32_t), value :: quark
end function

! void g_param_spec_set_qdata (GParamSpec *pspec, GQuark quark, gpointer data);
subroutine g_param_spec_set_qdata(pspec, quark, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: pspec
  integer(c_int32_t), value :: quark
  type(c_ptr), value :: data
end subroutine

! void g_param_spec_set_qdata_full (GParamSpec *pspec, GQuark quark, gpointer data, GDestroyNotify destroy);
subroutine g_param_spec_set_qdata_full(pspec, quark, data, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_funptr
  type(c_ptr), value :: pspec
  integer(c_int32_t), value :: quark
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

! gpointer g_param_spec_steal_qdata (GParamSpec *pspec, GQuark quark);
function g_param_spec_steal_qdata(pspec, quark) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_param_spec_steal_qdata
  type(c_ptr), value :: pspec
  integer(c_int32_t), value :: quark
end function

! GParamSpec* g_param_spec_get_redirect_target (GParamSpec *pspec);
function g_param_spec_get_redirect_target(pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_param_spec_get_redirect_target
  type(c_ptr), value :: pspec
end function

!  void g_param_value_set_default (GParamSpec *pspec, GValue *value);
subroutine g_param_value_set_default(pspec, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pspec
  type(c_ptr), value :: value
end subroutine

! gboolean g_param_value_defaults (GParamSpec *pspec, GValue *value);
function g_param_value_defaults(pspec, value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_param_value_defaults
  type(c_ptr), value :: pspec
  type(c_ptr), value :: value
end function

! gboolean g_param_value_validate (GParamSpec *pspec, GValue *value);
function g_param_value_validate(pspec, value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_param_value_validate
  type(c_ptr), value :: pspec
  type(c_ptr), value :: value
end function

! gboolean g_param_value_convert (GParamSpec *pspec, const GValue *src_value, GValue *dest_value, gboolean strict_validation);
function g_param_value_convert(pspec, src_value, dest_value, strict_validation) &
      &bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_param_value_convert
  type(c_ptr), value :: pspec
  type(c_ptr), value :: src_value
  type(c_ptr), value :: dest_value
  logical(c_bool), value :: strict_validation
end function

! gint g_param_values_cmp (GParamSpec *pspec, const GValue *value1, const GValue *value2);
function g_param_values_cmp(pspec, value1, value2) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_param_values_cmp
  type(c_ptr), value :: pspec
  type(c_ptr), value :: value1
  type(c_ptr), value :: value2
end function

! G_CONST_RETURN gchar* g_param_spec_get_name (GParamSpec *pspec);
function g_param_spec_get_name(pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_param_spec_get_name
  type(c_ptr), value :: pspec
end function

! G_CONST_RETURN gchar* g_param_spec_get_nick (GParamSpec *pspec);
function g_param_spec_get_nick(pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_param_spec_get_nick
  type(c_ptr), value :: pspec
end function

! G_CONST_RETURN gchar* g_param_spec_get_blurb (GParamSpec *pspec);
function g_param_spec_get_blurb(pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_param_spec_get_blurb
  type(c_ptr), value :: pspec
end function

! void g_value_set_param (GValue *value, GParamSpec *param);
subroutine g_value_set_param(value, param) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: param
end subroutine

! GParamSpec* g_value_get_param (const GValue *value);
function g_value_get_param(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_get_param
  type(c_ptr), value :: value
end function

! GParamSpec* g_value_dup_param (const GValue *value);
function g_value_dup_param(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_dup_param
  type(c_ptr), value :: value
end function

!  void g_value_take_param (GValue *value, GParamSpec *param);
subroutine g_value_take_param(value, param) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: param
end subroutine

!  void g_value_set_param_take_ownership (GValue *value, GParamSpec *param);
subroutine g_value_set_param_take_ownership(value, param) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: param
end subroutine

!  GType g_param_type_register_static (const gchar *name, const GParamSpecTypeInfo *pspec_info);
function g_param_type_register_static(name, pspec_info) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_param_type_register_static
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: pspec_info
end function

!  gpointer g_param_spec_internal (GType param_type, const gchar *name, const gchar *nick, const gchar *blurb, GParamFlags flags);
function g_param_spec_internal(param_type, name, nick, blurb, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char, c_int
  type(c_ptr) :: g_param_spec_internal
  integer(c_size_t), value :: param_type
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int), value :: flags
end function

! GParamSpecPool* g_param_spec_pool_new (gboolean type_prefixing);
function g_param_spec_pool_new(type_prefixing) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: g_param_spec_pool_new
  logical(c_bool), value :: type_prefixing
end function

! void g_param_spec_pool_insert (GParamSpecPool *pool, GParamSpec *pspec, GType owner_type);
subroutine g_param_spec_pool_insert(pool, pspec, owner_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: pool
  type(c_ptr), value :: pspec
  integer(c_size_t), value :: owner_type
end subroutine

! void g_param_spec_pool_remove (GParamSpecPool *pool, GParamSpec *pspec);
subroutine g_param_spec_pool_remove(pool, pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pool
  type(c_ptr), value :: pspec
end subroutine

! GParamSpec* g_param_spec_pool_lookup (GParamSpecPool *pool, const gchar *param_name, GType owner_type, gboolean walk_ancestors);
function g_param_spec_pool_lookup(pool, param_name, owner_type, walk_ancestors) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_bool
  type(c_ptr) :: g_param_spec_pool_lookup
  type(c_ptr), value :: pool
  character(kind=c_char), dimension(*) :: param_name
  integer(c_size_t), value :: owner_type
  logical(c_bool), value :: walk_ancestors
end function

! GList* g_param_spec_pool_list_owned (GParamSpecPool *pool, GType owner_type);
function g_param_spec_pool_list_owned(pool, owner_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_param_spec_pool_list_owned
  type(c_ptr), value :: pool
  integer(c_size_t), value :: owner_type
end function

! GParamSpec** g_param_spec_pool_list (GParamSpecPool *pool, GType owner_type, guint *n_pspecs_p);
function g_param_spec_pool_list(pool, owner_type, n_pspecs_p) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_param_spec_pool_list
  type(c_ptr), value :: pool
  integer(c_size_t), value :: owner_type
  type(c_ptr), value :: n_pspecs_p
end function

!   GClosure* g_cclosure_new (GCallback callback_func, gpointer user_data, GClosureNotify destroy_data);
function g_cclosure_new(callback_func, user_data, destroy_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_cclosure_new
  type(c_funptr), value :: callback_func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy_data
end function

! GClosure* g_cclosure_new_swap (GCallback callback_func, gpointer user_data, GClosureNotify destroy_data);
function g_cclosure_new_swap(callback_func, user_data, destroy_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_cclosure_new_swap
  type(c_funptr), value :: callback_func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy_data
end function

! GClosure* g_signal_type_cclosure_new (GType itype, guint struct_offset);
function g_signal_type_cclosure_new(itype, struct_offset) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int
  type(c_ptr) :: g_signal_type_cclosure_new
  integer(c_size_t), value :: itype
  integer(c_int), value :: struct_offset
end function

!  GClosure* g_closure_ref (GClosure *closure);
function g_closure_ref(closure) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_closure_ref
  type(c_ptr), value :: closure
end function

! void g_closure_sink (GClosure *closure);
subroutine g_closure_sink(closure) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: closure
end subroutine

! void g_closure_unref (GClosure *closure);
subroutine g_closure_unref(closure) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: closure
end subroutine

!  GClosure* g_closure_new_simple (guint sizeof_closure, gpointer data);
function g_closure_new_simple(sizeof_closure, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_closure_new_simple
  integer(c_int), value :: sizeof_closure
  type(c_ptr), value :: data
end function

! void g_closure_add_finalize_notifier (GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
subroutine g_closure_add_finalize_notifier(closure, notify_data, notify_func) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_ptr), value :: notify_data
  type(c_funptr), value :: notify_func
end subroutine

! void g_closure_remove_finalize_notifier (GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
subroutine g_closure_remove_finalize_notifier(closure, notify_data, notify_func)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_ptr), value :: notify_data
  type(c_funptr), value :: notify_func
end subroutine

! void g_closure_add_invalidate_notifier (GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
subroutine g_closure_add_invalidate_notifier(closure, notify_data, notify_func) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_ptr), value :: notify_data
  type(c_funptr), value :: notify_func
end subroutine

! void g_closure_remove_invalidate_notifier (GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
subroutine g_closure_remove_invalidate_notifier(closure, notify_data, notify_fun&
      &c) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_ptr), value :: notify_data
  type(c_funptr), value :: notify_func
end subroutine

! void g_closure_add_marshal_guards (GClosure *closure, gpointer pre_marshal_data, GClosureNotify pre_marshal_notify, gpointer post_marshal_data, GClosureNotify post_marshal_notify);
subroutine g_closure_add_marshal_guards(closure, pre_marshal_data, pre_marshal_n&
      &otify, post_marshal_data, post_marshal_notify) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_ptr), value :: pre_marshal_data
  type(c_funptr), value :: pre_marshal_notify
  type(c_ptr), value :: post_marshal_data
  type(c_funptr), value :: post_marshal_notify
end subroutine

! void g_closure_set_marshal (GClosure *closure, GClosureMarshal marshal);
subroutine g_closure_set_marshal(closure, marshal) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_funptr), value :: marshal
end subroutine

! void g_closure_set_meta_marshal (GClosure *closure, gpointer marshal_data, GClosureMarshal meta_marshal);
subroutine g_closure_set_meta_marshal(closure, marshal_data, meta_marshal) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_ptr), value :: marshal_data
  type(c_funptr), value :: meta_marshal
end subroutine

! void g_closure_invalidate (GClosure *closure);
subroutine g_closure_invalidate(closure) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: closure
end subroutine

! void g_closure_invoke (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint);
subroutine g_closure_invoke(closure, return_value, n_param_values, param_values,&
      & invocation_hint) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
end subroutine

!   void g_source_set_closure (GSource *source, GClosure *closure);
subroutine g_source_set_closure(source, closure) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: closure
end subroutine

!  GType g_io_channel_get_type (void);
function g_io_channel_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_io_channel_get_type
end function

! GType g_io_condition_get_type (void);
function g_io_condition_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_io_condition_get_type
end function

!   GEnumValue* g_enum_get_value (GEnumClass *enum_class, gint value);
function g_enum_get_value(enum_class, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_enum_get_value
  type(c_ptr), value :: enum_class
  integer(c_int), value :: value
end function

! GEnumValue* g_enum_get_value_by_name (GEnumClass *enum_class, const gchar *name);
function g_enum_get_value_by_name(enum_class, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_enum_get_value_by_name
  type(c_ptr), value :: enum_class
  character(kind=c_char), dimension(*) :: name
end function

! GEnumValue* g_enum_get_value_by_nick (GEnumClass *enum_class, const gchar *nick);
function g_enum_get_value_by_nick(enum_class, nick) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_enum_get_value_by_nick
  type(c_ptr), value :: enum_class
  character(kind=c_char), dimension(*) :: nick
end function

! GFlagsValue* g_flags_get_first_value (GFlagsClass *flags_class, guint value);
function g_flags_get_first_value(flags_class, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_flags_get_first_value
  type(c_ptr), value :: flags_class
  integer(c_int), value :: value
end function

! GFlagsValue* g_flags_get_value_by_name (GFlagsClass *flags_class, const gchar *name);
function g_flags_get_value_by_name(flags_class, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_flags_get_value_by_name
  type(c_ptr), value :: flags_class
  character(kind=c_char), dimension(*) :: name
end function

! GFlagsValue* g_flags_get_value_by_nick (GFlagsClass *flags_class, const gchar *nick);
function g_flags_get_value_by_nick(flags_class, nick) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_flags_get_value_by_nick
  type(c_ptr), value :: flags_class
  character(kind=c_char), dimension(*) :: nick
end function

! void g_value_set_enum (GValue *value, gint v_enum);
subroutine g_value_set_enum(value, v_enum) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: value
  integer(c_int), value :: v_enum
end subroutine

! gint g_value_get_enum (const GValue *value);
function g_value_get_enum(value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_value_get_enum
  type(c_ptr), value :: value
end function

! void g_value_set_flags (GValue *value, guint v_flags);
subroutine g_value_set_flags(value, v_flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: value
  integer(c_int), value :: v_flags
end subroutine

! guint g_value_get_flags (const GValue *value);
function g_value_get_flags(value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_value_get_flags
  type(c_ptr), value :: value
end function

!  GType g_enum_register_static (const gchar *name, const GEnumValue *const_static_values);
function g_enum_register_static(name, const_static_values) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_enum_register_static
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: const_static_values
end function

! GType g_flags_register_static (const gchar *name, const GFlagsValue *const_static_values);
function g_flags_register_static(name, const_static_values) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_flags_register_static
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: const_static_values
end function

!  void g_enum_complete_type_info (GType g_enum_type, GTypeInfo *info, const GEnumValue *const_values);
subroutine g_enum_complete_type_info(g_enum_type, info, const_values) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t), value :: g_enum_type
  type(c_ptr), value :: info
  type(c_ptr), value :: const_values
end subroutine

! void g_flags_complete_type_info (GType g_flags_type, GTypeInfo *info, const GFlagsValue *const_values);
subroutine g_flags_complete_type_info(g_flags_type, info, const_values) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t), value :: g_flags_type
  type(c_ptr), value :: info
  type(c_ptr), value :: const_values
end subroutine

!   void g_cclosure_marshal_VOID__VOID (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__VOID(closure, return_value, n_param_values, &
      &param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__BOOLEAN (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__BOOLEAN(closure, return_value, n_param_value&
      &s, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__CHAR (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__CHAR(closure, return_value, n_param_values, &
      &param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__UCHAR (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__UCHAR(closure, return_value, n_param_values,&
      & param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__INT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__INT(closure, return_value, n_param_values, p&
      &aram_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__UINT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__UINT(closure, return_value, n_param_values, &
      &param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__LONG (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__LONG(closure, return_value, n_param_values, &
      &param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__ULONG (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__ULONG(closure, return_value, n_param_values,&
      & param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__ENUM (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__ENUM(closure, return_value, n_param_values, &
      &param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__FLAGS (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__FLAGS(closure, return_value, n_param_values,&
      & param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__FLOAT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__FLOAT(closure, return_value, n_param_values,&
      & param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__DOUBLE (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__DOUBLE(closure, return_value, n_param_values&
      &, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__STRING (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__STRING(closure, return_value, n_param_values&
      &, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__PARAM (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__PARAM(closure, return_value, n_param_values,&
      & param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__BOXED (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__BOXED(closure, return_value, n_param_values,&
      & param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__POINTER(closure, return_value, n_param_value&
      &s, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__OBJECT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__OBJECT(closure, return_value, n_param_values&
      &, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__VARIANT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__VARIANT(closure, return_value, n_param_value&
      &s, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__UINT_POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__UINT_POINTER(closure, return_value, n_param_&
      &values, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_BOOLEAN__FLAGS (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_BOOLEAN__FLAGS(closure, return_value, n_param_valu&
      &es, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_STRING__OBJECT_POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_STRING__OBJECT_POINTER(closure, return_value, n_pa&
      &ram_values, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_BOOLEAN__BOXED_BOXED (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_BOOLEAN__BOXED_BOXED(closure, return_value, n_para&
      &m_values, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!   void g_value_set_char (GValue *value, gchar v_char);
subroutine g_value_set_char(value, v_char) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: value
  character(c_char), value :: v_char
end subroutine

! gchar g_value_get_char (const GValue *value);
function g_value_get_char(value) bind(c) 
  use iso_c_binding, only: c_char, c_ptr
  character(c_char) :: g_value_get_char
  type(c_ptr), value :: value
end function

! void g_value_set_uchar (GValue *value, guchar v_uchar);
subroutine g_value_set_uchar(value, v_uchar) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: value
  character(c_char), value :: v_uchar
end subroutine

! guchar g_value_get_uchar (const GValue *value);
function g_value_get_uchar(value) bind(c) 
  use iso_c_binding, only: c_char, c_ptr
  character(c_char) :: g_value_get_uchar
  type(c_ptr), value :: value
end function

! void g_value_set_boolean (GValue *value, gboolean v_boolean);
subroutine g_value_set_boolean(value, v_boolean) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: value
  logical(c_bool), value :: v_boolean
end subroutine

! gboolean g_value_get_boolean (const GValue *value);
function g_value_get_boolean(value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_value_get_boolean
  type(c_ptr), value :: value
end function

! void g_value_set_int (GValue *value, gint v_int);
subroutine g_value_set_int(value, v_int) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: value
  integer(c_int), value :: v_int
end subroutine

! gint g_value_get_int (const GValue *value);
function g_value_get_int(value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_value_get_int
  type(c_ptr), value :: value
end function

! void g_value_set_uint (GValue *value, guint v_uint);
subroutine g_value_set_uint(value, v_uint) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: value
  integer(c_int), value :: v_uint
end subroutine

! guint g_value_get_uint (const GValue *value);
function g_value_get_uint(value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_value_get_uint
  type(c_ptr), value :: value
end function

! void g_value_set_long (GValue *value, glong v_long);
subroutine g_value_set_long(value, v_long) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr), value :: value
  integer(c_long), value :: v_long
end subroutine

! glong g_value_get_long (const GValue *value);
function g_value_get_long(value) bind(c) 
  use iso_c_binding, only: c_long, c_ptr
  integer(c_long) :: g_value_get_long
  type(c_ptr), value :: value
end function

! void g_value_set_ulong (GValue *value, gulong v_ulong);
subroutine g_value_set_ulong(value, v_ulong) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr), value :: value
  integer(c_long), value :: v_ulong
end subroutine

! gulong g_value_get_ulong (const GValue *value);
function g_value_get_ulong(value) bind(c) 
  use iso_c_binding, only: c_long, c_ptr
  integer(c_long) :: g_value_get_ulong
  type(c_ptr), value :: value
end function

! void g_value_set_int64 (GValue *value, gint64 v_int64);
subroutine g_value_set_int64(value, v_int64) bind(c) 
  use iso_c_binding, only: c_ptr, c_int64_t
  type(c_ptr), value :: value
  integer(c_int64_t), value :: v_int64
end subroutine

! gint64 g_value_get_int64 (const GValue *value);
function g_value_get_int64(value) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_value_get_int64
  type(c_ptr), value :: value
end function

! void g_value_set_uint64 (GValue *value, guint64 v_uint64);
subroutine g_value_set_uint64(value, v_uint64) bind(c) 
  use iso_c_binding, only: c_ptr, c_int64_t
  type(c_ptr), value :: value
  integer(c_int64_t), value :: v_uint64
end subroutine

! guint64 g_value_get_uint64 (const GValue *value);
function g_value_get_uint64(value) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_value_get_uint64
  type(c_ptr), value :: value
end function

! void g_value_set_float (GValue *value, gfloat v_float);
subroutine g_value_set_float(value, v_float) bind(c) 
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: value
  real(c_float), value :: v_float
end subroutine

! gfloat g_value_get_float (const GValue *value);
function g_value_get_float(value) bind(c) 
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: g_value_get_float
  type(c_ptr), value :: value
end function

! void g_value_set_double (GValue *value, gdouble v_double);
subroutine g_value_set_double(value, v_double) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: value
  real(c_double), value :: v_double
end subroutine

! gdouble g_value_get_double (const GValue *value);
function g_value_get_double(value) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: g_value_get_double
  type(c_ptr), value :: value
end function

! void g_value_set_string (GValue *value, const gchar *v_string);
subroutine g_value_set_string(value, v_string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: value
  character(kind=c_char), dimension(*) :: v_string
end subroutine

! void g_value_set_static_string (GValue *value, const gchar *v_string);
subroutine g_value_set_static_string(value, v_string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: value
  character(kind=c_char), dimension(*) :: v_string
end subroutine

! G_CONST_RETURN gchar* g_value_get_string (const GValue *value);
function g_value_get_string(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_get_string
  type(c_ptr), value :: value
end function

! gchar* g_value_dup_string (const GValue *value);
function g_value_dup_string(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_dup_string
  type(c_ptr), value :: value
end function

! void g_value_set_pointer (GValue *value, gpointer v_pointer);
subroutine g_value_set_pointer(value, v_pointer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_pointer
end subroutine

! gpointer g_value_get_pointer (const GValue *value);
function g_value_get_pointer(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_get_pointer
  type(c_ptr), value :: value
end function

! GType g_gtype_get_type (void);
function g_gtype_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_gtype_get_type
end function

! void g_value_set_gtype (GValue *value, GType v_gtype);
subroutine g_value_set_gtype(value, v_gtype) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: value
  integer(c_size_t), value :: v_gtype
end subroutine

! GType g_value_get_gtype (const GValue *value);
function g_value_get_gtype(value) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_value_get_gtype
  type(c_ptr), value :: value
end function

! void g_value_set_variant (GValue *value, GVariant *variant);
subroutine g_value_set_variant(value, variant) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: variant
end subroutine

! void g_value_take_variant (GValue *value, GVariant *variant);
subroutine g_value_take_variant(value, variant) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: variant
end subroutine

! GVariant* g_value_get_variant (const GValue *value);
function g_value_get_variant(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_get_variant
  type(c_ptr), value :: value
end function

! GVariant* g_value_dup_variant (const GValue *value);
function g_value_dup_variant(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_dup_variant
  type(c_ptr), value :: value
end function

!  GType g_pointer_type_register_static (const gchar *name);
function g_pointer_type_register_static(name) bind(c) 
  use iso_c_binding, only: c_size_t, c_char
  integer(c_size_t) :: g_pointer_type_register_static
  character(kind=c_char), dimension(*) :: name
end function

!  gchar* g_strdup_value_contents (const GValue *value);
function g_strdup_value_contents(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_strdup_value_contents
  type(c_ptr), value :: value
end function

!  void g_value_take_string (GValue *value, gchar *v_string);
subroutine g_value_take_string(value, v_string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: value
  character(kind=c_char), dimension(*) :: v_string
end subroutine

!  void g_value_set_string_take_ownership (GValue *value, gchar *v_string);
subroutine g_value_set_string_take_ownership(value, v_string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: value
  character(kind=c_char), dimension(*) :: v_string
end subroutine

!   GType g_type_plugin_get_type (void) G_GNUC_CONST;
function g_type_plugin_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_type_plugin_get_type
end function

! void g_type_plugin_use (GTypePlugin *plugin);
subroutine g_type_plugin_use(plugin) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: plugin
end subroutine

! void g_type_plugin_unuse (GTypePlugin *plugin);
subroutine g_type_plugin_unuse(plugin) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: plugin
end subroutine

! void g_type_plugin_complete_type_info (GTypePlugin *plugin, GType g_type, GTypeInfo *info, GTypeValueTable *value_table);
subroutine g_type_plugin_complete_type_info(plugin, g_type, info, value_table) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: plugin
  integer(c_size_t), value :: g_type
  type(c_ptr), value :: info
  type(c_ptr), value :: value_table
end subroutine

! void g_type_plugin_complete_interface_info (GTypePlugin *plugin, GType instance_type, GType interface_type, GInterfaceInfo *info);
subroutine g_type_plugin_complete_interface_info(plugin, instance_type, interfac&
      &e_type, info) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: plugin
  integer(c_size_t), value :: instance_type
  integer(c_size_t), value :: interface_type
  type(c_ptr), value :: info
end subroutine

!   gpointer g_boxed_copy (GType boxed_type, gconstpointer src_boxed);
function g_boxed_copy(boxed_type, src_boxed) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_boxed_copy
  integer(c_size_t), value :: boxed_type
  type(c_ptr), value :: src_boxed
end function

! void g_boxed_free (GType boxed_type, gpointer boxed);
subroutine g_boxed_free(boxed_type, boxed) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t), value :: boxed_type
  type(c_ptr), value :: boxed
end subroutine

! void g_value_set_boxed (GValue *value, gconstpointer v_boxed);
subroutine g_value_set_boxed(value, v_boxed) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_boxed
end subroutine

! void g_value_set_static_boxed (GValue *value, gconstpointer v_boxed);
subroutine g_value_set_static_boxed(value, v_boxed) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_boxed
end subroutine

! gpointer g_value_get_boxed (const GValue *value);
function g_value_get_boxed(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_get_boxed
  type(c_ptr), value :: value
end function

! gpointer g_value_dup_boxed (const GValue *value);
function g_value_dup_boxed(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_dup_boxed
  type(c_ptr), value :: value
end function

!  GType g_boxed_type_register_static (const gchar *name, GBoxedCopyFunc boxed_copy, GBoxedFreeFunc boxed_free);
function g_boxed_type_register_static(name, boxed_copy, boxed_free) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_funptr
  integer(c_size_t) :: g_boxed_type_register_static
  character(kind=c_char), dimension(*) :: name
  type(c_funptr), value :: boxed_copy
  type(c_funptr), value :: boxed_free
end function

!  void g_value_take_boxed (GValue *value, gconstpointer v_boxed);
subroutine g_value_take_boxed(value, v_boxed) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_boxed
end subroutine

!  void g_value_set_boxed_take_ownership (GValue *value, gconstpointer v_boxed);
subroutine g_value_set_boxed_take_ownership(value, v_boxed) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_boxed
end subroutine

!  GType g_closure_get_type (void) G_GNUC_CONST;
function g_closure_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_closure_get_type
end function

! GType g_value_get_type (void) G_GNUC_CONST;
function g_value_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_value_get_type
end function

! GType g_value_array_get_type (void) G_GNUC_CONST;
function g_value_array_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_value_array_get_type
end function

! GType g_date_get_type (void) G_GNUC_CONST;
function g_date_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_date_get_type
end function

! GType g_strv_get_type (void) G_GNUC_CONST;
function g_strv_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_strv_get_type
end function

! GType g_gstring_get_type (void) G_GNUC_CONST;
function g_gstring_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_gstring_get_type
end function

! GType g_hash_table_get_type (void) G_GNUC_CONST;
function g_hash_table_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_hash_table_get_type
end function

! GType g_array_get_type (void) G_GNUC_CONST;
function g_array_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_array_get_type
end function

! GType g_byte_array_get_type (void) G_GNUC_CONST;
function g_byte_array_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_byte_array_get_type
end function

! GType g_ptr_array_get_type (void) G_GNUC_CONST;
function g_ptr_array_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_ptr_array_get_type
end function

! GType g_variant_type_get_gtype(void) G_GNUC_CONST;
function g_variant_type_get_gtype() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_variant_type_get_gtype
end function

! GType g_regex_get_type (void) G_GNUC_CONST;
function g_regex_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_regex_get_type
end function

! GType g_error_get_type (void) G_GNUC_CONST;
function g_error_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_error_get_type
end function

! GType g_date_time_get_type (void) G_GNUC_CONST;
function g_date_time_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_date_time_get_type
end function

!  GType g_variant_get_gtype (void) G_GNUC_CONST;
function g_variant_get_gtype() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_variant_get_gtype
end function

!   static void g_object_notify_queue_free (gpointer data) { GObjectNotifyQueue *nqueue = data;
subroutine g_object_notify_queue_free(data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: data
end subroutine

!   GType g_initially_unowned_get_type (void);
function g_initially_unowned_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_initially_unowned_get_type
end function

! void g_object_class_install_property (GObjectClass *oclass, guint property_id, GParamSpec *pspec);
subroutine g_object_class_install_property(oclass, property_id, pspec) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: oclass
  integer(c_int), value :: property_id
  type(c_ptr), value :: pspec
end subroutine

! GParamSpec* g_object_class_find_property (GObjectClass *oclass, const gchar *property_name);
function g_object_class_find_property(oclass, property_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_object_class_find_property
  type(c_ptr), value :: oclass
  character(kind=c_char), dimension(*) :: property_name
end function

! GParamSpec**g_object_class_list_properties (GObjectClass *oclass, guint *n_properties);
function g_object_class_list_properties(oclass, n_properties) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_object_class_list_properties
  type(c_ptr), value :: oclass
  type(c_ptr), value :: n_properties
end function

! void g_object_class_override_property (GObjectClass *oclass, guint property_id, const gchar *name);
subroutine g_object_class_override_property(oclass, property_id, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: oclass
  integer(c_int), value :: property_id
  character(kind=c_char), dimension(*) :: name
end subroutine

! void g_object_class_install_properties (GObjectClass *oclass, guint n_pspecs, GParamSpec **pspecs);
subroutine g_object_class_install_properties(oclass, n_pspecs, pspecs) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: oclass
  integer(c_int), value :: n_pspecs
  type(c_ptr), value :: pspecs
end subroutine

!  void g_object_interface_install_property (gpointer g_iface, GParamSpec *pspec);
subroutine g_object_interface_install_property(g_iface, pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: g_iface
  type(c_ptr), value :: pspec
end subroutine

! GParamSpec* g_object_interface_find_property (gpointer g_iface, const gchar *property_name);
function g_object_interface_find_property(g_iface, property_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_object_interface_find_property
  type(c_ptr), value :: g_iface
  character(kind=c_char), dimension(*) :: property_name
end function

! GParamSpec**g_object_interface_list_properties (gpointer g_iface, guint *n_properties_p);
function g_object_interface_list_properties(g_iface, n_properties_p) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_object_interface_list_properties
  type(c_ptr), value :: g_iface
  type(c_ptr), value :: n_properties_p
end function

!  GType g_object_get_type (void) G_GNUC_CONST;
function g_object_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_object_get_type
end function

! gpointer g_object_newv (GType object_type, guint n_parameters, GParameter *parameters);
function g_object_newv(object_type, n_parameters, parameters) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int
  type(c_ptr) :: g_object_newv
  integer(c_size_t), value :: object_type
  integer(c_int), value :: n_parameters
  type(c_ptr), value :: parameters
end function

! GObject* g_object_new_valist (GType object_type, const gchar *first_property_name, va_list var_args);
function g_object_new_valist(object_type, first_property_name, var_args) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_object_new_valist
  integer(c_size_t), value :: object_type
  character(kind=c_char), dimension(*) :: first_property_name
  type(c_ptr), value :: var_args
end function

! void g_object_set_valist (GObject *object, const gchar *first_property_name, va_list var_args);
subroutine g_object_set_valist(object, first_property_name, var_args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: first_property_name
  type(c_ptr), value :: var_args
end subroutine

! void g_object_get_valist (GObject *object, const gchar *first_property_name, va_list var_args);
subroutine g_object_get_valist(object, first_property_name, var_args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: first_property_name
  type(c_ptr), value :: var_args
end subroutine

! void g_object_set_property (GObject *object, const gchar *property_name, const GValue *value);
subroutine g_object_set_property(object, property_name, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property_name
  type(c_ptr), value :: value
end subroutine

! void g_object_get_property (GObject *object, const gchar *property_name, GValue *value);
subroutine g_object_get_property(object, property_name, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property_name
  type(c_ptr), value :: value
end subroutine

! void g_object_freeze_notify (GObject *object);
subroutine g_object_freeze_notify(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
end subroutine

! void g_object_notify (GObject *object, const gchar *property_name);
subroutine g_object_notify(object, property_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property_name
end subroutine

! void g_object_notify_by_pspec (GObject *object, GParamSpec *pspec);
subroutine g_object_notify_by_pspec(object, pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
  type(c_ptr), value :: pspec
end subroutine

! void g_object_thaw_notify (GObject *object);
subroutine g_object_thaw_notify(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
end subroutine

! gboolean g_object_is_floating (gpointer object);
function g_object_is_floating(object) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_object_is_floating
  type(c_ptr), value :: object
end function

! gpointer g_object_ref_sink (gpointer object);
function g_object_ref_sink(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_object_ref_sink
  type(c_ptr), value :: object
end function

! gpointer g_object_ref (gpointer object);
function g_object_ref(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_object_ref
  type(c_ptr), value :: object
end function

! void g_object_unref (gpointer object);
subroutine g_object_unref(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
end subroutine

! void g_object_weak_ref (GObject *object, GWeakNotify notify, gpointer data);
subroutine g_object_weak_ref(object, notify, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: object
  type(c_funptr), value :: notify
  type(c_ptr), value :: data
end subroutine

! void g_object_weak_unref (GObject *object, GWeakNotify notify, gpointer data);
subroutine g_object_weak_unref(object, notify, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: object
  type(c_funptr), value :: notify
  type(c_ptr), value :: data
end subroutine

! void g_object_add_weak_pointer (GObject *object, gpointer *weak_pointer_location);
subroutine g_object_add_weak_pointer(object, weak_pointer_location) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
  type(c_ptr), value :: weak_pointer_location
end subroutine

! void g_object_remove_weak_pointer (GObject *object, gpointer *weak_pointer_location);
subroutine g_object_remove_weak_pointer(object, weak_pointer_location) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
  type(c_ptr), value :: weak_pointer_location
end subroutine

!  void g_object_add_toggle_ref (GObject *object, GToggleNotify notify, gpointer data);
subroutine g_object_add_toggle_ref(object, notify, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: object
  type(c_funptr), value :: notify
  type(c_ptr), value :: data
end subroutine

! void g_object_remove_toggle_ref (GObject *object, GToggleNotify notify, gpointer data);
subroutine g_object_remove_toggle_ref(object, notify, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: object
  type(c_funptr), value :: notify
  type(c_ptr), value :: data
end subroutine

!  gpointer g_object_get_qdata (GObject *object, GQuark quark);
function g_object_get_qdata(object, quark) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_object_get_qdata
  type(c_ptr), value :: object
  integer(c_int32_t), value :: quark
end function

! void g_object_set_qdata (GObject *object, GQuark quark, gpointer data);
subroutine g_object_set_qdata(object, quark, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: object
  integer(c_int32_t), value :: quark
  type(c_ptr), value :: data
end subroutine

! void g_object_set_qdata_full (GObject *object, GQuark quark, gpointer data, GDestroyNotify destroy);
subroutine g_object_set_qdata_full(object, quark, data, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_funptr
  type(c_ptr), value :: object
  integer(c_int32_t), value :: quark
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

! gpointer g_object_steal_qdata (GObject *object, GQuark quark);
function g_object_steal_qdata(object, quark) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_object_steal_qdata
  type(c_ptr), value :: object
  integer(c_int32_t), value :: quark
end function

! gpointer g_object_get_data (GObject *object, const gchar *key);
function g_object_get_data(object, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_object_get_data
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: key
end function

! void g_object_set_data (GObject *object, const gchar *key, gpointer data);
subroutine g_object_set_data(object, key, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: data
end subroutine

! void g_object_set_data_full (GObject *object, const gchar *key, gpointer data, GDestroyNotify destroy);
subroutine g_object_set_data_full(object, key, data, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

! gpointer g_object_steal_data (GObject *object, const gchar *key);
function g_object_steal_data(object, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_object_steal_data
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: key
end function

! void g_object_watch_closure (GObject *object, GClosure *closure);
subroutine g_object_watch_closure(object, closure) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
  type(c_ptr), value :: closure
end subroutine

! GClosure* g_cclosure_new_object (GCallback callback_func, GObject *object);
function g_cclosure_new_object(callback_func, object) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_cclosure_new_object
  type(c_funptr), value :: callback_func
  type(c_ptr), value :: object
end function

! GClosure* g_cclosure_new_object_swap (GCallback callback_func, GObject *object);
function g_cclosure_new_object_swap(callback_func, object) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_cclosure_new_object_swap
  type(c_funptr), value :: callback_func
  type(c_ptr), value :: object
end function

! GClosure* g_closure_new_object (guint sizeof_closure, GObject *object);
function g_closure_new_object(sizeof_closure, object) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_closure_new_object
  integer(c_int), value :: sizeof_closure
  type(c_ptr), value :: object
end function

! void g_value_set_object (GValue *value, gpointer v_object);
subroutine g_value_set_object(value, v_object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_object
end subroutine

! gpointer g_value_get_object (const GValue *value);
function g_value_get_object(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_get_object
  type(c_ptr), value :: value
end function

! gpointer g_value_dup_object (const GValue *value);
function g_value_dup_object(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_dup_object
  type(c_ptr), value :: value
end function

! gulong g_signal_connect_object (gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer gobject, GConnectFlags connect_flags);
function g_signal_connect_object(instance, detailed_signal, c_handler, gobject, &
      &connect_flags) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_char, c_funptr, c_int
  integer(c_long) :: g_signal_connect_object
  type(c_ptr), value :: instance
  character(kind=c_char), dimension(*) :: detailed_signal
  type(c_funptr), value :: c_handler
  type(c_ptr), value :: gobject
  integer(c_int), value :: connect_flags
end function

!  void g_object_force_floating (GObject *object);
subroutine g_object_force_floating(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
end subroutine

! void g_object_run_dispose (GObject *object);
subroutine g_object_run_dispose(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
end subroutine

!  void g_value_take_object (GValue *value, gpointer v_object);
subroutine g_value_take_object(value, v_object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_object
end subroutine

!  void g_value_set_object_take_ownership (GValue *value, gpointer v_object);
subroutine g_value_set_object_take_ownership(value, v_object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_object
end subroutine

!  gsize g_object_compat_control (gsize what, gpointer data);
function g_object_compat_control(what, data) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_object_compat_control
  integer(c_size_t), value :: what
  type(c_ptr), value :: data
end function

!   void g_type_init (void);
subroutine g_type_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void g_type_init_with_debug_flags (GTypeDebugFlags debug_flags);
subroutine g_type_init_with_debug_flags(debug_flags) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: debug_flags
end subroutine

! G_CONST_RETURN gchar* g_type_name (GType type);
function g_type_name(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_name
  integer(c_size_t), value :: type
end function

! GQuark g_type_qname (GType type);
function g_type_qname(type) bind(c) 
  use iso_c_binding, only: c_int32_t, c_size_t
  integer(c_int32_t) :: g_type_qname
  integer(c_size_t), value :: type
end function

! GType g_type_from_name (const gchar *name);
function g_type_from_name(name) bind(c) 
  use iso_c_binding, only: c_size_t, c_char
  integer(c_size_t) :: g_type_from_name
  character(kind=c_char), dimension(*) :: name
end function

! GType g_type_parent (GType type);
function g_type_parent(type) bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_type_parent
  integer(c_size_t), value :: type
end function

! guint g_type_depth (GType type);
function g_type_depth(type) bind(c) 
  use iso_c_binding, only: c_int, c_size_t
  integer(c_int) :: g_type_depth
  integer(c_size_t), value :: type
end function

! GType g_type_next_base (GType leaf_type, GType root_type);
function g_type_next_base(leaf_type, root_type) bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_type_next_base
  integer(c_size_t), value :: leaf_type
  integer(c_size_t), value :: root_type
end function

! gboolean g_type_is_a (GType type, GType is_a_type);
function g_type_is_a(type, is_a_type) bind(c) 
  use iso_c_binding, only: c_bool, c_size_t
  logical(c_bool) :: g_type_is_a
  integer(c_size_t), value :: type
  integer(c_size_t), value :: is_a_type
end function

! gpointer g_type_class_ref (GType type);
function g_type_class_ref(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_class_ref
  integer(c_size_t), value :: type
end function

! gpointer g_type_class_peek (GType type);
function g_type_class_peek(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_class_peek
  integer(c_size_t), value :: type
end function

! gpointer g_type_class_peek_static (GType type);
function g_type_class_peek_static(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_class_peek_static
  integer(c_size_t), value :: type
end function

! void g_type_class_unref (gpointer g_class);
subroutine g_type_class_unref(g_class) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: g_class
end subroutine

! gpointer g_type_class_peek_parent (gpointer g_class);
function g_type_class_peek_parent(g_class) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_type_class_peek_parent
  type(c_ptr), value :: g_class
end function

! gpointer g_type_interface_peek (gpointer instance_class, GType iface_type);
function g_type_interface_peek(instance_class, iface_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_interface_peek
  type(c_ptr), value :: instance_class
  integer(c_size_t), value :: iface_type
end function

! gpointer g_type_interface_peek_parent (gpointer g_iface);
function g_type_interface_peek_parent(g_iface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_type_interface_peek_parent
  type(c_ptr), value :: g_iface
end function

!  gpointer g_type_default_interface_ref (GType g_type);
function g_type_default_interface_ref(g_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_default_interface_ref
  integer(c_size_t), value :: g_type
end function

! gpointer g_type_default_interface_peek (GType g_type);
function g_type_default_interface_peek(g_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_default_interface_peek
  integer(c_size_t), value :: g_type
end function

! void g_type_default_interface_unref (gpointer g_iface);
subroutine g_type_default_interface_unref(g_iface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: g_iface
end subroutine

!  GType* g_type_children (GType type, guint *n_children);
function g_type_children(type, n_children) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_children
  integer(c_size_t), value :: type
  type(c_ptr), value :: n_children
end function

! GType* g_type_interfaces (GType type, guint *n_interfaces);
function g_type_interfaces(type, n_interfaces) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_interfaces
  integer(c_size_t), value :: type
  type(c_ptr), value :: n_interfaces
end function

!  void g_type_set_qdata (GType type, GQuark quark, gpointer data);
subroutine g_type_set_qdata(type, quark, data) bind(c) 
  use iso_c_binding, only: c_size_t, c_int32_t, c_ptr
  integer(c_size_t), value :: type
  integer(c_int32_t), value :: quark
  type(c_ptr), value :: data
end subroutine

! gpointer g_type_get_qdata (GType type, GQuark quark);
function g_type_get_qdata(type, quark) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int32_t
  type(c_ptr) :: g_type_get_qdata
  integer(c_size_t), value :: type
  integer(c_int32_t), value :: quark
end function

! void g_type_query (GType type, GTypeQuery *query);
subroutine g_type_query(type, query) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t), value :: type
  type(c_ptr), value :: query
end subroutine

!  GType g_type_register_static (GType parent_type, const gchar *type_name, const GTypeInfo *info, GTypeFlags flags);
function g_type_register_static(parent_type, type_name, info, flags) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr, c_int
  integer(c_size_t) :: g_type_register_static
  integer(c_size_t), value :: parent_type
  character(kind=c_char), dimension(*) :: type_name
  type(c_ptr), value :: info
  integer(c_int), value :: flags
end function

! GType g_type_register_static_simple (GType parent_type, const gchar *type_name, guint class_size, GClassInitFunc class_init, guint instance_size, GInstanceInitFunc instance_init, GTypeFlags flags);
function g_type_register_static_simple(parent_type, type_name, class_size, class&
      &_init, instance_size, instance_init, flags) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_int, c_funptr
  integer(c_size_t) :: g_type_register_static_simple
  integer(c_size_t), value :: parent_type
  character(kind=c_char), dimension(*) :: type_name
  integer(c_int), value :: class_size
  type(c_funptr), value :: class_init
  integer(c_int), value :: instance_size
  type(c_funptr), value :: instance_init
  integer(c_int), value :: flags
end function

!  GType g_type_register_dynamic (GType parent_type, const gchar *type_name, GTypePlugin *plugin, GTypeFlags flags);
function g_type_register_dynamic(parent_type, type_name, plugin, flags) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr, c_int
  integer(c_size_t) :: g_type_register_dynamic
  integer(c_size_t), value :: parent_type
  character(kind=c_char), dimension(*) :: type_name
  type(c_ptr), value :: plugin
  integer(c_int), value :: flags
end function

! GType g_type_register_fundamental (GType type_id, const gchar *type_name, const GTypeInfo *info, const GTypeFundamentalInfo *finfo, GTypeFlags flags);
function g_type_register_fundamental(type_id, type_name, info, finfo, flags) bin&
      &d(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr, c_int
  integer(c_size_t) :: g_type_register_fundamental
  integer(c_size_t), value :: type_id
  character(kind=c_char), dimension(*) :: type_name
  type(c_ptr), value :: info
  type(c_ptr), value :: finfo
  integer(c_int), value :: flags
end function

! void g_type_add_interface_static (GType instance_type, GType interface_type, const GInterfaceInfo *info);
subroutine g_type_add_interface_static(instance_type, interface_type, info) bind&
      &(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t), value :: instance_type
  integer(c_size_t), value :: interface_type
  type(c_ptr), value :: info
end subroutine

! void g_type_add_interface_dynamic (GType instance_type, GType interface_type, GTypePlugin *plugin);
subroutine g_type_add_interface_dynamic(instance_type, interface_type, plugin) b&
      &ind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t), value :: instance_type
  integer(c_size_t), value :: interface_type
  type(c_ptr), value :: plugin
end subroutine

! void g_type_interface_add_prerequisite (GType interface_type, GType prerequisite_type);
subroutine g_type_interface_add_prerequisite(interface_type, prerequisite_type) &
      &bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t), value :: interface_type
  integer(c_size_t), value :: prerequisite_type
end subroutine

! GType*g_type_interface_prerequisites (GType interface_type, guint *n_prerequisites);
function g_type_interface_prerequisites(interface_type, n_prerequisites) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_interface_prerequisites
  integer(c_size_t), value :: interface_type
  type(c_ptr), value :: n_prerequisites
end function

! void g_type_class_add_private (gpointer g_class, gsize private_size);
subroutine g_type_class_add_private(g_class, private_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: g_class
  integer(c_size_t), value :: private_size
end subroutine

! gpointer g_type_instance_get_private (GTypeInstance *instance, GType private_type);
function g_type_instance_get_private(instance, private_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_instance_get_private
  type(c_ptr), value :: instance
  integer(c_size_t), value :: private_type
end function

!  void g_type_add_class_private (GType class_type, gsize private_size);
subroutine g_type_add_class_private(class_type, private_size) bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t), value :: class_type
  integer(c_size_t), value :: private_size
end subroutine

! gpointer g_type_class_get_private (GTypeClass *klass, GType private_type);
function g_type_class_get_private(klass, private_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_class_get_private
  type(c_ptr), value :: klass
  integer(c_size_t), value :: private_type
end function

!  GTypePlugin* g_type_get_plugin (GType type);
function g_type_get_plugin(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_get_plugin
  integer(c_size_t), value :: type
end function

! GTypePlugin* g_type_interface_get_plugin (GType instance_type, GType interface_type);
function g_type_interface_get_plugin(instance_type, interface_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_interface_get_plugin
  integer(c_size_t), value :: instance_type
  integer(c_size_t), value :: interface_type
end function

! GType g_type_fundamental_next (void);
function g_type_fundamental_next() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_type_fundamental_next
end function

! GType g_type_fundamental (GType type_id);
function g_type_fundamental(type_id) bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_type_fundamental
  integer(c_size_t), value :: type_id
end function

! GTypeInstance* g_type_create_instance (GType type);
function g_type_create_instance(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_create_instance
  integer(c_size_t), value :: type
end function

! void g_type_free_instance (GTypeInstance *instance);
subroutine g_type_free_instance(instance) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: instance
end subroutine

!  void g_type_add_class_cache_func (gpointer cache_data, GTypeClassCacheFunc cache_func);
subroutine g_type_add_class_cache_func(cache_data, cache_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: cache_data
  type(c_funptr), value :: cache_func
end subroutine

! void g_type_remove_class_cache_func (gpointer cache_data, GTypeClassCacheFunc cache_func);
subroutine g_type_remove_class_cache_func(cache_data, cache_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: cache_data
  type(c_funptr), value :: cache_func
end subroutine

! void g_type_class_unref_uncached (gpointer g_class);
subroutine g_type_class_unref_uncached(g_class) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: g_class
end subroutine

!  void g_type_add_interface_check (gpointer check_data, GTypeInterfaceCheckFunc check_func);
subroutine g_type_add_interface_check(check_data, check_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: check_data
  type(c_funptr), value :: check_func
end subroutine

! void g_type_remove_interface_check (gpointer check_data, GTypeInterfaceCheckFunc check_func);
subroutine g_type_remove_interface_check(check_data, check_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: check_data
  type(c_funptr), value :: check_func
end subroutine

!  GTypeValueTable* g_type_value_table_peek (GType type);
function g_type_value_table_peek(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_value_table_peek
  integer(c_size_t), value :: type
end function

!  gboolean g_type_check_instance (GTypeInstance *instance) G_GNUC_PURE;
function g_type_check_instance(instance) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_type_check_instance
  type(c_ptr), value :: instance
end function

! GTypeInstance* g_type_check_instance_cast (GTypeInstance *instance, GType iface_type);
function g_type_check_instance_cast(instance, iface_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_check_instance_cast
  type(c_ptr), value :: instance
  integer(c_size_t), value :: iface_type
end function

! gboolean g_type_check_instance_is_a (GTypeInstance *instance, GType iface_type) G_GNUC_PURE;
function g_type_check_instance_is_a(instance, iface_type) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_size_t
  logical(c_bool) :: g_type_check_instance_is_a
  type(c_ptr), value :: instance
  integer(c_size_t), value :: iface_type
end function

! GTypeClass* g_type_check_class_cast (GTypeClass *g_class, GType is_a_type);
function g_type_check_class_cast(g_class, is_a_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_check_class_cast
  type(c_ptr), value :: g_class
  integer(c_size_t), value :: is_a_type
end function

! gboolean g_type_check_class_is_a (GTypeClass *g_class, GType is_a_type) G_GNUC_PURE;
function g_type_check_class_is_a(g_class, is_a_type) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_size_t
  logical(c_bool) :: g_type_check_class_is_a
  type(c_ptr), value :: g_class
  integer(c_size_t), value :: is_a_type
end function

! gboolean g_type_check_is_value_type (GType type) G_GNUC_CONST;
function g_type_check_is_value_type(type) bind(c) 
  use iso_c_binding, only: c_bool, c_size_t
  logical(c_bool) :: g_type_check_is_value_type
  integer(c_size_t), value :: type
end function

! gboolean g_type_check_value (GValue *value) G_GNUC_PURE;
function g_type_check_value(value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_type_check_value
  type(c_ptr), value :: value
end function

! gboolean g_type_check_value_holds (GValue *value, GType type) G_GNUC_PURE;
function g_type_check_value_holds(value, type) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_size_t
  logical(c_bool) :: g_type_check_value_holds
  type(c_ptr), value :: value
  integer(c_size_t), value :: type
end function

! gboolean g_type_test_flags (GType type, guint flags) G_GNUC_CONST;
function g_type_test_flags(type, flags) bind(c) 
  use iso_c_binding, only: c_bool, c_size_t, c_int
  logical(c_bool) :: g_type_test_flags
  integer(c_size_t), value :: type
  integer(c_int), value :: flags
end function

!  G_CONST_RETURN gchar* g_type_name_from_instance (GTypeInstance *instance);
function g_type_name_from_instance(instance) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_type_name_from_instance
  type(c_ptr), value :: instance
end function

! G_CONST_RETURN gchar* g_type_name_from_class (GTypeClass *g_class);
function g_type_name_from_class(g_class) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_type_name_from_class
  type(c_ptr), value :: g_class
end function

!  G_GNUC_INTERNAL void g_value_c_init (void);
subroutine g_value_c_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

! G_GNUC_INTERNAL void g_value_types_init (void);
subroutine g_value_types_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

! G_GNUC_INTERNAL void g_enum_types_init (void);
subroutine g_enum_types_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

! G_GNUC_INTERNAL void g_param_type_init (void);
subroutine g_param_type_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

! G_GNUC_INTERNAL void g_boxed_type_init (void);
subroutine g_boxed_type_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

! G_GNUC_INTERNAL void g_object_type_init (void);
subroutine g_object_type_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

! G_GNUC_INTERNAL void g_param_spec_types_init (void);
subroutine g_param_spec_types_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

! G_GNUC_INTERNAL void g_value_transforms_init (void);
subroutine g_value_transforms_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

! G_GNUC_INTERNAL void g_signal_init (void);
subroutine g_signal_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

!   GParamSpec* g_param_spec_char (const gchar *name, const gchar *nick, const gchar *blurb, gint8 minimum, gint8 maximum, gint8 default_value, GParamFlags flags);
function g_param_spec_char(name, nick, blurb, minimum, maximum, default_value, f&
      &lags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int8_t, c_int
  type(c_ptr) :: g_param_spec_char
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int8_t), value :: minimum
  integer(c_int8_t), value :: maximum
  integer(c_int8_t), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_uchar (const gchar *name, const gchar *nick, const gchar *blurb, guint8 minimum, guint8 maximum, guint8 default_value, GParamFlags flags);
function g_param_spec_uchar(name, nick, blurb, minimum, maximum, default_value, &
      &flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int8_t, c_int
  type(c_ptr) :: g_param_spec_uchar
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int8_t), value :: minimum
  integer(c_int8_t), value :: maximum
  integer(c_int8_t), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_boolean (const gchar *name, const gchar *nick, const gchar *blurb, gboolean default_value, GParamFlags flags);
function g_param_spec_boolean(name, nick, blurb, default_value, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_bool, c_int
  type(c_ptr) :: g_param_spec_boolean
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  logical(c_bool), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_int (const gchar *name, const gchar *nick, const gchar *blurb, gint minimum, gint maximum, gint default_value, GParamFlags flags);
function g_param_spec_int(name, nick, blurb, minimum, maximum, default_value, fl&
      &ags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_int
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int), value :: minimum
  integer(c_int), value :: maximum
  integer(c_int), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_uint (const gchar *name, const gchar *nick, const gchar *blurb, guint minimum, guint maximum, guint default_value, GParamFlags flags);
function g_param_spec_uint(name, nick, blurb, minimum, maximum, default_value, f&
      &lags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_uint
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int), value :: minimum
  integer(c_int), value :: maximum
  integer(c_int), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_long (const gchar *name, const gchar *nick, const gchar *blurb, glong minimum, glong maximum, glong default_value, GParamFlags flags);
function g_param_spec_long(name, nick, blurb, minimum, maximum, default_value, f&
      &lags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long, c_int
  type(c_ptr) :: g_param_spec_long
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_long), value :: minimum
  integer(c_long), value :: maximum
  integer(c_long), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_ulong (const gchar *name, const gchar *nick, const gchar *blurb, gulong minimum, gulong maximum, gulong default_value, GParamFlags flags);
function g_param_spec_ulong(name, nick, blurb, minimum, maximum, default_value, &
      &flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long, c_int
  type(c_ptr) :: g_param_spec_ulong
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_long), value :: minimum
  integer(c_long), value :: maximum
  integer(c_long), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_int64 (const gchar *name, const gchar *nick, const gchar *blurb, gint64 minimum, gint64 maximum, gint64 default_value, GParamFlags flags);
function g_param_spec_int64(name, nick, blurb, minimum, maximum, default_value, &
      &flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int64_t, c_int
  type(c_ptr) :: g_param_spec_int64
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int64_t), value :: minimum
  integer(c_int64_t), value :: maximum
  integer(c_int64_t), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_uint64 (const gchar *name, const gchar *nick, const gchar *blurb, guint64 minimum, guint64 maximum, guint64 default_value, GParamFlags flags);
function g_param_spec_uint64(name, nick, blurb, minimum, maximum, default_value,&
      & flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int64_t, c_int
  type(c_ptr) :: g_param_spec_uint64
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int64_t), value :: minimum
  integer(c_int64_t), value :: maximum
  integer(c_int64_t), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_unichar (const gchar *name, const gchar *nick, const gchar *blurb, gunichar default_value, GParamFlags flags);
function g_param_spec_unichar(name, nick, blurb, default_value, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int32_t, c_int
  type(c_ptr) :: g_param_spec_unichar
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int32_t), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_enum (const gchar *name, const gchar *nick, const gchar *blurb, GType enum_type, gint default_value, GParamFlags flags);
function g_param_spec_enum(name, nick, blurb, enum_type, default_value, flags) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_enum
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_size_t), value :: enum_type
  integer(c_int), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_flags (const gchar *name, const gchar *nick, const gchar *blurb, GType flags_type, guint default_value, GParamFlags flags);
function g_param_spec_flags(name, nick, blurb, flags_type, default_value, flags)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_flags
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_size_t), value :: flags_type
  integer(c_int), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_float (const gchar *name, const gchar *nick, const gchar *blurb, gfloat minimum, gfloat maximum, gfloat default_value, GParamFlags flags);
function g_param_spec_float(name, nick, blurb, minimum, maximum, default_value, &
      &flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_float, c_int
  type(c_ptr) :: g_param_spec_float
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  real(c_float), value :: minimum
  real(c_float), value :: maximum
  real(c_float), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_double (const gchar *name, const gchar *nick, const gchar *blurb, gdouble minimum, gdouble maximum, gdouble default_value, GParamFlags flags);
function g_param_spec_double(name, nick, blurb, minimum, maximum, default_value,&
      & flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_double, c_int
  type(c_ptr) :: g_param_spec_double
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  real(c_double), value :: minimum
  real(c_double), value :: maximum
  real(c_double), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_string (const gchar *name, const gchar *nick, const gchar *blurb, const gchar *default_value, GParamFlags flags);
function g_param_spec_string(name, nick, blurb, default_value, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_string
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  character(kind=c_char), dimension(*) :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_param (const gchar *name, const gchar *nick, const gchar *blurb, GType param_type, GParamFlags flags);
function g_param_spec_param(name, nick, blurb, param_type, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_param
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_size_t), value :: param_type
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_boxed (const gchar *name, const gchar *nick, const gchar *blurb, GType boxed_type, GParamFlags flags);
function g_param_spec_boxed(name, nick, blurb, boxed_type, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_boxed
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_size_t), value :: boxed_type
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_pointer (const gchar *name, const gchar *nick, const gchar *blurb, GParamFlags flags);
function g_param_spec_pointer(name, nick, blurb, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_pointer
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_value_array (const gchar *name, const gchar *nick, const gchar *blurb, GParamSpec *element_spec, GParamFlags flags);
function g_param_spec_value_array(name, nick, blurb, element_spec, flags) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_value_array
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  type(c_ptr), value :: element_spec
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_object (const gchar *name, const gchar *nick, const gchar *blurb, GType object_type, GParamFlags flags);
function g_param_spec_object(name, nick, blurb, object_type, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_object
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_size_t), value :: object_type
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_override (const gchar *name, GParamSpec *overridden);
function g_param_spec_override(name, overridden) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_param_spec_override
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: overridden
end function

! GParamSpec* g_param_spec_gtype (const gchar *name, const gchar *nick, const gchar *blurb, GType is_a_type, GParamFlags flags);
function g_param_spec_gtype(name, nick, blurb, is_a_type, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_gtype
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_size_t), value :: is_a_type
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_variant (const gchar *name, const gchar *nick, const gchar *blurb, const GVariantType *type, GVariant *default_value, GParamFlags flags);
function g_param_spec_variant(name, nick, blurb, type, default_value, flags) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_variant
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  type(c_ptr), value :: type
  type(c_ptr), value :: default_value
  integer(c_int), value :: flags
end function

!   GValue* g_value_array_get_nth (GValueArray *value_array, guint index_);
function g_value_array_get_nth(value_array, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_value_array_get_nth
  type(c_ptr), value :: value_array
  integer(c_int), value :: index_
end function

! GValueArray* g_value_array_new (guint n_prealloced);
function g_value_array_new(n_prealloced) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_value_array_new
  integer(c_int), value :: n_prealloced
end function

! void g_value_array_free (GValueArray *value_array);
subroutine g_value_array_free(value_array) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value_array
end subroutine

! GValueArray* g_value_array_copy (const GValueArray *value_array);
function g_value_array_copy(value_array) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_array_copy
  type(c_ptr), value :: value_array
end function

! GValueArray* g_value_array_prepend (GValueArray *value_array, const GValue *value);
function g_value_array_prepend(value_array, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_array_prepend
  type(c_ptr), value :: value_array
  type(c_ptr), value :: value
end function

! GValueArray* g_value_array_append (GValueArray *value_array, const GValue *value);
function g_value_array_append(value_array, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_array_append
  type(c_ptr), value :: value_array
  type(c_ptr), value :: value
end function

! GValueArray* g_value_array_insert (GValueArray *value_array, guint index_, const GValue *value);
function g_value_array_insert(value_array, index_, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_value_array_insert
  type(c_ptr), value :: value_array
  integer(c_int), value :: index_
  type(c_ptr), value :: value
end function

! GValueArray* g_value_array_remove (GValueArray *value_array, guint index_);
function g_value_array_remove(value_array, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_value_array_remove
  type(c_ptr), value :: value_array
  integer(c_int), value :: index_
end function

! GValueArray* g_value_array_sort (GValueArray *value_array, GCompareFunc compare_func);
function g_value_array_sort(value_array, compare_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_value_array_sort
  type(c_ptr), value :: value_array
  type(c_funptr), value :: compare_func
end function

! GValueArray* g_value_array_sort_with_data (GValueArray *value_array, GCompareDataFunc compare_func, gpointer user_data);
function g_value_array_sort_with_data(value_array, compare_func, user_data) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_value_array_sort_with_data
  type(c_ptr), value :: value_array
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end function

!   GType g_binding_flags_get_type (void) G_GNUC_CONST;
function g_binding_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_binding_flags_get_type
end function

! GType g_binding_get_type (void) G_GNUC_CONST;
function g_binding_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_binding_get_type
end function

!  GBindingFlags g_binding_get_flags (GBinding *binding);
function g_binding_get_flags(binding) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_binding_get_flags
  type(c_ptr), value :: binding
end function

! GObject * g_binding_get_source (GBinding *binding);
function g_binding_get_source(binding) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_binding_get_source
  type(c_ptr), value :: binding
end function

! GObject * g_binding_get_target (GBinding *binding);
function g_binding_get_target(binding) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_binding_get_target
  type(c_ptr), value :: binding
end function

! G_CONST_RETURN gchar *g_binding_get_source_property (GBinding *binding);
function g_binding_get_source_property(binding) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_binding_get_source_property
  type(c_ptr), value :: binding
end function

! G_CONST_RETURN gchar *g_binding_get_target_property (GBinding *binding);
function g_binding_get_target_property(binding) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_binding_get_target_property
  type(c_ptr), value :: binding
end function

!  GBinding *g_object_bind_property (gpointer source, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags);
function g_object_bind_property(source, source_property, target, target_property&
      &, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_object_bind_property
  type(c_ptr), value :: source
  character(kind=c_char), dimension(*) :: source_property
  type(c_ptr), value :: target
  character(kind=c_char), dimension(*) :: target_property
  integer(c_int), value :: flags
end function

! GBinding *g_object_bind_property_full (gpointer source, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GBindingTransformFunc transform_to, GBindingTransformFunc transform_from, gpointer user_data, GDestroyNotify notify);
function g_object_bind_property_full(source, source_property, target, target_pro&
      &perty, flags, transform_to, transform_from, user_data, notify) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr) :: g_object_bind_property_full
  type(c_ptr), value :: source
  character(kind=c_char), dimension(*) :: source_property
  type(c_ptr), value :: target
  character(kind=c_char), dimension(*) :: target_property
  integer(c_int), value :: flags
  type(c_funptr), value :: transform_to
  type(c_funptr), value :: transform_from
  type(c_ptr), value :: user_data
  type(c_funptr), value :: notify
end function

! GBinding *g_object_bind_property_with_closures (gpointer source, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GClosure *transform_to, GClosure *transform_from);
function g_object_bind_property_with_closures(source, source_property, target, t&
      &arget_property, flags, transform_to, transform_from) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_object_bind_property_with_closures
  type(c_ptr), value :: source
  character(kind=c_char), dimension(*) :: source_property
  type(c_ptr), value :: target
  character(kind=c_char), dimension(*) :: target_property
  integer(c_int), value :: flags
  type(c_ptr), value :: transform_to
  type(c_ptr), value :: transform_from
end function

!   guint g_signal_newv (const gchar *signal_name, GType itype, GSignalFlags signal_flags, GClosure *class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, GType *param_types);
function g_signal_newv(signal_name, itype, signal_flags, class_closure, accumula&
      &tor, accu_data, c_marshaller, return_type, n_params, param_types) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_size_t, c_ptr, c_funptr
  integer(c_int) :: g_signal_newv
  character(kind=c_char), dimension(*) :: signal_name
  integer(c_size_t), value :: itype
  integer(c_int), value :: signal_flags
  type(c_ptr), value :: class_closure
  type(c_funptr), value :: accumulator
  type(c_ptr), value :: accu_data
  type(c_ptr), value :: c_marshaller
  integer(c_size_t), value :: return_type
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end function

! guint g_signal_new_valist (const gchar *signal_name, GType itype, GSignalFlags signal_flags, GClosure *class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, va_list args);
function g_signal_new_valist(signal_name, itype, signal_flags, class_closure, ac&
      &cumulator, accu_data, c_marshaller, return_type, n_params, args) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_size_t, c_ptr, c_funptr
  integer(c_int) :: g_signal_new_valist
  character(kind=c_char), dimension(*) :: signal_name
  integer(c_size_t), value :: itype
  integer(c_int), value :: signal_flags
  type(c_ptr), value :: class_closure
  type(c_funptr), value :: accumulator
  type(c_ptr), value :: accu_data
  type(c_ptr), value :: c_marshaller
  integer(c_size_t), value :: return_type
  integer(c_int), value :: n_params
  type(c_ptr), value :: args
end function

!  void g_signal_emitv (const GValue *instance_and_params, guint signal_id, GQuark detail, GValue *return_value);
subroutine g_signal_emitv(instance_and_params, signal_id, detail, return_value) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int32_t
  type(c_ptr), value :: instance_and_params
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: return_value
end subroutine

! void g_signal_emit_valist (gpointer instance, guint signal_id, GQuark detail, va_list var_args);
subroutine g_signal_emit_valist(instance, signal_id, detail, var_args) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int32_t
  type(c_ptr), value :: instance
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: var_args
end subroutine

! guint g_signal_lookup (const gchar *name, GType itype);
function g_signal_lookup(name, itype) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_size_t
  integer(c_int) :: g_signal_lookup
  character(kind=c_char), dimension(*) :: name
  integer(c_size_t), value :: itype
end function

! G_CONST_RETURN gchar* g_signal_name (guint signal_id);
function g_signal_name(signal_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_signal_name
  integer(c_int), value :: signal_id
end function

! void g_signal_query (guint signal_id, GSignalQuery *query);
subroutine g_signal_query(signal_id, query) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int), value :: signal_id
  type(c_ptr), value :: query
end subroutine

! guint* g_signal_list_ids (GType itype, guint *n_ids);
function g_signal_list_ids(itype, n_ids) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_signal_list_ids
  integer(c_size_t), value :: itype
  type(c_ptr), value :: n_ids
end function

! gboolean g_signal_parse_name (const gchar *detailed_signal, GType itype, guint *signal_id_p, GQuark *detail_p, gboolean force_detail_quark);
function g_signal_parse_name(detailed_signal, itype, signal_id_p, detail_p, forc&
      &e_detail_quark) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_size_t, c_ptr
  logical(c_bool) :: g_signal_parse_name
  character(kind=c_char), dimension(*) :: detailed_signal
  integer(c_size_t), value :: itype
  type(c_ptr), value :: signal_id_p
  type(c_ptr), value :: detail_p
  logical(c_bool), value :: force_detail_quark
end function

! GSignalInvocationHint* g_signal_get_invocation_hint (gpointer instance);
function g_signal_get_invocation_hint(instance) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_signal_get_invocation_hint
  type(c_ptr), value :: instance
end function

!  void g_signal_stop_emission (gpointer instance, guint signal_id, GQuark detail);
subroutine g_signal_stop_emission(instance, signal_id, detail) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int32_t
  type(c_ptr), value :: instance
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
end subroutine

! void g_signal_stop_emission_by_name (gpointer instance, const gchar *detailed_signal);
subroutine g_signal_stop_emission_by_name(instance, detailed_signal) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: instance
  character(kind=c_char), dimension(*) :: detailed_signal
end subroutine

! gulong g_signal_add_emission_hook (guint signal_id, GQuark detail, GSignalEmissionHook hook_func, gpointer hook_data, GDestroyNotify data_destroy);
function g_signal_add_emission_hook(signal_id, detail, hook_func, hook_data, dat&
      &a_destroy) bind(c) 
  use iso_c_binding, only: c_long, c_int, c_int32_t, c_funptr, c_ptr
  integer(c_long) :: g_signal_add_emission_hook
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_funptr), value :: hook_func
  type(c_ptr), value :: hook_data
  type(c_funptr), value :: data_destroy
end function

! void g_signal_remove_emission_hook (guint signal_id, gulong hook_id);
subroutine g_signal_remove_emission_hook(signal_id, hook_id) bind(c) 
  use iso_c_binding, only: c_int, c_long
  integer(c_int), value :: signal_id
  integer(c_long), value :: hook_id
end subroutine

!  gboolean g_signal_has_handler_pending (gpointer instance, guint signal_id, GQuark detail, gboolean may_be_blocked);
function g_signal_has_handler_pending(instance, signal_id, detail, may_be_blocke&
      &d) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int, c_int32_t
  logical(c_bool) :: g_signal_has_handler_pending
  type(c_ptr), value :: instance
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  logical(c_bool), value :: may_be_blocked
end function

! gulong g_signal_connect_closure_by_id (gpointer instance, guint signal_id, GQuark detail, GClosure *closure, gboolean after);
function g_signal_connect_closure_by_id(instance, signal_id, detail, closure, af&
      &ter) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_int, c_int32_t, c_bool
  integer(c_long) :: g_signal_connect_closure_by_id
  type(c_ptr), value :: instance
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: closure
  logical(c_bool), value :: after
end function

! gulong g_signal_connect_closure (gpointer instance, const gchar *detailed_signal, GClosure *closure, gboolean after);
function g_signal_connect_closure(instance, detailed_signal, closure, after) bin&
      &d(c) 
  use iso_c_binding, only: c_long, c_ptr, c_char, c_bool
  integer(c_long) :: g_signal_connect_closure
  type(c_ptr), value :: instance
  character(kind=c_char), dimension(*) :: detailed_signal
  type(c_ptr), value :: closure
  logical(c_bool), value :: after
end function

! gulong g_signal_connect_data (gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer data, GClosureNotify destroy_data, GConnectFlags connect_flags);
function g_signal_connect_data(instance, detailed_signal, c_handler, data, destr&
      &oy_data, connect_flags) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_char, c_funptr, c_int
  integer(c_long) :: g_signal_connect_data
  type(c_ptr), value :: instance
  character(kind=c_char), dimension(*) :: detailed_signal
  type(c_funptr), value :: c_handler
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy_data
  integer(c_int), value :: connect_flags
end function

! void g_signal_handler_block (gpointer instance, gulong handler_id);
subroutine g_signal_handler_block(instance, handler_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr), value :: instance
  integer(c_long), value :: handler_id
end subroutine

! void g_signal_handler_unblock (gpointer instance, gulong handler_id);
subroutine g_signal_handler_unblock(instance, handler_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr), value :: instance
  integer(c_long), value :: handler_id
end subroutine

! void g_signal_handler_disconnect (gpointer instance, gulong handler_id);
subroutine g_signal_handler_disconnect(instance, handler_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr), value :: instance
  integer(c_long), value :: handler_id
end subroutine

! gboolean g_signal_handler_is_connected (gpointer instance, gulong handler_id);
function g_signal_handler_is_connected(instance, handler_id) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_long
  logical(c_bool) :: g_signal_handler_is_connected
  type(c_ptr), value :: instance
  integer(c_long), value :: handler_id
end function

! gulong g_signal_handler_find (gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
function g_signal_handler_find(instance, mask, signal_id, detail, closure, func,&
      & data) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_int, c_int32_t
  integer(c_long) :: g_signal_handler_find
  type(c_ptr), value :: instance
  integer(c_int), value :: mask
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: closure
  type(c_ptr), value :: func
  type(c_ptr), value :: data
end function

! guint g_signal_handlers_block_matched (gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
function g_signal_handlers_block_matched(instance, mask, signal_id, detail, clos&
      &ure, func, data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_signal_handlers_block_matched
  type(c_ptr), value :: instance
  integer(c_int), value :: mask
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: closure
  type(c_ptr), value :: func
  type(c_ptr), value :: data
end function

! guint g_signal_handlers_unblock_matched (gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
function g_signal_handlers_unblock_matched(instance, mask, signal_id, detail, cl&
      &osure, func, data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_signal_handlers_unblock_matched
  type(c_ptr), value :: instance
  integer(c_int), value :: mask
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: closure
  type(c_ptr), value :: func
  type(c_ptr), value :: data
end function

! guint g_signal_handlers_disconnect_matched (gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
function g_signal_handlers_disconnect_matched(instance, mask, signal_id, detail,&
      & closure, func, data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_signal_handlers_disconnect_matched
  type(c_ptr), value :: instance
  integer(c_int), value :: mask
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: closure
  type(c_ptr), value :: func
  type(c_ptr), value :: data
end function

!  void g_signal_override_class_closure (guint signal_id, GType instance_type, GClosure *class_closure);
subroutine g_signal_override_class_closure(signal_id, instance_type, class_closu&
      &re) bind(c) 
  use iso_c_binding, only: c_int, c_size_t, c_ptr
  integer(c_int), value :: signal_id
  integer(c_size_t), value :: instance_type
  type(c_ptr), value :: class_closure
end subroutine

! void g_signal_override_class_handler (const gchar *signal_name, GType instance_type, GCallback class_handler);
subroutine g_signal_override_class_handler(signal_name, instance_type, class_han&
      &dler) bind(c) 
  use iso_c_binding, only: c_char, c_size_t, c_funptr
  character(kind=c_char), dimension(*) :: signal_name
  integer(c_size_t), value :: instance_type
  type(c_funptr), value :: class_handler
end subroutine

! void g_signal_chain_from_overridden (const GValue *instance_and_params, GValue *return_value);
subroutine g_signal_chain_from_overridden(instance_and_params, return_value) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: instance_and_params
  type(c_ptr), value :: return_value
end subroutine

!  gboolean g_signal_accumulator_true_handled (GSignalInvocationHint *ihint, GValue *return_accu, const GValue *handler_return, gpointer dummy);
function g_signal_accumulator_true_handled(ihint, return_accu, handler_return, d&
      &ummy) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_signal_accumulator_true_handled
  type(c_ptr), value :: ihint
  type(c_ptr), value :: return_accu
  type(c_ptr), value :: handler_return
  type(c_ptr), value :: dummy
end function

!  void g_signal_handlers_destroy (gpointer instance);
subroutine g_signal_handlers_destroy(instance) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: instance
end subroutine

!   GValue* g_value_init (GValue *value, GType g_type);
function g_value_init(value, g_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_value_init
  type(c_ptr), value :: value
  integer(c_size_t), value :: g_type
end function

! void g_value_copy (const GValue *src_value, GValue *dest_value);
subroutine g_value_copy(src_value, dest_value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: src_value
  type(c_ptr), value :: dest_value
end subroutine

! GValue* g_value_reset (GValue *value);
function g_value_reset(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_reset
  type(c_ptr), value :: value
end function

! void g_value_unset (GValue *value);
subroutine g_value_unset(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
end subroutine

! void g_value_set_instance (GValue *value, gpointer instance);
subroutine g_value_set_instance(value, instance) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: instance
end subroutine

!  gboolean g_value_fits_pointer (const GValue *value);
function g_value_fits_pointer(value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_value_fits_pointer
  type(c_ptr), value :: value
end function

! gpointer g_value_peek_pointer (const GValue *value);
function g_value_peek_pointer(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_peek_pointer
  type(c_ptr), value :: value
end function

!  gboolean g_value_type_compatible (GType src_type, GType dest_type);
function g_value_type_compatible(src_type, dest_type) bind(c) 
  use iso_c_binding, only: c_bool, c_size_t
  logical(c_bool) :: g_value_type_compatible
  integer(c_size_t), value :: src_type
  integer(c_size_t), value :: dest_type
end function

! gboolean g_value_type_transformable (GType src_type, GType dest_type);
function g_value_type_transformable(src_type, dest_type) bind(c) 
  use iso_c_binding, only: c_bool, c_size_t
  logical(c_bool) :: g_value_type_transformable
  integer(c_size_t), value :: src_type
  integer(c_size_t), value :: dest_type
end function

! gboolean g_value_transform (const GValue *src_value, GValue *dest_value);
function g_value_transform(src_value, dest_value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_value_transform
  type(c_ptr), value :: src_value
  type(c_ptr), value :: dest_value
end function

! void g_value_register_transform_func (GType src_type, GType dest_type, GValueTransform transform_func);
subroutine g_value_register_transform_func(src_type, dest_type, transform_func) &
      &bind(c) 
  use iso_c_binding, only: c_size_t, c_funptr
  integer(c_size_t), value :: src_type
  integer(c_size_t), value :: dest_type
  type(c_funptr), value :: transform_func
end subroutine

!   GType g_socket_service_get_type (void);
function g_socket_service_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_service_get_type
end function

!  GSocketService *g_socket_service_new (void);
function g_socket_service_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_service_new
end function

! void g_socket_service_start (GSocketService *service);
subroutine g_socket_service_start(service) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: service
end subroutine

! void g_socket_service_stop (GSocketService *service);
subroutine g_socket_service_stop(service) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: service
end subroutine

! gboolean g_socket_service_is_active (GSocketService *service);
function g_socket_service_is_active(service) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_socket_service_is_active
  type(c_ptr), value :: service
end function

!   GType g_filter_input_stream_get_type (void) G_GNUC_CONST;
function g_filter_input_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_filter_input_stream_get_type
end function

! GInputStream * g_filter_input_stream_get_base_stream (GFilterInputStream *stream);
function g_filter_input_stream_get_base_stream(stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_filter_input_stream_get_base_stream
  type(c_ptr), value :: stream
end function

! gboolean g_filter_input_stream_get_close_base_stream (GFilterInputStream *stream);
function g_filter_input_stream_get_close_base_stream(stream) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_filter_input_stream_get_close_base_stream
  type(c_ptr), value :: stream
end function

! void g_filter_input_stream_set_close_base_stream (GFilterInputStream *stream, gboolean close_base);
subroutine g_filter_input_stream_set_close_base_stream(stream, close_base) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: stream
  logical(c_bool), value :: close_base
end subroutine

!   GType g_cancellable_get_type (void) G_GNUC_CONST;
function g_cancellable_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_cancellable_get_type
end function

!  GCancellable *g_cancellable_new (void);
function g_cancellable_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_cancellable_new
end function

!  gboolean g_cancellable_is_cancelled (GCancellable *cancellable);
function g_cancellable_is_cancelled(cancellable) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_cancellable_is_cancelled
  type(c_ptr), value :: cancellable
end function

! gboolean g_cancellable_set_error_if_cancelled (GCancellable *cancellable, GError **error);
function g_cancellable_set_error_if_cancelled(cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_cancellable_set_error_if_cancelled
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  int g_cancellable_get_fd (GCancellable *cancellable);
function g_cancellable_get_fd(cancellable) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_cancellable_get_fd
  type(c_ptr), value :: cancellable
end function

! gboolean g_cancellable_make_pollfd (GCancellable *cancellable, GPollFD *pollfd);
function g_cancellable_make_pollfd(cancellable, pollfd) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_cancellable_make_pollfd
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: pollfd
end function

! void g_cancellable_release_fd (GCancellable *cancellable);
subroutine g_cancellable_release_fd(cancellable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cancellable
end subroutine

!  GCancellable *g_cancellable_get_current (void);
function g_cancellable_get_current() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_cancellable_get_current
end function

! void g_cancellable_push_current (GCancellable *cancellable);
subroutine g_cancellable_push_current(cancellable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cancellable
end subroutine

! void g_cancellable_pop_current (GCancellable *cancellable);
subroutine g_cancellable_pop_current(cancellable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cancellable
end subroutine

! void g_cancellable_reset (GCancellable *cancellable);
subroutine g_cancellable_reset(cancellable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cancellable
end subroutine

! gulong g_cancellable_connect (GCancellable *cancellable, GCallback callback, gpointer data, GDestroyNotify data_destroy_func);
function g_cancellable_connect(cancellable, callback, data, data_destroy_func) b&
      &ind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_funptr
  integer(c_long) :: g_cancellable_connect
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: data
  type(c_funptr), value :: data_destroy_func
end function

! void g_cancellable_disconnect (GCancellable *cancellable, gulong handler_id);
subroutine g_cancellable_disconnect(cancellable, handler_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr), value :: cancellable
  integer(c_long), value :: handler_id
end subroutine

!  void g_cancellable_cancel (GCancellable *cancellable);
subroutine g_cancellable_cancel(cancellable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cancellable
end subroutine

!   GType g_file_output_stream_get_type (void) G_GNUC_CONST;
function g_file_output_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_output_stream_get_type
end function

!  GFileInfo *g_file_output_stream_query_info (GFileOutputStream *stream, const char *attributes, GCancellable *cancellable, GError **error);
function g_file_output_stream_query_info(stream, attributes, cancellable, error)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_output_stream_query_info
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: attributes
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_output_stream_query_info_async (GFileOutputStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_output_stream_query_info_async(stream, attributes, io_priority&
      &, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileInfo *g_file_output_stream_query_info_finish (GFileOutputStream *stream, GAsyncResult *result, GError **error);
function g_file_output_stream_query_info_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_output_stream_query_info_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! char * g_file_output_stream_get_etag (GFileOutputStream *stream);
function g_file_output_stream_get_etag(stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_output_stream_get_etag
  type(c_ptr), value :: stream
end function

!   GType g_dbus_auth_observer_get_type (void) G_GNUC_CONST;
function g_dbus_auth_observer_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_auth_observer_get_type
end function

! GDBusAuthObserver *g_dbus_auth_observer_new (void);
function g_dbus_auth_observer_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_auth_observer_new
end function

! gboolean g_dbus_auth_observer_authorize_authenticated_peer (GDBusAuthObserver *observer, GIOStream *stream, GCredentials *credentials);
function g_dbus_auth_observer_authorize_authenticated_peer(observer, stream, cre&
      &dentials) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_dbus_auth_observer_authorize_authenticated_peer
  type(c_ptr), value :: observer
  type(c_ptr), value :: stream
  type(c_ptr), value :: credentials
end function

!   GType g_converter_get_type (void) G_GNUC_CONST;
function g_converter_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_converter_get_type
end function

!  GConverterResult g_converter_convert (GConverter *converter, const void *inbuf, gsize inbuf_size, void *outbuf, gsize outbuf_size, GConverterFlags flags, gsize *bytes_read, gsize *bytes_written, GError **error);
function g_converter_convert(converter, inbuf, inbuf_size, outbuf, outbuf_size, &
      &flags, bytes_read, bytes_written, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_size_t
  integer(c_int) :: g_converter_convert
  type(c_ptr), value :: converter
  type(c_ptr), value :: inbuf
  integer(c_size_t), value :: inbuf_size
  type(c_ptr), value :: outbuf
  integer(c_size_t), value :: outbuf_size
  integer(c_int), value :: flags
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! void g_converter_reset (GConverter *converter);
subroutine g_converter_reset(converter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: converter
end subroutine

!   GType g_data_output_stream_get_type (void) G_GNUC_CONST;
function g_data_output_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_data_output_stream_get_type
end function

! GDataOutputStream * g_data_output_stream_new (GOutputStream *base_stream);
function g_data_output_stream_new(base_stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_data_output_stream_new
  type(c_ptr), value :: base_stream
end function

!  void g_data_output_stream_set_byte_order (GDataOutputStream *stream, GDataStreamByteOrder order);
subroutine g_data_output_stream_set_byte_order(stream, order) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: stream
  integer(c_int), value :: order
end subroutine

! GDataStreamByteOrder g_data_output_stream_get_byte_order (GDataOutputStream *stream);
function g_data_output_stream_get_byte_order(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_data_output_stream_get_byte_order
  type(c_ptr), value :: stream
end function

!  gboolean g_data_output_stream_put_byte (GDataOutputStream *stream, guchar data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_byte(stream, data, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_data_output_stream_put_byte
  type(c_ptr), value :: stream
  character(c_char), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_data_output_stream_put_int16 (GDataOutputStream *stream, gint16 data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_int16(stream, data, cancellable, error) bind(c&
      &) 
  use iso_c_binding, only: c_bool, c_ptr, c_int16_t
  logical(c_bool) :: g_data_output_stream_put_int16
  type(c_ptr), value :: stream
  integer(c_int16_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_data_output_stream_put_uint16 (GDataOutputStream *stream, guint16 data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_uint16(stream, data, cancellable, error) bind(&
      &c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int16_t
  logical(c_bool) :: g_data_output_stream_put_uint16
  type(c_ptr), value :: stream
  integer(c_int16_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_data_output_stream_put_int32 (GDataOutputStream *stream, gint32 data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_int32(stream, data, cancellable, error) bind(c&
      &) 
  use iso_c_binding, only: c_bool, c_ptr, c_int32_t
  logical(c_bool) :: g_data_output_stream_put_int32
  type(c_ptr), value :: stream
  integer(c_int32_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_data_output_stream_put_uint32 (GDataOutputStream *stream, guint32 data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_uint32(stream, data, cancellable, error) bind(&
      &c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int32_t
  logical(c_bool) :: g_data_output_stream_put_uint32
  type(c_ptr), value :: stream
  integer(c_int32_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_data_output_stream_put_int64 (GDataOutputStream *stream, gint64 data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_int64(stream, data, cancellable, error) bind(c&
      &) 
  use iso_c_binding, only: c_bool, c_ptr, c_int64_t
  logical(c_bool) :: g_data_output_stream_put_int64
  type(c_ptr), value :: stream
  integer(c_int64_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_data_output_stream_put_uint64 (GDataOutputStream *stream, guint64 data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_uint64(stream, data, cancellable, error) bind(&
      &c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int64_t
  logical(c_bool) :: g_data_output_stream_put_uint64
  type(c_ptr), value :: stream
  integer(c_int64_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_data_output_stream_put_string (GDataOutputStream *stream, const char *str, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_string(stream, str, cancellable, error) bind(c&
      &) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_data_output_stream_put_string
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: str
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!   GType g_mount_operation_get_type (void) G_GNUC_CONST;
function g_mount_operation_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_mount_operation_get_type
end function

! GMountOperation * g_mount_operation_new (void);
function g_mount_operation_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_operation_new
end function

!  const char * g_mount_operation_get_username (GMountOperation *op);
function g_mount_operation_get_username(op) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_operation_get_username
  type(c_ptr), value :: op
end function

! void g_mount_operation_set_username (GMountOperation *op, const char *username);
subroutine g_mount_operation_set_username(op, username) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: op
  character(kind=c_char), dimension(*) :: username
end subroutine

! const char * g_mount_operation_get_password (GMountOperation *op);
function g_mount_operation_get_password(op) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_operation_get_password
  type(c_ptr), value :: op
end function

! void g_mount_operation_set_password (GMountOperation *op, const char *password);
subroutine g_mount_operation_set_password(op, password) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: op
  character(kind=c_char), dimension(*) :: password
end subroutine

! gboolean g_mount_operation_get_anonymous (GMountOperation *op);
function g_mount_operation_get_anonymous(op) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_mount_operation_get_anonymous
  type(c_ptr), value :: op
end function

! void g_mount_operation_set_anonymous (GMountOperation *op, gboolean anonymous);
subroutine g_mount_operation_set_anonymous(op, anonymous) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: op
  logical(c_bool), value :: anonymous
end subroutine

! const char * g_mount_operation_get_domain (GMountOperation *op);
function g_mount_operation_get_domain(op) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_operation_get_domain
  type(c_ptr), value :: op
end function

! void g_mount_operation_set_domain (GMountOperation *op, const char *domain);
subroutine g_mount_operation_set_domain(op, domain) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: op
  character(kind=c_char), dimension(*) :: domain
end subroutine

! GPasswordSave g_mount_operation_get_password_save (GMountOperation *op);
function g_mount_operation_get_password_save(op) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_mount_operation_get_password_save
  type(c_ptr), value :: op
end function

! void g_mount_operation_set_password_save (GMountOperation *op, GPasswordSave save);
subroutine g_mount_operation_set_password_save(op, save) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: op
  integer(c_int), value :: save
end subroutine

! int g_mount_operation_get_choice (GMountOperation *op);
function g_mount_operation_get_choice(op) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_mount_operation_get_choice
  type(c_ptr), value :: op
end function

! void g_mount_operation_set_choice (GMountOperation *op, int choice);
subroutine g_mount_operation_set_choice(op, choice) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: op
  integer(c_int), value :: choice
end subroutine

! void g_mount_operation_reply (GMountOperation *op, GMountOperationResult result);
subroutine g_mount_operation_reply(op, result) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: op
  integer(c_int), value :: result
end subroutine

!   GType g_permission_get_type (void);
function g_permission_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_permission_get_type
end function

! gboolean g_permission_acquire (GPermission *permission, GCancellable *cancellable, GError **error);
function g_permission_acquire(permission, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_permission_acquire
  type(c_ptr), value :: permission
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_permission_acquire_async (GPermission *permission, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_permission_acquire_async(permission, cancellable, callback, user_da&
      &ta) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: permission
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_permission_acquire_finish (GPermission *permission, GAsyncResult *result, GError **error);
function g_permission_acquire_finish(permission, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_permission_acquire_finish
  type(c_ptr), value :: permission
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  gboolean g_permission_release (GPermission *permission, GCancellable *cancellable, GError **error);
function g_permission_release(permission, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_permission_release
  type(c_ptr), value :: permission
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_permission_release_async (GPermission *permission, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_permission_release_async(permission, cancellable, callback, user_da&
      &ta) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: permission
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_permission_release_finish (GPermission *permission, GAsyncResult *result, GError **error);
function g_permission_release_finish(permission, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_permission_release_finish
  type(c_ptr), value :: permission
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  gboolean g_permission_get_allowed (GPermission *permission);
function g_permission_get_allowed(permission) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_permission_get_allowed
  type(c_ptr), value :: permission
end function

! gboolean g_permission_get_can_acquire (GPermission *permission);
function g_permission_get_can_acquire(permission) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_permission_get_can_acquire
  type(c_ptr), value :: permission
end function

! gboolean g_permission_get_can_release (GPermission *permission);
function g_permission_get_can_release(permission) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_permission_get_can_release
  type(c_ptr), value :: permission
end function

!  void g_permission_impl_update (GPermission *permission, gboolean allowed, gboolean can_acquire, gboolean can_release);
subroutine g_permission_impl_update(permission, allowed, can_acquire, can_releas&
      &e) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: permission
  logical(c_bool), value :: allowed
  logical(c_bool), value :: can_acquire
  logical(c_bool), value :: can_release
end subroutine

!   GType g_dbus_proxy_get_type (void) G_GNUC_CONST;
function g_dbus_proxy_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_proxy_get_type
end function

! void g_dbus_proxy_new (GDBusConnection *connection, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_proxy_new(connection, flags, info, name, object_path, interfac&
      &e_name, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char, c_funptr
  type(c_ptr), value :: connection
  integer(c_int), value :: flags
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GDBusProxy *g_dbus_proxy_new_finish (GAsyncResult *res, GError **error);
function g_dbus_proxy_new_finish(res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_new_finish
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GDBusProxy *g_dbus_proxy_new_sync (GDBusConnection *connection, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GError **error);
function g_dbus_proxy_new_sync(connection, flags, info, name, object_path, inter&
      &face_name, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr) :: g_dbus_proxy_new_sync
  type(c_ptr), value :: connection
  integer(c_int), value :: flags
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_dbus_proxy_new_for_bus (GBusType bus_type, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_proxy_new_for_bus(bus_type, flags, info, name, object_path, in&
      &terface_name, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_funptr
  integer(c_int), value :: bus_type
  integer(c_int), value :: flags
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GDBusProxy *g_dbus_proxy_new_for_bus_finish (GAsyncResult *res, GError **error);
function g_dbus_proxy_new_for_bus_finish(res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_new_for_bus_finish
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GDBusProxy *g_dbus_proxy_new_for_bus_sync (GBusType bus_type, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GError **error);
function g_dbus_proxy_new_for_bus_sync(bus_type, flags, info, name, object_path,&
      & interface_name, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr) :: g_dbus_proxy_new_for_bus_sync
  integer(c_int), value :: bus_type
  integer(c_int), value :: flags
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GDBusConnection *g_dbus_proxy_get_connection (GDBusProxy *proxy);
function g_dbus_proxy_get_connection(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_connection
  type(c_ptr), value :: proxy
end function

! GDBusProxyFlags g_dbus_proxy_get_flags (GDBusProxy *proxy);
function g_dbus_proxy_get_flags(proxy) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_proxy_get_flags
  type(c_ptr), value :: proxy
end function

! const gchar *g_dbus_proxy_get_name (GDBusProxy *proxy);
function g_dbus_proxy_get_name(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_name
  type(c_ptr), value :: proxy
end function

! gchar *g_dbus_proxy_get_name_owner (GDBusProxy *proxy);
function g_dbus_proxy_get_name_owner(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_name_owner
  type(c_ptr), value :: proxy
end function

! const gchar *g_dbus_proxy_get_object_path (GDBusProxy *proxy);
function g_dbus_proxy_get_object_path(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_object_path
  type(c_ptr), value :: proxy
end function

! const gchar *g_dbus_proxy_get_interface_name (GDBusProxy *proxy);
function g_dbus_proxy_get_interface_name(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_interface_name
  type(c_ptr), value :: proxy
end function

! gint g_dbus_proxy_get_default_timeout (GDBusProxy *proxy);
function g_dbus_proxy_get_default_timeout(proxy) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_proxy_get_default_timeout
  type(c_ptr), value :: proxy
end function

! void g_dbus_proxy_set_default_timeout (GDBusProxy *proxy, gint timeout_msec);
subroutine g_dbus_proxy_set_default_timeout(proxy, timeout_msec) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: proxy
  integer(c_int), value :: timeout_msec
end subroutine

! GDBusInterfaceInfo *g_dbus_proxy_get_interface_info (GDBusProxy *proxy);
function g_dbus_proxy_get_interface_info(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_interface_info
  type(c_ptr), value :: proxy
end function

! void g_dbus_proxy_set_interface_info (GDBusProxy *proxy, GDBusInterfaceInfo *info);
subroutine g_dbus_proxy_set_interface_info(proxy, info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: proxy
  type(c_ptr), value :: info
end subroutine

! GVariant *g_dbus_proxy_get_cached_property (GDBusProxy *proxy, const gchar *property_name);
function g_dbus_proxy_get_cached_property(proxy, property_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_proxy_get_cached_property
  type(c_ptr), value :: proxy
  character(kind=c_char), dimension(*) :: property_name
end function

! void g_dbus_proxy_set_cached_property (GDBusProxy *proxy, const gchar *property_name, GVariant *value);
subroutine g_dbus_proxy_set_cached_property(proxy, property_name, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: proxy
  character(kind=c_char), dimension(*) :: property_name
  type(c_ptr), value :: value
end subroutine

! gchar **g_dbus_proxy_get_cached_property_names (GDBusProxy *proxy);
function g_dbus_proxy_get_cached_property_names(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_cached_property_names
  type(c_ptr), value :: proxy
end function

! void g_dbus_proxy_call (GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_proxy_call(proxy, method_name, parameters, flags, timeout_msec&
      &, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: proxy
  character(kind=c_char), dimension(*) :: method_name
  type(c_ptr), value :: parameters
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GVariant *g_dbus_proxy_call_finish (GDBusProxy *proxy, GAsyncResult *res, GError **error);
function g_dbus_proxy_call_finish(proxy, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_call_finish
  type(c_ptr), value :: proxy
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GVariant *g_dbus_proxy_call_sync (GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GError **error);
function g_dbus_proxy_call_sync(proxy, method_name, parameters, flags, timeout_m&
      &sec, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_dbus_proxy_call_sync
  type(c_ptr), value :: proxy
  character(kind=c_char), dimension(*) :: method_name
  type(c_ptr), value :: parameters
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!   GType g_srv_target_get_type (void) G_GNUC_CONST;
function g_srv_target_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_srv_target_get_type
end function

!  GSrvTarget *g_srv_target_new (const gchar *hostname, guint16 port, guint16 priority, guint16 weight);
function g_srv_target_new(hostname, port, priority, weight) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int16_t
  type(c_ptr) :: g_srv_target_new
  character(kind=c_char), dimension(*) :: hostname
  integer(c_int16_t), value :: port
  integer(c_int16_t), value :: priority
  integer(c_int16_t), value :: weight
end function

! GSrvTarget *g_srv_target_copy (GSrvTarget *target);
function g_srv_target_copy(target) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_srv_target_copy
  type(c_ptr), value :: target
end function

! void g_srv_target_free (GSrvTarget *target);
subroutine g_srv_target_free(target) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: target
end subroutine

!  const gchar *g_srv_target_get_hostname (GSrvTarget *target);
function g_srv_target_get_hostname(target) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_srv_target_get_hostname
  type(c_ptr), value :: target
end function

! guint16 g_srv_target_get_port (GSrvTarget *target);
function g_srv_target_get_port(target) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_srv_target_get_port
  type(c_ptr), value :: target
end function

! guint16 g_srv_target_get_priority (GSrvTarget *target);
function g_srv_target_get_priority(target) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_srv_target_get_priority
  type(c_ptr), value :: target
end function

! guint16 g_srv_target_get_weight (GSrvTarget *target);
function g_srv_target_get_weight(target) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_srv_target_get_weight
  type(c_ptr), value :: target
end function

!  GList *g_srv_target_list_sort (GList *targets);
function g_srv_target_list_sort(targets) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_srv_target_list_sort
  type(c_ptr), value :: targets
end function

!   guint g_bus_watch_name (GBusType bus_type, const gchar *name, GBusNameWatcherFlags flags, GBusNameAppearedCallback name_appeared_handler, GBusNameVanishedCallback name_vanished_handler, gpointer user_data, GDestroyNotify user_data_free_func);
function g_bus_watch_name(bus_type, name, flags, name_appeared_handler, name_van&
      &ished_handler, user_data, user_data_free_func) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_funptr, c_ptr
  integer(c_int) :: g_bus_watch_name
  integer(c_int), value :: bus_type
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_funptr), value :: name_appeared_handler
  type(c_funptr), value :: name_vanished_handler
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
end function

! guint g_bus_watch_name_on_connection (GDBusConnection *connection, const gchar *name, GBusNameWatcherFlags flags, GBusNameAppearedCallback name_appeared_handler, GBusNameVanishedCallback name_vanished_handler, gpointer user_data, GDestroyNotify user_data_free_func);
function g_bus_watch_name_on_connection(connection, name, flags, name_appeared_h&
      &andler, name_vanished_handler, user_data, user_data_free_func) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_funptr
  integer(c_int) :: g_bus_watch_name_on_connection
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_funptr), value :: name_appeared_handler
  type(c_funptr), value :: name_vanished_handler
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
end function

! guint g_bus_watch_name_with_closures (GBusType bus_type, const gchar *name, GBusNameWatcherFlags flags, GClosure *name_appeared_closure, GClosure *name_vanished_closure);
function g_bus_watch_name_with_closures(bus_type, name, flags, name_appeared_clo&
      &sure, name_vanished_closure) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_ptr
  integer(c_int) :: g_bus_watch_name_with_closures
  integer(c_int), value :: bus_type
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_ptr), value :: name_appeared_closure
  type(c_ptr), value :: name_vanished_closure
end function

! guint g_bus_watch_name_on_connection_with_closures ( GDBusConnection *connection, const gchar *name, GBusNameWatcherFlags flags, GClosure *name_appeared_closure, GClosure *name_vanished_closure);
function g_bus_watch_name_on_connection_with_closures(connection, name, flags, n&
      &ame_appeared_closure, name_vanished_closure) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_bus_watch_name_on_connection_with_closures
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_ptr), value :: name_appeared_closure
  type(c_ptr), value :: name_vanished_closure
end function

! void g_bus_unwatch_name (guint watcher_id);
subroutine g_bus_unwatch_name(watcher_id) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: watcher_id
end subroutine

!   GType g_native_volume_monitor_get_type (void) G_GNUC_CONST;
function g_native_volume_monitor_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_native_volume_monitor_get_type
end function

!   GType g_async_initable_get_type (void) G_GNUC_CONST;
function g_async_initable_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_async_initable_get_type
end function

!  void g_async_initable_init_async (GAsyncInitable *initable, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_async_initable_init_async(initable, io_priority, cancellable, callb&
      &ack, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: initable
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_async_initable_init_finish (GAsyncInitable *initable, GAsyncResult *res, GError **error);
function g_async_initable_init_finish(initable, res, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_async_initable_init_finish
  type(c_ptr), value :: initable
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! void g_async_initable_newv_async (GType object_type, guint n_parameters, GParameter *parameters, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_async_initable_newv_async(object_type, n_parameters, parameters, io&
      &_priority, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_size_t, c_int, c_ptr, c_funptr
  integer(c_size_t), value :: object_type
  integer(c_int), value :: n_parameters
  type(c_ptr), value :: parameters
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! void g_async_initable_new_valist_async (GType object_type, const gchar *first_property_name, va_list var_args, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_async_initable_new_valist_async(object_type, first_property_name, v&
      &ar_args, io_priority, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr, c_int, c_funptr
  integer(c_size_t), value :: object_type
  character(kind=c_char), dimension(*) :: first_property_name
  type(c_ptr), value :: var_args
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GObject *g_async_initable_new_finish (GAsyncInitable *initable, GAsyncResult *res, GError **error);
function g_async_initable_new_finish(initable, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_initable_new_finish
  type(c_ptr), value :: initable
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

!   GQuark g_dbus_error_quark (void);
function g_dbus_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_dbus_error_quark
end function

!  gboolean g_dbus_error_is_remote_error (const GError *error);
function g_dbus_error_is_remote_error(error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_dbus_error_is_remote_error
  type(c_ptr), value :: error
end function

! gchar *g_dbus_error_get_remote_error (const GError *error);
function g_dbus_error_get_remote_error(error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_error_get_remote_error
  type(c_ptr), value :: error
end function

! gboolean g_dbus_error_strip_remote_error (GError *error);
function g_dbus_error_strip_remote_error(error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_dbus_error_strip_remote_error
  type(c_ptr), value :: error
end function

!  gboolean g_dbus_error_register_error (GQuark error_domain, gint error_code, const gchar *dbus_error_name);
function g_dbus_error_register_error(error_domain, error_code, dbus_error_name) &
      &bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t, c_int, c_char
  logical(c_bool) :: g_dbus_error_register_error
  integer(c_int32_t), value :: error_domain
  integer(c_int), value :: error_code
  character(kind=c_char), dimension(*) :: dbus_error_name
end function

! gboolean g_dbus_error_unregister_error (GQuark error_domain, gint error_code, const gchar *dbus_error_name);
function g_dbus_error_unregister_error(error_domain, error_code, dbus_error_name&
      &) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t, c_int, c_char
  logical(c_bool) :: g_dbus_error_unregister_error
  integer(c_int32_t), value :: error_domain
  integer(c_int), value :: error_code
  character(kind=c_char), dimension(*) :: dbus_error_name
end function

! void g_dbus_error_register_error_domain (const gchar *error_domain_quark_name, volatile gsize *quark_volatile, const GDBusErrorEntry *entries, guint num_entries);
subroutine g_dbus_error_register_error_domain(error_domain_quark_name, quark_vol&
      &atile, entries, num_entries) bind(c) 
  use iso_c_binding, only: c_char, c_ptr, c_int
  character(kind=c_char), dimension(*) :: error_domain_quark_name
  type(c_ptr), value :: quark_volatile
  integer(c_int), value :: entries
  integer(c_int), value :: num_entries
end subroutine

!  GError *g_dbus_error_new_for_dbus_error (const gchar *dbus_error_name, const gchar *dbus_error_message);
function g_dbus_error_new_for_dbus_error(dbus_error_name, dbus_error_message) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_error_new_for_dbus_error
  character(kind=c_char), dimension(*) :: dbus_error_name
  character(kind=c_char), dimension(*) :: dbus_error_message
end function

! void g_dbus_error_set_dbus_error_valist (GError **error, const gchar *dbus_error_name, const gchar *dbus_error_message, const gchar *format, va_list var_args);
subroutine g_dbus_error_set_dbus_error_valist(error, dbus_error_name, dbus_error&
      &_message, format, var_args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: error
  character(kind=c_char), dimension(*) :: dbus_error_name
  character(kind=c_char), dimension(*) :: dbus_error_message
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: var_args
end subroutine

! gchar *g_dbus_error_encode_gerror (const GError *error);
function g_dbus_error_encode_gerror(error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_error_encode_gerror
  type(c_ptr), value :: error
end function

!   GType g_simple_permission_get_type (void);
function g_simple_permission_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_simple_permission_get_type
end function

! GPermission * g_simple_permission_new (gboolean allowed);
function g_simple_permission_new(allowed) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: g_simple_permission_new
  logical(c_bool), value :: allowed
end function

!   GType g_app_info_create_flags_get_type (void) G_GNUC_CONST;
function g_app_info_create_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_app_info_create_flags_get_type
end function

!  GType g_converter_flags_get_type (void) G_GNUC_CONST;
function g_converter_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_converter_flags_get_type
end function

!  GType g_converter_result_get_type (void) G_GNUC_CONST;
function g_converter_result_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_converter_result_get_type
end function

!  GType g_data_stream_byte_order_get_type (void) G_GNUC_CONST;
function g_data_stream_byte_order_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_data_stream_byte_order_get_type
end function

!  GType g_data_stream_newline_type_get_type (void) G_GNUC_CONST;
function g_data_stream_newline_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_data_stream_newline_type_get_type
end function

!  GType g_file_attribute_type_get_type (void) G_GNUC_CONST;
function g_file_attribute_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_attribute_type_get_type
end function

!  GType g_file_attribute_info_flags_get_type (void) G_GNUC_CONST;
function g_file_attribute_info_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_attribute_info_flags_get_type
end function

!  GType g_file_attribute_status_get_type (void) G_GNUC_CONST;
function g_file_attribute_status_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_attribute_status_get_type
end function

!  GType g_file_query_info_flags_get_type (void) G_GNUC_CONST;
function g_file_query_info_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_query_info_flags_get_type
end function

!  GType g_file_create_flags_get_type (void) G_GNUC_CONST;
function g_file_create_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_create_flags_get_type
end function

!  GType g_mount_mount_flags_get_type (void) G_GNUC_CONST;
function g_mount_mount_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_mount_mount_flags_get_type
end function

!  GType g_mount_unmount_flags_get_type (void) G_GNUC_CONST;
function g_mount_unmount_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_mount_unmount_flags_get_type
end function

!  GType g_drive_start_flags_get_type (void) G_GNUC_CONST;
function g_drive_start_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_drive_start_flags_get_type
end function

!  GType g_drive_start_stop_type_get_type (void) G_GNUC_CONST;
function g_drive_start_stop_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_drive_start_stop_type_get_type
end function

!  GType g_file_copy_flags_get_type (void) G_GNUC_CONST;
function g_file_copy_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_copy_flags_get_type
end function

!  GType g_file_monitor_flags_get_type (void) G_GNUC_CONST;
function g_file_monitor_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_monitor_flags_get_type
end function

!  GType g_file_type_get_type (void) G_GNUC_CONST;
function g_file_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_type_get_type
end function

!  GType g_filesystem_preview_type_get_type (void) G_GNUC_CONST;
function g_filesystem_preview_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_filesystem_preview_type_get_type
end function

!  GType g_file_monitor_event_get_type (void) G_GNUC_CONST;
function g_file_monitor_event_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_monitor_event_get_type
end function

!  GType g_io_error_enum_get_type (void) G_GNUC_CONST;
function g_io_error_enum_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_io_error_enum_get_type
end function

!  GType g_ask_password_flags_get_type (void) G_GNUC_CONST;
function g_ask_password_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_ask_password_flags_get_type
end function

!  GType g_password_save_get_type (void) G_GNUC_CONST;
function g_password_save_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_password_save_get_type
end function

!  GType g_mount_operation_result_get_type (void) G_GNUC_CONST;
function g_mount_operation_result_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_mount_operation_result_get_type
end function

!  GType g_output_stream_splice_flags_get_type (void) G_GNUC_CONST;
function g_output_stream_splice_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_output_stream_splice_flags_get_type
end function

!  GType g_emblem_origin_get_type (void) G_GNUC_CONST;
function g_emblem_origin_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_emblem_origin_get_type
end function

!  GType g_resolver_error_get_type (void) G_GNUC_CONST;
function g_resolver_error_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_resolver_error_get_type
end function

!  GType g_socket_family_get_type (void) G_GNUC_CONST;
function g_socket_family_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_family_get_type
end function

!  GType g_socket_type_get_type (void) G_GNUC_CONST;
function g_socket_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_type_get_type
end function

!  GType g_socket_msg_flags_get_type (void) G_GNUC_CONST;
function g_socket_msg_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_msg_flags_get_type
end function

!  GType g_socket_protocol_get_type (void) G_GNUC_CONST;
function g_socket_protocol_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_protocol_get_type
end function

!  GType g_zlib_compressor_format_get_type (void) G_GNUC_CONST;
function g_zlib_compressor_format_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_zlib_compressor_format_get_type
end function

!  GType g_unix_socket_address_type_get_type (void) G_GNUC_CONST;
function g_unix_socket_address_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_unix_socket_address_type_get_type
end function

!  GType g_bus_type_get_type (void) G_GNUC_CONST;
function g_bus_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_bus_type_get_type
end function

!  GType g_bus_name_owner_flags_get_type (void) G_GNUC_CONST;
function g_bus_name_owner_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_bus_name_owner_flags_get_type
end function

!  GType g_bus_name_watcher_flags_get_type (void) G_GNUC_CONST;
function g_bus_name_watcher_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_bus_name_watcher_flags_get_type
end function

!  GType g_dbus_proxy_flags_get_type (void) G_GNUC_CONST;
function g_dbus_proxy_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_proxy_flags_get_type
end function

!  GType g_dbus_error_get_type (void) G_GNUC_CONST;
function g_dbus_error_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_error_get_type
end function

!  GType g_dbus_connection_flags_get_type (void) G_GNUC_CONST;
function g_dbus_connection_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_connection_flags_get_type
end function

!  GType g_dbus_capability_flags_get_type (void) G_GNUC_CONST;
function g_dbus_capability_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_capability_flags_get_type
end function

!  GType g_dbus_call_flags_get_type (void) G_GNUC_CONST;
function g_dbus_call_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_call_flags_get_type
end function

!  GType g_dbus_message_type_get_type (void) G_GNUC_CONST;
function g_dbus_message_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_message_type_get_type
end function

!  GType g_dbus_message_flags_get_type (void) G_GNUC_CONST;
function g_dbus_message_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_message_flags_get_type
end function

!  GType g_dbus_message_header_field_get_type (void) G_GNUC_CONST;
function g_dbus_message_header_field_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_message_header_field_get_type
end function

!  GType g_dbus_property_info_flags_get_type (void) G_GNUC_CONST;
function g_dbus_property_info_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_property_info_flags_get_type
end function

!  GType g_dbus_subtree_flags_get_type (void) G_GNUC_CONST;
function g_dbus_subtree_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_subtree_flags_get_type
end function

!  GType g_dbus_server_flags_get_type (void) G_GNUC_CONST;
function g_dbus_server_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_server_flags_get_type
end function

!  GType g_dbus_signal_flags_get_type (void) G_GNUC_CONST;
function g_dbus_signal_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_signal_flags_get_type
end function

!  GType g_dbus_send_message_flags_get_type (void) G_GNUC_CONST;
function g_dbus_send_message_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_send_message_flags_get_type
end function

!  GType g_credentials_type_get_type (void) G_GNUC_CONST;
function g_credentials_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_credentials_type_get_type
end function

!  GType g_dbus_message_byte_order_get_type (void) G_GNUC_CONST;
function g_dbus_message_byte_order_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_message_byte_order_get_type
end function

!  GType g_settings_bind_flags_get_type (void) G_GNUC_CONST;
function g_settings_bind_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_settings_bind_flags_get_type
end function

!   GType g_async_result_get_type (void) G_GNUC_CONST;
function g_async_result_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_async_result_get_type
end function

!  gpointer g_async_result_get_user_data (GAsyncResult *res);
function g_async_result_get_user_data(res) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_result_get_user_data
  type(c_ptr), value :: res
end function

! GObject *g_async_result_get_source_object (GAsyncResult *res);
function g_async_result_get_source_object(res) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_result_get_source_object
  type(c_ptr), value :: res
end function

!   gboolean g_content_type_equals (const gchar *type1, const gchar *type2);
function g_content_type_equals(type1, type2) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_content_type_equals
  character(kind=c_char), dimension(*) :: type1
  character(kind=c_char), dimension(*) :: type2
end function

! gboolean g_content_type_is_a (const gchar *type, const gchar *supertype);
function g_content_type_is_a(type, supertype) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_content_type_is_a
  character(kind=c_char), dimension(*) :: type
  character(kind=c_char), dimension(*) :: supertype
end function

! gboolean g_content_type_is_unknown (const gchar *type);
function g_content_type_is_unknown(type) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_content_type_is_unknown
  character(kind=c_char), dimension(*) :: type
end function

! gchar * g_content_type_get_description (const gchar *type);
function g_content_type_get_description(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_content_type_get_description
  character(kind=c_char), dimension(*) :: type
end function

! gchar * g_content_type_get_mime_type (const gchar *type);
function g_content_type_get_mime_type(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_content_type_get_mime_type
  character(kind=c_char), dimension(*) :: type
end function

! GIcon * g_content_type_get_icon (const gchar *type);
function g_content_type_get_icon(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_content_type_get_icon
  character(kind=c_char), dimension(*) :: type
end function

! gboolean g_content_type_can_be_executable (const gchar *type);
function g_content_type_can_be_executable(type) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_content_type_can_be_executable
  character(kind=c_char), dimension(*) :: type
end function

!  gchar * g_content_type_from_mime_type (const gchar *mime_type);
function g_content_type_from_mime_type(mime_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_content_type_from_mime_type
  character(kind=c_char), dimension(*) :: mime_type
end function

!  gchar * g_content_type_guess (const gchar *filename, const guchar *data, gsize data_size, gboolean *result_uncertain);
function g_content_type_guess(filename, data, data_size, result_uncertain) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_content_type_guess
  character(kind=c_char), dimension(*) :: filename
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: data_size
  type(c_ptr), value :: result_uncertain
end function

!  gchar ** g_content_type_guess_for_tree (GFile *root);
function g_content_type_guess_for_tree(root) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_content_type_guess_for_tree
  type(c_ptr), value :: root
end function

!  GList * g_content_types_get_registered (void);
function g_content_types_get_registered() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_content_types_get_registered
end function

!   GType g_socket_connectable_get_type (void) G_GNUC_CONST;
function g_socket_connectable_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_connectable_get_type
end function

!  GSocketAddressEnumerator *g_socket_connectable_enumerate (GSocketConnectable *connectable);
function g_socket_connectable_enumerate(connectable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_connectable_enumerate
  type(c_ptr), value :: connectable
end function

!  GSocketAddressEnumerator *g_socket_connectable_proxy_enumerate (GSocketConnectable *connectable);
function g_socket_connectable_proxy_enumerate(connectable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_connectable_proxy_enumerate
  type(c_ptr), value :: connectable
end function

!   GType g_vfs_get_type (void) G_GNUC_CONST;
function g_vfs_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_vfs_get_type
end function

!  gboolean g_vfs_is_active (GVfs *vfs);
function g_vfs_is_active(vfs) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_vfs_is_active
  type(c_ptr), value :: vfs
end function

! GFile * g_vfs_get_file_for_path (GVfs *vfs, const char *path);
function g_vfs_get_file_for_path(vfs, path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_vfs_get_file_for_path
  type(c_ptr), value :: vfs
  character(kind=c_char), dimension(*) :: path
end function

! GFile * g_vfs_get_file_for_uri (GVfs *vfs, const char *uri);
function g_vfs_get_file_for_uri(vfs, uri) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_vfs_get_file_for_uri
  type(c_ptr), value :: vfs
  character(kind=c_char), dimension(*) :: uri
end function

! const gchar* const * g_vfs_get_supported_uri_schemes (GVfs *vfs);
function g_vfs_get_supported_uri_schemes(vfs) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_vfs_get_supported_uri_schemes
  type(c_ptr), value :: vfs
end function

!  GFile * g_vfs_parse_name (GVfs *vfs, const char *parse_name);
function g_vfs_parse_name(vfs, parse_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_vfs_parse_name
  type(c_ptr), value :: vfs
  character(kind=c_char), dimension(*) :: parse_name
end function

!  GVfs * g_vfs_get_default (void);
function g_vfs_get_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_vfs_get_default
end function

! GVfs * g_vfs_get_local (void);
function g_vfs_get_local() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_vfs_get_local
end function

!   gboolean g_dbus_is_address (const gchar *string);
function g_dbus_is_address(string) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_dbus_is_address
  character(kind=c_char), dimension(*) :: string
end function

! gboolean g_dbus_is_supported_address (const gchar *string, GError **error);
function g_dbus_is_supported_address(string, error) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_ptr
  logical(c_bool) :: g_dbus_is_supported_address
  character(kind=c_char), dimension(*) :: string
  type(c_ptr), value :: error
end function

!  void g_dbus_address_get_stream (const gchar *address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_address_get_stream(address, cancellable, callback, user_data) &
      &bind(c) 
  use iso_c_binding, only: c_char, c_ptr, c_funptr
  character(kind=c_char), dimension(*) :: address
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

!  GIOStream *g_dbus_address_get_stream_finish (GAsyncResult *res, gchar **out_guid, GError **error);
function g_dbus_address_get_stream_finish(res, out_guid, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_address_get_stream_finish
  type(c_ptr), value :: res
  character(kind=c_char), dimension(*) :: out_guid
  type(c_ptr), value :: error
end function

!  GIOStream *g_dbus_address_get_stream_sync (const gchar *address, gchar **out_guid, GCancellable *cancellable, GError **error);
function g_dbus_address_get_stream_sync(address, out_guid, cancellable, error) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_address_get_stream_sync
  character(kind=c_char), dimension(*) :: address
  character(kind=c_char), dimension(*) :: out_guid
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  gchar *g_dbus_address_get_for_bus_sync (GBusType bus_type, GCancellable *cancellable, GError **error);
function g_dbus_address_get_for_bus_sync(bus_type, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_dbus_address_get_for_bus_sync
  integer(c_int), value :: bus_type
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!   GType g_io_stream_get_type (void) G_GNUC_CONST;
function g_io_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_io_stream_get_type
end function

!  GInputStream * g_io_stream_get_input_stream (GIOStream *stream);
function g_io_stream_get_input_stream(stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_io_stream_get_input_stream
  type(c_ptr), value :: stream
end function

! GOutputStream *g_io_stream_get_output_stream (GIOStream *stream);
function g_io_stream_get_output_stream(stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_io_stream_get_output_stream
  type(c_ptr), value :: stream
end function

!  gboolean g_io_stream_close (GIOStream *stream, GCancellable *cancellable, GError **error);
function g_io_stream_close(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_io_stream_close
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_io_stream_close_async (GIOStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_io_stream_close_async(stream, io_priority, cancellable, callback, u&
      &ser_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_io_stream_close_finish (GIOStream *stream, GAsyncResult *result, GError **error);
function g_io_stream_close_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_io_stream_close_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  gboolean g_io_stream_is_closed (GIOStream *stream);
function g_io_stream_is_closed(stream) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_io_stream_is_closed
  type(c_ptr), value :: stream
end function

! gboolean g_io_stream_has_pending (GIOStream *stream);
function g_io_stream_has_pending(stream) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_io_stream_has_pending
  type(c_ptr), value :: stream
end function

! gboolean g_io_stream_set_pending (GIOStream *stream, GError **error);
function g_io_stream_set_pending(stream, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_io_stream_set_pending
  type(c_ptr), value :: stream
  type(c_ptr), value :: error
end function

! void g_io_stream_clear_pending (GIOStream *stream);
subroutine g_io_stream_clear_pending(stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: stream
end subroutine

!   GType g_buffered_input_stream_get_type (void) G_GNUC_CONST;
function g_buffered_input_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_buffered_input_stream_get_type
end function

! GInputStream* g_buffered_input_stream_new (GInputStream *base_stream);
function g_buffered_input_stream_new(base_stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_buffered_input_stream_new
  type(c_ptr), value :: base_stream
end function

! GInputStream* g_buffered_input_stream_new_sized (GInputStream *base_stream, gsize size);
function g_buffered_input_stream_new_sized(base_stream, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_buffered_input_stream_new_sized
  type(c_ptr), value :: base_stream
  integer(c_size_t), value :: size
end function

!  gsize g_buffered_input_stream_get_buffer_size (GBufferedInputStream *stream);
function g_buffered_input_stream_get_buffer_size(stream) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_buffered_input_stream_get_buffer_size
  type(c_ptr), value :: stream
end function

! void g_buffered_input_stream_set_buffer_size (GBufferedInputStream *stream, gsize size);
subroutine g_buffered_input_stream_set_buffer_size(stream, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: stream
  integer(c_size_t), value :: size
end subroutine

! gsize g_buffered_input_stream_get_available (GBufferedInputStream *stream);
function g_buffered_input_stream_get_available(stream) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_buffered_input_stream_get_available
  type(c_ptr), value :: stream
end function

! gsize g_buffered_input_stream_peek (GBufferedInputStream *stream, void *buffer, gsize offset, gsize count);
function g_buffered_input_stream_peek(stream, buffer, offset, count) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_buffered_input_stream_peek
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: offset
  integer(c_size_t), value :: count
end function

! const void* g_buffered_input_stream_peek_buffer (GBufferedInputStream *stream, gsize *count);
subroutine g_buffered_input_stream_peek_buffer(stream, count) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: stream
  type(c_ptr), value :: count
end subroutine

!  gssize g_buffered_input_stream_fill (GBufferedInputStream *stream, gssize count, GCancellable *cancellable, GError **error);
function g_buffered_input_stream_fill(stream, count, cancellable, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_buffered_input_stream_fill
  type(c_ptr), value :: stream
  integer(c_size_t), value :: count
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_buffered_input_stream_fill_async (GBufferedInputStream *stream, gssize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_buffered_input_stream_fill_async(stream, count, io_priority, cancel&
      &lable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_size_t), value :: count
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gssize g_buffered_input_stream_fill_finish (GBufferedInputStream *stream, GAsyncResult *result, GError **error);
function g_buffered_input_stream_fill_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_buffered_input_stream_fill_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  int g_buffered_input_stream_read_byte (GBufferedInputStream *stream, GCancellable *cancellable, GError **error);
function g_buffered_input_stream_read_byte(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_buffered_input_stream_read_byte
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!   GType g_socket_connection_get_type (void) G_GNUC_CONST;
function g_socket_connection_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_connection_get_type
end function

!  GSocket *g_socket_connection_get_socket (GSocketConnection *connection);
function g_socket_connection_get_socket(connection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_connection_get_socket
  type(c_ptr), value :: connection
end function

! GSocketAddress *g_socket_connection_get_local_address (GSocketConnection *connection, GError **error);
function g_socket_connection_get_local_address(connection, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_connection_get_local_address
  type(c_ptr), value :: connection
  type(c_ptr), value :: error
end function

! GSocketAddress *g_socket_connection_get_remote_address (GSocketConnection *connection, GError **error);
function g_socket_connection_get_remote_address(connection, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_connection_get_remote_address
  type(c_ptr), value :: connection
  type(c_ptr), value :: error
end function

! void g_socket_connection_factory_register_type (GType g_type, GSocketFamily family, GSocketType type, gint protocol);
subroutine g_socket_connection_factory_register_type(g_type, family, type, proto&
      &col) bind(c) 
  use iso_c_binding, only: c_size_t, c_int
  integer(c_size_t), value :: g_type
  integer(c_int), value :: family
  integer(c_int), value :: type
  integer(c_int), value :: protocol
end subroutine

! GType g_socket_connection_factory_lookup_type (GSocketFamily family, GSocketType type, gint protocol_id);
function g_socket_connection_factory_lookup_type(family, type, protocol_id) bind&
      &(c) 
  use iso_c_binding, only: c_size_t, c_int
  integer(c_size_t) :: g_socket_connection_factory_lookup_type
  integer(c_int), value :: family
  integer(c_int), value :: type
  integer(c_int), value :: protocol_id
end function

! GSocketConnection *g_socket_connection_factory_create_connection (GSocket *socket);
function g_socket_connection_factory_create_connection(socket) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_connection_factory_create_connection
  type(c_ptr), value :: socket
end function

!   GType g_file_get_type (void) G_GNUC_CONST;
function g_file_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_get_type
end function

!  GFile * g_file_new_for_path (const char *path);
function g_file_new_for_path(path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_new_for_path
  character(kind=c_char), dimension(*) :: path
end function

! GFile * g_file_new_for_uri (const char *uri);
function g_file_new_for_uri(uri) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_new_for_uri
  character(kind=c_char), dimension(*) :: uri
end function

! GFile * g_file_new_for_commandline_arg (const char *arg);
function g_file_new_for_commandline_arg(arg) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_new_for_commandline_arg
  character(kind=c_char), dimension(*) :: arg
end function

! GFile * g_file_parse_name (const char *parse_name);
function g_file_parse_name(parse_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_parse_name
  character(kind=c_char), dimension(*) :: parse_name
end function

! GFile * g_file_dup (GFile *file);
function g_file_dup(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_dup
  type(c_ptr), value :: file
end function

! guint g_file_hash (gconstpointer file);
function g_file_hash(file) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_hash
  type(c_ptr), value :: file
end function

! gboolean g_file_equal (GFile *file1, GFile *file2);
function g_file_equal(file1, file2) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_equal
  type(c_ptr), value :: file1
  type(c_ptr), value :: file2
end function

! char * g_file_get_basename (GFile *file);
function g_file_get_basename(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_get_basename
  type(c_ptr), value :: file
end function

! char * g_file_get_path (GFile *file);
function g_file_get_path(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_get_path
  type(c_ptr), value :: file
end function

! char * g_file_get_uri (GFile *file);
function g_file_get_uri(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_get_uri
  type(c_ptr), value :: file
end function

! char * g_file_get_parse_name (GFile *file);
function g_file_get_parse_name(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_get_parse_name
  type(c_ptr), value :: file
end function

! GFile * g_file_get_parent (GFile *file);
function g_file_get_parent(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_get_parent
  type(c_ptr), value :: file
end function

! gboolean g_file_has_parent (GFile *file, GFile *parent);
function g_file_has_parent(file, parent) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_has_parent
  type(c_ptr), value :: file
  type(c_ptr), value :: parent
end function

! GFile * g_file_get_child (GFile *file, const char *name);
function g_file_get_child(file, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_get_child
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: name
end function

! GFile * g_file_get_child_for_display_name (GFile *file, const char *display_name, GError **error);
function g_file_get_child_for_display_name(file, display_name, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_get_child_for_display_name
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: display_name
  type(c_ptr), value :: error
end function

! gboolean g_file_has_prefix (GFile *file, GFile *prefix);
function g_file_has_prefix(file, prefix) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_has_prefix
  type(c_ptr), value :: file
  type(c_ptr), value :: prefix
end function

! char * g_file_get_relative_path (GFile *parent, GFile *descendant);
function g_file_get_relative_path(parent, descendant) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_get_relative_path
  type(c_ptr), value :: parent
  type(c_ptr), value :: descendant
end function

! GFile * g_file_resolve_relative_path (GFile *file, const char *relative_path);
function g_file_resolve_relative_path(file, relative_path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_resolve_relative_path
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: relative_path
end function

! gboolean g_file_is_native (GFile *file);
function g_file_is_native(file) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_is_native
  type(c_ptr), value :: file
end function

! gboolean g_file_has_uri_scheme (GFile *file, const char *uri_scheme);
function g_file_has_uri_scheme(file, uri_scheme) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_file_has_uri_scheme
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: uri_scheme
end function

! char * g_file_get_uri_scheme (GFile *file);
function g_file_get_uri_scheme(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_get_uri_scheme
  type(c_ptr), value :: file
end function

! GFileInputStream * g_file_read (GFile *file, GCancellable *cancellable, GError **error);
function g_file_read(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_read
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_read_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_read_async(file, io_priority, cancellable, callback, user_data&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileInputStream * g_file_read_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_read_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_read_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GFileOutputStream * g_file_append_to (GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
function g_file_append_to(file, flags, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_file_append_to
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GFileOutputStream * g_file_create (GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
function g_file_create(file, flags, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_file_create
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GFileOutputStream * g_file_replace (GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
function g_file_replace(file, etag, make_backup, flags, cancellable, error) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_char, c_bool, c_int
  type(c_ptr) :: g_file_replace
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: etag
  logical(c_bool), value :: make_backup
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_append_to_async (GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_append_to_async(file, flags, io_priority, cancellable, callbac&
      &k, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileOutputStream * g_file_append_to_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_append_to_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_append_to_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! void g_file_create_async (GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_create_async(file, flags, io_priority, cancellable, callback, &
      &user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileOutputStream * g_file_create_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_create_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_create_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! void g_file_replace_async (GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_replace_async(file, etag, make_backup, flags, io_priority, can&
      &cellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_bool, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: etag
  logical(c_bool), value :: make_backup
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileOutputStream * g_file_replace_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_replace_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_replace_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GFileIOStream * g_file_open_readwrite (GFile *file, GCancellable *cancellable, GError **error);
function g_file_open_readwrite(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_open_readwrite
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_open_readwrite_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_open_readwrite_async(file, io_priority, cancellable, callback,&
      & user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileIOStream * g_file_open_readwrite_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_open_readwrite_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_open_readwrite_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GFileIOStream * g_file_create_readwrite (GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
function g_file_create_readwrite(file, flags, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_file_create_readwrite
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_create_readwrite_async (GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_create_readwrite_async(file, flags, io_priority, cancellable, &
      &callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileIOStream * g_file_create_readwrite_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_create_readwrite_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_create_readwrite_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GFileIOStream * g_file_replace_readwrite (GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
function g_file_replace_readwrite(file, etag, make_backup, flags, cancellable, e&
      &rror) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_bool, c_int
  type(c_ptr) :: g_file_replace_readwrite
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: etag
  logical(c_bool), value :: make_backup
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_replace_readwrite_async (GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_replace_readwrite_async(file, etag, make_backup, flags, io_pri&
      &ority, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_bool, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: etag
  logical(c_bool), value :: make_backup
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileIOStream * g_file_replace_readwrite_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_replace_readwrite_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_replace_readwrite_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! gboolean g_file_query_exists (GFile *file, GCancellable *cancellable);
function g_file_query_exists(file, cancellable) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_query_exists
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
end function

! GFileType g_file_query_file_type (GFile *file, GFileQueryInfoFlags flags, GCancellable *cancellable);
function g_file_query_file_type(file, flags, cancellable) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_query_file_type
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
end function

! GFileInfo * g_file_query_info (GFile *file, const char *attributes, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_query_info(file, attributes, flags, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_file_query_info
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_query_info_async (GFile *file, const char *attributes, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_query_info_async(file, attributes, flags, io_priority, cancell&
      &able, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileInfo * g_file_query_info_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_query_info_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_query_info_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GFileInfo * g_file_query_filesystem_info (GFile *file, const char *attributes, GCancellable *cancellable, GError **error);
function g_file_query_filesystem_info(file, attributes, cancellable, error) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_query_filesystem_info
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attributes
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_query_filesystem_info_async (GFile *file, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_query_filesystem_info_async(file, attributes, io_priority, can&
      &cellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileInfo * g_file_query_filesystem_info_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_query_filesystem_info_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_query_filesystem_info_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GMount * g_file_find_enclosing_mount (GFile *file, GCancellable *cancellable, GError **error);
function g_file_find_enclosing_mount(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_find_enclosing_mount
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_find_enclosing_mount_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_find_enclosing_mount_async(file, io_priority, cancellable, cal&
      &lback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GMount * g_file_find_enclosing_mount_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_find_enclosing_mount_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_find_enclosing_mount_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GFileEnumerator * g_file_enumerate_children (GFile *file, const char *attributes, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_enumerate_children(file, attributes, flags, cancellable, error) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_file_enumerate_children
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_enumerate_children_async (GFile *file, const char *attributes, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_enumerate_children_async(file, attributes, flags, io_priority,&
      & cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileEnumerator * g_file_enumerate_children_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_enumerate_children_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_enumerate_children_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GFile * g_file_set_display_name (GFile *file, const char *display_name, GCancellable *cancellable, GError **error);
function g_file_set_display_name(file, display_name, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_set_display_name
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: display_name
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_set_display_name_async (GFile *file, const char *display_name, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_set_display_name_async(file, display_name, io_priority, cancel&
      &lable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: display_name
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFile * g_file_set_display_name_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_set_display_name_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_set_display_name_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! gboolean g_file_delete (GFile *file, GCancellable *cancellable, GError **error);
function g_file_delete(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_delete
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_trash (GFile *file, GCancellable *cancellable, GError **error);
function g_file_trash(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_trash
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_copy (GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GError **error);
function g_file_copy(source, destination, flags, cancellable, progress_callback,&
      & progress_callback_data, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int, c_funptr
  logical(c_bool) :: g_file_copy
  type(c_ptr), value :: source
  type(c_ptr), value :: destination
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: progress_callback
  type(c_ptr), value :: progress_callback_data
  type(c_ptr), value :: error
end function

! void g_file_copy_async (GFile *source, GFile *destination, GFileCopyFlags flags, int io_priority, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_copy_async(source, destination, flags, io_priority, cancellabl&
      &e, progress_callback, progress_callback_data, callback, user_data) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: source
  type(c_ptr), value :: destination
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: progress_callback
  type(c_ptr), value :: progress_callback_data
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_copy_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_copy_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_copy_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! gboolean g_file_move (GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GError **error);
function g_file_move(source, destination, flags, cancellable, progress_callback,&
      & progress_callback_data, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int, c_funptr
  logical(c_bool) :: g_file_move
  type(c_ptr), value :: source
  type(c_ptr), value :: destination
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: progress_callback
  type(c_ptr), value :: progress_callback_data
  type(c_ptr), value :: error
end function

! gboolean g_file_make_directory (GFile *file, GCancellable *cancellable, GError **error);
function g_file_make_directory(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_make_directory
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_make_directory_with_parents (GFile *file, GCancellable *cancellable, GError **error);
function g_file_make_directory_with_parents(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_make_directory_with_parents
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_make_symbolic_link (GFile *file, const char *symlink_value, GCancellable *cancellable, GError **error);
function g_file_make_symbolic_link(file, symlink_value, cancellable, error) bind&
      &(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_file_make_symbolic_link
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: symlink_value
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GFileAttributeInfoList *g_file_query_settable_attributes (GFile *file, GCancellable *cancellable, GError **error);
function g_file_query_settable_attributes(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_query_settable_attributes
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GFileAttributeInfoList *g_file_query_writable_namespaces (GFile *file, GCancellable *cancellable, GError **error);
function g_file_query_writable_namespaces(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_query_writable_namespaces
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_set_attribute (GFile *file, const char *attribute, GFileAttributeType type, gpointer value_p, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute(file, attribute, type, value_p, flags, cancellable&
      &, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: g_file_set_attribute
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int), value :: type
  type(c_ptr), value :: value_p
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_set_attributes_from_info (GFile *file, GFileInfo *info, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attributes_from_info(file, info, flags, cancellable, error) &
      &bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: g_file_set_attributes_from_info
  type(c_ptr), value :: file
  type(c_ptr), value :: info
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_set_attributes_async (GFile *file, GFileInfo *info, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_set_attributes_async(file, info, flags, io_priority, cancellab&
      &le, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  type(c_ptr), value :: info
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_set_attributes_finish (GFile *file, GAsyncResult *result, GFileInfo **info, GError **error);
function g_file_set_attributes_finish(file, result, info, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_set_attributes_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: info
  type(c_ptr), value :: error
end function

! gboolean g_file_set_attribute_string (GFile *file, const char *attribute, const char *value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute_string(file, attribute, value, flags, cancellable,&
      & error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: g_file_set_attribute_string
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  character(kind=c_char), dimension(*) :: value
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_set_attribute_byte_string (GFile *file, const char *attribute, const char *value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute_byte_string(file, attribute, value, flags, cancell&
      &able, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: g_file_set_attribute_byte_string
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  character(kind=c_char), dimension(*) :: value
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_set_attribute_uint32 (GFile *file, const char *attribute, guint32 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute_uint32(file, attribute, value, flags, cancellable,&
      & error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int32_t, c_int
  logical(c_bool) :: g_file_set_attribute_uint32
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int32_t), value :: value
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_set_attribute_int32 (GFile *file, const char *attribute, gint32 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute_int32(file, attribute, value, flags, cancellable, &
      &error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int32_t, c_int
  logical(c_bool) :: g_file_set_attribute_int32
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int32_t), value :: value
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_set_attribute_uint64 (GFile *file, const char *attribute, guint64 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute_uint64(file, attribute, value, flags, cancellable,&
      & error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int64_t, c_int
  logical(c_bool) :: g_file_set_attribute_uint64
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int64_t), value :: value
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_set_attribute_int64 (GFile *file, const char *attribute, gint64 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute_int64(file, attribute, value, flags, cancellable, &
      &error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int64_t, c_int
  logical(c_bool) :: g_file_set_attribute_int64
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int64_t), value :: value
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_mount_enclosing_volume (GFile *location, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_mount_enclosing_volume(location, flags, mount_operation, cance&
      &llable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: location
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_mount_enclosing_volume_finish (GFile *location, GAsyncResult *result, GError **error);
function g_file_mount_enclosing_volume_finish(location, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_mount_enclosing_volume_finish
  type(c_ptr), value :: location
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_file_mount_mountable (GFile *file, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_mount_mountable(file, flags, mount_operation, cancellable, cal&
      &lback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFile * g_file_mount_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_mount_mountable_finish(file, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_mount_mountable_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_file_unmount_mountable (GFile *file, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_unmount_mountable(file, flags, cancellable, callback, user_dat&
      &a) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_unmount_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_unmount_mountable_finish(file, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_unmount_mountable_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_file_unmount_mountable_with_operation (GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_unmount_mountable_with_operation(file, flags, mount_operation,&
      & cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_unmount_mountable_with_operation_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_unmount_mountable_with_operation_finish(file, result, error) bin&
      &d(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_unmount_mountable_with_operation_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_file_eject_mountable (GFile *file, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_eject_mountable(file, flags, cancellable, callback, user_data)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_eject_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_eject_mountable_finish(file, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_eject_mountable_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_file_eject_mountable_with_operation (GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_eject_mountable_with_operation(file, flags, mount_operation, c&
      &ancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_eject_mountable_with_operation_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_eject_mountable_with_operation_finish(file, result, error) bind(&
      &c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_eject_mountable_with_operation_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  gboolean g_file_copy_attributes (GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GError **error);
function g_file_copy_attributes(source, destination, flags, cancellable, error) &
      &bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: g_file_copy_attributes
  type(c_ptr), value :: source
  type(c_ptr), value :: destination
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  GFileMonitor* g_file_monitor_directory (GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error);
function g_file_monitor_directory(file, flags, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_file_monitor_directory
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GFileMonitor* g_file_monitor_file (GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error);
function g_file_monitor_file(file, flags, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_file_monitor_file
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GFileMonitor* g_file_monitor (GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error);
function g_file_monitor(file, flags, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_file_monitor
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_file_start_mountable (GFile *file, GDriveStartFlags flags, GMountOperation *start_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_start_mountable(file, flags, start_operation, cancellable, cal&
      &lback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: start_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_start_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_start_mountable_finish(file, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_start_mountable_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_file_stop_mountable (GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_stop_mountable(file, flags, mount_operation, cancellable, call&
      &back, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_stop_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_stop_mountable_finish(file, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_stop_mountable_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_file_poll_mountable (GFile *file, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_poll_mountable(file, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_poll_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_poll_mountable_finish(file, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_poll_mountable_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  GAppInfo *g_file_query_default_handler (GFile *file, GCancellable *cancellable, GError **error);
function g_file_query_default_handler(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_query_default_handler
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_load_contents (GFile *file, GCancellable *cancellable, char **contents, gsize *length, char **etag_out, GError **error);
function g_file_load_contents(file, cancellable, contents, length, etag_out, err&
      &or) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_file_load_contents
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  character(kind=c_char), dimension(*) :: contents
  type(c_ptr), value :: length
  character(kind=c_char), dimension(*) :: etag_out
  type(c_ptr), value :: error
end function

! void g_file_load_contents_async (GFile *file, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_load_contents_async(file, cancellable, callback, user_data) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_load_contents_finish (GFile *file, GAsyncResult *res, char **contents, gsize *length, char **etag_out, GError **error);
function g_file_load_contents_finish(file, res, contents, length, etag_out, erro&
      &r) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_file_load_contents_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  character(kind=c_char), dimension(*) :: contents
  type(c_ptr), value :: length
  character(kind=c_char), dimension(*) :: etag_out
  type(c_ptr), value :: error
end function

! void g_file_load_partial_contents_async (GFile *file, GCancellable *cancellable, GFileReadMoreCallback read_more_callback, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_load_partial_contents_async(file, cancellable, read_more_callb&
      &ack, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: read_more_callback
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_load_partial_contents_finish (GFile *file, GAsyncResult *res, char **contents, gsize *length, char **etag_out, GError **error);
function g_file_load_partial_contents_finish(file, res, contents, length, etag_o&
      &ut, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_file_load_partial_contents_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  character(kind=c_char), dimension(*) :: contents
  type(c_ptr), value :: length
  character(kind=c_char), dimension(*) :: etag_out
  type(c_ptr), value :: error
end function

! gboolean g_file_replace_contents (GFile *file, const char *contents, gsize length, const char *etag, gboolean make_backup, GFileCreateFlags flags, char **new_etag, GCancellable *cancellable, GError **error);
function g_file_replace_contents(file, contents, length, etag, make_backup, flag&
      &s, new_etag, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_size_t, c_int
  logical(c_bool) :: g_file_replace_contents
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: contents
  integer(c_size_t), value :: length
  character(kind=c_char), dimension(*) :: etag
  logical(c_bool), value :: make_backup
  integer(c_int), value :: flags
  character(kind=c_char), dimension(*) :: new_etag
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_replace_contents_async (GFile *file, const char *contents, gsize length, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_replace_contents_async(file, contents, length, etag, make_back&
      &up, flags, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_bool, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: contents
  integer(c_size_t), value :: length
  character(kind=c_char), dimension(*) :: etag
  logical(c_bool), value :: make_backup
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_replace_contents_finish (GFile *file, GAsyncResult *res, char **new_etag, GError **error);
function g_file_replace_contents_finish(file, res, new_etag, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_file_replace_contents_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  character(kind=c_char), dimension(*) :: new_etag
  type(c_ptr), value :: error
end function

!  gboolean g_file_supports_thread_contexts (GFile *file);
function g_file_supports_thread_contexts(file) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_supports_thread_contexts
  type(c_ptr), value :: file
end function

!   GType g_mount_get_type (void) G_GNUC_CONST;
function g_mount_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_mount_get_type
end function

!  GFile * g_mount_get_root (GMount *mount);
function g_mount_get_root(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_get_root
  type(c_ptr), value :: mount
end function

! GFile * g_mount_get_default_location (GMount *mount);
function g_mount_get_default_location(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_get_default_location
  type(c_ptr), value :: mount
end function

! char * g_mount_get_name (GMount *mount);
function g_mount_get_name(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_get_name
  type(c_ptr), value :: mount
end function

! GIcon * g_mount_get_icon (GMount *mount);
function g_mount_get_icon(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_get_icon
  type(c_ptr), value :: mount
end function

! char * g_mount_get_uuid (GMount *mount);
function g_mount_get_uuid(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_get_uuid
  type(c_ptr), value :: mount
end function

! GVolume * g_mount_get_volume (GMount *mount);
function g_mount_get_volume(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_get_volume
  type(c_ptr), value :: mount
end function

! GDrive * g_mount_get_drive (GMount *mount);
function g_mount_get_drive(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_get_drive
  type(c_ptr), value :: mount
end function

! gboolean g_mount_can_unmount (GMount *mount);
function g_mount_can_unmount(mount) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_mount_can_unmount
  type(c_ptr), value :: mount
end function

! gboolean g_mount_can_eject (GMount *mount);
function g_mount_can_eject(mount) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_mount_can_eject
  type(c_ptr), value :: mount
end function

!  void g_mount_unmount (GMount *mount, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_mount_unmount(mount, flags, cancellable, callback, user_data) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: mount
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_mount_unmount_finish (GMount *mount, GAsyncResult *result, GError **error);
function g_mount_unmount_finish(mount, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_mount_unmount_finish
  type(c_ptr), value :: mount
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_mount_eject (GMount *mount, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_mount_eject(mount, flags, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: mount
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_mount_eject_finish (GMount *mount, GAsyncResult *result, GError **error);
function g_mount_eject_finish(mount, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_mount_eject_finish
  type(c_ptr), value :: mount
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_mount_remount (GMount *mount, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_mount_remount(mount, flags, mount_operation, cancellable, callback,&
      & user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: mount
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_mount_remount_finish (GMount *mount, GAsyncResult *result, GError **error);
function g_mount_remount_finish(mount, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_mount_remount_finish
  type(c_ptr), value :: mount
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_mount_guess_content_type (GMount *mount, gboolean force_rescan, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_mount_guess_content_type(mount, force_rescan, cancellable, callback&
      &, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_funptr
  type(c_ptr), value :: mount
  logical(c_bool), value :: force_rescan
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gchar ** g_mount_guess_content_type_finish (GMount *mount, GAsyncResult *result, GError **error);
function g_mount_guess_content_type_finish(mount, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_guess_content_type_finish
  type(c_ptr), value :: mount
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! gchar ** g_mount_guess_content_type_sync (GMount *mount, gboolean force_rescan, GCancellable *cancellable, GError **error);
function g_mount_guess_content_type_sync(mount, force_rescan, cancellable, error&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: g_mount_guess_content_type_sync
  type(c_ptr), value :: mount
  logical(c_bool), value :: force_rescan
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  gboolean g_mount_is_shadowed (GMount *mount);
function g_mount_is_shadowed(mount) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_mount_is_shadowed
  type(c_ptr), value :: mount
end function

! void g_mount_shadow (GMount *mount);
subroutine g_mount_shadow(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mount
end subroutine

! void g_mount_unshadow (GMount *mount);
subroutine g_mount_unshadow(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mount
end subroutine

!  void g_mount_unmount_with_operation (GMount *mount, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_mount_unmount_with_operation(mount, flags, mount_operation, cancell&
      &able, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: mount
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_mount_unmount_with_operation_finish (GMount *mount, GAsyncResult *result, GError **error);
function g_mount_unmount_with_operation_finish(mount, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_mount_unmount_with_operation_finish
  type(c_ptr), value :: mount
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_mount_eject_with_operation (GMount *mount, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_mount_eject_with_operation(mount, flags, mount_operation, cancellab&
      &le, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: mount
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_mount_eject_with_operation_finish (GMount *mount, GAsyncResult *result, GError **error);
function g_mount_eject_with_operation_finish(mount, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_mount_eject_with_operation_finish
  type(c_ptr), value :: mount
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!   guint g_bus_own_name (GBusType bus_type, const gchar *name, GBusNameOwnerFlags flags, GBusAcquiredCallback bus_acquired_handler, GBusNameAcquiredCallback name_acquired_handler, GBusNameLostCallback name_lost_handler, gpointer user_data, GDestroyNotify user_data_free_func);
function g_bus_own_name(bus_type, name, flags, bus_acquired_handler, name_acquir&
      &ed_handler, name_lost_handler, user_data, user_data_free_func) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_funptr, c_ptr
  integer(c_int) :: g_bus_own_name
  integer(c_int), value :: bus_type
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_funptr), value :: bus_acquired_handler
  type(c_funptr), value :: name_acquired_handler
  type(c_funptr), value :: name_lost_handler
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
end function

!  guint g_bus_own_name_on_connection (GDBusConnection *connection, const gchar *name, GBusNameOwnerFlags flags, GBusNameAcquiredCallback name_acquired_handler, GBusNameLostCallback name_lost_handler, gpointer user_data, GDestroyNotify user_data_free_func);
function g_bus_own_name_on_connection(connection, name, flags, name_acquired_han&
      &dler, name_lost_handler, user_data, user_data_free_func) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_funptr
  integer(c_int) :: g_bus_own_name_on_connection
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_funptr), value :: name_acquired_handler
  type(c_funptr), value :: name_lost_handler
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
end function

!  guint g_bus_own_name_with_closures (GBusType bus_type, const gchar *name, GBusNameOwnerFlags flags, GClosure *bus_acquired_closure, GClosure *name_acquired_closure, GClosure *name_lost_closure);
function g_bus_own_name_with_closures(bus_type, name, flags, bus_acquired_closur&
      &e, name_acquired_closure, name_lost_closure) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_ptr
  integer(c_int) :: g_bus_own_name_with_closures
  integer(c_int), value :: bus_type
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_ptr), value :: bus_acquired_closure
  type(c_ptr), value :: name_acquired_closure
  type(c_ptr), value :: name_lost_closure
end function

!  guint g_bus_own_name_on_connection_with_closures ( GDBusConnection *connection, const gchar *name, GBusNameOwnerFlags flags, GClosure *name_acquired_closure, GClosure *name_lost_closure);
function g_bus_own_name_on_connection_with_closures(connection, name, flags, nam&
      &e_acquired_closure, name_lost_closure) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_bus_own_name_on_connection_with_closures
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_ptr), value :: name_acquired_closure
  type(c_ptr), value :: name_lost_closure
end function

!  void g_bus_unown_name (guint owner_id);
subroutine g_bus_unown_name(owner_id) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: owner_id
end subroutine

!   GType g_themed_icon_get_type (void) G_GNUC_CONST;
function g_themed_icon_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_themed_icon_get_type
end function

!  GIcon *g_themed_icon_new (const char *iconname);
function g_themed_icon_new(iconname) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_themed_icon_new
  character(kind=c_char), dimension(*) :: iconname
end function

! GIcon *g_themed_icon_new_with_default_fallbacks (const char *iconname);
function g_themed_icon_new_with_default_fallbacks(iconname) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_themed_icon_new_with_default_fallbacks
  character(kind=c_char), dimension(*) :: iconname
end function

! GIcon *g_themed_icon_new_from_names (char **iconnames, int len);
function g_themed_icon_new_from_names(iconnames, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_themed_icon_new_from_names
  character(kind=c_char), dimension(*) :: iconnames
  integer(c_int), value :: len
end function

! void g_themed_icon_prepend_name (GThemedIcon *icon, const char *iconname);
subroutine g_themed_icon_prepend_name(icon, iconname) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: icon
  character(kind=c_char), dimension(*) :: iconname
end subroutine

! void g_themed_icon_append_name (GThemedIcon *icon, const char *iconname);
subroutine g_themed_icon_append_name(icon, iconname) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: icon
  character(kind=c_char), dimension(*) :: iconname
end subroutine

!  const gchar* const * g_themed_icon_get_names (GThemedIcon *icon);
function g_themed_icon_get_names(icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_themed_icon_get_names
  type(c_ptr), value :: icon
end function

!   GType g_app_info_get_type (void) G_GNUC_CONST;
function g_app_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_app_info_get_type
end function

! GAppInfo * g_app_info_create_from_commandline (const char *commandline, const char *application_name, GAppInfoCreateFlags flags, GError **error);
function g_app_info_create_from_commandline(commandline, application_name, flags&
      &, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_app_info_create_from_commandline
  character(kind=c_char), dimension(*) :: commandline
  character(kind=c_char), dimension(*) :: application_name
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! GAppInfo * g_app_info_dup (GAppInfo *appinfo);
function g_app_info_dup(appinfo) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_info_dup
  type(c_ptr), value :: appinfo
end function

! gboolean g_app_info_equal (GAppInfo *appinfo1, GAppInfo *appinfo2);
function g_app_info_equal(appinfo1, appinfo2) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_app_info_equal
  type(c_ptr), value :: appinfo1
  type(c_ptr), value :: appinfo2
end function

! const char *g_app_info_get_id (GAppInfo *appinfo);
function g_app_info_get_id(appinfo) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_info_get_id
  type(c_ptr), value :: appinfo
end function

! const char *g_app_info_get_name (GAppInfo *appinfo);
function g_app_info_get_name(appinfo) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_info_get_name
  type(c_ptr), value :: appinfo
end function

! const char *g_app_info_get_display_name (GAppInfo *appinfo);
function g_app_info_get_display_name(appinfo) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_info_get_display_name
  type(c_ptr), value :: appinfo
end function

! const char *g_app_info_get_description (GAppInfo *appinfo);
function g_app_info_get_description(appinfo) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_info_get_description
  type(c_ptr), value :: appinfo
end function

! const char *g_app_info_get_executable (GAppInfo *appinfo);
function g_app_info_get_executable(appinfo) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_info_get_executable
  type(c_ptr), value :: appinfo
end function

! const char *g_app_info_get_commandline (GAppInfo *appinfo);
function g_app_info_get_commandline(appinfo) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_info_get_commandline
  type(c_ptr), value :: appinfo
end function

! GIcon * g_app_info_get_icon (GAppInfo *appinfo);
function g_app_info_get_icon(appinfo) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_info_get_icon
  type(c_ptr), value :: appinfo
end function

! gboolean g_app_info_launch (GAppInfo *appinfo, GList *files, GAppLaunchContext *launch_context, GError **error);
function g_app_info_launch(appinfo, files, launch_context, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_app_info_launch
  type(c_ptr), value :: appinfo
  type(c_ptr), value :: files
  type(c_ptr), value :: launch_context
  type(c_ptr), value :: error
end function

! gboolean g_app_info_supports_uris (GAppInfo *appinfo);
function g_app_info_supports_uris(appinfo) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_app_info_supports_uris
  type(c_ptr), value :: appinfo
end function

! gboolean g_app_info_supports_files (GAppInfo *appinfo);
function g_app_info_supports_files(appinfo) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_app_info_supports_files
  type(c_ptr), value :: appinfo
end function

! gboolean g_app_info_launch_uris (GAppInfo *appinfo, GList *uris, GAppLaunchContext *launch_context, GError **error);
function g_app_info_launch_uris(appinfo, uris, launch_context, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_app_info_launch_uris
  type(c_ptr), value :: appinfo
  type(c_ptr), value :: uris
  type(c_ptr), value :: launch_context
  type(c_ptr), value :: error
end function

! gboolean g_app_info_should_show (GAppInfo *appinfo);
function g_app_info_should_show(appinfo) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_app_info_should_show
  type(c_ptr), value :: appinfo
end function

!  gboolean g_app_info_set_as_default_for_type (GAppInfo *appinfo, const char *content_type, GError **error);
function g_app_info_set_as_default_for_type(appinfo, content_type, error) bind(c&
      &) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_app_info_set_as_default_for_type
  type(c_ptr), value :: appinfo
  character(kind=c_char), dimension(*) :: content_type
  type(c_ptr), value :: error
end function

! gboolean g_app_info_set_as_default_for_extension (GAppInfo *appinfo, const char *extension, GError **error);
function g_app_info_set_as_default_for_extension(appinfo, extension, error) bind&
      &(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_app_info_set_as_default_for_extension
  type(c_ptr), value :: appinfo
  character(kind=c_char), dimension(*) :: extension
  type(c_ptr), value :: error
end function

! gboolean g_app_info_add_supports_type (GAppInfo *appinfo, const char *content_type, GError **error);
function g_app_info_add_supports_type(appinfo, content_type, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_app_info_add_supports_type
  type(c_ptr), value :: appinfo
  character(kind=c_char), dimension(*) :: content_type
  type(c_ptr), value :: error
end function

! gboolean g_app_info_can_remove_supports_type (GAppInfo *appinfo);
function g_app_info_can_remove_supports_type(appinfo) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_app_info_can_remove_supports_type
  type(c_ptr), value :: appinfo
end function

! gboolean g_app_info_remove_supports_type (GAppInfo *appinfo, const char *content_type, GError **error);
function g_app_info_remove_supports_type(appinfo, content_type, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_app_info_remove_supports_type
  type(c_ptr), value :: appinfo
  character(kind=c_char), dimension(*) :: content_type
  type(c_ptr), value :: error
end function

! gboolean g_app_info_can_delete (GAppInfo *appinfo);
function g_app_info_can_delete(appinfo) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_app_info_can_delete
  type(c_ptr), value :: appinfo
end function

! gboolean g_app_info_delete (GAppInfo *appinfo);
function g_app_info_delete(appinfo) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_app_info_delete
  type(c_ptr), value :: appinfo
end function

!  GList * g_app_info_get_all (void);
function g_app_info_get_all() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_info_get_all
end function

! GList * g_app_info_get_all_for_type (const char *content_type);
function g_app_info_get_all_for_type(content_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_app_info_get_all_for_type
  character(kind=c_char), dimension(*) :: content_type
end function

! void g_app_info_reset_type_associations (const char *content_type);
subroutine g_app_info_reset_type_associations(content_type) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: content_type
end subroutine

! GAppInfo *g_app_info_get_default_for_type (const char *content_type, gboolean must_support_uris);
function g_app_info_get_default_for_type(content_type, must_support_uris) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_char, c_bool
  type(c_ptr) :: g_app_info_get_default_for_type
  character(kind=c_char), dimension(*) :: content_type
  logical(c_bool), value :: must_support_uris
end function

! GAppInfo *g_app_info_get_default_for_uri_scheme (const char *uri_scheme);
function g_app_info_get_default_for_uri_scheme(uri_scheme) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_app_info_get_default_for_uri_scheme
  character(kind=c_char), dimension(*) :: uri_scheme
end function

!  gboolean g_app_info_launch_default_for_uri (const char *uri, GAppLaunchContext *launch_context, GError **error);
function g_app_info_launch_default_for_uri(uri, launch_context, error) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_ptr
  logical(c_bool) :: g_app_info_launch_default_for_uri
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: launch_context
  type(c_ptr), value :: error
end function

!  GType g_app_launch_context_get_type (void) G_GNUC_CONST;
function g_app_launch_context_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_app_launch_context_get_type
end function

! GAppLaunchContext *g_app_launch_context_new (void);
function g_app_launch_context_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_launch_context_new
end function

! char * g_app_launch_context_get_display (GAppLaunchContext *context, GAppInfo *info, GList *files);
function g_app_launch_context_get_display(context, info, files) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_launch_context_get_display
  type(c_ptr), value :: context
  type(c_ptr), value :: info
  type(c_ptr), value :: files
end function

! char * g_app_launch_context_get_startup_notify_id (GAppLaunchContext *context, GAppInfo *info, GList *files);
function g_app_launch_context_get_startup_notify_id(context, info, files) bind(c&
      &) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_launch_context_get_startup_notify_id
  type(c_ptr), value :: context
  type(c_ptr), value :: info
  type(c_ptr), value :: files
end function

! void g_app_launch_context_launch_failed (GAppLaunchContext *context, const char * startup_notify_id);
subroutine g_app_launch_context_launch_failed(context, startup_notify_id) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: startup_notify_id
end subroutine

!   GType g_zlib_compressor_get_type (void) G_GNUC_CONST;
function g_zlib_compressor_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_zlib_compressor_get_type
end function

!  GZlibCompressor *g_zlib_compressor_new (GZlibCompressorFormat format, int level);
function g_zlib_compressor_new(format, level) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_zlib_compressor_new
  integer(c_int), value :: format
  integer(c_int), value :: level
end function

!  GFileInfo *g_zlib_compressor_get_file_info (GZlibCompressor *compressor);
function g_zlib_compressor_get_file_info(compressor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_zlib_compressor_get_file_info
  type(c_ptr), value :: compressor
end function

! void g_zlib_compressor_set_file_info (GZlibCompressor *compressor, GFileInfo *file_info);
subroutine g_zlib_compressor_set_file_info(compressor, file_info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: compressor
  type(c_ptr), value :: file_info
end subroutine

!   GType g_network_address_get_type (void) G_GNUC_CONST;
function g_network_address_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_network_address_get_type
end function

!  GSocketConnectable *g_network_address_new (const gchar *hostname, guint16 port);
function g_network_address_new(hostname, port) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int16_t
  type(c_ptr) :: g_network_address_new
  character(kind=c_char), dimension(*) :: hostname
  integer(c_int16_t), value :: port
end function

! GSocketConnectable *g_network_address_parse (const gchar *host_and_port, guint16 default_port, GError **error);
function g_network_address_parse(host_and_port, default_port, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int16_t
  type(c_ptr) :: g_network_address_parse
  character(kind=c_char), dimension(*) :: host_and_port
  integer(c_int16_t), value :: default_port
  type(c_ptr), value :: error
end function

! GSocketConnectable *g_network_address_parse_uri (const gchar *uri, guint16 default_port, GError **error);
function g_network_address_parse_uri(uri, default_port, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int16_t
  type(c_ptr) :: g_network_address_parse_uri
  character(kind=c_char), dimension(*) :: uri
  integer(c_int16_t), value :: default_port
  type(c_ptr), value :: error
end function

! const gchar *g_network_address_get_hostname (GNetworkAddress *addr);
function g_network_address_get_hostname(addr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_network_address_get_hostname
  type(c_ptr), value :: addr
end function

! guint16 g_network_address_get_port (GNetworkAddress *addr);
function g_network_address_get_port(addr) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_network_address_get_port
  type(c_ptr), value :: addr
end function

! const gchar *g_network_address_get_scheme (GNetworkAddress *addr);
function g_network_address_get_scheme(addr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_network_address_get_scheme
  type(c_ptr), value :: addr
end function

!   GType g_socket_listener_get_type (void) G_GNUC_CONST;
function g_socket_listener_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_listener_get_type
end function

!  GSocketListener * g_socket_listener_new (void);
function g_socket_listener_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_listener_new
end function

!  void g_socket_listener_set_backlog (GSocketListener *listener, int listen_backlog);
subroutine g_socket_listener_set_backlog(listener, listen_backlog) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: listener
  integer(c_int), value :: listen_backlog
end subroutine

!  gboolean g_socket_listener_add_socket (GSocketListener *listener, GSocket *socket, GObject *source_object, GError **error);
function g_socket_listener_add_socket(listener, socket, source_object, error) bi&
      &nd(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_socket_listener_add_socket
  type(c_ptr), value :: listener
  type(c_ptr), value :: socket
  type(c_ptr), value :: source_object
  type(c_ptr), value :: error
end function

! gboolean g_socket_listener_add_address (GSocketListener *listener, GSocketAddress *address, GSocketType type, GSocketProtocol protocol, GObject *source_object, GSocketAddress **effective_address, GError **error);
function g_socket_listener_add_address(listener, address, type, protocol, source&
      &_object, effective_address, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: g_socket_listener_add_address
  type(c_ptr), value :: listener
  type(c_ptr), value :: address
  integer(c_int), value :: type
  integer(c_int), value :: protocol
  type(c_ptr), value :: source_object
  type(c_ptr), value :: effective_address
  type(c_ptr), value :: error
end function

! gboolean g_socket_listener_add_inet_port (GSocketListener *listener, guint16 port, GObject *source_object, GError **error);
function g_socket_listener_add_inet_port(listener, port, source_object, error) b&
      &ind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int16_t
  logical(c_bool) :: g_socket_listener_add_inet_port
  type(c_ptr), value :: listener
  integer(c_int16_t), value :: port
  type(c_ptr), value :: source_object
  type(c_ptr), value :: error
end function

! guint16 g_socket_listener_add_any_inet_port (GSocketListener *listener, GObject *source_object, GError **error);
function g_socket_listener_add_any_inet_port(listener, source_object, error) bin&
      &d(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_socket_listener_add_any_inet_port
  type(c_ptr), value :: listener
  type(c_ptr), value :: source_object
  type(c_ptr), value :: error
end function

!  GSocket * g_socket_listener_accept_socket (GSocketListener *listener, GObject **source_object, GCancellable *cancellable, GError **error);
function g_socket_listener_accept_socket(listener, source_object, cancellable, e&
      &rror) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_listener_accept_socket
  type(c_ptr), value :: listener
  type(c_ptr), value :: source_object
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_socket_listener_accept_socket_async (GSocketListener *listener, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_listener_accept_socket_async(listener, cancellable, callback&
      &, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: listener
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GSocket * g_socket_listener_accept_socket_finish (GSocketListener *listener, GAsyncResult *result, GObject **source_object, GError **error);
function g_socket_listener_accept_socket_finish(listener, result, source_object,&
      & error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_listener_accept_socket_finish
  type(c_ptr), value :: listener
  type(c_ptr), value :: result
  type(c_ptr), value :: source_object
  type(c_ptr), value :: error
end function

!  GSocketConnection * g_socket_listener_accept (GSocketListener *listener, GObject **source_object, GCancellable *cancellable, GError **error);
function g_socket_listener_accept(listener, source_object, cancellable, error) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_listener_accept
  type(c_ptr), value :: listener
  type(c_ptr), value :: source_object
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_socket_listener_accept_async (GSocketListener *listener, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_listener_accept_async(listener, cancellable, callback, user_&
      &data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: listener
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

!  GSocketConnection * g_socket_listener_accept_finish (GSocketListener *listener, GAsyncResult *result, GObject **source_object, GError **error);
function g_socket_listener_accept_finish(listener, result, source_object, error)&
      & bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_listener_accept_finish
  type(c_ptr), value :: listener
  type(c_ptr), value :: result
  type(c_ptr), value :: source_object
  type(c_ptr), value :: error
end function

!  void g_socket_listener_close (GSocketListener *listener);
subroutine g_socket_listener_close(listener) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: listener
end subroutine

!   GType g_settings_backend_get_type (void);
function g_settings_backend_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_settings_backend_get_type
end function

!  void g_settings_backend_changed (GSettingsBackend *backend, const gchar *key, gpointer origin_tag);
subroutine g_settings_backend_changed(backend, key, origin_tag) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: backend
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: origin_tag
end subroutine

! void g_settings_backend_path_changed (GSettingsBackend *backend, const gchar *path, gpointer origin_tag);
subroutine g_settings_backend_path_changed(backend, path, origin_tag) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: backend
  character(kind=c_char), dimension(*) :: path
  type(c_ptr), value :: origin_tag
end subroutine

! void g_settings_backend_flatten_tree (GTree *tree, gchar **path, const gchar ***keys, GVariant ***values);
subroutine g_settings_backend_flatten_tree(tree, path, keys, values) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: tree
  character(kind=c_char), dimension(*) :: path
  character(kind=c_char), dimension(*) :: keys
  type(c_ptr), value :: values
end subroutine

! void g_settings_backend_keys_changed (GSettingsBackend *backend, const gchar *path, gchar const * const *items, gpointer origin_tag);
subroutine g_settings_backend_keys_changed(backend, path, items, origin_tag) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: backend
  character(kind=c_char), dimension(*) :: path
  character(kind=c_char), dimension(*) :: items
  type(c_ptr), value :: origin_tag
end subroutine

!  void g_settings_backend_path_writable_changed (GSettingsBackend *backend, const gchar *path);
subroutine g_settings_backend_path_writable_changed(backend, path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: backend
  character(kind=c_char), dimension(*) :: path
end subroutine

! void g_settings_backend_writable_changed (GSettingsBackend *backend, const gchar *key);
subroutine g_settings_backend_writable_changed(backend, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: backend
  character(kind=c_char), dimension(*) :: key
end subroutine

! void g_settings_backend_changed_tree (GSettingsBackend *backend, GTree *tree, gpointer origin_tag);
subroutine g_settings_backend_changed_tree(backend, tree, origin_tag) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: backend
  type(c_ptr), value :: tree
  type(c_ptr), value :: origin_tag
end subroutine

!  GSettingsBackend * g_keyfile_settings_backend_new (const gchar *filename, const gchar *root_path, const gchar *root_group);
function g_keyfile_settings_backend_new(filename, root_path, root_group) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_keyfile_settings_backend_new
  character(kind=c_char), dimension(*) :: filename
  character(kind=c_char), dimension(*) :: root_path
  character(kind=c_char), dimension(*) :: root_group
end function

!   GType g_input_stream_get_type (void) G_GNUC_CONST;
function g_input_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_input_stream_get_type
end function

!  gssize g_input_stream_read (GInputStream *stream, void *buffer, gsize count, GCancellable *cancellable, GError **error);
function g_input_stream_read(stream, buffer, count, cancellable, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_input_stream_read
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_input_stream_read_all (GInputStream *stream, void *buffer, gsize count, gsize *bytes_read, GCancellable *cancellable, GError **error);
function g_input_stream_read_all(stream, buffer, count, bytes_read, cancellable,&
      & error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_size_t
  logical(c_bool) :: g_input_stream_read_all
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gssize g_input_stream_skip (GInputStream *stream, gsize count, GCancellable *cancellable, GError **error);
function g_input_stream_skip(stream, count, cancellable, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_input_stream_skip
  type(c_ptr), value :: stream
  integer(c_size_t), value :: count
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_input_stream_close (GInputStream *stream, GCancellable *cancellable, GError **error);
function g_input_stream_close(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_input_stream_close
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_input_stream_read_async (GInputStream *stream, void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_input_stream_read_async(stream, buffer, count, io_priority, cancell&
      &able, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gssize g_input_stream_read_finish (GInputStream *stream, GAsyncResult *result, GError **error);
function g_input_stream_read_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_input_stream_read_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_input_stream_skip_async (GInputStream *stream, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_input_stream_skip_async(stream, count, io_priority, cancellable, ca&
      &llback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_size_t), value :: count
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gssize g_input_stream_skip_finish (GInputStream *stream, GAsyncResult *result, GError **error);
function g_input_stream_skip_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_input_stream_skip_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_input_stream_close_async (GInputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_input_stream_close_async(stream, io_priority, cancellable, callback&
      &, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_input_stream_close_finish (GInputStream *stream, GAsyncResult *result, GError **error);
function g_input_stream_close_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_input_stream_close_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  gboolean g_input_stream_is_closed (GInputStream *stream);
function g_input_stream_is_closed(stream) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_input_stream_is_closed
  type(c_ptr), value :: stream
end function

! gboolean g_input_stream_has_pending (GInputStream *stream);
function g_input_stream_has_pending(stream) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_input_stream_has_pending
  type(c_ptr), value :: stream
end function

! gboolean g_input_stream_set_pending (GInputStream *stream, GError **error);
function g_input_stream_set_pending(stream, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_input_stream_set_pending
  type(c_ptr), value :: stream
  type(c_ptr), value :: error
end function

! void g_input_stream_clear_pending (GInputStream *stream);
subroutine g_input_stream_clear_pending(stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: stream
end subroutine

!   GType g_proxy_address_get_type (void) G_GNUC_CONST;
function g_proxy_address_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_proxy_address_get_type
end function

!  GSocketAddress *g_proxy_address_new (GInetAddress *inetaddr, guint16 port, const gchar *protocol, const gchar *dest_hostname, guint16 dest_port, const gchar *username, const gchar *password);
function g_proxy_address_new(inetaddr, port, protocol, dest_hostname, dest_port,&
      & username, password) bind(c) 
  use iso_c_binding, only: c_ptr, c_int16_t, c_char
  type(c_ptr) :: g_proxy_address_new
  type(c_ptr), value :: inetaddr
  integer(c_int16_t), value :: port
  character(kind=c_char), dimension(*) :: protocol
  character(kind=c_char), dimension(*) :: dest_hostname
  integer(c_int16_t), value :: dest_port
  character(kind=c_char), dimension(*) :: username
  character(kind=c_char), dimension(*) :: password
end function

!  const gchar *g_proxy_address_get_protocol (GProxyAddress *proxy);
function g_proxy_address_get_protocol(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_proxy_address_get_protocol
  type(c_ptr), value :: proxy
end function

! const gchar *g_proxy_address_get_destination_hostname (GProxyAddress *proxy);
function g_proxy_address_get_destination_hostname(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_proxy_address_get_destination_hostname
  type(c_ptr), value :: proxy
end function

! guint16 g_proxy_address_get_destination_port (GProxyAddress *proxy);
function g_proxy_address_get_destination_port(proxy) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_proxy_address_get_destination_port
  type(c_ptr), value :: proxy
end function

! const gchar *g_proxy_address_get_username (GProxyAddress *proxy);
function g_proxy_address_get_username(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_proxy_address_get_username
  type(c_ptr), value :: proxy
end function

! const gchar *g_proxy_address_get_password (GProxyAddress *proxy);
function g_proxy_address_get_password(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_proxy_address_get_password
  type(c_ptr), value :: proxy
end function

!   GType g_socket_get_type (void) G_GNUC_CONST;
function g_socket_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_get_type
end function

! GSocket * g_socket_new (GSocketFamily family, GSocketType type, GSocketProtocol protocol, GError **error);
function g_socket_new(family, type, protocol, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_socket_new
  integer(c_int), value :: family
  integer(c_int), value :: type
  integer(c_int), value :: protocol
  type(c_ptr), value :: error
end function

! GSocket * g_socket_new_from_fd (gint fd, GError **error);
function g_socket_new_from_fd(fd, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_socket_new_from_fd
  integer(c_int), value :: fd
  type(c_ptr), value :: error
end function

! int g_socket_get_fd (GSocket *socket);
function g_socket_get_fd(socket) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_get_fd
  type(c_ptr), value :: socket
end function

! GSocketFamily g_socket_get_family (GSocket *socket);
function g_socket_get_family(socket) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_get_family
  type(c_ptr), value :: socket
end function

! GSocketType g_socket_get_socket_type (GSocket *socket);
function g_socket_get_socket_type(socket) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_get_socket_type
  type(c_ptr), value :: socket
end function

! GSocketProtocol g_socket_get_protocol (GSocket *socket);
function g_socket_get_protocol(socket) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_get_protocol
  type(c_ptr), value :: socket
end function

! GSocketAddress * g_socket_get_local_address (GSocket *socket, GError **error);
function g_socket_get_local_address(socket, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_get_local_address
  type(c_ptr), value :: socket
  type(c_ptr), value :: error
end function

! GSocketAddress * g_socket_get_remote_address (GSocket *socket, GError **error);
function g_socket_get_remote_address(socket, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_get_remote_address
  type(c_ptr), value :: socket
  type(c_ptr), value :: error
end function

! void g_socket_set_blocking (GSocket *socket, gboolean blocking);
subroutine g_socket_set_blocking(socket, blocking) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: socket
  logical(c_bool), value :: blocking
end subroutine

! gboolean g_socket_get_blocking (GSocket *socket);
function g_socket_get_blocking(socket) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_socket_get_blocking
  type(c_ptr), value :: socket
end function

! void g_socket_set_keepalive (GSocket *socket, gboolean keepalive);
subroutine g_socket_set_keepalive(socket, keepalive) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: socket
  logical(c_bool), value :: keepalive
end subroutine

! gboolean g_socket_get_keepalive (GSocket *socket);
function g_socket_get_keepalive(socket) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_socket_get_keepalive
  type(c_ptr), value :: socket
end function

! gint g_socket_get_listen_backlog (GSocket *socket);
function g_socket_get_listen_backlog(socket) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_get_listen_backlog
  type(c_ptr), value :: socket
end function

! void g_socket_set_listen_backlog (GSocket *socket, gint backlog);
subroutine g_socket_set_listen_backlog(socket, backlog) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: socket
  integer(c_int), value :: backlog
end subroutine

! guint g_socket_get_timeout (GSocket *socket);
function g_socket_get_timeout(socket) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_get_timeout
  type(c_ptr), value :: socket
end function

! void g_socket_set_timeout (GSocket *socket, guint timeout);
subroutine g_socket_set_timeout(socket, timeout) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: socket
  integer(c_int), value :: timeout
end subroutine

! gboolean g_socket_is_connected (GSocket *socket);
function g_socket_is_connected(socket) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_socket_is_connected
  type(c_ptr), value :: socket
end function

! gboolean g_socket_bind (GSocket *socket, GSocketAddress *address, gboolean allow_reuse, GError **error);
function g_socket_bind(socket, address, allow_reuse, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_socket_bind
  type(c_ptr), value :: socket
  type(c_ptr), value :: address
  logical(c_bool), value :: allow_reuse
  type(c_ptr), value :: error
end function

! gboolean g_socket_connect (GSocket *socket, GSocketAddress *address, GCancellable *cancellable, GError **error);
function g_socket_connect(socket, address, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_socket_connect
  type(c_ptr), value :: socket
  type(c_ptr), value :: address
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_socket_check_connect_result (GSocket *socket, GError **error);
function g_socket_check_connect_result(socket, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_socket_check_connect_result
  type(c_ptr), value :: socket
  type(c_ptr), value :: error
end function

! GIOCondition g_socket_condition_check (GSocket *socket, GIOCondition condition);
function g_socket_condition_check(socket, condition) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_condition_check
  type(c_ptr), value :: socket
  integer(c_int), value :: condition
end function

! gboolean g_socket_condition_wait (GSocket *socket, GIOCondition condition, GCancellable *cancellable, GError **error);
function g_socket_condition_wait(socket, condition, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: g_socket_condition_wait
  type(c_ptr), value :: socket
  integer(c_int), value :: condition
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GSocket * g_socket_accept (GSocket *socket, GCancellable *cancellable, GError **error);
function g_socket_accept(socket, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_accept
  type(c_ptr), value :: socket
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_socket_listen (GSocket *socket, GError **error);
function g_socket_listen(socket, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_socket_listen
  type(c_ptr), value :: socket
  type(c_ptr), value :: error
end function

! gssize g_socket_receive (GSocket *socket, gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
function g_socket_receive(socket, buffer, size, cancellable, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char
  integer(c_size_t) :: g_socket_receive
  type(c_ptr), value :: socket
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: size
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gssize g_socket_receive_from (GSocket *socket, GSocketAddress **address, gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
function g_socket_receive_from(socket, address, buffer, size, cancellable, error&
      &) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char
  integer(c_size_t) :: g_socket_receive_from
  type(c_ptr), value :: socket
  type(c_ptr), value :: address
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: size
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gssize g_socket_send (GSocket *socket, const gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
function g_socket_send(socket, buffer, size, cancellable, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char
  integer(c_size_t) :: g_socket_send
  type(c_ptr), value :: socket
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: size
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gssize g_socket_send_to (GSocket *socket, GSocketAddress *address, const gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
function g_socket_send_to(socket, address, buffer, size, cancellable, error) bin&
      &d(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char
  integer(c_size_t) :: g_socket_send_to
  type(c_ptr), value :: socket
  type(c_ptr), value :: address
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: size
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gssize g_socket_receive_message (GSocket *socket, GSocketAddress **address, GInputVector *vectors, gint num_vectors, GSocketControlMessage ***messages, gint *num_messages, gint *flags, GCancellable *cancellable, GError **error);
function g_socket_receive_message(socket, address, vectors, num_vectors, message&
      &s, num_messages, flags, cancellable, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_int
  integer(c_size_t) :: g_socket_receive_message
  type(c_ptr), value :: socket
  type(c_ptr), value :: address
  type(c_ptr), value :: vectors
  integer(c_int), value :: num_vectors
  type(c_ptr), value :: messages
  type(c_ptr), value :: num_messages
  type(c_ptr), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gssize g_socket_send_message (GSocket *socket, GSocketAddress *address, GOutputVector *vectors, gint num_vectors, GSocketControlMessage **messages, gint num_messages, gint flags, GCancellable *cancellable, GError **error);
function g_socket_send_message(socket, address, vectors, num_vectors, messages, &
      &num_messages, flags, cancellable, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_int
  integer(c_size_t) :: g_socket_send_message
  type(c_ptr), value :: socket
  type(c_ptr), value :: address
  type(c_ptr), value :: vectors
  integer(c_int), value :: num_vectors
  type(c_ptr), value :: messages
  integer(c_int), value :: num_messages
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_socket_close (GSocket *socket, GError **error);
function g_socket_close(socket, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_socket_close
  type(c_ptr), value :: socket
  type(c_ptr), value :: error
end function

! gboolean g_socket_shutdown (GSocket *socket, gboolean shutdown_read, gboolean shutdown_write, GError **error);
function g_socket_shutdown(socket, shutdown_read, shutdown_write, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_socket_shutdown
  type(c_ptr), value :: socket
  logical(c_bool), value :: shutdown_read
  logical(c_bool), value :: shutdown_write
  type(c_ptr), value :: error
end function

! gboolean g_socket_is_closed (GSocket *socket);
function g_socket_is_closed(socket) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_socket_is_closed
  type(c_ptr), value :: socket
end function

! GSource * g_socket_create_source (GSocket *socket, GIOCondition condition, GCancellable *cancellable);
function g_socket_create_source(socket, condition, cancellable) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_socket_create_source
  type(c_ptr), value :: socket
  integer(c_int), value :: condition
  type(c_ptr), value :: cancellable
end function

! gboolean g_socket_speaks_ipv4 (GSocket *socket);
function g_socket_speaks_ipv4(socket) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_socket_speaks_ipv4
  type(c_ptr), value :: socket
end function

! GCredentials *g_socket_get_credentials (GSocket *socket, GError **error);
function g_socket_get_credentials(socket, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_get_credentials
  type(c_ptr), value :: socket
  type(c_ptr), value :: error
end function

!  gssize g_socket_receive_with_blocking (GSocket *socket, gchar *buffer, gsize size, gboolean blocking, GCancellable *cancellable, GError **error);
function g_socket_receive_with_blocking(socket, buffer, size, blocking, cancella&
      &ble, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char, c_bool
  integer(c_size_t) :: g_socket_receive_with_blocking
  type(c_ptr), value :: socket
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: size
  logical(c_bool), value :: blocking
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gssize g_socket_send_with_blocking (GSocket *socket, const gchar *buffer, gsize size, gboolean blocking, GCancellable *cancellable, GError **error);
function g_socket_send_with_blocking(socket, buffer, size, blocking, cancellable&
      &, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char, c_bool
  integer(c_size_t) :: g_socket_send_with_blocking
  type(c_ptr), value :: socket
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: size
  logical(c_bool), value :: blocking
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!   GType g_socket_address_get_type (void) G_GNUC_CONST;
function g_socket_address_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_address_get_type
end function

!  GSocketFamily g_socket_address_get_family (GSocketAddress *address);
function g_socket_address_get_family(address) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_address_get_family
  type(c_ptr), value :: address
end function

!  GSocketAddress * g_socket_address_new_from_native (gpointer native, gsize len);
function g_socket_address_new_from_native(native, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_socket_address_new_from_native
  type(c_ptr), value :: native
  integer(c_size_t), value :: len
end function

!  gboolean g_socket_address_to_native (GSocketAddress *address, gpointer dest, gsize destlen, GError **error);
function g_socket_address_to_native(address, dest, destlen, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_size_t
  logical(c_bool) :: g_socket_address_to_native
  type(c_ptr), value :: address
  type(c_ptr), value :: dest
  integer(c_size_t), value :: destlen
  type(c_ptr), value :: error
end function

!  gssize g_socket_address_get_native_size (GSocketAddress *address);
function g_socket_address_get_native_size(address) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_socket_address_get_native_size
  type(c_ptr), value :: address
end function

!   GType g_file_info_get_type (void) G_GNUC_CONST;
function g_file_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_info_get_type
end function

!  GFileInfo * g_file_info_new (void);
function g_file_info_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_info_new
end function

! GFileInfo * g_file_info_dup (GFileInfo *other);
function g_file_info_dup(other) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_info_dup
  type(c_ptr), value :: other
end function

! void g_file_info_copy_into (GFileInfo *src_info, GFileInfo *dest_info);
subroutine g_file_info_copy_into(src_info, dest_info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: src_info
  type(c_ptr), value :: dest_info
end subroutine

! gboolean g_file_info_has_attribute (GFileInfo *info, const char *attribute);
function g_file_info_has_attribute(info, attribute) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_file_info_has_attribute
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! gboolean g_file_info_has_namespace (GFileInfo *info, const char *name_space);
function g_file_info_has_namespace(info, name_space) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_file_info_has_namespace
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name_space
end function

! char ** g_file_info_list_attributes (GFileInfo *info, const char *name_space);
function g_file_info_list_attributes(info, name_space) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_info_list_attributes
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name_space
end function

! gboolean g_file_info_get_attribute_data (GFileInfo *info, const char *attribute, GFileAttributeType *type, gpointer *value_pp, GFileAttributeStatus *status);
function g_file_info_get_attribute_data(info, attribute, type, value_pp, status)&
      & bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: g_file_info_get_attribute_data
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int), value :: type
  type(c_ptr), value :: value_pp
  integer(c_int), value :: status
end function

! GFileAttributeType g_file_info_get_attribute_type (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_type(info, attribute) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_file_info_get_attribute_type
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! void g_file_info_remove_attribute (GFileInfo *info, const char *attribute);
subroutine g_file_info_remove_attribute(info, attribute) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end subroutine

! GFileAttributeStatus g_file_info_get_attribute_status (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_status(info, attribute) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_file_info_get_attribute_status
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! gboolean g_file_info_set_attribute_status (GFileInfo *info, const char *attribute, GFileAttributeStatus status);
function g_file_info_set_attribute_status(info, attribute, status) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: g_file_info_set_attribute_status
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int), value :: status
end function

! char * g_file_info_get_attribute_as_string (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_as_string(info, attribute) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_info_get_attribute_as_string
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! const char * g_file_info_get_attribute_string (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_string(info, attribute) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_info_get_attribute_string
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! const char * g_file_info_get_attribute_byte_string (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_byte_string(info, attribute) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_info_get_attribute_byte_string
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! gboolean g_file_info_get_attribute_boolean (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_boolean(info, attribute) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_file_info_get_attribute_boolean
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! guint32 g_file_info_get_attribute_uint32 (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_uint32(info, attribute) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr, c_char
  integer(c_int32_t) :: g_file_info_get_attribute_uint32
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! gint32 g_file_info_get_attribute_int32 (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_int32(info, attribute) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr, c_char
  integer(c_int32_t) :: g_file_info_get_attribute_int32
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! guint64 g_file_info_get_attribute_uint64 (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_uint64(info, attribute) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr, c_char
  integer(c_int64_t) :: g_file_info_get_attribute_uint64
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! gint64 g_file_info_get_attribute_int64 (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_int64(info, attribute) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr, c_char
  integer(c_int64_t) :: g_file_info_get_attribute_int64
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! GObject * g_file_info_get_attribute_object (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_object(info, attribute) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_info_get_attribute_object
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! char ** g_file_info_get_attribute_stringv (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_stringv(info, attribute) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_info_get_attribute_stringv
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

!  void g_file_info_set_attribute (GFileInfo *info, const char *attribute, GFileAttributeType type, gpointer value_p);
subroutine g_file_info_set_attribute(info, attribute, type, value_p) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int), value :: type
  type(c_ptr), value :: value_p
end subroutine

! void g_file_info_set_attribute_string (GFileInfo *info, const char *attribute, const char *attr_value);
subroutine g_file_info_set_attribute_string(info, attribute, attr_value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  character(kind=c_char), dimension(*) :: attr_value
end subroutine

! void g_file_info_set_attribute_byte_string (GFileInfo *info, const char *attribute, const char *attr_value);
subroutine g_file_info_set_attribute_byte_string(info, attribute, attr_value) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  character(kind=c_char), dimension(*) :: attr_value
end subroutine

! void g_file_info_set_attribute_boolean (GFileInfo *info, const char *attribute, gboolean attr_value);
subroutine g_file_info_set_attribute_boolean(info, attribute, attr_value) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_char, c_bool
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  logical(c_bool), value :: attr_value
end subroutine

! void g_file_info_set_attribute_uint32 (GFileInfo *info, const char *attribute, guint32 attr_value);
subroutine g_file_info_set_attribute_uint32(info, attribute, attr_value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int32_t
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int32_t), value :: attr_value
end subroutine

! void g_file_info_set_attribute_int32 (GFileInfo *info, const char *attribute, gint32 attr_value);
subroutine g_file_info_set_attribute_int32(info, attribute, attr_value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int32_t
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int32_t), value :: attr_value
end subroutine

! void g_file_info_set_attribute_uint64 (GFileInfo *info, const char *attribute, guint64 attr_value);
subroutine g_file_info_set_attribute_uint64(info, attribute, attr_value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int64_t
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int64_t), value :: attr_value
end subroutine

! void g_file_info_set_attribute_int64 (GFileInfo *info, const char *attribute, gint64 attr_value);
subroutine g_file_info_set_attribute_int64(info, attribute, attr_value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int64_t
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int64_t), value :: attr_value
end subroutine

! void g_file_info_set_attribute_object (GFileInfo *info, const char *attribute, GObject *attr_value);
subroutine g_file_info_set_attribute_object(info, attribute, attr_value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  type(c_ptr), value :: attr_value
end subroutine

! void g_file_info_set_attribute_stringv (GFileInfo *info, const char *attribute, char **attr_value);
subroutine g_file_info_set_attribute_stringv(info, attribute, attr_value) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  character(kind=c_char), dimension(*) :: attr_value
end subroutine

!  void g_file_info_clear_status (GFileInfo *info);
subroutine g_file_info_clear_status(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
end subroutine

!  GFileType g_file_info_get_file_type (GFileInfo *info);
function g_file_info_get_file_type(info) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_info_get_file_type
  type(c_ptr), value :: info
end function

! gboolean g_file_info_get_is_hidden (GFileInfo *info);
function g_file_info_get_is_hidden(info) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_info_get_is_hidden
  type(c_ptr), value :: info
end function

! gboolean g_file_info_get_is_backup (GFileInfo *info);
function g_file_info_get_is_backup(info) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_info_get_is_backup
  type(c_ptr), value :: info
end function

! gboolean g_file_info_get_is_symlink (GFileInfo *info);
function g_file_info_get_is_symlink(info) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_info_get_is_symlink
  type(c_ptr), value :: info
end function

! const char * g_file_info_get_name (GFileInfo *info);
function g_file_info_get_name(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_info_get_name
  type(c_ptr), value :: info
end function

! const char * g_file_info_get_display_name (GFileInfo *info);
function g_file_info_get_display_name(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_info_get_display_name
  type(c_ptr), value :: info
end function

! const char * g_file_info_get_edit_name (GFileInfo *info);
function g_file_info_get_edit_name(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_info_get_edit_name
  type(c_ptr), value :: info
end function

! GIcon * g_file_info_get_icon (GFileInfo *info);
function g_file_info_get_icon(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_info_get_icon
  type(c_ptr), value :: info
end function

! const char * g_file_info_get_content_type (GFileInfo *info);
function g_file_info_get_content_type(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_info_get_content_type
  type(c_ptr), value :: info
end function

! goffset g_file_info_get_size (GFileInfo *info);
function g_file_info_get_size(info) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_file_info_get_size
  type(c_ptr), value :: info
end function

! void g_file_info_get_modification_time (GFileInfo *info, GTimeVal *result);
subroutine g_file_info_get_modification_time(info, result) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
  type(c_ptr), value :: result
end subroutine

! const char * g_file_info_get_symlink_target (GFileInfo *info);
function g_file_info_get_symlink_target(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_info_get_symlink_target
  type(c_ptr), value :: info
end function

! const char * g_file_info_get_etag (GFileInfo *info);
function g_file_info_get_etag(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_info_get_etag
  type(c_ptr), value :: info
end function

! gint32 g_file_info_get_sort_order (GFileInfo *info);
function g_file_info_get_sort_order(info) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_file_info_get_sort_order
  type(c_ptr), value :: info
end function

!  void g_file_info_set_attribute_mask (GFileInfo *info, GFileAttributeMatcher *mask);
subroutine g_file_info_set_attribute_mask(info, mask) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
  type(c_ptr), value :: mask
end subroutine

! void g_file_info_unset_attribute_mask (GFileInfo *info);
subroutine g_file_info_unset_attribute_mask(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
end subroutine

!  void g_file_info_set_file_type (GFileInfo *info, GFileType type);
subroutine g_file_info_set_file_type(info, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: info
  integer(c_int), value :: type
end subroutine

! void g_file_info_set_is_hidden (GFileInfo *info, gboolean is_hidden);
subroutine g_file_info_set_is_hidden(info, is_hidden) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: info
  logical(c_bool), value :: is_hidden
end subroutine

! void g_file_info_set_is_symlink (GFileInfo *info, gboolean is_symlink);
subroutine g_file_info_set_is_symlink(info, is_symlink) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: info
  logical(c_bool), value :: is_symlink
end subroutine

! void g_file_info_set_name (GFileInfo *info, const char *name);
subroutine g_file_info_set_name(info, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
end subroutine

! void g_file_info_set_display_name (GFileInfo *info, const char *display_name);
subroutine g_file_info_set_display_name(info, display_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: display_name
end subroutine

! void g_file_info_set_edit_name (GFileInfo *info, const char *edit_name);
subroutine g_file_info_set_edit_name(info, edit_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: edit_name
end subroutine

! void g_file_info_set_icon (GFileInfo *info, GIcon *icon);
subroutine g_file_info_set_icon(info, icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
  type(c_ptr), value :: icon
end subroutine

! void g_file_info_set_content_type (GFileInfo *info, const char *content_type);
subroutine g_file_info_set_content_type(info, content_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: content_type
end subroutine

! void g_file_info_set_size (GFileInfo *info, goffset size);
subroutine g_file_info_set_size(info, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int64_t
  type(c_ptr), value :: info
  integer(c_int64_t), value :: size
end subroutine

! void g_file_info_set_modification_time (GFileInfo *info, GTimeVal *mtime);
subroutine g_file_info_set_modification_time(info, mtime) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
  type(c_ptr), value :: mtime
end subroutine

! void g_file_info_set_symlink_target (GFileInfo *info, const char *symlink_target);
subroutine g_file_info_set_symlink_target(info, symlink_target) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: symlink_target
end subroutine

! void g_file_info_set_sort_order (GFileInfo *info, gint32 sort_order);
subroutine g_file_info_set_sort_order(info, sort_order) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: info
  integer(c_int32_t), value :: sort_order
end subroutine

!  GType g_file_attribute_matcher_get_type (void) G_GNUC_CONST;
function g_file_attribute_matcher_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_attribute_matcher_get_type
end function

! GFileAttributeMatcher *g_file_attribute_matcher_new (const char *attributes);
function g_file_attribute_matcher_new(attributes) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_attribute_matcher_new
  character(kind=c_char), dimension(*) :: attributes
end function

! GFileAttributeMatcher *g_file_attribute_matcher_ref (GFileAttributeMatcher *matcher);
function g_file_attribute_matcher_ref(matcher) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_attribute_matcher_ref
  type(c_ptr), value :: matcher
end function

! void g_file_attribute_matcher_unref (GFileAttributeMatcher *matcher);
subroutine g_file_attribute_matcher_unref(matcher) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: matcher
end subroutine

! gboolean g_file_attribute_matcher_matches (GFileAttributeMatcher *matcher, const char *attribute);
function g_file_attribute_matcher_matches(matcher, attribute) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_file_attribute_matcher_matches
  type(c_ptr), value :: matcher
  character(kind=c_char), dimension(*) :: attribute
end function

! gboolean g_file_attribute_matcher_matches_only (GFileAttributeMatcher *matcher, const char *attribute);
function g_file_attribute_matcher_matches_only(matcher, attribute) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_file_attribute_matcher_matches_only
  type(c_ptr), value :: matcher
  character(kind=c_char), dimension(*) :: attribute
end function

! gboolean g_file_attribute_matcher_enumerate_namespace (GFileAttributeMatcher *matcher, const char *ns);
function g_file_attribute_matcher_enumerate_namespace(matcher, ns) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_file_attribute_matcher_enumerate_namespace
  type(c_ptr), value :: matcher
  character(kind=c_char), dimension(*) :: ns
end function

! const char * g_file_attribute_matcher_enumerate_next (GFileAttributeMatcher *matcher);
function g_file_attribute_matcher_enumerate_next(matcher) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_attribute_matcher_enumerate_next
  type(c_ptr), value :: matcher
end function

!   GType g_tcp_connection_get_type (void) G_GNUC_CONST;
function g_tcp_connection_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_tcp_connection_get_type
end function

!  void g_tcp_connection_set_graceful_disconnect (GTcpConnection *connection, gboolean graceful_disconnect);
subroutine g_tcp_connection_set_graceful_disconnect(connection, graceful_disconn&
      &ect) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: connection
  logical(c_bool), value :: graceful_disconnect
end subroutine

! gboolean g_tcp_connection_get_graceful_disconnect (GTcpConnection *connection);
function g_tcp_connection_get_graceful_disconnect(connection) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_tcp_connection_get_graceful_disconnect
  type(c_ptr), value :: connection
end function

!   GType g_memory_input_stream_get_type (void) G_GNUC_CONST;
function g_memory_input_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_memory_input_stream_get_type
end function

! GInputStream * g_memory_input_stream_new (void);
function g_memory_input_stream_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_memory_input_stream_new
end function

! GInputStream * g_memory_input_stream_new_from_data (const void *data, gssize len, GDestroyNotify destroy);
function g_memory_input_stream_new_from_data(data, len, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_funptr
  type(c_ptr) :: g_memory_input_stream_new_from_data
  type(c_ptr), value :: data
  integer(c_size_t), value :: len
  type(c_funptr), value :: destroy
end function

! void g_memory_input_stream_add_data (GMemoryInputStream *stream, const void *data, gssize len, GDestroyNotify destroy);
subroutine g_memory_input_stream_add_data(stream, data, len, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_funptr
  type(c_ptr), value :: stream
  type(c_ptr), value :: data
  integer(c_size_t), value :: len
  type(c_funptr), value :: destroy
end subroutine

!   GType g_volume_monitor_get_type (void) G_GNUC_CONST;
function g_volume_monitor_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_volume_monitor_get_type
end function

!  GVolumeMonitor *g_volume_monitor_get (void);
function g_volume_monitor_get() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_monitor_get
end function

! GList * g_volume_monitor_get_connected_drives (GVolumeMonitor *volume_monitor);
function g_volume_monitor_get_connected_drives(volume_monitor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_monitor_get_connected_drives
  type(c_ptr), value :: volume_monitor
end function

! GList * g_volume_monitor_get_volumes (GVolumeMonitor *volume_monitor);
function g_volume_monitor_get_volumes(volume_monitor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_monitor_get_volumes
  type(c_ptr), value :: volume_monitor
end function

! GList * g_volume_monitor_get_mounts (GVolumeMonitor *volume_monitor);
function g_volume_monitor_get_mounts(volume_monitor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_monitor_get_mounts
  type(c_ptr), value :: volume_monitor
end function

! GVolume * g_volume_monitor_get_volume_for_uuid (GVolumeMonitor *volume_monitor, const char *uuid);
function g_volume_monitor_get_volume_for_uuid(volume_monitor, uuid) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_volume_monitor_get_volume_for_uuid
  type(c_ptr), value :: volume_monitor
  character(kind=c_char), dimension(*) :: uuid
end function

! GMount * g_volume_monitor_get_mount_for_uuid (GVolumeMonitor *volume_monitor, const char *uuid);
function g_volume_monitor_get_mount_for_uuid(volume_monitor, uuid) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_volume_monitor_get_mount_for_uuid
  type(c_ptr), value :: volume_monitor
  character(kind=c_char), dimension(*) :: uuid
end function

!  GVolume * g_volume_monitor_adopt_orphan_mount (GMount *mount);
function g_volume_monitor_adopt_orphan_mount(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_monitor_adopt_orphan_mount
  type(c_ptr), value :: mount
end function

!   GType g_emblemed_icon_get_type (void) G_GNUC_CONST;
function g_emblemed_icon_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_emblemed_icon_get_type
end function

!  GIcon *g_emblemed_icon_new (GIcon *icon, GEmblem *emblem);
function g_emblemed_icon_new(icon, emblem) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_emblemed_icon_new
  type(c_ptr), value :: icon
  type(c_ptr), value :: emblem
end function

! GIcon *g_emblemed_icon_get_icon (GEmblemedIcon *emblemed);
function g_emblemed_icon_get_icon(emblemed) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_emblemed_icon_get_icon
  type(c_ptr), value :: emblemed
end function

! GList *g_emblemed_icon_get_emblems (GEmblemedIcon *emblemed);
function g_emblemed_icon_get_emblems(emblemed) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_emblemed_icon_get_emblems
  type(c_ptr), value :: emblemed
end function

! void g_emblemed_icon_add_emblem (GEmblemedIcon *emblemed, GEmblem *emblem);
subroutine g_emblemed_icon_add_emblem(emblemed, emblem) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: emblemed
  type(c_ptr), value :: emblem
end subroutine

!   void g_io_scheduler_push_job (GIOSchedulerJobFunc job_func, gpointer user_data, GDestroyNotify notify, gint io_priority, GCancellable *cancellable);
subroutine g_io_scheduler_push_job(job_func, user_data, notify, io_priority, can&
      &cellable) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr, c_int
  type(c_funptr), value :: job_func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: notify
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
end subroutine

! void g_io_scheduler_cancel_all_jobs (void);
subroutine g_io_scheduler_cancel_all_jobs() bind(c) 
  use iso_c_binding, only: 
end subroutine

! gboolean g_io_scheduler_job_send_to_mainloop (GIOSchedulerJob *job, GSourceFunc func, gpointer user_data, GDestroyNotify notify);
function g_io_scheduler_job_send_to_mainloop(job, func, user_data, notify) bind(&
      &c) 
  use iso_c_binding, only: c_bool, c_ptr, c_funptr
  logical(c_bool) :: g_io_scheduler_job_send_to_mainloop
  type(c_ptr), value :: job
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: notify
end function

! void g_io_scheduler_job_send_to_mainloop_async (GIOSchedulerJob *job, GSourceFunc func, gpointer user_data, GDestroyNotify notify);
subroutine g_io_scheduler_job_send_to_mainloop_async(job, func, user_data, notif&
      &y) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: job
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: notify
end subroutine

!   GType g_converter_output_stream_get_type (void) G_GNUC_CONST;
function g_converter_output_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_converter_output_stream_get_type
end function

! GOutputStream *g_converter_output_stream_new (GOutputStream *base_stream, GConverter *converter);
function g_converter_output_stream_new(base_stream, converter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_converter_output_stream_new
  type(c_ptr), value :: base_stream
  type(c_ptr), value :: converter
end function

! GConverter *g_converter_output_stream_get_converter (GConverterOutputStream *converter_stream);
function g_converter_output_stream_get_converter(converter_stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_converter_output_stream_get_converter
  type(c_ptr), value :: converter_stream
end function

!   GType g_dbus_message_get_type (void) G_GNUC_CONST;
function g_dbus_message_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_message_get_type
end function

! GDBusMessage *g_dbus_message_new (void);
function g_dbus_message_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_new
end function

! GDBusMessage *g_dbus_message_new_signal (const gchar *path, const gchar *interface_, const gchar *signal);
function g_dbus_message_new_signal(path, interface_, signal) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_message_new_signal
  character(kind=c_char), dimension(*) :: path
  character(kind=c_char), dimension(*) :: interface_
  character(kind=c_char), dimension(*) :: signal
end function

! GDBusMessage *g_dbus_message_new_method_call (const gchar *name, const gchar *path, const gchar *interface_, const gchar *method);
function g_dbus_message_new_method_call(name, path, interface_, method) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_message_new_method_call
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: path
  character(kind=c_char), dimension(*) :: interface_
  character(kind=c_char), dimension(*) :: method
end function

! GDBusMessage *g_dbus_message_new_method_reply (GDBusMessage *method_call_message);
function g_dbus_message_new_method_reply(method_call_message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_new_method_reply
  type(c_ptr), value :: method_call_message
end function

! GDBusMessage *g_dbus_message_new_method_error_valist (GDBusMessage *method_call_message, const gchar *error_name, const gchar *error_message_format, va_list var_args);
function g_dbus_message_new_method_error_valist(method_call_message, error_name,&
      & error_message_format, var_args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_message_new_method_error_valist
  type(c_ptr), value :: method_call_message
  character(kind=c_char), dimension(*) :: error_name
  character(kind=c_char), dimension(*) :: error_message_format
  type(c_ptr), value :: var_args
end function

! GDBusMessage *g_dbus_message_new_method_error_literal (GDBusMessage *method_call_message, const gchar *error_name, const gchar *error_message);
function g_dbus_message_new_method_error_literal(method_call_message, error_name&
      &, error_message) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_message_new_method_error_literal
  type(c_ptr), value :: method_call_message
  character(kind=c_char), dimension(*) :: error_name
  character(kind=c_char), dimension(*) :: error_message
end function

! gchar *g_dbus_message_print (GDBusMessage *message, guint indent);
function g_dbus_message_print(message, indent) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_dbus_message_print
  type(c_ptr), value :: message
  integer(c_int), value :: indent
end function

! gboolean g_dbus_message_get_locked (GDBusMessage *message);
function g_dbus_message_get_locked(message) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_dbus_message_get_locked
  type(c_ptr), value :: message
end function

! void g_dbus_message_lock (GDBusMessage *message);
subroutine g_dbus_message_lock(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: message
end subroutine

! GDBusMessage *g_dbus_message_copy (GDBusMessage *message, GError **error);
function g_dbus_message_copy(message, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_copy
  type(c_ptr), value :: message
  type(c_ptr), value :: error
end function

! GDBusMessageByteOrder g_dbus_message_get_byte_order (GDBusMessage *message);
function g_dbus_message_get_byte_order(message) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_message_get_byte_order
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_byte_order (GDBusMessage *message, GDBusMessageByteOrder byte_order);
subroutine g_dbus_message_set_byte_order(message, byte_order) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: message
  integer(c_int), value :: byte_order
end subroutine

!  GDBusMessageType g_dbus_message_get_message_type (GDBusMessage *message);
function g_dbus_message_get_message_type(message) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_message_get_message_type
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_message_type (GDBusMessage *message, GDBusMessageType type);
subroutine g_dbus_message_set_message_type(message, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: message
  integer(c_int), value :: type
end subroutine

! GDBusMessageFlags g_dbus_message_get_flags (GDBusMessage *message);
function g_dbus_message_get_flags(message) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_message_get_flags
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_flags (GDBusMessage *message, GDBusMessageFlags flags);
subroutine g_dbus_message_set_flags(message, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: message
  integer(c_int), value :: flags
end subroutine

! guint32 g_dbus_message_get_serial (GDBusMessage *message);
function g_dbus_message_get_serial(message) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_dbus_message_get_serial
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_serial (GDBusMessage *message, guint32 serial);
subroutine g_dbus_message_set_serial(message, serial) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: message
  integer(c_int32_t), value :: serial
end subroutine

! GVariant *g_dbus_message_get_header (GDBusMessage *message, GDBusMessageHeaderField header_field);
function g_dbus_message_get_header(message, header_field) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_dbus_message_get_header
  type(c_ptr), value :: message
  integer(c_int), value :: header_field
end function

! void g_dbus_message_set_header (GDBusMessage *message, GDBusMessageHeaderField header_field, GVariant *value);
subroutine g_dbus_message_set_header(message, header_field, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: message
  integer(c_int), value :: header_field
  type(c_ptr), value :: value
end subroutine

! guchar *g_dbus_message_get_header_fields (GDBusMessage *message);
function g_dbus_message_get_header_fields(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_header_fields
  type(c_ptr), value :: message
end function

! GVariant *g_dbus_message_get_body (GDBusMessage *message);
function g_dbus_message_get_body(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_body
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_body (GDBusMessage *message, GVariant *body);
subroutine g_dbus_message_set_body(message, body) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: message
  type(c_ptr), value :: body
end subroutine

! GUnixFDList *g_dbus_message_get_unix_fd_list (GDBusMessage *message);
function g_dbus_message_get_unix_fd_list(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_unix_fd_list
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_unix_fd_list (GDBusMessage *message, GUnixFDList *fd_list);
subroutine g_dbus_message_set_unix_fd_list(message, fd_list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: message
  type(c_ptr), value :: fd_list
end subroutine

!  guint32 g_dbus_message_get_reply_serial (GDBusMessage *message);
function g_dbus_message_get_reply_serial(message) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_dbus_message_get_reply_serial
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_reply_serial (GDBusMessage *message, guint32 value);
subroutine g_dbus_message_set_reply_serial(message, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: message
  integer(c_int32_t), value :: value
end subroutine

!  const gchar *g_dbus_message_get_interface (GDBusMessage *message);
function g_dbus_message_get_interface(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_interface
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_interface (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_interface(message, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

!  const gchar *g_dbus_message_get_member (GDBusMessage *message);
function g_dbus_message_get_member(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_member
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_member (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_member(message, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

!  const gchar *g_dbus_message_get_path (GDBusMessage *message);
function g_dbus_message_get_path(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_path
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_path (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_path(message, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

!  const gchar *g_dbus_message_get_sender (GDBusMessage *message);
function g_dbus_message_get_sender(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_sender
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_sender (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_sender(message, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

!  const gchar *g_dbus_message_get_destination (GDBusMessage *message);
function g_dbus_message_get_destination(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_destination
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_destination (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_destination(message, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

!  const gchar *g_dbus_message_get_error_name (GDBusMessage *message);
function g_dbus_message_get_error_name(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_error_name
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_error_name (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_error_name(message, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

!  const gchar *g_dbus_message_get_signature (GDBusMessage *message);
function g_dbus_message_get_signature(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_signature
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_signature (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_signature(message, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

!  guint32 g_dbus_message_get_num_unix_fds (GDBusMessage *message);
function g_dbus_message_get_num_unix_fds(message) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_dbus_message_get_num_unix_fds
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_num_unix_fds (GDBusMessage *message, guint32 value);
subroutine g_dbus_message_set_num_unix_fds(message, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: message
  integer(c_int32_t), value :: value
end subroutine

!  const gchar *g_dbus_message_get_arg0 (GDBusMessage *message);
function g_dbus_message_get_arg0(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_arg0
  type(c_ptr), value :: message
end function

!  GDBusMessage *g_dbus_message_new_from_blob (guchar *blob, gsize blob_len, GDBusCapabilityFlags capabilities, GError **error);
function g_dbus_message_new_from_blob(blob, blob_len, capabilities, error) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_dbus_message_new_from_blob
  character(kind=c_char), dimension(*) :: blob
  integer(c_size_t), value :: blob_len
  integer(c_int), value :: capabilities
  type(c_ptr), value :: error
end function

!  gssize g_dbus_message_bytes_needed (guchar *blob, gsize blob_len, GError **error);
function g_dbus_message_bytes_needed(blob, blob_len, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_dbus_message_bytes_needed
  character(kind=c_char), dimension(*) :: blob
  integer(c_size_t), value :: blob_len
  type(c_ptr), value :: error
end function

!  guchar *g_dbus_message_to_blob (GDBusMessage *message, gsize *out_size, GDBusCapabilityFlags capabilities, GError **error);
function g_dbus_message_to_blob(message, out_size, capabilities, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_dbus_message_to_blob
  type(c_ptr), value :: message
  type(c_ptr), value :: out_size
  integer(c_int), value :: capabilities
  type(c_ptr), value :: error
end function

!  gboolean g_dbus_message_to_gerror (GDBusMessage *message, GError **error);
function g_dbus_message_to_gerror(message, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_dbus_message_to_gerror
  type(c_ptr), value :: message
  type(c_ptr), value :: error
end function

!   GType g_dbus_server_get_type (void) G_GNUC_CONST;
function g_dbus_server_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_server_get_type
end function

! GDBusServer *g_dbus_server_new_sync (const gchar *address, GDBusServerFlags flags, const gchar *guid, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error);
function g_dbus_server_new_sync(address, flags, guid, observer, cancellable, err&
      &or) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_dbus_server_new_sync
  character(kind=c_char), dimension(*) :: address
  integer(c_int), value :: flags
  character(kind=c_char), dimension(*) :: guid
  type(c_ptr), value :: observer
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! const gchar *g_dbus_server_get_client_address (GDBusServer *server);
function g_dbus_server_get_client_address(server) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_server_get_client_address
  type(c_ptr), value :: server
end function

! const gchar *g_dbus_server_get_guid (GDBusServer *server);
function g_dbus_server_get_guid(server) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_server_get_guid
  type(c_ptr), value :: server
end function

! GDBusServerFlags g_dbus_server_get_flags (GDBusServer *server);
function g_dbus_server_get_flags(server) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_server_get_flags
  type(c_ptr), value :: server
end function

! void g_dbus_server_start (GDBusServer *server);
subroutine g_dbus_server_start(server) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: server
end subroutine

! void g_dbus_server_stop (GDBusServer *server);
subroutine g_dbus_server_stop(server) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: server
end subroutine

! gboolean g_dbus_server_is_active (GDBusServer *server);
function g_dbus_server_is_active(server) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_dbus_server_is_active
  type(c_ptr), value :: server
end function

!   GType g_socket_control_message_get_type (void) G_GNUC_CONST;
function g_socket_control_message_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_control_message_get_type
end function

! gsize g_socket_control_message_get_size (GSocketControlMessage *message);
function g_socket_control_message_get_size(message) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_socket_control_message_get_size
  type(c_ptr), value :: message
end function

! int g_socket_control_message_get_level (GSocketControlMessage *message);
function g_socket_control_message_get_level(message) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_control_message_get_level
  type(c_ptr), value :: message
end function

! int g_socket_control_message_get_msg_type (GSocketControlMessage *message);
function g_socket_control_message_get_msg_type(message) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_control_message_get_msg_type
  type(c_ptr), value :: message
end function

! void g_socket_control_message_serialize (GSocketControlMessage *message, gpointer data);
subroutine g_socket_control_message_serialize(message, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: message
  type(c_ptr), value :: data
end subroutine

! GSocketControlMessage *g_socket_control_message_deserialize (int level, int type, gsize size, gpointer data);
function g_socket_control_message_deserialize(level, type, size, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_size_t
  type(c_ptr) :: g_socket_control_message_deserialize
  integer(c_int), value :: level
  integer(c_int), value :: type
  integer(c_size_t), value :: size
  type(c_ptr), value :: data
end function

!   GType g_seekable_get_type (void) G_GNUC_CONST;
function g_seekable_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_seekable_get_type
end function

!  goffset g_seekable_tell (GSeekable *seekable);
function g_seekable_tell(seekable) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_seekable_tell
  type(c_ptr), value :: seekable
end function

! gboolean g_seekable_can_seek (GSeekable *seekable);
function g_seekable_can_seek(seekable) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_seekable_can_seek
  type(c_ptr), value :: seekable
end function

! gboolean g_seekable_seek (GSeekable *seekable, goffset offset, GSeekType type, GCancellable *cancellable, GError **error);
function g_seekable_seek(seekable, offset, type, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int64_t, c_int
  logical(c_bool) :: g_seekable_seek
  type(c_ptr), value :: seekable
  integer(c_int64_t), value :: offset
  integer(c_int), value :: type
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_seekable_can_truncate (GSeekable *seekable);
function g_seekable_can_truncate(seekable) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_seekable_can_truncate
  type(c_ptr), value :: seekable
end function

! gboolean g_seekable_truncate (GSeekable *seekable, goffset offset, GCancellable *cancellable, GError **error);
function g_seekable_truncate(seekable, offset, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int64_t
  logical(c_bool) :: g_seekable_truncate
  type(c_ptr), value :: seekable
  integer(c_int64_t), value :: offset
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!   GType g_charset_converter_get_type (void) G_GNUC_CONST;
function g_charset_converter_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_charset_converter_get_type
end function

!  GCharsetConverter *g_charset_converter_new (const gchar *to_charset, const gchar *from_charset, GError **error);
function g_charset_converter_new(to_charset, from_charset, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_charset_converter_new
  character(kind=c_char), dimension(*) :: to_charset
  character(kind=c_char), dimension(*) :: from_charset
  type(c_ptr), value :: error
end function

! void g_charset_converter_set_use_fallback (GCharsetConverter *converter, gboolean use_fallback);
subroutine g_charset_converter_set_use_fallback(converter, use_fallback) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: converter
  logical(c_bool), value :: use_fallback
end subroutine

! gboolean g_charset_converter_get_use_fallback (GCharsetConverter *converter);
function g_charset_converter_get_use_fallback(converter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_charset_converter_get_use_fallback
  type(c_ptr), value :: converter
end function

! guint g_charset_converter_get_num_fallbacks (GCharsetConverter *converter);
function g_charset_converter_get_num_fallbacks(converter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_charset_converter_get_num_fallbacks
  type(c_ptr), value :: converter
end function

!   GType g_inet_socket_address_get_type (void) G_GNUC_CONST;
function g_inet_socket_address_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_inet_socket_address_get_type
end function

!  GSocketAddress *g_inet_socket_address_new (GInetAddress *address, guint16 port);
function g_inet_socket_address_new(address, port) bind(c) 
  use iso_c_binding, only: c_ptr, c_int16_t
  type(c_ptr) :: g_inet_socket_address_new
  type(c_ptr), value :: address
  integer(c_int16_t), value :: port
end function

!  GInetAddress * g_inet_socket_address_get_address (GInetSocketAddress *address);
function g_inet_socket_address_get_address(address) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_inet_socket_address_get_address
  type(c_ptr), value :: address
end function

!  guint16 g_inet_socket_address_get_port (GInetSocketAddress *address);
function g_inet_socket_address_get_port(address) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_inet_socket_address_get_port
  type(c_ptr), value :: address
end function

!   GType g_emblem_get_type (void) G_GNUC_CONST;
function g_emblem_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_emblem_get_type
end function

!  GEmblem *g_emblem_new (GIcon *icon);
function g_emblem_new(icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_emblem_new
  type(c_ptr), value :: icon
end function

! GEmblem *g_emblem_new_with_origin (GIcon *icon, GEmblemOrigin origin);
function g_emblem_new_with_origin(icon, origin) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_emblem_new_with_origin
  type(c_ptr), value :: icon
  integer(c_int), value :: origin
end function

! GIcon *g_emblem_get_icon (GEmblem *emblem);
function g_emblem_get_icon(emblem) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_emblem_get_icon
  type(c_ptr), value :: emblem
end function

! GEmblemOrigin g_emblem_get_origin (GEmblem *emblem);
function g_emblem_get_origin(emblem) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_emblem_get_origin
  type(c_ptr), value :: emblem
end function

!   GType g_file_icon_get_type (void) G_GNUC_CONST;
function g_file_icon_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_icon_get_type
end function

!  GIcon * g_file_icon_new (GFile *file);
function g_file_icon_new(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_icon_new
  type(c_ptr), value :: file
end function

!  GFile * g_file_icon_get_file (GFileIcon *icon);
function g_file_icon_get_file(icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_icon_get_file
  type(c_ptr), value :: icon
end function

!   GType g_filter_output_stream_get_type (void) G_GNUC_CONST;
function g_filter_output_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_filter_output_stream_get_type
end function

! GOutputStream * g_filter_output_stream_get_base_stream (GFilterOutputStream *stream);
function g_filter_output_stream_get_base_stream(stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_filter_output_stream_get_base_stream
  type(c_ptr), value :: stream
end function

! gboolean g_filter_output_stream_get_close_base_stream (GFilterOutputStream *stream);
function g_filter_output_stream_get_close_base_stream(stream) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_filter_output_stream_get_close_base_stream
  type(c_ptr), value :: stream
end function

! void g_filter_output_stream_set_close_base_stream (GFilterOutputStream *stream, gboolean close_base);
subroutine g_filter_output_stream_set_close_base_stream(stream, close_base) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: stream
  logical(c_bool), value :: close_base
end subroutine

!   GType g_settings_get_type (void);
function g_settings_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_settings_get_type
end function

!  const gchar * const * g_settings_list_schemas (void);
function g_settings_list_schemas() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_settings_list_schemas
end function

! GSettings * g_settings_new (const gchar *schema);
function g_settings_new(schema) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_settings_new
  character(kind=c_char), dimension(*) :: schema
end function

! GSettings * g_settings_new_with_path (const gchar *schema, const gchar *path);
function g_settings_new_with_path(schema, path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_settings_new_with_path
  character(kind=c_char), dimension(*) :: schema
  character(kind=c_char), dimension(*) :: path
end function

! GSettings * g_settings_new_with_backend (const gchar *schema, GSettingsBackend *backend);
function g_settings_new_with_backend(schema, backend) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_settings_new_with_backend
  character(kind=c_char), dimension(*) :: schema
  type(c_ptr), value :: backend
end function

! GSettings * g_settings_new_with_backend_and_path (const gchar *schema, GSettingsBackend *backend, const gchar *path);
function g_settings_new_with_backend_and_path(schema, backend, path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_settings_new_with_backend_and_path
  character(kind=c_char), dimension(*) :: schema
  type(c_ptr), value :: backend
  character(kind=c_char), dimension(*) :: path
end function

! gchar ** g_settings_list_children (GSettings *settings);
function g_settings_list_children(settings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_settings_list_children
  type(c_ptr), value :: settings
end function

! gchar ** g_settings_list_keys (GSettings *settings);
function g_settings_list_keys(settings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_settings_list_keys
  type(c_ptr), value :: settings
end function

!  gboolean g_settings_set_value (GSettings *settings, const gchar *key, GVariant *value);
function g_settings_set_value(settings, key, value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_settings_set_value
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: value
end function

! GVariant * g_settings_get_value (GSettings *settings, const gchar *key);
function g_settings_get_value(settings, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_settings_get_value
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! void g_settings_reset (GSettings *settings, const gchar *key);
subroutine g_settings_reset(settings, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end subroutine

!  gint g_settings_get_int (GSettings *settings, const gchar *key);
function g_settings_get_int(settings, key) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_get_int
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! gboolean g_settings_set_int (GSettings *settings, const gchar *key, gint value);
function g_settings_set_int(settings, key, value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: g_settings_set_int
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: value
end function

! gchar * g_settings_get_string (GSettings *settings, const gchar *key);
function g_settings_get_string(settings, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_settings_get_string
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! gboolean g_settings_set_string (GSettings *settings, const gchar *key, const gchar *value);
function g_settings_set_string(settings, key, value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_settings_set_string
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: value
end function

! gboolean g_settings_get_boolean (GSettings *settings, const gchar *key);
function g_settings_get_boolean(settings, key) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_settings_get_boolean
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! gboolean g_settings_set_boolean (GSettings *settings, const gchar *key, gboolean value);
function g_settings_set_boolean(settings, key, value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_settings_set_boolean
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  logical(c_bool), value :: value
end function

! gdouble g_settings_get_double (GSettings *settings, const gchar *key);
function g_settings_get_double(settings, key) bind(c) 
  use iso_c_binding, only: c_double, c_ptr, c_char
  real(c_double) :: g_settings_get_double
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! gboolean g_settings_set_double (GSettings *settings, const gchar *key, gdouble value);
function g_settings_set_double(settings, key, value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_double
  logical(c_bool) :: g_settings_set_double
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  real(c_double), value :: value
end function

! gchar ** g_settings_get_strv (GSettings *settings, const gchar *key);
function g_settings_get_strv(settings, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_settings_get_strv
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! gboolean g_settings_set_strv (GSettings *settings, const gchar *key, const gchar *const *value);
function g_settings_set_strv(settings, key, value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_settings_set_strv
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: value
end function

! gint g_settings_get_enum (GSettings *settings, const gchar *key);
function g_settings_get_enum(settings, key) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_get_enum
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! gboolean g_settings_set_enum (GSettings *settings, const gchar *key, gint value);
function g_settings_set_enum(settings, key, value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: g_settings_set_enum
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: value
end function

! guint g_settings_get_flags (GSettings *settings, const gchar *key);
function g_settings_get_flags(settings, key) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_get_flags
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! gboolean g_settings_set_flags (GSettings *settings, const gchar *key, guint value);
function g_settings_set_flags(settings, key, value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: g_settings_set_flags
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: value
end function

! GSettings * g_settings_get_child (GSettings *settings, const gchar *name);
function g_settings_get_child(settings, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_settings_get_child
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: name
end function

!  gboolean g_settings_is_writable (GSettings *settings, const gchar *name);
function g_settings_is_writable(settings, name) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_settings_is_writable
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: name
end function

!  void g_settings_delay (GSettings *settings);
subroutine g_settings_delay(settings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: settings
end subroutine

! void g_settings_apply (GSettings *settings);
subroutine g_settings_apply(settings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: settings
end subroutine

! void g_settings_revert (GSettings *settings);
subroutine g_settings_revert(settings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: settings
end subroutine

! gboolean g_settings_get_has_unapplied (GSettings *settings);
function g_settings_get_has_unapplied(settings) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_settings_get_has_unapplied
  type(c_ptr), value :: settings
end function

! void g_settings_sync (void);
subroutine g_settings_sync() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  void g_settings_bind (GSettings *settings, const gchar *key, gpointer object, const gchar *property, GSettingsBindFlags flags);
subroutine g_settings_bind(settings, key, object, property, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property
  integer(c_int), value :: flags
end subroutine

! void g_settings_bind_with_mapping (GSettings *settings, const gchar *key, gpointer object, const gchar *property, GSettingsBindFlags flags, GSettingsBindGetMapping get_mapping, GSettingsBindSetMapping set_mapping, gpointer user_data, GDestroyNotify destroy);
subroutine g_settings_bind_with_mapping(settings, key, object, property, flags, &
      &get_mapping, set_mapping, user_data, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property
  integer(c_int), value :: flags
  type(c_funptr), value :: get_mapping
  type(c_funptr), value :: set_mapping
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy
end subroutine

! void g_settings_bind_writable (GSettings *settings, const gchar *key, gpointer object, const gchar *property, gboolean inverted);
subroutine g_settings_bind_writable(settings, key, object, property, inverted) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_bool
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property
  logical(c_bool), value :: inverted
end subroutine

! void g_settings_unbind (gpointer object, const gchar *property);
subroutine g_settings_unbind(object, property) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property
end subroutine

!  gpointer g_settings_get_mapped (GSettings *settings, const gchar *key, GSettingsGetMapping mapping, gpointer user_data);
function g_settings_get_mapped(settings, key, mapping, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr) :: g_settings_get_mapped
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  type(c_funptr), value :: mapping
  type(c_ptr), value :: user_data
end function

!   GType g_converter_input_stream_get_type (void) G_GNUC_CONST;
function g_converter_input_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_converter_input_stream_get_type
end function

! GInputStream *g_converter_input_stream_new (GInputStream *base_stream, GConverter *converter);
function g_converter_input_stream_new(base_stream, converter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_converter_input_stream_new
  type(c_ptr), value :: base_stream
  type(c_ptr), value :: converter
end function

! GConverter *g_converter_input_stream_get_converter (GConverterInputStream *converter_stream);
function g_converter_input_stream_get_converter(converter_stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_converter_input_stream_get_converter
  type(c_ptr), value :: converter_stream
end function

!   GQuark g_io_error_quark (void);
function g_io_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_io_error_quark
end function

! GIOErrorEnum g_io_error_from_errno (gint err_no);
function g_io_error_from_errno(err_no) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_io_error_from_errno
  integer(c_int), value :: err_no
end function

!  GIOErrorEnum g_io_error_from_win32_error (gint error_code);
function g_io_error_from_win32_error(error_code) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_io_error_from_win32_error
  integer(c_int), value :: error_code
end function

!   GType g_file_enumerator_get_type (void) G_GNUC_CONST;
function g_file_enumerator_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_enumerator_get_type
end function

!  GFileInfo *g_file_enumerator_next_file (GFileEnumerator *enumerator, GCancellable *cancellable, GError **error);
function g_file_enumerator_next_file(enumerator, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_enumerator_next_file
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_enumerator_close (GFileEnumerator *enumerator, GCancellable *cancellable, GError **error);
function g_file_enumerator_close(enumerator, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_enumerator_close
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_enumerator_next_files_async (GFileEnumerator *enumerator, int num_files, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_enumerator_next_files_async(enumerator, num_files, io_priority&
      &, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: enumerator
  integer(c_int), value :: num_files
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GList * g_file_enumerator_next_files_finish (GFileEnumerator *enumerator, GAsyncResult *result, GError **error);
function g_file_enumerator_next_files_finish(enumerator, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_enumerator_next_files_finish
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_file_enumerator_close_async (GFileEnumerator *enumerator, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_enumerator_close_async(enumerator, io_priority, cancellable, c&
      &allback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: enumerator
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_enumerator_close_finish (GFileEnumerator *enumerator, GAsyncResult *result, GError **error);
function g_file_enumerator_close_finish(enumerator, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_enumerator_close_finish
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! gboolean g_file_enumerator_is_closed (GFileEnumerator *enumerator);
function g_file_enumerator_is_closed(enumerator) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_enumerator_is_closed
  type(c_ptr), value :: enumerator
end function

! gboolean g_file_enumerator_has_pending (GFileEnumerator *enumerator);
function g_file_enumerator_has_pending(enumerator) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_enumerator_has_pending
  type(c_ptr), value :: enumerator
end function

! void g_file_enumerator_set_pending (GFileEnumerator *enumerator, gboolean pending);
subroutine g_file_enumerator_set_pending(enumerator, pending) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: enumerator
  logical(c_bool), value :: pending
end subroutine

! GFile * g_file_enumerator_get_container (GFileEnumerator *enumerator);
function g_file_enumerator_get_container(enumerator) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_enumerator_get_container
  type(c_ptr), value :: enumerator
end function

!   GType g_dbus_method_invocation_get_type (void) G_GNUC_CONST;
function g_dbus_method_invocation_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_method_invocation_get_type
end function

! const gchar *g_dbus_method_invocation_get_sender (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_sender(invocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_sender
  type(c_ptr), value :: invocation
end function

! const gchar *g_dbus_method_invocation_get_object_path (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_object_path(invocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_object_path
  type(c_ptr), value :: invocation
end function

! const gchar *g_dbus_method_invocation_get_interface_name (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_interface_name(invocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_interface_name
  type(c_ptr), value :: invocation
end function

! const gchar *g_dbus_method_invocation_get_method_name (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_method_name(invocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_method_name
  type(c_ptr), value :: invocation
end function

! const GDBusMethodInfo *g_dbus_method_invocation_get_method_info (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_method_info(invocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_method_info
  type(c_ptr), value :: invocation
end function

! GDBusConnection *g_dbus_method_invocation_get_connection (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_connection(invocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_connection
  type(c_ptr), value :: invocation
end function

! GDBusMessage *g_dbus_method_invocation_get_message (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_message(invocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_message
  type(c_ptr), value :: invocation
end function

! GVariant *g_dbus_method_invocation_get_parameters (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_parameters(invocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_parameters
  type(c_ptr), value :: invocation
end function

! gpointer g_dbus_method_invocation_get_user_data (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_user_data(invocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_user_data
  type(c_ptr), value :: invocation
end function

!  void g_dbus_method_invocation_return_value (GDBusMethodInvocation *invocation, GVariant *parameters);
subroutine g_dbus_method_invocation_return_value(invocation, parameters) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: invocation
  type(c_ptr), value :: parameters
end subroutine

! void g_dbus_method_invocation_return_error_valist (GDBusMethodInvocation *invocation, GQuark domain, gint code, const gchar *format, va_list var_args);
subroutine g_dbus_method_invocation_return_error_valist(invocation, domain, code&
      &, format, var_args) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_int, c_char
  type(c_ptr), value :: invocation
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: var_args
end subroutine

! void g_dbus_method_invocation_return_error_literal (GDBusMethodInvocation *invocation, GQuark domain, gint code, const gchar *message);
subroutine g_dbus_method_invocation_return_error_literal(invocation, domain, cod&
      &e, message) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_int, c_char
  type(c_ptr), value :: invocation
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
  character(kind=c_char), dimension(*) :: message
end subroutine

! void g_dbus_method_invocation_return_gerror (GDBusMethodInvocation *invocation, const GError *error);
subroutine g_dbus_method_invocation_return_gerror(invocation, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: invocation
  type(c_ptr), value :: error
end subroutine

! void g_dbus_method_invocation_return_dbus_error (GDBusMethodInvocation *invocation, const gchar *error_name, const gchar *error_message);
subroutine g_dbus_method_invocation_return_dbus_error(invocation, error_name, er&
      &ror_message) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: invocation
  character(kind=c_char), dimension(*) :: error_name
  character(kind=c_char), dimension(*) :: error_message
end subroutine

!   GType g_resolver_get_type (void) G_GNUC_CONST;
function g_resolver_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_resolver_get_type
end function

! GResolver *g_resolver_get_default (void);
function g_resolver_get_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_resolver_get_default
end function

! void g_resolver_set_default (GResolver *resolver);
subroutine g_resolver_set_default(resolver) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: resolver
end subroutine

!  GList *g_resolver_lookup_by_name (GResolver *resolver, const gchar *hostname, GCancellable *cancellable, GError **error);
function g_resolver_lookup_by_name(resolver, hostname, cancellable, error) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_resolver_lookup_by_name
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: hostname
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_resolver_lookup_by_name_async (GResolver *resolver, const gchar *hostname, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_resolver_lookup_by_name_async(resolver, hostname, cancellable, call&
      &back, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: hostname
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GList *g_resolver_lookup_by_name_finish (GResolver *resolver, GAsyncResult *result, GError **error);
function g_resolver_lookup_by_name_finish(resolver, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_resolver_lookup_by_name_finish
  type(c_ptr), value :: resolver
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_resolver_free_addresses (GList *addresses);
subroutine g_resolver_free_addresses(addresses) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: addresses
end subroutine

!  gchar *g_resolver_lookup_by_address (GResolver *resolver, GInetAddress *address, GCancellable *cancellable, GError **error);
function g_resolver_lookup_by_address(resolver, address, cancellable, error) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_resolver_lookup_by_address
  type(c_ptr), value :: resolver
  type(c_ptr), value :: address
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_resolver_lookup_by_address_async (GResolver *resolver, GInetAddress *address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_resolver_lookup_by_address_async(resolver, address, cancellable, ca&
      &llback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: resolver
  type(c_ptr), value :: address
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gchar *g_resolver_lookup_by_address_finish (GResolver *resolver, GAsyncResult *result, GError **error);
function g_resolver_lookup_by_address_finish(resolver, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_resolver_lookup_by_address_finish
  type(c_ptr), value :: resolver
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  GList *g_resolver_lookup_service (GResolver *resolver, const gchar *service, const gchar *protocol, const gchar *domain, GCancellable *cancellable, GError **error);
function g_resolver_lookup_service(resolver, service, protocol, domain, cancella&
      &ble, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_resolver_lookup_service
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: service
  character(kind=c_char), dimension(*) :: protocol
  character(kind=c_char), dimension(*) :: domain
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_resolver_lookup_service_async (GResolver *resolver, const gchar *service, const gchar *protocol, const gchar *domain, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_resolver_lookup_service_async(resolver, service, protocol, domain, &
      &cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: service
  character(kind=c_char), dimension(*) :: protocol
  character(kind=c_char), dimension(*) :: domain
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GList *g_resolver_lookup_service_finish (GResolver *resolver, GAsyncResult *result, GError **error);
function g_resolver_lookup_service_finish(resolver, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_resolver_lookup_service_finish
  type(c_ptr), value :: resolver
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_resolver_free_targets (GList *targets);
subroutine g_resolver_free_targets(targets) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: targets
end subroutine

!  GQuark g_resolver_error_quark (void);
function g_resolver_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_resolver_error_quark
end function

!   GType g_socket_client_get_type (void) G_GNUC_CONST;
function g_socket_client_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_client_get_type
end function

!  GSocketClient *g_socket_client_new (void);
function g_socket_client_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_client_new
end function

!  GSocketFamily g_socket_client_get_family (GSocketClient *client);
function g_socket_client_get_family(client) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_client_get_family
  type(c_ptr), value :: client
end function

! void g_socket_client_set_family (GSocketClient *client, GSocketFamily family);
subroutine g_socket_client_set_family(client, family) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: client
  integer(c_int), value :: family
end subroutine

! GSocketType g_socket_client_get_socket_type (GSocketClient *client);
function g_socket_client_get_socket_type(client) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_client_get_socket_type
  type(c_ptr), value :: client
end function

! void g_socket_client_set_socket_type (GSocketClient *client, GSocketType type);
subroutine g_socket_client_set_socket_type(client, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: client
  integer(c_int), value :: type
end subroutine

! GSocketProtocol g_socket_client_get_protocol (GSocketClient *client);
function g_socket_client_get_protocol(client) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_client_get_protocol
  type(c_ptr), value :: client
end function

! void g_socket_client_set_protocol (GSocketClient *client, GSocketProtocol protocol);
subroutine g_socket_client_set_protocol(client, protocol) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: client
  integer(c_int), value :: protocol
end subroutine

! GSocketAddress *g_socket_client_get_local_address (GSocketClient *client);
function g_socket_client_get_local_address(client) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_client_get_local_address
  type(c_ptr), value :: client
end function

! void g_socket_client_set_local_address (GSocketClient *client, GSocketAddress *address);
subroutine g_socket_client_set_local_address(client, address) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: client
  type(c_ptr), value :: address
end subroutine

! guint g_socket_client_get_timeout (GSocketClient *client);
function g_socket_client_get_timeout(client) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_client_get_timeout
  type(c_ptr), value :: client
end function

! void g_socket_client_set_timeout (GSocketClient *client, guint timeout);
subroutine g_socket_client_set_timeout(client, timeout) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: client
  integer(c_int), value :: timeout
end subroutine

! gboolean g_socket_client_get_enable_proxy (GSocketClient *client);
function g_socket_client_get_enable_proxy(client) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_socket_client_get_enable_proxy
  type(c_ptr), value :: client
end function

! void g_socket_client_set_enable_proxy (GSocketClient *client, gboolean enable);
subroutine g_socket_client_set_enable_proxy(client, enable) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: client
  logical(c_bool), value :: enable
end subroutine

!  GSocketConnection * g_socket_client_connect (GSocketClient *client, GSocketConnectable *connectable, GCancellable *cancellable, GError **error);
function g_socket_client_connect(client, connectable, cancellable, error) bind(c&
      &) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_client_connect
  type(c_ptr), value :: client
  type(c_ptr), value :: connectable
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GSocketConnection * g_socket_client_connect_to_host (GSocketClient *client, const gchar *host_and_port, guint16 default_port, GCancellable *cancellable, GError **error);
function g_socket_client_connect_to_host(client, host_and_port, default_port, ca&
      &ncellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int16_t
  type(c_ptr) :: g_socket_client_connect_to_host
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: host_and_port
  integer(c_int16_t), value :: default_port
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GSocketConnection * g_socket_client_connect_to_service (GSocketClient *client, const gchar *domain, const gchar *service, GCancellable *cancellable, GError **error);
function g_socket_client_connect_to_service(client, domain, service, cancellable&
      &, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_socket_client_connect_to_service
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: service
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GSocketConnection * g_socket_client_connect_to_uri (GSocketClient *client, const gchar *uri, guint16 default_port, GCancellable *cancellable, GError **error);
function g_socket_client_connect_to_uri(client, uri, default_port, cancellable, &
      &error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int16_t
  type(c_ptr) :: g_socket_client_connect_to_uri
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: uri
  integer(c_int16_t), value :: default_port
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_socket_client_connect_async (GSocketClient *client, GSocketConnectable *connectable, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_client_connect_async(client, connectable, cancellable, callb&
      &ack, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: client
  type(c_ptr), value :: connectable
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GSocketConnection * g_socket_client_connect_finish (GSocketClient *client, GAsyncResult *result, GError **error);
function g_socket_client_connect_finish(client, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_client_connect_finish
  type(c_ptr), value :: client
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_socket_client_connect_to_host_async (GSocketClient *client, const gchar *host_and_port, guint16 default_port, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_client_connect_to_host_async(client, host_and_port, default_&
      &port, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int16_t, c_funptr
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: host_and_port
  integer(c_int16_t), value :: default_port
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GSocketConnection * g_socket_client_connect_to_host_finish (GSocketClient *client, GAsyncResult *result, GError **error);
function g_socket_client_connect_to_host_finish(client, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_client_connect_to_host_finish
  type(c_ptr), value :: client
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_socket_client_connect_to_service_async (GSocketClient *client, const gchar *domain, const gchar *service, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_client_connect_to_service_async(client, domain, service, can&
      &cellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: service
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GSocketConnection * g_socket_client_connect_to_service_finish (GSocketClient *client, GAsyncResult *result, GError **error);
function g_socket_client_connect_to_service_finish(client, result, error) bind(c&
      &) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_client_connect_to_service_finish
  type(c_ptr), value :: client
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_socket_client_connect_to_uri_async (GSocketClient *client, const gchar *uri, guint16 default_port, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_client_connect_to_uri_async(client, uri, default_port, cance&
      &llable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int16_t, c_funptr
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: uri
  integer(c_int16_t), value :: default_port
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GSocketConnection * g_socket_client_connect_to_uri_finish (GSocketClient *client, GAsyncResult *result, GError **error);
function g_socket_client_connect_to_uri_finish(client, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_client_connect_to_uri_finish
  type(c_ptr), value :: client
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_socket_client_add_application_proxy (GSocketClient *client, const gchar *protocol);
subroutine g_socket_client_add_application_proxy(client, protocol) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: protocol
end subroutine

!   GType g_loadable_icon_get_type (void) G_GNUC_CONST;
function g_loadable_icon_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_loadable_icon_get_type
end function

!  GInputStream *g_loadable_icon_load (GLoadableIcon *icon, int size, char **type, GCancellable *cancellable, GError **error);
function g_loadable_icon_load(icon, size, type, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr) :: g_loadable_icon_load
  type(c_ptr), value :: icon
  integer(c_int), value :: size
  character(kind=c_char), dimension(*) :: type
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_loadable_icon_load_async (GLoadableIcon *icon, int size, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_loadable_icon_load_async(icon, size, cancellable, callback, user_da&
      &ta) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: icon
  integer(c_int), value :: size
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GInputStream *g_loadable_icon_load_finish (GLoadableIcon *icon, GAsyncResult *res, char **type, GError **error);
function g_loadable_icon_load_finish(icon, res, type, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_loadable_icon_load_finish
  type(c_ptr), value :: icon
  type(c_ptr), value :: res
  character(kind=c_char), dimension(*) :: type
  type(c_ptr), value :: error
end function

!   GType g_icon_get_type (void) G_GNUC_CONST;
function g_icon_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_icon_get_type
end function

!  guint g_icon_hash (gconstpointer icon);
function g_icon_hash(icon) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_icon_hash
  type(c_ptr), value :: icon
end function

! gboolean g_icon_equal (GIcon *icon1, GIcon *icon2);
function g_icon_equal(icon1, icon2) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_icon_equal
  type(c_ptr), value :: icon1
  type(c_ptr), value :: icon2
end function

! gchar *g_icon_to_string (GIcon *icon);
function g_icon_to_string(icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_icon_to_string
  type(c_ptr), value :: icon
end function

! GIcon *g_icon_new_for_string (const gchar *str, GError **error);
function g_icon_new_for_string(str, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_icon_new_for_string
  character(kind=c_char), dimension(*) :: str
  type(c_ptr), value :: error
end function

!   GType g_drive_get_type (void) G_GNUC_CONST;
function g_drive_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_drive_get_type
end function

!  char * g_drive_get_name (GDrive *drive);
function g_drive_get_name(drive) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_drive_get_name
  type(c_ptr), value :: drive
end function

! GIcon * g_drive_get_icon (GDrive *drive);
function g_drive_get_icon(drive) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_drive_get_icon
  type(c_ptr), value :: drive
end function

! gboolean g_drive_has_volumes (GDrive *drive);
function g_drive_has_volumes(drive) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_drive_has_volumes
  type(c_ptr), value :: drive
end function

! GList * g_drive_get_volumes (GDrive *drive);
function g_drive_get_volumes(drive) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_drive_get_volumes
  type(c_ptr), value :: drive
end function

! gboolean g_drive_is_media_removable (GDrive *drive);
function g_drive_is_media_removable(drive) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_drive_is_media_removable
  type(c_ptr), value :: drive
end function

! gboolean g_drive_has_media (GDrive *drive);
function g_drive_has_media(drive) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_drive_has_media
  type(c_ptr), value :: drive
end function

! gboolean g_drive_is_media_check_automatic (GDrive *drive);
function g_drive_is_media_check_automatic(drive) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_drive_is_media_check_automatic
  type(c_ptr), value :: drive
end function

! gboolean g_drive_can_poll_for_media (GDrive *drive);
function g_drive_can_poll_for_media(drive) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_drive_can_poll_for_media
  type(c_ptr), value :: drive
end function

! gboolean g_drive_can_eject (GDrive *drive);
function g_drive_can_eject(drive) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_drive_can_eject
  type(c_ptr), value :: drive
end function

!  void g_drive_eject (GDrive *drive, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_drive_eject(drive, flags, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: drive
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_drive_eject_finish (GDrive *drive, GAsyncResult *result, GError **error);
function g_drive_eject_finish(drive, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_drive_eject_finish
  type(c_ptr), value :: drive
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_drive_poll_for_media (GDrive *drive, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_drive_poll_for_media(drive, cancellable, callback, user_data) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: drive
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_drive_poll_for_media_finish (GDrive *drive, GAsyncResult *result, GError **error);
function g_drive_poll_for_media_finish(drive, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_drive_poll_for_media_finish
  type(c_ptr), value :: drive
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! char * g_drive_get_identifier (GDrive *drive, const char *kind);
function g_drive_get_identifier(drive, kind) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_drive_get_identifier
  type(c_ptr), value :: drive
  character(kind=c_char), dimension(*) :: kind
end function

! char ** g_drive_enumerate_identifiers (GDrive *drive);
function g_drive_enumerate_identifiers(drive) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_drive_enumerate_identifiers
  type(c_ptr), value :: drive
end function

!  GDriveStartStopType g_drive_get_start_stop_type (GDrive *drive);
function g_drive_get_start_stop_type(drive) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_drive_get_start_stop_type
  type(c_ptr), value :: drive
end function

!  gboolean g_drive_can_start (GDrive *drive);
function g_drive_can_start(drive) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_drive_can_start
  type(c_ptr), value :: drive
end function

! gboolean g_drive_can_start_degraded (GDrive *drive);
function g_drive_can_start_degraded(drive) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_drive_can_start_degraded
  type(c_ptr), value :: drive
end function

! void g_drive_start (GDrive *drive, GDriveStartFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_drive_start(drive, flags, mount_operation, cancellable, callback, u&
      &ser_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: drive
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_drive_start_finish (GDrive *drive, GAsyncResult *result, GError **error);
function g_drive_start_finish(drive, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_drive_start_finish
  type(c_ptr), value :: drive
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  gboolean g_drive_can_stop (GDrive *drive);
function g_drive_can_stop(drive) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_drive_can_stop
  type(c_ptr), value :: drive
end function

! void g_drive_stop (GDrive *drive, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_drive_stop(drive, flags, mount_operation, cancellable, callback, us&
      &er_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: drive
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_drive_stop_finish (GDrive *drive, GAsyncResult *result, GError **error);
function g_drive_stop_finish(drive, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_drive_stop_finish
  type(c_ptr), value :: drive
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_drive_eject_with_operation (GDrive *drive, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_drive_eject_with_operation(drive, flags, mount_operation, cancellab&
      &le, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: drive
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_drive_eject_with_operation_finish (GDrive *drive, GAsyncResult *result, GError **error);
function g_drive_eject_with_operation_finish(drive, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_drive_eject_with_operation_finish
  type(c_ptr), value :: drive
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!   GType g_file_monitor_get_type (void) G_GNUC_CONST;
function g_file_monitor_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_monitor_get_type
end function

!  gboolean g_file_monitor_cancel (GFileMonitor *monitor);
function g_file_monitor_cancel(monitor) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_monitor_cancel
  type(c_ptr), value :: monitor
end function

! gboolean g_file_monitor_is_cancelled (GFileMonitor *monitor);
function g_file_monitor_is_cancelled(monitor) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_file_monitor_is_cancelled
  type(c_ptr), value :: monitor
end function

! void g_file_monitor_set_rate_limit (GFileMonitor *monitor, int limit_msecs);
subroutine g_file_monitor_set_rate_limit(monitor, limit_msecs) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: monitor
  integer(c_int), value :: limit_msecs
end subroutine

!  void g_file_monitor_emit_event (GFileMonitor *monitor, GFile *child, GFile *other_file, GFileMonitorEvent event_type);
subroutine g_file_monitor_emit_event(monitor, child, other_file, event_type) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: monitor
  type(c_ptr), value :: child
  type(c_ptr), value :: other_file
  integer(c_int), value :: event_type
end subroutine

!   GType g_initable_get_type (void) G_GNUC_CONST;
function g_initable_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_initable_get_type
end function

!  gboolean g_initable_init (GInitable *initable, GCancellable *cancellable, GError **error);
function g_initable_init(initable, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_initable_init
  type(c_ptr), value :: initable
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gpointer g_initable_newv (GType object_type, guint n_parameters, GParameter *parameters, GCancellable *cancellable, GError **error);
function g_initable_newv(object_type, n_parameters, parameters, cancellable, err&
      &or) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int
  type(c_ptr) :: g_initable_newv
  integer(c_size_t), value :: object_type
  integer(c_int), value :: n_parameters
  type(c_ptr), value :: parameters
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GObject* g_initable_new_valist (GType object_type, const gchar *first_property_name, va_list var_args, GCancellable *cancellable, GError **error);
function g_initable_new_valist(object_type, first_property_name, var_args, cance&
      &llable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_initable_new_valist
  integer(c_size_t), value :: object_type
  character(kind=c_char), dimension(*) :: first_property_name
  type(c_ptr), value :: var_args
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!   GType g_file_input_stream_get_type (void) G_GNUC_CONST;
function g_file_input_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_input_stream_get_type
end function

!  GFileInfo *g_file_input_stream_query_info (GFileInputStream *stream, const char *attributes, GCancellable *cancellable, GError **error);
function g_file_input_stream_query_info(stream, attributes, cancellable, error) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_input_stream_query_info
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: attributes
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_input_stream_query_info_async (GFileInputStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_input_stream_query_info_async(stream, attributes, io_priority,&
      & cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileInfo *g_file_input_stream_query_info_finish (GFileInputStream *stream, GAsyncResult *result, GError **error);
function g_file_input_stream_query_info_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_input_stream_query_info_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!   const gchar *g_dbus_annotation_info_lookup (GDBusAnnotationInfo **annotations, const gchar *name);
function g_dbus_annotation_info_lookup(annotations, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_annotation_info_lookup
  type(c_ptr), value :: annotations
  character(kind=c_char), dimension(*) :: name
end function

! GDBusMethodInfo *g_dbus_interface_info_lookup_method (GDBusInterfaceInfo *info, const gchar *name);
function g_dbus_interface_info_lookup_method(info, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_interface_info_lookup_method
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
end function

! GDBusSignalInfo *g_dbus_interface_info_lookup_signal (GDBusInterfaceInfo *info, const gchar *name);
function g_dbus_interface_info_lookup_signal(info, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_interface_info_lookup_signal
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
end function

! GDBusPropertyInfo *g_dbus_interface_info_lookup_property (GDBusInterfaceInfo *info, const gchar *name);
function g_dbus_interface_info_lookup_property(info, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_interface_info_lookup_property
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
end function

! void g_dbus_interface_info_generate_xml (GDBusInterfaceInfo *info, guint indent, GString *string_builder);
subroutine g_dbus_interface_info_generate_xml(info, indent, string_builder) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: info
  integer(c_int), value :: indent
  type(c_ptr), value :: string_builder
end subroutine

!  GDBusNodeInfo *g_dbus_node_info_new_for_xml (const gchar *xml_data, GError **error);
function g_dbus_node_info_new_for_xml(xml_data, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_node_info_new_for_xml
  character(kind=c_char), dimension(*) :: xml_data
  type(c_ptr), value :: error
end function

! GDBusInterfaceInfo *g_dbus_node_info_lookup_interface (GDBusNodeInfo *info, const gchar *name);
function g_dbus_node_info_lookup_interface(info, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_node_info_lookup_interface
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
end function

! void g_dbus_node_info_generate_xml (GDBusNodeInfo *info, guint indent, GString *string_builder);
subroutine g_dbus_node_info_generate_xml(info, indent, string_builder) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: info
  integer(c_int), value :: indent
  type(c_ptr), value :: string_builder
end subroutine

!  GDBusNodeInfo *g_dbus_node_info_ref (GDBusNodeInfo *info);
function g_dbus_node_info_ref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_node_info_ref
  type(c_ptr), value :: info
end function

! GDBusInterfaceInfo *g_dbus_interface_info_ref (GDBusInterfaceInfo *info);
function g_dbus_interface_info_ref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_interface_info_ref
  type(c_ptr), value :: info
end function

! GDBusMethodInfo *g_dbus_method_info_ref (GDBusMethodInfo *info);
function g_dbus_method_info_ref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_info_ref
  type(c_ptr), value :: info
end function

! GDBusSignalInfo *g_dbus_signal_info_ref (GDBusSignalInfo *info);
function g_dbus_signal_info_ref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_signal_info_ref
  type(c_ptr), value :: info
end function

! GDBusPropertyInfo *g_dbus_property_info_ref (GDBusPropertyInfo *info);
function g_dbus_property_info_ref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_property_info_ref
  type(c_ptr), value :: info
end function

! GDBusArgInfo *g_dbus_arg_info_ref (GDBusArgInfo *info);
function g_dbus_arg_info_ref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_arg_info_ref
  type(c_ptr), value :: info
end function

! GDBusAnnotationInfo *g_dbus_annotation_info_ref (GDBusAnnotationInfo *info);
function g_dbus_annotation_info_ref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_annotation_info_ref
  type(c_ptr), value :: info
end function

!  void g_dbus_node_info_unref (GDBusNodeInfo *info);
subroutine g_dbus_node_info_unref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
end subroutine

! void g_dbus_interface_info_unref (GDBusInterfaceInfo *info);
subroutine g_dbus_interface_info_unref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
end subroutine

! void g_dbus_method_info_unref (GDBusMethodInfo *info);
subroutine g_dbus_method_info_unref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
end subroutine

! void g_dbus_signal_info_unref (GDBusSignalInfo *info);
subroutine g_dbus_signal_info_unref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
end subroutine

! void g_dbus_property_info_unref (GDBusPropertyInfo *info);
subroutine g_dbus_property_info_unref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
end subroutine

! void g_dbus_arg_info_unref (GDBusArgInfo *info);
subroutine g_dbus_arg_info_unref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
end subroutine

! void g_dbus_annotation_info_unref (GDBusAnnotationInfo *info);
subroutine g_dbus_annotation_info_unref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
end subroutine

!  GType g_dbus_node_info_get_type (void) G_GNUC_CONST;
function g_dbus_node_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_node_info_get_type
end function

! GType g_dbus_interface_info_get_type (void) G_GNUC_CONST;
function g_dbus_interface_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_interface_info_get_type
end function

! GType g_dbus_method_info_get_type (void) G_GNUC_CONST;
function g_dbus_method_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_method_info_get_type
end function

! GType g_dbus_signal_info_get_type (void) G_GNUC_CONST;
function g_dbus_signal_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_signal_info_get_type
end function

! GType g_dbus_property_info_get_type (void) G_GNUC_CONST;
function g_dbus_property_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_property_info_get_type
end function

! GType g_dbus_arg_info_get_type (void) G_GNUC_CONST;
function g_dbus_arg_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_arg_info_get_type
end function

! GType g_dbus_annotation_info_get_type (void) G_GNUC_CONST;
function g_dbus_annotation_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_annotation_info_get_type
end function

!   GType g_data_input_stream_get_type (void) G_GNUC_CONST;
function g_data_input_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_data_input_stream_get_type
end function

! GDataInputStream * g_data_input_stream_new (GInputStream *base_stream);
function g_data_input_stream_new(base_stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_data_input_stream_new
  type(c_ptr), value :: base_stream
end function

!  void g_data_input_stream_set_byte_order (GDataInputStream *stream, GDataStreamByteOrder order);
subroutine g_data_input_stream_set_byte_order(stream, order) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: stream
  integer(c_int), value :: order
end subroutine

! GDataStreamByteOrder g_data_input_stream_get_byte_order (GDataInputStream *stream);
function g_data_input_stream_get_byte_order(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_data_input_stream_get_byte_order
  type(c_ptr), value :: stream
end function

! void g_data_input_stream_set_newline_type (GDataInputStream *stream, GDataStreamNewlineType type);
subroutine g_data_input_stream_set_newline_type(stream, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: stream
  integer(c_int), value :: type
end subroutine

! GDataStreamNewlineType g_data_input_stream_get_newline_type (GDataInputStream *stream);
function g_data_input_stream_get_newline_type(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_data_input_stream_get_newline_type
  type(c_ptr), value :: stream
end function

! guchar g_data_input_stream_read_byte (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_byte(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_char, c_ptr
  character(c_char) :: g_data_input_stream_read_byte
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gint16 g_data_input_stream_read_int16 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_int16(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_data_input_stream_read_int16
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! guint16 g_data_input_stream_read_uint16 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_uint16(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_data_input_stream_read_uint16
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gint32 g_data_input_stream_read_int32 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_int32(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_data_input_stream_read_int32
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! guint32 g_data_input_stream_read_uint32 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_uint32(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_data_input_stream_read_uint32
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gint64 g_data_input_stream_read_int64 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_int64(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_data_input_stream_read_int64
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! guint64 g_data_input_stream_read_uint64 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_uint64(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_data_input_stream_read_uint64
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! char * g_data_input_stream_read_line (GDataInputStream *stream, gsize *length, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_line(stream, length, cancellable, error) bind(&
      &c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_data_input_stream_read_line
  type(c_ptr), value :: stream
  type(c_ptr), value :: length
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_data_input_stream_read_line_async (GDataInputStream *stream, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_data_input_stream_read_line_async(stream, io_priority, cancellable,&
      & callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! char * g_data_input_stream_read_line_finish (GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
function g_data_input_stream_read_line_finish(stream, result, length, error) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_data_input_stream_read_line_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! char * g_data_input_stream_read_until (GDataInputStream *stream, const gchar *stop_chars, gsize *length, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_until(stream, stop_chars, length, cancellable,&
      & error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_data_input_stream_read_until
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: stop_chars
  type(c_ptr), value :: length
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_data_input_stream_read_until_async (GDataInputStream *stream, const gchar *stop_chars, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_data_input_stream_read_until_async(stream, stop_chars, io_priority,&
      & cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: stop_chars
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! char * g_data_input_stream_read_until_finish (GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
function g_data_input_stream_read_until_finish(stream, result, length, error) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_data_input_stream_read_until_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

!  char * g_data_input_stream_read_upto (GDataInputStream *stream, const gchar *stop_chars, gssize stop_chars_len, gsize *length, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_upto(stream, stop_chars, stop_chars_len, lengt&
      &h, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_data_input_stream_read_upto
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: stop_chars
  integer(c_size_t), value :: stop_chars_len
  type(c_ptr), value :: length
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_data_input_stream_read_upto_async (GDataInputStream *stream, const gchar *stop_chars, gssize stop_chars_len, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_data_input_stream_read_upto_async(stream, stop_chars, stop_chars_le&
      &n, io_priority, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: stop_chars
  integer(c_size_t), value :: stop_chars_len
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! char * g_data_input_stream_read_upto_finish (GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
function g_data_input_stream_read_upto_finish(stream, result, length, error) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_data_input_stream_read_upto_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

!   GType g_proxy_get_type (void) G_GNUC_CONST;
function g_proxy_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_proxy_get_type
end function

!  GProxy *g_proxy_get_default_for_protocol (const gchar *protocol);
function g_proxy_get_default_for_protocol(protocol) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_proxy_get_default_for_protocol
  character(kind=c_char), dimension(*) :: protocol
end function

!  GIOStream *g_proxy_connect (GProxy *proxy, GIOStream *connection, GProxyAddress *proxy_address, GCancellable *cancellable, GError **error);
function g_proxy_connect(proxy, connection, proxy_address, cancellable, error) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_proxy_connect
  type(c_ptr), value :: proxy
  type(c_ptr), value :: connection
  type(c_ptr), value :: proxy_address
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_proxy_connect_async (GProxy *proxy, GIOStream *connection, GProxyAddress *proxy_address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_proxy_connect_async(proxy, connection, proxy_address, cancellable, &
      &callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: proxy
  type(c_ptr), value :: connection
  type(c_ptr), value :: proxy_address
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

!  GIOStream *g_proxy_connect_finish (GProxy *proxy, GAsyncResult *result, GError **error);
function g_proxy_connect_finish(proxy, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_proxy_connect_finish
  type(c_ptr), value :: proxy
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  gboolean g_proxy_supports_hostname (GProxy *proxy);
function g_proxy_supports_hostname(proxy) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_proxy_supports_hostname
  type(c_ptr), value :: proxy
end function

!   GType g_memory_output_stream_get_type (void) G_GNUC_CONST;
function g_memory_output_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_memory_output_stream_get_type
end function

!  GOutputStream *g_memory_output_stream_new (gpointer data, gsize size, GReallocFunc realloc_function, GDestroyNotify destroy_function);
function g_memory_output_stream_new(data, size, realloc_function, destroy_functi&
      &on) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_funptr
  type(c_ptr) :: g_memory_output_stream_new
  type(c_ptr), value :: data
  integer(c_size_t), value :: size
  type(c_funptr), value :: realloc_function
  type(c_funptr), value :: destroy_function
end function

! gpointer g_memory_output_stream_get_data (GMemoryOutputStream *ostream);
function g_memory_output_stream_get_data(ostream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_memory_output_stream_get_data
  type(c_ptr), value :: ostream
end function

! gsize g_memory_output_stream_get_size (GMemoryOutputStream *ostream);
function g_memory_output_stream_get_size(ostream) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_memory_output_stream_get_size
  type(c_ptr), value :: ostream
end function

! gsize g_memory_output_stream_get_data_size (GMemoryOutputStream *ostream);
function g_memory_output_stream_get_data_size(ostream) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_memory_output_stream_get_data_size
  type(c_ptr), value :: ostream
end function

! gpointer g_memory_output_stream_steal_data (GMemoryOutputStream *ostream);
function g_memory_output_stream_steal_data(ostream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_memory_output_stream_steal_data
  type(c_ptr), value :: ostream
end function

!   GType g_dbus_connection_get_type (void) G_GNUC_CONST;
function g_dbus_connection_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_connection_get_type
end function

!  void g_bus_get (GBusType bus_type, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_bus_get(bus_type, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int), value :: bus_type
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GDBusConnection *g_bus_get_finish (GAsyncResult *res, GError **error);
function g_bus_get_finish(res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_bus_get_finish
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GDBusConnection *g_bus_get_sync (GBusType bus_type, GCancellable *cancellable, GError **error);
function g_bus_get_sync(bus_type, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_bus_get_sync
  integer(c_int), value :: bus_type
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_dbus_connection_new (GIOStream *stream, const gchar *guid, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_connection_new(stream, guid, flags, observer, cancellable, cal&
      &lback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: guid
  integer(c_int), value :: flags
  type(c_ptr), value :: observer
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GDBusConnection *g_dbus_connection_new_finish (GAsyncResult *res, GError **error);
function g_dbus_connection_new_finish(res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_connection_new_finish
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GDBusConnection *g_dbus_connection_new_sync (GIOStream *stream, const gchar *guid, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error);
function g_dbus_connection_new_sync(stream, guid, flags, observer, cancellable, &
      &error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_dbus_connection_new_sync
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: guid
  integer(c_int), value :: flags
  type(c_ptr), value :: observer
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_dbus_connection_new_for_address (const gchar *address, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_connection_new_for_address(address, flags, observer, cancellab&
      &le, callback, user_data) bind(c) 
  use iso_c_binding, only: c_char, c_int, c_ptr, c_funptr
  character(kind=c_char), dimension(*) :: address
  integer(c_int), value :: flags
  type(c_ptr), value :: observer
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GDBusConnection *g_dbus_connection_new_for_address_finish (GAsyncResult *res, GError **error);
function g_dbus_connection_new_for_address_finish(res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_connection_new_for_address_finish
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GDBusConnection *g_dbus_connection_new_for_address_sync (const gchar *address, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error);
function g_dbus_connection_new_for_address_sync(address, flags, observer, cancel&
      &lable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_dbus_connection_new_for_address_sync
  character(kind=c_char), dimension(*) :: address
  integer(c_int), value :: flags
  type(c_ptr), value :: observer
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_dbus_connection_start_message_processing (GDBusConnection *connection);
subroutine g_dbus_connection_start_message_processing(connection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: connection
end subroutine

! gboolean g_dbus_connection_is_closed (GDBusConnection *connection);
function g_dbus_connection_is_closed(connection) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_dbus_connection_is_closed
  type(c_ptr), value :: connection
end function

! GIOStream *g_dbus_connection_get_stream (GDBusConnection *connection);
function g_dbus_connection_get_stream(connection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_connection_get_stream
  type(c_ptr), value :: connection
end function

! const gchar *g_dbus_connection_get_guid (GDBusConnection *connection);
function g_dbus_connection_get_guid(connection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_connection_get_guid
  type(c_ptr), value :: connection
end function

! const gchar *g_dbus_connection_get_unique_name (GDBusConnection *connection);
function g_dbus_connection_get_unique_name(connection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_connection_get_unique_name
  type(c_ptr), value :: connection
end function

! GCredentials *g_dbus_connection_get_peer_credentials (GDBusConnection *connection);
function g_dbus_connection_get_peer_credentials(connection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_connection_get_peer_credentials
  type(c_ptr), value :: connection
end function

! gboolean g_dbus_connection_get_exit_on_close (GDBusConnection *connection);
function g_dbus_connection_get_exit_on_close(connection) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_dbus_connection_get_exit_on_close
  type(c_ptr), value :: connection
end function

! void g_dbus_connection_set_exit_on_close (GDBusConnection *connection, gboolean exit_on_close);
subroutine g_dbus_connection_set_exit_on_close(connection, exit_on_close) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: connection
  logical(c_bool), value :: exit_on_close
end subroutine

! GDBusCapabilityFlags g_dbus_connection_get_capabilities (GDBusConnection *connection);
function g_dbus_connection_get_capabilities(connection) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_get_capabilities
  type(c_ptr), value :: connection
end function

!  void g_dbus_connection_close (GDBusConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_connection_close(connection, cancellable, callback, user_data)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: connection
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_dbus_connection_close_finish (GDBusConnection *connection, GAsyncResult *res, GError **error);
function g_dbus_connection_close_finish(connection, res, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_dbus_connection_close_finish
  type(c_ptr), value :: connection
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! gboolean g_dbus_connection_close_sync (GDBusConnection *connection, GCancellable *cancellable, GError **error);
function g_dbus_connection_close_sync(connection, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_dbus_connection_close_sync
  type(c_ptr), value :: connection
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_dbus_connection_flush (GDBusConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_connection_flush(connection, cancellable, callback, user_data)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: connection
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_dbus_connection_flush_finish (GDBusConnection *connection, GAsyncResult *res, GError **error);
function g_dbus_connection_flush_finish(connection, res, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_dbus_connection_flush_finish
  type(c_ptr), value :: connection
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! gboolean g_dbus_connection_flush_sync (GDBusConnection *connection, GCancellable *cancellable, GError **error);
function g_dbus_connection_flush_sync(connection, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_dbus_connection_flush_sync
  type(c_ptr), value :: connection
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  gboolean g_dbus_connection_send_message (GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, volatile guint32 *out_serial, GError **error);
function g_dbus_connection_send_message(connection, message, flags, out_serial, &
      &error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: g_dbus_connection_send_message
  type(c_ptr), value :: connection
  type(c_ptr), value :: message
  integer(c_int), value :: flags
  type(c_ptr), value :: out_serial
  type(c_ptr), value :: error
end function

! void g_dbus_connection_send_message_with_reply (GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, gint timeout_msec, volatile guint32 *out_serial, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_connection_send_message_with_reply(connection, message, flags,&
      & timeout_msec, out_serial, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: connection
  type(c_ptr), value :: message
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: out_serial
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GDBusMessage *g_dbus_connection_send_message_with_reply_finish (GDBusConnection *connection, GAsyncResult *res, GError **error);
function g_dbus_connection_send_message_with_reply_finish(connection, res, error&
      &) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_connection_send_message_with_reply_finish
  type(c_ptr), value :: connection
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GDBusMessage *g_dbus_connection_send_message_with_reply_sync (GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, gint timeout_msec, volatile guint32 *out_serial, GCancellable *cancellable, GError **error);
function g_dbus_connection_send_message_with_reply_sync(connection, message, fla&
      &gs, timeout_msec, out_serial, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_dbus_connection_send_message_with_reply_sync
  type(c_ptr), value :: connection
  type(c_ptr), value :: message
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: out_serial
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  gboolean g_dbus_connection_emit_signal (GDBusConnection *connection, const gchar *destination_bus_name, const gchar *object_path, const gchar *interface_name, const gchar *signal_name, GVariant *parameters, GError **error);
function g_dbus_connection_emit_signal(connection, destination_bus_name, object_&
      &path, interface_name, signal_name, parameters, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_dbus_connection_emit_signal
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: destination_bus_name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  character(kind=c_char), dimension(*) :: signal_name
  type(c_ptr), value :: parameters
  type(c_ptr), value :: error
end function

! void g_dbus_connection_call (GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_connection_call(connection, bus_name, object_path, interface_n&
      &ame, method_name, parameters, reply_type, flags, timeout_msec, cancellabl&
      &e, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: bus_name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  character(kind=c_char), dimension(*) :: method_name
  type(c_ptr), value :: parameters
  type(c_ptr), value :: reply_type
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GVariant *g_dbus_connection_call_finish (GDBusConnection *connection, GAsyncResult *res, GError **error);
function g_dbus_connection_call_finish(connection, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_connection_call_finish
  type(c_ptr), value :: connection
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GVariant *g_dbus_connection_call_sync (GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GError **error);
function g_dbus_connection_call_sync(connection, bus_name, object_path, interfac&
      &e_name, method_name, parameters, reply_type, flags, timeout_msec, cancell&
      &able, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_dbus_connection_call_sync
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: bus_name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  character(kind=c_char), dimension(*) :: method_name
  type(c_ptr), value :: parameters
  type(c_ptr), value :: reply_type
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  guint g_dbus_connection_register_object (GDBusConnection *connection, const gchar *object_path, GDBusInterfaceInfo *interface_info, const GDBusInterfaceVTable *vtable, gpointer user_data, GDestroyNotify user_data_free_func, GError **error);
function g_dbus_connection_register_object(connection, object_path, interface_in&
      &fo, vtable, user_data, user_data_free_func, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_funptr
  integer(c_int) :: g_dbus_connection_register_object
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: object_path
  type(c_ptr), value :: interface_info
  type(c_ptr), value :: vtable
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
  type(c_ptr), value :: error
end function

! gboolean g_dbus_connection_unregister_object (GDBusConnection *connection, guint registration_id);
function g_dbus_connection_unregister_object(connection, registration_id) bind(c&
      &) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: g_dbus_connection_unregister_object
  type(c_ptr), value :: connection
  integer(c_int), value :: registration_id
end function

!  guint g_dbus_connection_register_subtree (GDBusConnection *connection, const gchar *object_path, const GDBusSubtreeVTable *vtable, GDBusSubtreeFlags flags, gpointer user_data, GDestroyNotify user_data_free_func, GError **error);
function g_dbus_connection_register_subtree(connection, object_path, vtable, fla&
      &gs, user_data, user_data_free_func, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_funptr
  integer(c_int) :: g_dbus_connection_register_subtree
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: object_path
  type(c_ptr), value :: vtable
  integer(c_int), value :: flags
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
  type(c_ptr), value :: error
end function

! gboolean g_dbus_connection_unregister_subtree (GDBusConnection *connection, guint registration_id);
function g_dbus_connection_unregister_subtree(connection, registration_id) bind(&
      &c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: g_dbus_connection_unregister_subtree
  type(c_ptr), value :: connection
  integer(c_int), value :: registration_id
end function

!  guint g_dbus_connection_signal_subscribe (GDBusConnection *connection, const gchar *sender, const gchar *interface_name, const gchar *member, const gchar *object_path, const gchar *arg0, GDBusSignalFlags flags, GDBusSignalCallback callback, gpointer user_data, GDestroyNotify user_data_free_func);
function g_dbus_connection_signal_subscribe(connection, sender, interface_name, &
      &member, object_path, arg0, flags, callback, user_data, user_data_free_fun&
      &c) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_funptr
  integer(c_int) :: g_dbus_connection_signal_subscribe
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: sender
  character(kind=c_char), dimension(*) :: interface_name
  character(kind=c_char), dimension(*) :: member
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: arg0
  integer(c_int), value :: flags
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
end function

! void g_dbus_connection_signal_unsubscribe (GDBusConnection *connection, guint subscription_id);
subroutine g_dbus_connection_signal_unsubscribe(connection, subscription_id) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: connection
  integer(c_int), value :: subscription_id
end subroutine

!  guint g_dbus_connection_add_filter (GDBusConnection *connection, GDBusMessageFilterFunction filter_function, gpointer user_data, GDestroyNotify user_data_free_func);
function g_dbus_connection_add_filter(connection, filter_function, user_data, us&
      &er_data_free_func) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int) :: g_dbus_connection_add_filter
  type(c_ptr), value :: connection
  type(c_funptr), value :: filter_function
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
end function

!  void g_dbus_connection_remove_filter (GDBusConnection *connection, guint filter_id);
subroutine g_dbus_connection_remove_filter(connection, filter_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: connection
  integer(c_int), value :: filter_id
end subroutine

!   GType g_proxy_address_enumerator_get_type (void) G_GNUC_CONST;
function g_proxy_address_enumerator_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_proxy_address_enumerator_get_type
end function

!   GType g_network_service_get_type (void) G_GNUC_CONST;
function g_network_service_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_network_service_get_type
end function

!  GSocketConnectable *g_network_service_new (const gchar *service, const gchar *protocol, const gchar *domain);
function g_network_service_new(service, protocol, domain) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_network_service_new
  character(kind=c_char), dimension(*) :: service
  character(kind=c_char), dimension(*) :: protocol
  character(kind=c_char), dimension(*) :: domain
end function

!  const gchar *g_network_service_get_service (GNetworkService *srv);
function g_network_service_get_service(srv) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_network_service_get_service
  type(c_ptr), value :: srv
end function

! const gchar *g_network_service_get_protocol (GNetworkService *srv);
function g_network_service_get_protocol(srv) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_network_service_get_protocol
  type(c_ptr), value :: srv
end function

! const gchar *g_network_service_get_domain (GNetworkService *srv);
function g_network_service_get_domain(srv) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_network_service_get_domain
  type(c_ptr), value :: srv
end function

! const gchar *g_network_service_get_scheme (GNetworkService *srv);
function g_network_service_get_scheme(srv) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_network_service_get_scheme
  type(c_ptr), value :: srv
end function

! void g_network_service_set_scheme (GNetworkService *srv, const gchar *scheme);
subroutine g_network_service_set_scheme(srv, scheme) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: srv
  character(kind=c_char), dimension(*) :: scheme
end subroutine

!   GType g_output_stream_get_type (void) G_GNUC_CONST;
function g_output_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_output_stream_get_type
end function

!  gssize g_output_stream_write (GOutputStream *stream, const void *buffer, gsize count, GCancellable *cancellable, GError **error);
function g_output_stream_write(stream, buffer, count, cancellable, error) bind(c&
      &) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_output_stream_write
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_output_stream_write_all (GOutputStream *stream, const void *buffer, gsize count, gsize *bytes_written, GCancellable *cancellable, GError **error);
function g_output_stream_write_all(stream, buffer, count, bytes_written, cancell&
      &able, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_size_t
  logical(c_bool) :: g_output_stream_write_all
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gssize g_output_stream_splice (GOutputStream *stream, GInputStream *source, GOutputStreamSpliceFlags flags, GCancellable *cancellable, GError **error);
function g_output_stream_splice(stream, source, flags, cancellable, error) bind(&
      &c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_int
  integer(c_size_t) :: g_output_stream_splice
  type(c_ptr), value :: stream
  type(c_ptr), value :: source
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_output_stream_flush (GOutputStream *stream, GCancellable *cancellable, GError **error);
function g_output_stream_flush(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_output_stream_flush
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_output_stream_close (GOutputStream *stream, GCancellable *cancellable, GError **error);
function g_output_stream_close(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_output_stream_close
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_output_stream_write_async (GOutputStream *stream, const void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_output_stream_write_async(stream, buffer, count, io_priority, cance&
      &llable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gssize g_output_stream_write_finish (GOutputStream *stream, GAsyncResult *result, GError **error);
function g_output_stream_write_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_output_stream_write_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_output_stream_splice_async (GOutputStream *stream, GInputStream *source, GOutputStreamSpliceFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_output_stream_splice_async(stream, source, flags, io_priority, canc&
      &ellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream
  type(c_ptr), value :: source
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gssize g_output_stream_splice_finish (GOutputStream *stream, GAsyncResult *result, GError **error);
function g_output_stream_splice_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_output_stream_splice_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_output_stream_flush_async (GOutputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_output_stream_flush_async(stream, io_priority, cancellable, callbac&
      &k, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_output_stream_flush_finish (GOutputStream *stream, GAsyncResult *result, GError **error);
function g_output_stream_flush_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_output_stream_flush_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_output_stream_close_async (GOutputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_output_stream_close_async(stream, io_priority, cancellable, callbac&
      &k, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_output_stream_close_finish (GOutputStream *stream, GAsyncResult *result, GError **error);
function g_output_stream_close_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_output_stream_close_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  gboolean g_output_stream_is_closed (GOutputStream *stream);
function g_output_stream_is_closed(stream) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_output_stream_is_closed
  type(c_ptr), value :: stream
end function

! gboolean g_output_stream_is_closing (GOutputStream *stream);
function g_output_stream_is_closing(stream) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_output_stream_is_closing
  type(c_ptr), value :: stream
end function

! gboolean g_output_stream_has_pending (GOutputStream *stream);
function g_output_stream_has_pending(stream) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_output_stream_has_pending
  type(c_ptr), value :: stream
end function

! gboolean g_output_stream_set_pending (GOutputStream *stream, GError **error);
function g_output_stream_set_pending(stream, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_output_stream_set_pending
  type(c_ptr), value :: stream
  type(c_ptr), value :: error
end function

! void g_output_stream_clear_pending (GOutputStream *stream);
subroutine g_output_stream_clear_pending(stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: stream
end subroutine

!   GType g_io_module_get_type (void) G_GNUC_CONST;
function g_io_module_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_io_module_get_type
end function

! GIOModule *g_io_module_new (const gchar *filename);
function g_io_module_new(filename) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_io_module_new
  character(kind=c_char), dimension(*) :: filename
end function

!  void g_io_modules_scan_all_in_directory (const char *dirname);
subroutine g_io_modules_scan_all_in_directory(dirname) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: dirname
end subroutine

! GList *g_io_modules_load_all_in_directory (const gchar *dirname);
function g_io_modules_load_all_in_directory(dirname) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_io_modules_load_all_in_directory
  character(kind=c_char), dimension(*) :: dirname
end function

!  GIOExtensionPoint *g_io_extension_point_register (const char *name);
function g_io_extension_point_register(name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_io_extension_point_register
  character(kind=c_char), dimension(*) :: name
end function

! GIOExtensionPoint *g_io_extension_point_lookup (const char *name);
function g_io_extension_point_lookup(name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_io_extension_point_lookup
  character(kind=c_char), dimension(*) :: name
end function

! void g_io_extension_point_set_required_type (GIOExtensionPoint *extension_point, GType type);
subroutine g_io_extension_point_set_required_type(extension_point, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: extension_point
  integer(c_size_t), value :: type
end subroutine

! GType g_io_extension_point_get_required_type (GIOExtensionPoint *extension_point);
function g_io_extension_point_get_required_type(extension_point) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_io_extension_point_get_required_type
  type(c_ptr), value :: extension_point
end function

! GList *g_io_extension_point_get_extensions (GIOExtensionPoint *extension_point);
function g_io_extension_point_get_extensions(extension_point) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_io_extension_point_get_extensions
  type(c_ptr), value :: extension_point
end function

! GIOExtension * g_io_extension_point_get_extension_by_name (GIOExtensionPoint *extension_point, const char *name);
function g_io_extension_point_get_extension_by_name(extension_point, name) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_io_extension_point_get_extension_by_name
  type(c_ptr), value :: extension_point
  character(kind=c_char), dimension(*) :: name
end function

! GIOExtension * g_io_extension_point_implement (const char *extension_point_name, GType type, const char *extension_name, gint priority);
function g_io_extension_point_implement(extension_point_name, type, extension_na&
      &me, priority) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_io_extension_point_implement
  character(kind=c_char), dimension(*) :: extension_point_name
  integer(c_size_t), value :: type
  character(kind=c_char), dimension(*) :: extension_name
  integer(c_int), value :: priority
end function

!  GType g_io_extension_get_type (GIOExtension *extension);
function g_io_extension_get_type(extension) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_io_extension_get_type
  type(c_ptr), value :: extension
end function

! const char * g_io_extension_get_name (GIOExtension *extension);
function g_io_extension_get_name(extension) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_io_extension_get_name
  type(c_ptr), value :: extension
end function

! gint g_io_extension_get_priority (GIOExtension *extension);
function g_io_extension_get_priority(extension) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_io_extension_get_priority
  type(c_ptr), value :: extension
end function

! GTypeClass* g_io_extension_ref_class (GIOExtension *extension);
function g_io_extension_ref_class(extension) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_io_extension_ref_class
  type(c_ptr), value :: extension
end function

!  void g_io_module_load (GIOModule *module);
subroutine g_io_module_load(module) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: module
end subroutine

!  void g_io_module_unload (GIOModule *module);
subroutine g_io_module_unload(module) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: module
end subroutine

!  char **g_io_module_query (void);
function g_io_module_query() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_io_module_query
end function

!   GType g_threaded_socket_service_get_type (void);
function g_threaded_socket_service_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_threaded_socket_service_get_type
end function

! GSocketService * g_threaded_socket_service_new (int max_threads);
function g_threaded_socket_service_new(max_threads) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_threaded_socket_service_new
  integer(c_int), value :: max_threads
end function

!   GType g_filename_completer_get_type (void) G_GNUC_CONST;
function g_filename_completer_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_filename_completer_get_type
end function

!  GFilenameCompleter *g_filename_completer_new (void);
function g_filename_completer_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_filename_completer_new
end function

!  char * g_filename_completer_get_completion_suffix (GFilenameCompleter *completer, const char *initial_text);
function g_filename_completer_get_completion_suffix(completer, initial_text) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_filename_completer_get_completion_suffix
  type(c_ptr), value :: completer
  character(kind=c_char), dimension(*) :: initial_text
end function

! char ** g_filename_completer_get_completions (GFilenameCompleter *completer, const char *initial_text);
function g_filename_completer_get_completions(completer, initial_text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_filename_completer_get_completions
  type(c_ptr), value :: completer
  character(kind=c_char), dimension(*) :: initial_text
end function

! void g_filename_completer_set_dirs_only (GFilenameCompleter *completer, gboolean dirs_only);
subroutine g_filename_completer_set_dirs_only(completer, dirs_only) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: completer
  logical(c_bool), value :: dirs_only
end subroutine

!   GType g_inet_address_get_type (void) G_GNUC_CONST;
function g_inet_address_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_inet_address_get_type
end function

!  GInetAddress * g_inet_address_new_from_string (const gchar *string);
function g_inet_address_new_from_string(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_inet_address_new_from_string
  character(kind=c_char), dimension(*) :: string
end function

!  GInetAddress * g_inet_address_new_from_bytes (const guint8 *bytes, GSocketFamily family);
function g_inet_address_new_from_bytes(bytes, family) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_inet_address_new_from_bytes
  type(c_ptr), value :: bytes
  integer(c_int), value :: family
end function

!  GInetAddress * g_inet_address_new_loopback (GSocketFamily family);
function g_inet_address_new_loopback(family) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_inet_address_new_loopback
  integer(c_int), value :: family
end function

!  GInetAddress * g_inet_address_new_any (GSocketFamily family);
function g_inet_address_new_any(family) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_inet_address_new_any
  integer(c_int), value :: family
end function

!  gchar * g_inet_address_to_string (GInetAddress *address);
function g_inet_address_to_string(address) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_inet_address_to_string
  type(c_ptr), value :: address
end function

!  const guint8 * g_inet_address_to_bytes (GInetAddress *address);
function g_inet_address_to_bytes(address) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_inet_address_to_bytes
  type(c_ptr), value :: address
end function

!  gsize g_inet_address_get_native_size (GInetAddress *address);
function g_inet_address_get_native_size(address) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_inet_address_get_native_size
  type(c_ptr), value :: address
end function

!  GSocketFamily g_inet_address_get_family (GInetAddress *address);
function g_inet_address_get_family(address) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_family
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_any (GInetAddress *address);
function g_inet_address_get_is_any(address) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_inet_address_get_is_any
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_loopback (GInetAddress *address);
function g_inet_address_get_is_loopback(address) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_inet_address_get_is_loopback
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_link_local (GInetAddress *address);
function g_inet_address_get_is_link_local(address) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_inet_address_get_is_link_local
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_site_local (GInetAddress *address);
function g_inet_address_get_is_site_local(address) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_inet_address_get_is_site_local
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_multicast (GInetAddress *address);
function g_inet_address_get_is_multicast(address) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_inet_address_get_is_multicast
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_mc_global (GInetAddress *address);
function g_inet_address_get_is_mc_global(address) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_inet_address_get_is_mc_global
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_mc_link_local (GInetAddress *address);
function g_inet_address_get_is_mc_link_local(address) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_inet_address_get_is_mc_link_local
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_mc_node_local (GInetAddress *address);
function g_inet_address_get_is_mc_node_local(address) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_inet_address_get_is_mc_node_local
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_mc_org_local (GInetAddress *address);
function g_inet_address_get_is_mc_org_local(address) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_inet_address_get_is_mc_org_local
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_mc_site_local (GInetAddress *address);
function g_inet_address_get_is_mc_site_local(address) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_inet_address_get_is_mc_site_local
  type(c_ptr), value :: address
end function

!   GType g_buffered_output_stream_get_type (void) G_GNUC_CONST;
function g_buffered_output_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_buffered_output_stream_get_type
end function

! GOutputStream* g_buffered_output_stream_new (GOutputStream *base_stream);
function g_buffered_output_stream_new(base_stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_buffered_output_stream_new
  type(c_ptr), value :: base_stream
end function

! GOutputStream* g_buffered_output_stream_new_sized (GOutputStream *base_stream, gsize size);
function g_buffered_output_stream_new_sized(base_stream, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_buffered_output_stream_new_sized
  type(c_ptr), value :: base_stream
  integer(c_size_t), value :: size
end function

! gsize g_buffered_output_stream_get_buffer_size (GBufferedOutputStream *stream);
function g_buffered_output_stream_get_buffer_size(stream) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_buffered_output_stream_get_buffer_size
  type(c_ptr), value :: stream
end function

! void g_buffered_output_stream_set_buffer_size (GBufferedOutputStream *stream, gsize size);
subroutine g_buffered_output_stream_set_buffer_size(stream, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: stream
  integer(c_size_t), value :: size
end subroutine

! gboolean g_buffered_output_stream_get_auto_grow (GBufferedOutputStream *stream);
function g_buffered_output_stream_get_auto_grow(stream) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_buffered_output_stream_get_auto_grow
  type(c_ptr), value :: stream
end function

! void g_buffered_output_stream_set_auto_grow (GBufferedOutputStream *stream, gboolean auto_grow);
subroutine g_buffered_output_stream_set_auto_grow(stream, auto_grow) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: stream
  logical(c_bool), value :: auto_grow
end subroutine

!   gboolean g_dbus_is_guid (const gchar *string);
function g_dbus_is_guid(string) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_dbus_is_guid
  character(kind=c_char), dimension(*) :: string
end function

! gchar *g_dbus_generate_guid (void);
function g_dbus_generate_guid() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_generate_guid
end function

!  gboolean g_dbus_is_name (const gchar *string);
function g_dbus_is_name(string) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_dbus_is_name
  character(kind=c_char), dimension(*) :: string
end function

! gboolean g_dbus_is_unique_name (const gchar *string);
function g_dbus_is_unique_name(string) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_dbus_is_unique_name
  character(kind=c_char), dimension(*) :: string
end function

! gboolean g_dbus_is_member_name (const gchar *string);
function g_dbus_is_member_name(string) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_dbus_is_member_name
  character(kind=c_char), dimension(*) :: string
end function

! gboolean g_dbus_is_interface_name (const gchar *string);
function g_dbus_is_interface_name(string) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_dbus_is_interface_name
  character(kind=c_char), dimension(*) :: string
end function

!   GType g_file_io_stream_get_type (void) G_GNUC_CONST;
function g_file_io_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_io_stream_get_type
end function

!  GFileInfo *g_file_io_stream_query_info (GFileIOStream *stream, const char *attributes, GCancellable *cancellable, GError **error);
function g_file_io_stream_query_info(stream, attributes, cancellable, error) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_io_stream_query_info
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: attributes
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_io_stream_query_info_async (GFileIOStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_io_stream_query_info_async(stream, attributes, io_priority, ca&
      &ncellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileInfo *g_file_io_stream_query_info_finish (GFileIOStream *stream, GAsyncResult *result, GError **error);
function g_file_io_stream_query_info_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_io_stream_query_info_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! char * g_file_io_stream_get_etag (GFileIOStream *stream);
function g_file_io_stream_get_etag(stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_io_stream_get_etag
  type(c_ptr), value :: stream
end function

!   GType g_file_attribute_info_list_get_type (void);
function g_file_attribute_info_list_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_attribute_info_list_get_type
end function

! GFileAttributeInfoList * g_file_attribute_info_list_new (void);
function g_file_attribute_info_list_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_attribute_info_list_new
end function

! GFileAttributeInfoList * g_file_attribute_info_list_ref (GFileAttributeInfoList *list);
function g_file_attribute_info_list_ref(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_attribute_info_list_ref
  type(c_ptr), value :: list
end function

! void g_file_attribute_info_list_unref (GFileAttributeInfoList *list);
subroutine g_file_attribute_info_list_unref(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

! GFileAttributeInfoList * g_file_attribute_info_list_dup (GFileAttributeInfoList *list);
function g_file_attribute_info_list_dup(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_attribute_info_list_dup
  type(c_ptr), value :: list
end function

! const GFileAttributeInfo *g_file_attribute_info_list_lookup (GFileAttributeInfoList *list, const char *name);
function g_file_attribute_info_list_lookup(list, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_attribute_info_list_lookup
  type(c_ptr), value :: list
  character(kind=c_char), dimension(*) :: name
end function

! void g_file_attribute_info_list_add (GFileAttributeInfoList *list, const char *name, GFileAttributeType type, GFileAttributeInfoFlags flags);
subroutine g_file_attribute_info_list_add(list, name, type, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: list
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: type
  integer(c_int), value :: flags
end subroutine

!   GType g_volume_get_type (void) G_GNUC_CONST;
function g_volume_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_volume_get_type
end function

!  char * g_volume_get_name (GVolume *volume);
function g_volume_get_name(volume) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_get_name
  type(c_ptr), value :: volume
end function

! GIcon * g_volume_get_icon (GVolume *volume);
function g_volume_get_icon(volume) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_get_icon
  type(c_ptr), value :: volume
end function

! char * g_volume_get_uuid (GVolume *volume);
function g_volume_get_uuid(volume) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_get_uuid
  type(c_ptr), value :: volume
end function

! GDrive * g_volume_get_drive (GVolume *volume);
function g_volume_get_drive(volume) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_get_drive
  type(c_ptr), value :: volume
end function

! GMount * g_volume_get_mount (GVolume *volume);
function g_volume_get_mount(volume) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_get_mount
  type(c_ptr), value :: volume
end function

! gboolean g_volume_can_mount (GVolume *volume);
function g_volume_can_mount(volume) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_volume_can_mount
  type(c_ptr), value :: volume
end function

! gboolean g_volume_can_eject (GVolume *volume);
function g_volume_can_eject(volume) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_volume_can_eject
  type(c_ptr), value :: volume
end function

! gboolean g_volume_should_automount (GVolume *volume);
function g_volume_should_automount(volume) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_volume_should_automount
  type(c_ptr), value :: volume
end function

! void g_volume_mount (GVolume *volume, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_volume_mount(volume, flags, mount_operation, cancellable, callback,&
      & user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: volume
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_volume_mount_finish (GVolume *volume, GAsyncResult *result, GError **error);
function g_volume_mount_finish(volume, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_volume_mount_finish
  type(c_ptr), value :: volume
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_volume_eject (GVolume *volume, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_volume_eject(volume, flags, cancellable, callback, user_data) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: volume
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_volume_eject_finish (GVolume *volume, GAsyncResult *result, GError **error);
function g_volume_eject_finish(volume, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_volume_eject_finish
  type(c_ptr), value :: volume
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  char * g_volume_get_identifier (GVolume *volume, const char *kind);
function g_volume_get_identifier(volume, kind) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_volume_get_identifier
  type(c_ptr), value :: volume
  character(kind=c_char), dimension(*) :: kind
end function

! char ** g_volume_enumerate_identifiers (GVolume *volume);
function g_volume_enumerate_identifiers(volume) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_enumerate_identifiers
  type(c_ptr), value :: volume
end function

!  GFile * g_volume_get_activation_root (GVolume *volume);
function g_volume_get_activation_root(volume) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_get_activation_root
  type(c_ptr), value :: volume
end function

!  void g_volume_eject_with_operation (GVolume *volume, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_volume_eject_with_operation(volume, flags, mount_operation, cancell&
      &able, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: volume
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_volume_eject_with_operation_finish (GVolume *volume, GAsyncResult *result, GError **error);
function g_volume_eject_with_operation_finish(volume, result, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_volume_eject_with_operation_finish
  type(c_ptr), value :: volume
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!   GType g_proxy_resolver_get_type (void) G_GNUC_CONST;
function g_proxy_resolver_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_proxy_resolver_get_type
end function

! GProxyResolver *g_proxy_resolver_get_default (void);
function g_proxy_resolver_get_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_proxy_resolver_get_default
end function

!  gboolean g_proxy_resolver_is_supported (GProxyResolver *resolver);
function g_proxy_resolver_is_supported(resolver) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_proxy_resolver_is_supported
  type(c_ptr), value :: resolver
end function

! gchar **g_proxy_resolver_lookup (GProxyResolver *resolver, const gchar *uri, GCancellable *cancellable, GError **error);
function g_proxy_resolver_lookup(resolver, uri, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_proxy_resolver_lookup
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_proxy_resolver_lookup_async (GProxyResolver *resolver, const gchar *uri, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_proxy_resolver_lookup_async(resolver, uri, cancellable, callback, u&
      &ser_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gchar **g_proxy_resolver_lookup_finish (GProxyResolver *resolver, GAsyncResult *result, GError **error);
function g_proxy_resolver_lookup_finish(resolver, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_proxy_resolver_lookup_finish
  type(c_ptr), value :: resolver
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!   GType g_zlib_decompressor_get_type (void) G_GNUC_CONST;
function g_zlib_decompressor_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_zlib_decompressor_get_type
end function

!  GZlibDecompressor *g_zlib_decompressor_new (GZlibCompressorFormat format);
function g_zlib_decompressor_new(format) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_zlib_decompressor_new
  integer(c_int), value :: format
end function

!  GFileInfo *g_zlib_decompressor_get_file_info (GZlibDecompressor *decompressor);
function g_zlib_decompressor_get_file_info(decompressor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_zlib_decompressor_get_file_info
  type(c_ptr), value :: decompressor
end function

!   GType g_simple_async_result_get_type (void) G_GNUC_CONST;
function g_simple_async_result_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_simple_async_result_get_type
end function

!  GSimpleAsyncResult *g_simple_async_result_new (GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, gpointer source_tag);
function g_simple_async_result_new(source_object, callback, user_data, source_ta&
      &g) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_simple_async_result_new
  type(c_ptr), value :: source_object
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
  type(c_ptr), value :: source_tag
end function

! GSimpleAsyncResult *g_simple_async_result_new_error (GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, GQuark domain, gint code, const char *format, ...) G_GNUC_PRINTF (6, 7);
function g_simple_async_result_new_error() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_simple_async_result_new_error
end function

! GSimpleAsyncResult *g_simple_async_result_new_from_error (GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, GError *error);
function g_simple_async_result_new_from_error(source_object, callback, user_data&
      &, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_simple_async_result_new_from_error
  type(c_ptr), value :: source_object
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
  type(c_ptr), value :: error
end function

!  void g_simple_async_result_set_op_res_gpointer (GSimpleAsyncResult *simple, gpointer op_res, GDestroyNotify destroy_op_res);
subroutine g_simple_async_result_set_op_res_gpointer(simple, op_res, destroy_op_&
      &res) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: simple
  type(c_ptr), value :: op_res
  type(c_funptr), value :: destroy_op_res
end subroutine

! gpointer g_simple_async_result_get_op_res_gpointer (GSimpleAsyncResult *simple);
function g_simple_async_result_get_op_res_gpointer(simple) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_simple_async_result_get_op_res_gpointer
  type(c_ptr), value :: simple
end function

!  void g_simple_async_result_set_op_res_gssize (GSimpleAsyncResult *simple, gssize op_res);
subroutine g_simple_async_result_set_op_res_gssize(simple, op_res) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: simple
  integer(c_size_t), value :: op_res
end subroutine

! gssize g_simple_async_result_get_op_res_gssize (GSimpleAsyncResult *simple);
function g_simple_async_result_get_op_res_gssize(simple) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_simple_async_result_get_op_res_gssize
  type(c_ptr), value :: simple
end function

!  void g_simple_async_result_set_op_res_gboolean (GSimpleAsyncResult *simple, gboolean op_res);
subroutine g_simple_async_result_set_op_res_gboolean(simple, op_res) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: simple
  logical(c_bool), value :: op_res
end subroutine

! gboolean g_simple_async_result_get_op_res_gboolean (GSimpleAsyncResult *simple);
function g_simple_async_result_get_op_res_gboolean(simple) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_simple_async_result_get_op_res_gboolean
  type(c_ptr), value :: simple
end function

!  gpointer g_simple_async_result_get_source_tag (GSimpleAsyncResult *simple);
function g_simple_async_result_get_source_tag(simple) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_simple_async_result_get_source_tag
  type(c_ptr), value :: simple
end function

! void g_simple_async_result_set_handle_cancellation (GSimpleAsyncResult *simple, gboolean handle_cancellation);
subroutine g_simple_async_result_set_handle_cancellation(simple, handle_cancella&
      &tion) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: simple
  logical(c_bool), value :: handle_cancellation
end subroutine

! void g_simple_async_result_complete (GSimpleAsyncResult *simple);
subroutine g_simple_async_result_complete(simple) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: simple
end subroutine

! void g_simple_async_result_complete_in_idle (GSimpleAsyncResult *simple);
subroutine g_simple_async_result_complete_in_idle(simple) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: simple
end subroutine

! void g_simple_async_result_run_in_thread (GSimpleAsyncResult *simple, GSimpleAsyncThreadFunc func, int io_priority, GCancellable *cancellable);
subroutine g_simple_async_result_run_in_thread(simple, func, io_priority, cancel&
      &lable) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr, c_int
  type(c_ptr), value :: simple
  type(c_funptr), value :: func
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
end subroutine

! void g_simple_async_result_set_from_error (GSimpleAsyncResult *simple, const GError *error);
subroutine g_simple_async_result_set_from_error(simple, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: simple
  type(c_ptr), value :: error
end subroutine

! gboolean g_simple_async_result_propagate_error (GSimpleAsyncResult *simple, GError **dest);
function g_simple_async_result_propagate_error(simple, dest) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_simple_async_result_propagate_error
  type(c_ptr), value :: simple
  type(c_ptr), value :: dest
end function

! void g_simple_async_result_set_error (GSimpleAsyncResult *simple, GQuark domain, gint code, const char *format, ...) G_GNUC_PRINTF (4, 5);
subroutine g_simple_async_result_set_error() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void g_simple_async_result_set_error_va (GSimpleAsyncResult *simple, GQuark domain, gint code, const char *format, va_list args);
subroutine g_simple_async_result_set_error_va(simple, domain, code, format, args&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_int, c_char
  type(c_ptr), value :: simple
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end subroutine

! gboolean g_simple_async_result_is_valid (GAsyncResult *result, GObject *source, gpointer source_tag);
function g_simple_async_result_is_valid(result, source, source_tag) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_simple_async_result_is_valid
  type(c_ptr), value :: result
  type(c_ptr), value :: source
  type(c_ptr), value :: source_tag
end function

! void g_simple_async_report_gerror_in_idle (GObject *object, GAsyncReadyCallback callback, gpointer user_data, GError *error);
subroutine g_simple_async_report_gerror_in_idle(object, callback, user_data, err&
      &or) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: object
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
  type(c_ptr), value :: error
end subroutine

!   GType g_socket_address_enumerator_get_type (void) G_GNUC_CONST;
function g_socket_address_enumerator_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_address_enumerator_get_type
end function

!  GSocketAddress *g_socket_address_enumerator_next (GSocketAddressEnumerator *enumerator, GCancellable *cancellable, GError **error);
function g_socket_address_enumerator_next(enumerator, cancellable, error) bind(c&
      &) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_address_enumerator_next
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_socket_address_enumerator_next_async (GSocketAddressEnumerator *enumerator, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_address_enumerator_next_async(enumerator, cancellable, callb&
      &ack, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GSocketAddress *g_socket_address_enumerator_next_finish (GSocketAddressEnumerator *enumerator, GAsyncResult *result, GError **error);
function g_socket_address_enumerator_next_finish(enumerator, result, error) bind&
      &(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_address_enumerator_next_finish
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!   GType g_credentials_get_type (void) G_GNUC_CONST;
function g_credentials_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_credentials_get_type
end function

!  GCredentials *g_credentials_new (void);
function g_credentials_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_credentials_new
end function

!  gchar *g_credentials_to_string (GCredentials *credentials);
function g_credentials_to_string(credentials) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_credentials_to_string
  type(c_ptr), value :: credentials
end function

!  gpointer g_credentials_get_native (GCredentials *credentials, GCredentialsType native_type);
function g_credentials_get_native(credentials, native_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_credentials_get_native
  type(c_ptr), value :: credentials
  integer(c_int), value :: native_type
end function

!  void g_credentials_set_native (GCredentials *credentials, GCredentialsType native_type, gpointer native);
subroutine g_credentials_set_native(credentials, native_type, native) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: credentials
  integer(c_int), value :: native_type
  type(c_ptr), value :: native
end subroutine

!  gboolean g_credentials_is_same_user (GCredentials *credentials, GCredentials *other_credentials, GError **error);
function g_credentials_is_same_user(credentials, other_credentials, error) bind(&
      &c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_credentials_is_same_user
  type(c_ptr), value :: credentials
  type(c_ptr), value :: other_credentials
  type(c_ptr), value :: error
end function

!  uid_t g_credentials_get_unix_user (GCredentials *credentials, GError **error);
function g_credentials_get_unix_user(credentials, error) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_credentials_get_unix_user
  type(c_ptr), value :: credentials
  type(c_ptr), value :: error
end function

! gboolean g_credentials_set_unix_user (GCredentials *credentials, uid_t uid, GError **error);
function g_credentials_set_unix_user(credentials, uid, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int32_t
  logical(c_bool) :: g_credentials_set_unix_user
  type(c_ptr), value :: credentials
  integer(c_int32_t), value :: uid
  type(c_ptr), value :: error
end function

!   gint g_atomic_int_exchange_and_add (volatile gint G_GNUC_MAY_ALIAS *atomic, gint val);
function g_atomic_int_exchange_and_add(atomic, val) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_atomic_int_exchange_and_add
  type(c_ptr), value :: atomic
  integer(c_int), value :: val
end function

! void g_atomic_int_add (volatile gint G_GNUC_MAY_ALIAS *atomic, gint val);
subroutine g_atomic_int_add(atomic, val) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: atomic
  integer(c_int), value :: val
end subroutine

! gboolean g_atomic_int_compare_and_exchange (volatile gint G_GNUC_MAY_ALIAS *atomic, gint oldval, gint newval);
function g_atomic_int_compare_and_exchange(atomic, oldval, newval) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: g_atomic_int_compare_and_exchange
  type(c_ptr), value :: atomic
  integer(c_int), value :: oldval
  integer(c_int), value :: newval
end function

! gboolean g_atomic_pointer_compare_and_exchange (volatile gpointer G_GNUC_MAY_ALIAS *atomic, gpointer oldval, gpointer newval);
function g_atomic_pointer_compare_and_exchange(atomic, oldval, newval) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_atomic_pointer_compare_and_exchange
  type(c_ptr), value :: atomic
  type(c_ptr), value :: oldval
  type(c_ptr), value :: newval
end function

!  gint g_atomic_int_get (volatile gint G_GNUC_MAY_ALIAS *atomic);
function g_atomic_int_get(atomic) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_atomic_int_get
  type(c_ptr), value :: atomic
end function

! void g_atomic_int_set (volatile gint G_GNUC_MAY_ALIAS *atomic, gint newval);
subroutine g_atomic_int_set(atomic, newval) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: atomic
  integer(c_int), value :: newval
end subroutine

! gpointer g_atomic_pointer_get (volatile gpointer G_GNUC_MAY_ALIAS *atomic);
function g_atomic_pointer_get(atomic) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_atomic_pointer_get
  type(c_ptr), value :: atomic
end function

! void g_atomic_pointer_set (volatile gpointer G_GNUC_MAY_ALIAS *atomic, gpointer newval);
subroutine g_atomic_pointer_set(atomic, newval) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: atomic
  type(c_ptr), value :: newval
end subroutine

!   G_CONST_RETURN gchar* g_get_user_name (void);
function g_get_user_name() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_user_name
end function

! G_CONST_RETURN gchar* g_get_real_name (void);
function g_get_real_name() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_real_name
end function

! G_CONST_RETURN gchar* g_get_home_dir (void);
function g_get_home_dir() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_home_dir
end function

! G_CONST_RETURN gchar* g_get_tmp_dir (void);
function g_get_tmp_dir() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_tmp_dir
end function

! G_CONST_RETURN gchar* g_get_host_name (void);
function g_get_host_name() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_host_name
end function

! gchar* g_get_prgname (void);
function g_get_prgname() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_prgname
end function

! void g_set_prgname (const gchar *prgname);
subroutine g_set_prgname(prgname) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: prgname
end subroutine

! G_CONST_RETURN gchar* g_get_application_name (void);
function g_get_application_name() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_application_name
end function

! void g_set_application_name (const gchar *application_name);
subroutine g_set_application_name(application_name) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: application_name
end subroutine

!  void g_reload_user_special_dirs_cache (void);
subroutine g_reload_user_special_dirs_cache() bind(c) 
  use iso_c_binding, only: 
end subroutine

! G_CONST_RETURN gchar* g_get_user_data_dir (void);
function g_get_user_data_dir() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_user_data_dir
end function

! G_CONST_RETURN gchar* g_get_user_config_dir (void);
function g_get_user_config_dir() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_user_config_dir
end function

! G_CONST_RETURN gchar* g_get_user_cache_dir (void);
function g_get_user_cache_dir() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_user_cache_dir
end function

! G_CONST_RETURN gchar* G_CONST_RETURN * g_get_system_data_dirs (void);
function g_get_system_data_dirs() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_system_data_dirs
end function

!  G_CONST_RETURN gchar* G_CONST_RETURN * g_win32_get_system_data_dirs_for_module (void (*address_of_function)(void));
function g_win32_get_system_data_dirs_for_module() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_win32_get_system_data_dirs_for_module
end function

!  gint g_snprintf (gchar *string, gulong n, gchar const *format, ...) G_GNUC_PRINTF (3, 4);
function g_snprintf() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_snprintf
end function

! gint g_vsnprintf (gchar *string, gulong n, gchar const *format, va_list args);
function g_vsnprintf(string, n, format, args) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_long, c_ptr
  integer(c_int) :: g_vsnprintf
  character(kind=c_char), dimension(*) :: string
  integer(c_long), value :: n
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

!  gboolean g_path_is_absolute (const gchar *file_name);
function g_path_is_absolute(file_name) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_path_is_absolute
  character(kind=c_char), dimension(*) :: file_name
end function

!  G_CONST_RETURN gchar* g_path_skip_root (const gchar *file_name);
function g_path_skip_root(file_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_path_skip_root
  character(kind=c_char), dimension(*) :: file_name
end function

!  G_CONST_RETURN gchar* g_basename (const gchar *file_name);
function g_basename(file_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_basename
  character(kind=c_char), dimension(*) :: file_name
end function

!  gchar* g_get_current_dir (void);
function g_get_current_dir() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_current_dir
end function

! gchar* g_path_get_basename (const gchar *file_name) G_GNUC_MALLOC;
function g_path_get_basename(file_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_path_get_basename
  character(kind=c_char), dimension(*) :: file_name
end function

! gchar* g_path_get_dirname (const gchar *file_name) G_GNUC_MALLOC;
function g_path_get_dirname(file_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_path_get_dirname
  character(kind=c_char), dimension(*) :: file_name
end function

!  void g_nullify_pointer (gpointer *nullify_location);
subroutine g_nullify_pointer(nullify_location) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: nullify_location
end subroutine

!  G_CONST_RETURN gchar* g_getenv (const gchar *variable);
function g_getenv(variable) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_getenv
  character(kind=c_char), dimension(*) :: variable
end function

! gboolean g_setenv (const gchar *variable, const gchar *value, gboolean overwrite);
function g_setenv(variable, value, overwrite) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_setenv
  character(kind=c_char), dimension(*) :: variable
  character(kind=c_char), dimension(*) :: value
  logical(c_bool), value :: overwrite
end function

! void g_unsetenv (const gchar *variable);
subroutine g_unsetenv(variable) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: variable
end subroutine

! gchar** g_listenv (void);
function g_listenv() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_listenv
end function

!  void g_atexit (GVoidFunc func);
subroutine g_atexit(func) bind(c) 
  use iso_c_binding, only: c_funptr
  type(c_funptr), value :: func
end subroutine

!  int atexit (void (*)(void));
function atexit() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: atexit
end function

!  gchar* g_find_program_in_path (const gchar *program);
function g_find_program_in_path(program) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_find_program_in_path
  character(kind=c_char), dimension(*) :: program
end function

! gint g_bit_nth_msf (gulong mask, gint nth_bit) G_GNUC_CONST;
function g_bit_nth_msf(mask, nth_bit) bind(c) 
  use iso_c_binding, only: c_int, c_long
  integer(c_int) :: g_bit_nth_msf
  integer(c_long), value :: mask
  integer(c_int), value :: nth_bit
end function

! guint g_bit_storage (gulong number) G_GNUC_CONST;
function g_bit_storage(number) bind(c) 
  use iso_c_binding, only: c_int, c_long
  integer(c_int) :: g_bit_storage
  integer(c_long), value :: number
end function

!  void g_trash_stack_push (GTrashStack **stack_p, gpointer data_p);
subroutine g_trash_stack_push(stack_p, data_p) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: stack_p
  type(c_ptr), value :: data_p
end subroutine

! gpointer g_trash_stack_pop (GTrashStack **stack_p);
function g_trash_stack_pop(stack_p) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_trash_stack_pop
  type(c_ptr), value :: stack_p
end function

! gpointer g_trash_stack_peek (GTrashStack **stack_p);
function g_trash_stack_peek(stack_p) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_trash_stack_peek
  type(c_ptr), value :: stack_p
end function

! guint g_trash_stack_height (GTrashStack **stack_p);
function g_trash_stack_height(stack_p) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_trash_stack_height
  type(c_ptr), value :: stack_p
end function

!  const gchar * glib_check_version (guint required_major, guint required_minor, guint required_micro);
function glib_check_version(required_major, required_minor, required_micro) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: glib_check_version
  integer(c_int), value :: required_major
  integer(c_int), value :: required_minor
  integer(c_int), value :: required_micro
end function

!   gint g_poll (GPollFD *fds, guint nfds, gint timeout);
function g_poll(fds, nfds, timeout) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_poll
  type(c_ptr), value :: fds
  integer(c_int), value :: nfds
  integer(c_int), value :: timeout
end function

!   GPatternSpec* g_pattern_spec_new (const gchar *pattern);
function g_pattern_spec_new(pattern) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_pattern_spec_new
  character(kind=c_char), dimension(*) :: pattern
end function

! void g_pattern_spec_free (GPatternSpec *pspec);
subroutine g_pattern_spec_free(pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pspec
end subroutine

! gboolean g_pattern_spec_equal (GPatternSpec *pspec1, GPatternSpec *pspec2);
function g_pattern_spec_equal(pspec1, pspec2) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_pattern_spec_equal
  type(c_ptr), value :: pspec1
  type(c_ptr), value :: pspec2
end function

! gboolean g_pattern_match (GPatternSpec *pspec, guint string_length, const gchar *string, const gchar *string_reversed);
function g_pattern_match(pspec, string_length, string, string_reversed) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int, c_char
  logical(c_bool) :: g_pattern_match
  type(c_ptr), value :: pspec
  integer(c_int), value :: string_length
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: string_reversed
end function

! gboolean g_pattern_match_string (GPatternSpec *pspec, const gchar *string);
function g_pattern_match_string(pspec, string) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_pattern_match_string
  type(c_ptr), value :: pspec
  character(kind=c_char), dimension(*) :: string
end function

! gboolean g_pattern_match_simple (const gchar *pattern, const gchar *string);
function g_pattern_match_simple(pattern, string) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_pattern_match_simple
  character(kind=c_char), dimension(*) :: pattern
  character(kind=c_char), dimension(*) :: string
end function

!   GQuark g_option_error_quark (void);
function g_option_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_option_error_quark
end function

!  GOptionContext *g_option_context_new (const gchar *parameter_string);
function g_option_context_new(parameter_string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_option_context_new
  character(kind=c_char), dimension(*) :: parameter_string
end function

! void g_option_context_set_summary (GOptionContext *context, const gchar *summary);
subroutine g_option_context_set_summary(context, summary) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: summary
end subroutine

! G_CONST_RETURN gchar *g_option_context_get_summary (GOptionContext *context);
function g_option_context_get_summary(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_option_context_get_summary
  type(c_ptr), value :: context
end function

! void g_option_context_set_description (GOptionContext *context, const gchar *description);
subroutine g_option_context_set_description(context, description) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: description
end subroutine

! G_CONST_RETURN gchar *g_option_context_get_description (GOptionContext *context);
function g_option_context_get_description(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_option_context_get_description
  type(c_ptr), value :: context
end function

! void g_option_context_free (GOptionContext *context);
subroutine g_option_context_free(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

! void g_option_context_set_help_enabled (GOptionContext *context, gboolean help_enabled);
subroutine g_option_context_set_help_enabled(context, help_enabled) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: context
  logical(c_bool), value :: help_enabled
end subroutine

! gboolean g_option_context_get_help_enabled (GOptionContext *context);
function g_option_context_get_help_enabled(context) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_option_context_get_help_enabled
  type(c_ptr), value :: context
end function

! void g_option_context_set_ignore_unknown_options (GOptionContext *context, gboolean ignore_unknown);
subroutine g_option_context_set_ignore_unknown_options(context, ignore_unknown) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: context
  logical(c_bool), value :: ignore_unknown
end subroutine

! gboolean g_option_context_get_ignore_unknown_options (GOptionContext *context);
function g_option_context_get_ignore_unknown_options(context) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_option_context_get_ignore_unknown_options
  type(c_ptr), value :: context
end function

!  void g_option_context_add_main_entries (GOptionContext *context, const GOptionEntry *entries, const gchar *translation_domain);
subroutine g_option_context_add_main_entries(context, entries, translation_domai&
      &n) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: context
  type(c_ptr), value :: entries
  character(kind=c_char), dimension(*) :: translation_domain
end subroutine

! gboolean g_option_context_parse (GOptionContext *context, gint *argc, gchar ***argv, GError **error);
function g_option_context_parse(context, argc, argv, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_option_context_parse
  type(c_ptr), value :: context
  type(c_ptr), value :: argc
  character(kind=c_char), dimension(*) :: argv
  type(c_ptr), value :: error
end function

! void g_option_context_set_translate_func (GOptionContext *context, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify);
subroutine g_option_context_set_translate_func(context, func, data, destroy_noti&
      &fy) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: context
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy_notify
end subroutine

! void g_option_context_set_translation_domain (GOptionContext *context, const gchar *domain);
subroutine g_option_context_set_translation_domain(context, domain) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: domain
end subroutine

!  void g_option_context_add_group (GOptionContext *context, GOptionGroup *group);
subroutine g_option_context_add_group(context, group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: group
end subroutine

! void g_option_context_set_main_group (GOptionContext *context, GOptionGroup *group);
subroutine g_option_context_set_main_group(context, group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: group
end subroutine

! GOptionGroup *g_option_context_get_main_group (GOptionContext *context);
function g_option_context_get_main_group(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_option_context_get_main_group
  type(c_ptr), value :: context
end function

! gchar *g_option_context_get_help (GOptionContext *context, gboolean main_help, GOptionGroup *group);
function g_option_context_get_help(context, main_help, group) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: g_option_context_get_help
  type(c_ptr), value :: context
  logical(c_bool), value :: main_help
  type(c_ptr), value :: group
end function

!  GOptionGroup *g_option_group_new (const gchar *name, const gchar *description, const gchar *help_description, gpointer user_data, GDestroyNotify destroy);
function g_option_group_new(name, description, help_description, user_data, dest&
      &roy) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr) :: g_option_group_new
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: description
  character(kind=c_char), dimension(*) :: help_description
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy
end function

! void g_option_group_set_parse_hooks (GOptionGroup *group, GOptionParseFunc pre_parse_func, GOptionParseFunc post_parse_func);
subroutine g_option_group_set_parse_hooks(group, pre_parse_func, post_parse_func&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: group
  type(c_funptr), value :: pre_parse_func
  type(c_funptr), value :: post_parse_func
end subroutine

! void g_option_group_set_error_hook (GOptionGroup *group, GOptionErrorFunc error_func);
subroutine g_option_group_set_error_hook(group, error_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: group
  integer(c_int), value :: error_func
end subroutine

! void g_option_group_free (GOptionGroup *group);
subroutine g_option_group_free(group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: group
end subroutine

! void g_option_group_add_entries (GOptionGroup *group, const GOptionEntry *entries);
subroutine g_option_group_add_entries(group, entries) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: group
  type(c_ptr), value :: entries
end subroutine

! void g_option_group_set_translate_func (GOptionGroup *group, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify);
subroutine g_option_group_set_translate_func(group, func, data, destroy_notify) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: group
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy_notify
end subroutine

! void g_option_group_set_translation_domain (GOptionGroup *group, const gchar *domain);
subroutine g_option_group_set_translation_domain(group, domain) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: group
  character(kind=c_char), dimension(*) :: domain
end subroutine

!   gboolean g_get_charset (G_CONST_RETURN char **charset);
function g_get_charset(charset) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_get_charset
  character(kind=c_char), dimension(*) :: charset
end function

!  gboolean g_unichar_isalnum (gunichar c) G_GNUC_CONST;
function g_unichar_isalnum(c) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: g_unichar_isalnum
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_isalpha (gunichar c) G_GNUC_CONST;
function g_unichar_isalpha(c) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: g_unichar_isalpha
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_iscntrl (gunichar c) G_GNUC_CONST;
function g_unichar_iscntrl(c) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: g_unichar_iscntrl
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_isdigit (gunichar c) G_GNUC_CONST;
function g_unichar_isdigit(c) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: g_unichar_isdigit
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_isgraph (gunichar c) G_GNUC_CONST;
function g_unichar_isgraph(c) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: g_unichar_isgraph
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_islower (gunichar c) G_GNUC_CONST;
function g_unichar_islower(c) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: g_unichar_islower
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_isprint (gunichar c) G_GNUC_CONST;
function g_unichar_isprint(c) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: g_unichar_isprint
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_ispunct (gunichar c) G_GNUC_CONST;
function g_unichar_ispunct(c) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: g_unichar_ispunct
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_isspace (gunichar c) G_GNUC_CONST;
function g_unichar_isspace(c) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: g_unichar_isspace
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_isupper (gunichar c) G_GNUC_CONST;
function g_unichar_isupper(c) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: g_unichar_isupper
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_isxdigit (gunichar c) G_GNUC_CONST;
function g_unichar_isxdigit(c) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: g_unichar_isxdigit
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_istitle (gunichar c) G_GNUC_CONST;
function g_unichar_istitle(c) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: g_unichar_istitle
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_isdefined (gunichar c) G_GNUC_CONST;
function g_unichar_isdefined(c) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: g_unichar_isdefined
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_iswide (gunichar c) G_GNUC_CONST;
function g_unichar_iswide(c) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: g_unichar_iswide
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_iswide_cjk(gunichar c) G_GNUC_CONST;
function g_unichar_iswide_cjk(c) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: g_unichar_iswide_cjk
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_iszerowidth(gunichar c) G_GNUC_CONST;
function g_unichar_iszerowidth(c) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: g_unichar_iszerowidth
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_ismark (gunichar c) G_GNUC_CONST;
function g_unichar_ismark(c) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: g_unichar_ismark
  integer(c_int32_t), value :: c
end function

!  gunichar g_unichar_toupper (gunichar c) G_GNUC_CONST;
function g_unichar_toupper(c) bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_unichar_toupper
  integer(c_int32_t), value :: c
end function

! gunichar g_unichar_tolower (gunichar c) G_GNUC_CONST;
function g_unichar_tolower(c) bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_unichar_tolower
  integer(c_int32_t), value :: c
end function

! gunichar g_unichar_totitle (gunichar c) G_GNUC_CONST;
function g_unichar_totitle(c) bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_unichar_totitle
  integer(c_int32_t), value :: c
end function

!  gint g_unichar_digit_value (gunichar c) G_GNUC_CONST;
function g_unichar_digit_value(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_digit_value
  integer(c_int32_t), value :: c
end function

!  gint g_unichar_xdigit_value (gunichar c) G_GNUC_CONST;
function g_unichar_xdigit_value(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_xdigit_value
  integer(c_int32_t), value :: c
end function

!  GUnicodeType g_unichar_type (gunichar c) G_GNUC_CONST;
function g_unichar_type(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_type
  integer(c_int32_t), value :: c
end function

!  GUnicodeBreakType g_unichar_break_type (gunichar c) G_GNUC_CONST;
function g_unichar_break_type(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_break_type
  integer(c_int32_t), value :: c
end function

!  gint g_unichar_combining_class (gunichar uc) G_GNUC_CONST;
function g_unichar_combining_class(uc) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_combining_class
  integer(c_int32_t), value :: uc
end function

!  void g_unicode_canonical_ordering (gunichar *string, gsize len);
subroutine g_unicode_canonical_ordering(string, len) bind(c) 
  use iso_c_binding, only: c_char, c_size_t
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: len
end subroutine

!  gunichar *g_unicode_canonical_decomposition (gunichar ch, gsize *result_len) G_GNUC_MALLOC;
function g_unicode_canonical_decomposition(ch, result_len) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_unicode_canonical_decomposition
  integer(c_int32_t), value :: ch
  type(c_ptr), value :: result_len
end function

!  gunichar g_utf8_get_char (const gchar *p) G_GNUC_PURE;
function g_utf8_get_char(p) bind(c) 
  use iso_c_binding, only: c_int32_t, c_char
  integer(c_int32_t) :: g_utf8_get_char
  character(kind=c_char), dimension(*) :: p
end function

! gunichar g_utf8_get_char_validated (const gchar *p, gssize max_len) G_GNUC_PURE;
function g_utf8_get_char_validated(p, max_len) bind(c) 
  use iso_c_binding, only: c_int32_t, c_char, c_size_t
  integer(c_int32_t) :: g_utf8_get_char_validated
  character(kind=c_char), dimension(*) :: p
  integer(c_size_t), value :: max_len
end function

!  gchar* g_utf8_offset_to_pointer (const gchar *str, glong offset) G_GNUC_PURE;
function g_utf8_offset_to_pointer(str, offset) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr) :: g_utf8_offset_to_pointer
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: offset
end function

! glong g_utf8_pointer_to_offset (const gchar *str, const gchar *pos) G_GNUC_PURE;
function g_utf8_pointer_to_offset(str, pos) bind(c) 
  use iso_c_binding, only: c_long, c_char
  integer(c_long) :: g_utf8_pointer_to_offset
  character(kind=c_char), dimension(*) :: str
  character(kind=c_char), dimension(*) :: pos
end function

! gchar* g_utf8_prev_char (const gchar *p) G_GNUC_PURE;
function g_utf8_prev_char(p) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_utf8_prev_char
  character(kind=c_char), dimension(*) :: p
end function

! gchar* g_utf8_find_next_char (const gchar *p, const gchar *end) G_GNUC_PURE;
function g_utf8_find_next_char(p, end) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_utf8_find_next_char
  character(kind=c_char), dimension(*) :: p
  character(kind=c_char), dimension(*) :: end
end function

! gchar* g_utf8_find_prev_char (const gchar *str, const gchar *p) G_GNUC_PURE;
function g_utf8_find_prev_char(str, p) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_utf8_find_prev_char
  character(kind=c_char), dimension(*) :: str
  character(kind=c_char), dimension(*) :: p
end function

!  glong g_utf8_strlen (const gchar *p, gssize max) G_GNUC_PURE;
function g_utf8_strlen(p, max) bind(c) 
  use iso_c_binding, only: c_long, c_char, c_size_t
  integer(c_long) :: g_utf8_strlen
  character(kind=c_char), dimension(*) :: p
  integer(c_size_t), value :: max
end function

!  gchar* g_utf8_strncpy (gchar *dest, const gchar *src, gsize n);
function g_utf8_strncpy(dest, src, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_strncpy
  character(kind=c_char), dimension(*) :: dest
  character(kind=c_char), dimension(*) :: src
  integer(c_size_t), value :: n
end function

!  gchar* g_utf8_strchr (const gchar *p, gssize len, gunichar c);
function g_utf8_strchr(p, len, c) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int32_t
  type(c_ptr) :: g_utf8_strchr
  character(kind=c_char), dimension(*) :: p
  integer(c_size_t), value :: len
  integer(c_int32_t), value :: c
end function

! gchar* g_utf8_strrchr (const gchar *p, gssize len, gunichar c);
function g_utf8_strrchr(p, len, c) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int32_t
  type(c_ptr) :: g_utf8_strrchr
  character(kind=c_char), dimension(*) :: p
  integer(c_size_t), value :: len
  integer(c_int32_t), value :: c
end function

! gchar* g_utf8_strreverse (const gchar *str, gssize len);
function g_utf8_strreverse(str, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_strreverse
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

!  gunichar2 *g_utf8_to_utf16 (const gchar *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
function g_utf8_to_utf16(str, len, items_read, items_written, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr) :: g_utf8_to_utf16
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_read
  type(c_ptr), value :: items_written
  type(c_ptr), value :: error
end function

! gunichar * g_utf8_to_ucs4 (const gchar *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
function g_utf8_to_ucs4(str, len, items_read, items_written, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr) :: g_utf8_to_ucs4
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_read
  type(c_ptr), value :: items_written
  type(c_ptr), value :: error
end function

! gunichar * g_utf8_to_ucs4_fast (const gchar *str, glong len, glong *items_written) G_GNUC_MALLOC;
function g_utf8_to_ucs4_fast(str, len, items_written) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr) :: g_utf8_to_ucs4_fast
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_written
end function

! gunichar * g_utf16_to_ucs4 (const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
function g_utf16_to_ucs4(str, len, items_read, items_written, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr) :: g_utf16_to_ucs4
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_read
  type(c_ptr), value :: items_written
  type(c_ptr), value :: error
end function

! gchar* g_utf16_to_utf8 (const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
function g_utf16_to_utf8(str, len, items_read, items_written, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr) :: g_utf16_to_utf8
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_read
  type(c_ptr), value :: items_written
  type(c_ptr), value :: error
end function

! gunichar2 *g_ucs4_to_utf16 (const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
function g_ucs4_to_utf16(str, len, items_read, items_written, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr) :: g_ucs4_to_utf16
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_read
  type(c_ptr), value :: items_written
  type(c_ptr), value :: error
end function

! gchar* g_ucs4_to_utf8 (const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
function g_ucs4_to_utf8(str, len, items_read, items_written, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr) :: g_ucs4_to_utf8
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_read
  type(c_ptr), value :: items_written
  type(c_ptr), value :: error
end function

!  gint g_unichar_to_utf8 (gunichar c, gchar *outbuf);
function g_unichar_to_utf8(c, outbuf) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t, c_char
  integer(c_int) :: g_unichar_to_utf8
  integer(c_int32_t), value :: c
  character(kind=c_char), dimension(*) :: outbuf
end function

!  gboolean g_utf8_validate (const gchar *str, gssize max_len, const gchar **end);
function g_utf8_validate(str, max_len, end) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_size_t
  logical(c_bool) :: g_utf8_validate
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: max_len
  character(kind=c_char), dimension(*) :: end
end function

!  gboolean g_unichar_validate (gunichar ch) G_GNUC_CONST;
function g_unichar_validate(ch) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: g_unichar_validate
  integer(c_int32_t), value :: ch
end function

!  gchar *g_utf8_strup (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_utf8_strup(str, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_strup
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

! gchar *g_utf8_strdown (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_utf8_strdown(str, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_strdown
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

! gchar *g_utf8_casefold (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_utf8_casefold(str, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_casefold
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

!  gchar *g_utf8_normalize (const gchar *str, gssize len, GNormalizeMode mode) G_GNUC_MALLOC;
function g_utf8_normalize(str, len, mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_utf8_normalize
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
  integer(c_int), value :: mode
end function

!  gint g_utf8_collate (const gchar *str1, const gchar *str2) G_GNUC_PURE;
function g_utf8_collate(str1, str2) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_utf8_collate
  character(kind=c_char), dimension(*) :: str1
  character(kind=c_char), dimension(*) :: str2
end function

! gchar *g_utf8_collate_key (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_utf8_collate_key(str, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_collate_key
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

! gchar *g_utf8_collate_key_for_filename (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_utf8_collate_key_for_filename(str, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_collate_key_for_filename
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

!  gboolean g_unichar_get_mirror_char (gunichar ch, gunichar *mirrored_ch);
function g_unichar_get_mirror_char(ch, mirrored_ch) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t, c_char
  logical(c_bool) :: g_unichar_get_mirror_char
  integer(c_int32_t), value :: ch
  character(kind=c_char), dimension(*) :: mirrored_ch
end function

!  GUnicodeScript g_unichar_get_script (gunichar ch) G_GNUC_CONST;
function g_unichar_get_script(ch) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_get_script
  integer(c_int32_t), value :: ch
end function

!   gint g_printf (gchar const *format, ...) G_GNUC_PRINTF (1, 2);
function g_printf() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_printf
end function

! gint g_fprintf (FILE *file, gchar const *format, ...) G_GNUC_PRINTF (2, 3);
function g_fprintf() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_fprintf
end function

! gint g_sprintf (gchar *string, gchar const *format, ...) G_GNUC_PRINTF (2, 3);
function g_sprintf() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_sprintf
end function

!  gint g_vprintf (gchar const *format, va_list args);
function g_vprintf(format, args) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_ptr
  integer(c_int) :: g_vprintf
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

! gint g_vfprintf (FILE *file, gchar const *format, va_list args);
function g_vfprintf(file, format, args) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_vfprintf
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

! gint g_vsprintf (gchar *string, gchar const *format, va_list args);
function g_vsprintf(string, format, args) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_ptr
  integer(c_int) :: g_vsprintf
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

! gint g_vasprintf (gchar **string, gchar const *format, va_list args);
function g_vasprintf(string, format, args) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_ptr
  integer(c_int) :: g_vasprintf
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

!   gsize g_base64_encode_step (const guchar *in, gsize len, gboolean break_lines, gchar *out, gint *state, gint *save);
function g_base64_encode_step(in, len, break_lines, out, state, save) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_bool, c_ptr
  integer(c_size_t) :: g_base64_encode_step
  character(kind=c_char), dimension(*) :: in
  integer(c_size_t), value :: len
  logical(c_bool), value :: break_lines
  character(kind=c_char), dimension(*) :: out
  type(c_ptr), value :: state
  type(c_ptr), value :: save
end function

! gsize g_base64_encode_close (gboolean break_lines, gchar *out, gint *state, gint *save);
function g_base64_encode_close(break_lines, out, state, save) bind(c) 
  use iso_c_binding, only: c_size_t, c_bool, c_char, c_ptr
  integer(c_size_t) :: g_base64_encode_close
  logical(c_bool), value :: break_lines
  character(kind=c_char), dimension(*) :: out
  type(c_ptr), value :: state
  type(c_ptr), value :: save
end function

! gchar* g_base64_encode (const guchar *data, gsize len) G_GNUC_MALLOC;
function g_base64_encode(data, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_base64_encode
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: len
end function

! gsize g_base64_decode_step (const gchar *in, gsize len, guchar *out, gint *state, guint *save);
function g_base64_decode_step(in, len, out, state, save) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_base64_decode_step
  character(kind=c_char), dimension(*) :: in
  integer(c_size_t), value :: len
  character(kind=c_char), dimension(*) :: out
  type(c_ptr), value :: state
  type(c_ptr), value :: save
end function

! guchar *g_base64_decode (const gchar *text, gsize *out_len) G_GNUC_MALLOC;
function g_base64_decode(text, out_len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_base64_decode
  character(kind=c_char), dimension(*) :: text
  type(c_ptr), value :: out_len
end function

! guchar *g_base64_decode_inplace (gchar *text, gsize *out_len);
function g_base64_decode_inplace(text, out_len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_base64_decode_inplace
  character(kind=c_char), dimension(*) :: text
  type(c_ptr), value :: out_len
end function

!   GDir * g_dir_open (const gchar *path, guint flags, GError **error);
function g_dir_open(path, flags, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_dir_open
  character(kind=c_char), dimension(*) :: path
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! G_CONST_RETURN gchar *g_dir_read_name (GDir *dir);
function g_dir_read_name(dir) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dir_read_name
  type(c_ptr), value :: dir
end function

! void g_dir_rewind (GDir *dir);
subroutine g_dir_rewind(dir) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: dir
end subroutine

! void g_dir_close (GDir *dir);
subroutine g_dir_close(dir) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: dir
end subroutine

!   GRand* g_rand_new_with_seed (guint32 seed);
function g_rand_new_with_seed(seed) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_rand_new_with_seed
  integer(c_int32_t), value :: seed
end function

! GRand* g_rand_new_with_seed_array (const guint32 *seed, guint seed_length);
function g_rand_new_with_seed_array(seed, seed_length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_rand_new_with_seed_array
  type(c_ptr), value :: seed
  integer(c_int), value :: seed_length
end function

! GRand* g_rand_new (void);
function g_rand_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_rand_new
end function

! void g_rand_free (GRand *rand_);
subroutine g_rand_free(rand_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: rand_
end subroutine

! GRand* g_rand_copy (GRand *rand_);
function g_rand_copy(rand_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_rand_copy
  type(c_ptr), value :: rand_
end function

! void g_rand_set_seed (GRand *rand_, guint32 seed);
subroutine g_rand_set_seed(rand_, seed) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: rand_
  integer(c_int32_t), value :: seed
end subroutine

! void g_rand_set_seed_array (GRand *rand_, const guint32 *seed, guint seed_length);
subroutine g_rand_set_seed_array(rand_, seed, seed_length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: rand_
  type(c_ptr), value :: seed
  integer(c_int), value :: seed_length
end subroutine

!  guint32 g_rand_int (GRand *rand_);
function g_rand_int(rand_) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_rand_int
  type(c_ptr), value :: rand_
end function

! gint32 g_rand_int_range (GRand *rand_, gint32 begin, gint32 end);
function g_rand_int_range(rand_, begin, end) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_rand_int_range
  type(c_ptr), value :: rand_
  integer(c_int32_t), value :: begin
  integer(c_int32_t), value :: end
end function

! gdouble g_rand_double (GRand *rand_);
function g_rand_double(rand_) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: g_rand_double
  type(c_ptr), value :: rand_
end function

! gdouble g_rand_double_range (GRand *rand_, gdouble begin, gdouble end);
function g_rand_double_range(rand_, begin, end) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: g_rand_double_range
  type(c_ptr), value :: rand_
  real(c_double), value :: begin
  real(c_double), value :: end
end function

! void g_random_set_seed (guint32 seed);
subroutine g_random_set_seed(seed) bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t), value :: seed
end subroutine

!  guint32 g_random_int (void);
function g_random_int() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_random_int
end function

! gint32 g_random_int_range (gint32 begin, gint32 end);
function g_random_int_range(begin, end) bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_random_int_range
  integer(c_int32_t), value :: begin
  integer(c_int32_t), value :: end
end function

! gdouble g_random_double (void);
function g_random_double() bind(c) 
  use iso_c_binding, only: c_double
  real(c_double) :: g_random_double
end function

! gdouble g_random_double_range (gdouble begin, gdouble end);
function g_random_double_range(begin, end) bind(c) 
  use iso_c_binding, only: c_double
  real(c_double) :: g_random_double_range
  real(c_double), value :: begin
  real(c_double), value :: end
end function

!   void g_date_time_unref (GDateTime *datetime);
subroutine g_date_time_unref(datetime) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: datetime
end subroutine

! GDateTime * g_date_time_ref (GDateTime *datetime);
function g_date_time_ref(datetime) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_ref
  type(c_ptr), value :: datetime
end function

!  GDateTime * g_date_time_new_now (GTimeZone *tz);
function g_date_time_new_now(tz) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_new_now
  type(c_ptr), value :: tz
end function

! GDateTime * g_date_time_new_now_local (void);
function g_date_time_new_now_local() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_new_now_local
end function

! GDateTime * g_date_time_new_now_utc (void);
function g_date_time_new_now_utc() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_new_now_utc
end function

!  GDateTime * g_date_time_new_from_unix_local (gint64 t);
function g_date_time_new_from_unix_local(t) bind(c) 
  use iso_c_binding, only: c_ptr, c_int64_t
  type(c_ptr) :: g_date_time_new_from_unix_local
  integer(c_int64_t), value :: t
end function

! GDateTime * g_date_time_new_from_unix_utc (gint64 t);
function g_date_time_new_from_unix_utc(t) bind(c) 
  use iso_c_binding, only: c_ptr, c_int64_t
  type(c_ptr) :: g_date_time_new_from_unix_utc
  integer(c_int64_t), value :: t
end function

!  GDateTime * g_date_time_new_from_timeval_local (const GTimeVal *tv);
function g_date_time_new_from_timeval_local(tv) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_new_from_timeval_local
  type(c_ptr), value :: tv
end function

! GDateTime * g_date_time_new_from_timeval_utc (const GTimeVal *tv);
function g_date_time_new_from_timeval_utc(tv) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_new_from_timeval_utc
  type(c_ptr), value :: tv
end function

!  GDateTime * g_date_time_new (GTimeZone *tz, gint year, gint month, gint day, gint hour, gint minute, gdouble seconds);
function g_date_time_new(tz, year, month, day, hour, minute, seconds) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_double
  type(c_ptr) :: g_date_time_new
  type(c_ptr), value :: tz
  integer(c_int), value :: year
  integer(c_int), value :: month
  integer(c_int), value :: day
  integer(c_int), value :: hour
  integer(c_int), value :: minute
  real(c_double), value :: seconds
end function

! GDateTime * g_date_time_new_local (gint year, gint month, gint day, gint hour, gint minute, gdouble seconds);
function g_date_time_new_local(year, month, day, hour, minute, seconds) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_double
  type(c_ptr) :: g_date_time_new_local
  integer(c_int), value :: year
  integer(c_int), value :: month
  integer(c_int), value :: day
  integer(c_int), value :: hour
  integer(c_int), value :: minute
  real(c_double), value :: seconds
end function

! GDateTime * g_date_time_new_utc (gint year, gint month, gint day, gint hour, gint minute, gdouble seconds);
function g_date_time_new_utc(year, month, day, hour, minute, seconds) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_double
  type(c_ptr) :: g_date_time_new_utc
  integer(c_int), value :: year
  integer(c_int), value :: month
  integer(c_int), value :: day
  integer(c_int), value :: hour
  integer(c_int), value :: minute
  real(c_double), value :: seconds
end function

!  G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add (GDateTime *datetime, GTimeSpan timespan);
function g_date_time_add(datetime, timespan) bind(c) 
  use iso_c_binding, only: c_ptr, c_int64_t
  type(c_ptr) :: g_date_time_add
  type(c_ptr), value :: datetime
  integer(c_int64_t), value :: timespan
end function

!  G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_years (GDateTime *datetime, gint years);
function g_date_time_add_years(datetime, years) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_date_time_add_years
  type(c_ptr), value :: datetime
  integer(c_int), value :: years
end function

! G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_months (GDateTime *datetime, gint months);
function g_date_time_add_months(datetime, months) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_date_time_add_months
  type(c_ptr), value :: datetime
  integer(c_int), value :: months
end function

! G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_weeks (GDateTime *datetime, gint weeks);
function g_date_time_add_weeks(datetime, weeks) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_date_time_add_weeks
  type(c_ptr), value :: datetime
  integer(c_int), value :: weeks
end function

! G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_days (GDateTime *datetime, gint days);
function g_date_time_add_days(datetime, days) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_date_time_add_days
  type(c_ptr), value :: datetime
  integer(c_int), value :: days
end function

!  G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_hours (GDateTime *datetime, gint hours);
function g_date_time_add_hours(datetime, hours) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_date_time_add_hours
  type(c_ptr), value :: datetime
  integer(c_int), value :: hours
end function

! G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_minutes (GDateTime *datetime, gint minutes);
function g_date_time_add_minutes(datetime, minutes) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_date_time_add_minutes
  type(c_ptr), value :: datetime
  integer(c_int), value :: minutes
end function

! G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_seconds (GDateTime *datetime, gdouble seconds);
function g_date_time_add_seconds(datetime, seconds) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr) :: g_date_time_add_seconds
  type(c_ptr), value :: datetime
  real(c_double), value :: seconds
end function

!  G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_full (GDateTime *datetime, gint years, gint months, gint days, gint hours, gint minutes, gdouble seconds);
function g_date_time_add_full(datetime, years, months, days, hours, minutes, sec&
      &onds) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_double
  type(c_ptr) :: g_date_time_add_full
  type(c_ptr), value :: datetime
  integer(c_int), value :: years
  integer(c_int), value :: months
  integer(c_int), value :: days
  integer(c_int), value :: hours
  integer(c_int), value :: minutes
  real(c_double), value :: seconds
end function

!  gint g_date_time_compare (gconstpointer dt1, gconstpointer dt2);
function g_date_time_compare(dt1, dt2) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_compare
  type(c_ptr), value :: dt1
  type(c_ptr), value :: dt2
end function

! GTimeSpan g_date_time_difference (GDateTime *end, GDateTime *begin);
function g_date_time_difference(end, begin) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_date_time_difference
  type(c_ptr), value :: end
  type(c_ptr), value :: begin
end function

! guint g_date_time_hash (gconstpointer datetime);
function g_date_time_hash(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_hash
  type(c_ptr), value :: datetime
end function

! gboolean g_date_time_equal (gconstpointer dt1, gconstpointer dt2);
function g_date_time_equal(dt1, dt2) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_date_time_equal
  type(c_ptr), value :: dt1
  type(c_ptr), value :: dt2
end function

!  void g_date_time_get_ymd (GDateTime *datetime, gint *year, gint *month, gint *day);
subroutine g_date_time_get_ymd(datetime, year, month, day) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: datetime
  type(c_ptr), value :: year
  type(c_ptr), value :: month
  type(c_ptr), value :: day
end subroutine

!  gint g_date_time_get_year (GDateTime *datetime);
function g_date_time_get_year(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_year
  type(c_ptr), value :: datetime
end function

! gint g_date_time_get_month (GDateTime *datetime);
function g_date_time_get_month(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_month
  type(c_ptr), value :: datetime
end function

! gint g_date_time_get_day_of_month (GDateTime *datetime);
function g_date_time_get_day_of_month(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_day_of_month
  type(c_ptr), value :: datetime
end function

!  gint g_date_time_get_week_numbering_year (GDateTime *datetime);
function g_date_time_get_week_numbering_year(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_week_numbering_year
  type(c_ptr), value :: datetime
end function

! gint g_date_time_get_week_of_year (GDateTime *datetime);
function g_date_time_get_week_of_year(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_week_of_year
  type(c_ptr), value :: datetime
end function

! gint g_date_time_get_day_of_week (GDateTime *datetime);
function g_date_time_get_day_of_week(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_day_of_week
  type(c_ptr), value :: datetime
end function

!  gint g_date_time_get_day_of_year (GDateTime *datetime);
function g_date_time_get_day_of_year(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_day_of_year
  type(c_ptr), value :: datetime
end function

!  gint g_date_time_get_hour (GDateTime *datetime);
function g_date_time_get_hour(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_hour
  type(c_ptr), value :: datetime
end function

! gint g_date_time_get_minute (GDateTime *datetime);
function g_date_time_get_minute(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_minute
  type(c_ptr), value :: datetime
end function

! gint g_date_time_get_second (GDateTime *datetime);
function g_date_time_get_second(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_second
  type(c_ptr), value :: datetime
end function

! gint g_date_time_get_microsecond (GDateTime *datetime);
function g_date_time_get_microsecond(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_microsecond
  type(c_ptr), value :: datetime
end function

! gdouble g_date_time_get_seconds (GDateTime *datetime);
function g_date_time_get_seconds(datetime) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: g_date_time_get_seconds
  type(c_ptr), value :: datetime
end function

!  gint64 g_date_time_to_unix (GDateTime *datetime);
function g_date_time_to_unix(datetime) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_date_time_to_unix
  type(c_ptr), value :: datetime
end function

! gboolean g_date_time_to_timeval (GDateTime *datetime, GTimeVal *tv);
function g_date_time_to_timeval(datetime, tv) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_date_time_to_timeval
  type(c_ptr), value :: datetime
  type(c_ptr), value :: tv
end function

!  GTimeSpan g_date_time_get_utc_offset (GDateTime *datetime);
function g_date_time_get_utc_offset(datetime) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_date_time_get_utc_offset
  type(c_ptr), value :: datetime
end function

! const gchar * g_date_time_get_timezone_abbreviation (GDateTime *datetime);
function g_date_time_get_timezone_abbreviation(datetime) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_get_timezone_abbreviation
  type(c_ptr), value :: datetime
end function

! gboolean g_date_time_is_daylight_savings (GDateTime *datetime);
function g_date_time_is_daylight_savings(datetime) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_date_time_is_daylight_savings
  type(c_ptr), value :: datetime
end function

!  GDateTime * g_date_time_to_timezone (GDateTime *datetime, GTimeZone *tz);
function g_date_time_to_timezone(datetime, tz) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_to_timezone
  type(c_ptr), value :: datetime
  type(c_ptr), value :: tz
end function

! GDateTime * g_date_time_to_local (GDateTime *datetime);
function g_date_time_to_local(datetime) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_to_local
  type(c_ptr), value :: datetime
end function

! GDateTime * g_date_time_to_utc (GDateTime *datetime);
function g_date_time_to_utc(datetime) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_to_utc
  type(c_ptr), value :: datetime
end function

!  gchar * g_date_time_format (GDateTime *datetime, const gchar *format) G_GNUC_MALLOC;
function g_date_time_format(datetime, format) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_date_time_format
  type(c_ptr), value :: datetime
  character(kind=c_char), dimension(*) :: format
end function

!   void g_hook_list_init (GHookList *hook_list, guint hook_size);
subroutine g_hook_list_init(hook_list, hook_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: hook_list
  integer(c_int), value :: hook_size
end subroutine

! void g_hook_list_clear (GHookList *hook_list);
subroutine g_hook_list_clear(hook_list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hook_list
end subroutine

! GHook* g_hook_alloc (GHookList *hook_list);
function g_hook_alloc(hook_list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_hook_alloc
  type(c_ptr), value :: hook_list
end function

! void g_hook_free (GHookList *hook_list, GHook *hook);
subroutine g_hook_free(hook_list, hook) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
end subroutine

! GHook * g_hook_ref (GHookList *hook_list, GHook *hook);
function g_hook_ref(hook_list, hook) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_hook_ref
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
end function

! void g_hook_unref (GHookList *hook_list, GHook *hook);
subroutine g_hook_unref(hook_list, hook) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
end subroutine

! gboolean g_hook_destroy (GHookList *hook_list, gulong hook_id);
function g_hook_destroy(hook_list, hook_id) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_long
  logical(c_bool) :: g_hook_destroy
  type(c_ptr), value :: hook_list
  integer(c_long), value :: hook_id
end function

! void g_hook_destroy_link (GHookList *hook_list, GHook *hook);
subroutine g_hook_destroy_link(hook_list, hook) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
end subroutine

! void g_hook_prepend (GHookList *hook_list, GHook *hook);
subroutine g_hook_prepend(hook_list, hook) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
end subroutine

! void g_hook_insert_before (GHookList *hook_list, GHook *sibling, GHook *hook);
subroutine g_hook_insert_before(hook_list, sibling, hook) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: sibling
  type(c_ptr), value :: hook
end subroutine

! void g_hook_insert_sorted (GHookList *hook_list, GHook *hook, GHookCompareFunc func);
subroutine g_hook_insert_sorted(hook_list, hook, func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
  type(c_funptr), value :: func
end subroutine

! GHook* g_hook_get (GHookList *hook_list, gulong hook_id);
function g_hook_get(hook_list, hook_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr) :: g_hook_get
  type(c_ptr), value :: hook_list
  integer(c_long), value :: hook_id
end function

! GHook* g_hook_find (GHookList *hook_list, gboolean need_valids, GHookFindFunc func, gpointer data);
function g_hook_find(hook_list, need_valids, func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_funptr
  type(c_ptr) :: g_hook_find
  type(c_ptr), value :: hook_list
  logical(c_bool), value :: need_valids
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end function

! GHook* g_hook_find_data (GHookList *hook_list, gboolean need_valids, gpointer data);
function g_hook_find_data(hook_list, need_valids, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: g_hook_find_data
  type(c_ptr), value :: hook_list
  logical(c_bool), value :: need_valids
  type(c_ptr), value :: data
end function

! GHook* g_hook_find_func (GHookList *hook_list, gboolean need_valids, gpointer func);
function g_hook_find_func(hook_list, need_valids, func) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: g_hook_find_func
  type(c_ptr), value :: hook_list
  logical(c_bool), value :: need_valids
  type(c_ptr), value :: func
end function

! GHook* g_hook_find_func_data (GHookList *hook_list, gboolean need_valids, gpointer func, gpointer data);
function g_hook_find_func_data(hook_list, need_valids, func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: g_hook_find_func_data
  type(c_ptr), value :: hook_list
  logical(c_bool), value :: need_valids
  type(c_ptr), value :: func
  type(c_ptr), value :: data
end function

!  GHook* g_hook_first_valid (GHookList *hook_list, gboolean may_be_in_call);
function g_hook_first_valid(hook_list, may_be_in_call) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: g_hook_first_valid
  type(c_ptr), value :: hook_list
  logical(c_bool), value :: may_be_in_call
end function

!  GHook* g_hook_next_valid (GHookList *hook_list, GHook *hook, gboolean may_be_in_call);
function g_hook_next_valid(hook_list, hook, may_be_in_call) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: g_hook_next_valid
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
  logical(c_bool), value :: may_be_in_call
end function

!  gint g_hook_compare_ids (GHook *new_hook, GHook *sibling);
function g_hook_compare_ids(new_hook, sibling) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_hook_compare_ids
  type(c_ptr), value :: new_hook
  type(c_ptr), value :: sibling
end function

!  void g_hook_list_invoke (GHookList *hook_list, gboolean may_recurse);
subroutine g_hook_list_invoke(hook_list, may_recurse) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: hook_list
  logical(c_bool), value :: may_recurse
end subroutine

!  void g_hook_list_invoke_check (GHookList *hook_list, gboolean may_recurse);
subroutine g_hook_list_invoke_check(hook_list, may_recurse) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: hook_list
  logical(c_bool), value :: may_recurse
end subroutine

!  void g_hook_list_marshal (GHookList *hook_list, gboolean may_recurse, GHookMarshaller marshaller, gpointer marshal_data);
subroutine g_hook_list_marshal(hook_list, may_recurse, marshaller, marshal_data)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_funptr
  type(c_ptr), value :: hook_list
  logical(c_bool), value :: may_recurse
  type(c_funptr), value :: marshaller
  type(c_ptr), value :: marshal_data
end subroutine

! void g_hook_list_marshal_check (GHookList *hook_list, gboolean may_recurse, GHookCheckMarshaller marshaller, gpointer marshal_data);
subroutine g_hook_list_marshal_check(hook_list, may_recurse, marshaller, marshal&
      &_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_funptr
  type(c_ptr), value :: hook_list
  logical(c_bool), value :: may_recurse
  type(c_funptr), value :: marshaller
  type(c_ptr), value :: marshal_data
end subroutine

!   GCache* g_cache_new (GCacheNewFunc value_new_func, GCacheDestroyFunc value_destroy_func, GCacheDupFunc key_dup_func, GCacheDestroyFunc key_destroy_func, GHashFunc hash_key_func, GHashFunc hash_value_func, GEqualFunc key_equal_func);
function g_cache_new(value_new_func, value_destroy_func, key_dup_func, key_destr&
      &oy_func, hash_key_func, hash_value_func, key_equal_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_cache_new
  type(c_funptr), value :: value_new_func
  type(c_funptr), value :: value_destroy_func
  type(c_funptr), value :: key_dup_func
  type(c_funptr), value :: key_destroy_func
  type(c_funptr), value :: hash_key_func
  type(c_funptr), value :: hash_value_func
  type(c_funptr), value :: key_equal_func
end function

! void g_cache_destroy (GCache *cache);
subroutine g_cache_destroy(cache) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cache
end subroutine

! gpointer g_cache_insert (GCache *cache, gpointer key);
function g_cache_insert(cache, key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_cache_insert
  type(c_ptr), value :: cache
  type(c_ptr), value :: key
end function

! void g_cache_remove (GCache *cache, gconstpointer value);
subroutine g_cache_remove(cache, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cache
  type(c_ptr), value :: value
end subroutine

! void g_cache_key_foreach (GCache *cache, GHFunc func, gpointer user_data);
subroutine g_cache_key_foreach(cache, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: cache
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!  void g_cache_value_foreach (GCache *cache, GHFunc func, gpointer user_data);
subroutine g_cache_value_foreach(cache, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: cache
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!   gboolean g_variant_type_string_is_valid (const gchar *type_string);
function g_variant_type_string_is_valid(type_string) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_variant_type_string_is_valid
  character(kind=c_char), dimension(*) :: type_string
end function

! gboolean g_variant_type_string_scan (const gchar *string, const gchar *limit, const gchar **endptr);
function g_variant_type_string_scan(string, limit, endptr) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_variant_type_string_scan
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: limit
  character(kind=c_char), dimension(*) :: endptr
end function

!  void g_variant_type_free (GVariantType *type);
subroutine g_variant_type_free(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: type
end subroutine

! GVariantType * g_variant_type_copy (const GVariantType *type);
function g_variant_type_copy(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_copy
  type(c_ptr), value :: type
end function

! GVariantType * g_variant_type_new (const gchar *type_string);
function g_variant_type_new(type_string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_type_new
  character(kind=c_char), dimension(*) :: type_string
end function

!  gsize g_variant_type_get_string_length (const GVariantType *type);
function g_variant_type_get_string_length(type) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_variant_type_get_string_length
  type(c_ptr), value :: type
end function

! const gchar * g_variant_type_peek_string (const GVariantType *type);
function g_variant_type_peek_string(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_peek_string
  type(c_ptr), value :: type
end function

! gchar * g_variant_type_dup_string (const GVariantType *type);
function g_variant_type_dup_string(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_dup_string
  type(c_ptr), value :: type
end function

!  gboolean g_variant_type_is_definite (const GVariantType *type);
function g_variant_type_is_definite(type) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_variant_type_is_definite
  type(c_ptr), value :: type
end function

! gboolean g_variant_type_is_container (const GVariantType *type);
function g_variant_type_is_container(type) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_variant_type_is_container
  type(c_ptr), value :: type
end function

! gboolean g_variant_type_is_basic (const GVariantType *type);
function g_variant_type_is_basic(type) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_variant_type_is_basic
  type(c_ptr), value :: type
end function

! gboolean g_variant_type_is_maybe (const GVariantType *type);
function g_variant_type_is_maybe(type) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_variant_type_is_maybe
  type(c_ptr), value :: type
end function

! gboolean g_variant_type_is_array (const GVariantType *type);
function g_variant_type_is_array(type) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_variant_type_is_array
  type(c_ptr), value :: type
end function

! gboolean g_variant_type_is_tuple (const GVariantType *type);
function g_variant_type_is_tuple(type) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_variant_type_is_tuple
  type(c_ptr), value :: type
end function

! gboolean g_variant_type_is_dict_entry (const GVariantType *type);
function g_variant_type_is_dict_entry(type) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_variant_type_is_dict_entry
  type(c_ptr), value :: type
end function

! gboolean g_variant_type_is_variant (const GVariantType *type);
function g_variant_type_is_variant(type) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_variant_type_is_variant
  type(c_ptr), value :: type
end function

!  guint g_variant_type_hash (gconstpointer type);
function g_variant_type_hash(type) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_type_hash
  type(c_ptr), value :: type
end function

! gboolean g_variant_type_equal (gconstpointer type1, gconstpointer type2);
function g_variant_type_equal(type1, type2) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_variant_type_equal
  type(c_ptr), value :: type1
  type(c_ptr), value :: type2
end function

!  gboolean g_variant_type_is_subtype_of (const GVariantType *type, const GVariantType *supertype);
function g_variant_type_is_subtype_of(type, supertype) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_variant_type_is_subtype_of
  type(c_ptr), value :: type
  type(c_ptr), value :: supertype
end function

!  const GVariantType * g_variant_type_element (const GVariantType *type);
function g_variant_type_element(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_element
  type(c_ptr), value :: type
end function

! const GVariantType * g_variant_type_first (const GVariantType *type);
function g_variant_type_first(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_first
  type(c_ptr), value :: type
end function

! const GVariantType * g_variant_type_next (const GVariantType *type);
function g_variant_type_next(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_next
  type(c_ptr), value :: type
end function

! gsize g_variant_type_n_items (const GVariantType *type);
function g_variant_type_n_items(type) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_variant_type_n_items
  type(c_ptr), value :: type
end function

! const GVariantType * g_variant_type_key (const GVariantType *type);
function g_variant_type_key(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_key
  type(c_ptr), value :: type
end function

! const GVariantType * g_variant_type_value (const GVariantType *type);
function g_variant_type_value(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_value
  type(c_ptr), value :: type
end function

!  GVariantType * g_variant_type_new_array (const GVariantType *element);
function g_variant_type_new_array(element) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_new_array
  type(c_ptr), value :: element
end function

! GVariantType * g_variant_type_new_maybe (const GVariantType *element);
function g_variant_type_new_maybe(element) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_new_maybe
  type(c_ptr), value :: element
end function

! GVariantType * g_variant_type_new_tuple (const GVariantType * const *items, gint length);
function g_variant_type_new_tuple(items, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_variant_type_new_tuple
  type(c_ptr), value :: items
  integer(c_int), value :: length
end function

! GVariantType * g_variant_type_new_dict_entry (const GVariantType *key, const GVariantType *value);
function g_variant_type_new_dict_entry(key, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_new_dict_entry
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end function

!  const GVariantType * g_variant_type_checked_ (const gchar *);
function g_variant_type_checked_() bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_type_checked_
end function

!   GError* g_error_new (GQuark domain, gint code, const gchar *format, ...) G_GNUC_PRINTF (3, 4);
function g_error_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_error_new
end function

!  GError* g_error_new_literal (GQuark domain, gint code, const gchar *message);
function g_error_new_literal(domain, code, message) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_int, c_char
  type(c_ptr) :: g_error_new_literal
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
  character(kind=c_char), dimension(*) :: message
end function

! GError* g_error_new_valist (GQuark domain, gint code, const gchar *format, va_list args);
function g_error_new_valist(domain, code, format, args) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_int, c_char
  type(c_ptr) :: g_error_new_valist
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

!  void g_error_free (GError *error);
subroutine g_error_free(error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: error
end subroutine

! GError* g_error_copy (const GError *error);
function g_error_copy(error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_error_copy
  type(c_ptr), value :: error
end function

!  gboolean g_error_matches (const GError *error, GQuark domain, gint code);
function g_error_matches(error, domain, code) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int32_t, c_int
  logical(c_bool) :: g_error_matches
  type(c_ptr), value :: error
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
end function

!  void g_set_error (GError **err, GQuark domain, gint code, const gchar *format, ...) G_GNUC_PRINTF (4, 5);
subroutine g_set_error() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  void g_set_error_literal (GError **err, GQuark domain, gint code, const gchar *message);
subroutine g_set_error_literal(err, domain, code, message) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_int, c_char
  type(c_ptr), value :: err
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
  character(kind=c_char), dimension(*) :: message
end subroutine

!  void g_propagate_error (GError **dest, GError *src);
subroutine g_propagate_error(dest, src) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: dest
  type(c_ptr), value :: src
end subroutine

!  void g_clear_error (GError **err);
subroutine g_clear_error(err) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: err
end subroutine

!  void g_prefix_error (GError **err, const gchar *format, ...) G_GNUC_PRINTF (2, 3);
subroutine g_prefix_error() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  void g_propagate_prefixed_error (GError **dest, GError *src, const gchar *format, ...) G_GNUC_PRINTF (3, 4);
subroutine g_propagate_prefixed_error() bind(c) 
  use iso_c_binding, only: 
end subroutine

!   gssize g_checksum_type_get_length (GChecksumType checksum_type);
function g_checksum_type_get_length(checksum_type) bind(c) 
  use iso_c_binding, only: c_size_t, c_int
  integer(c_size_t) :: g_checksum_type_get_length
  integer(c_int), value :: checksum_type
end function

!  GChecksum * g_checksum_new (GChecksumType checksum_type);
function g_checksum_new(checksum_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_checksum_new
  integer(c_int), value :: checksum_type
end function

! void g_checksum_reset (GChecksum *checksum);
subroutine g_checksum_reset(checksum) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: checksum
end subroutine

! GChecksum * g_checksum_copy (const GChecksum *checksum);
function g_checksum_copy(checksum) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_checksum_copy
  type(c_ptr), value :: checksum
end function

! void g_checksum_free (GChecksum *checksum);
subroutine g_checksum_free(checksum) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: checksum
end subroutine

! void g_checksum_update (GChecksum *checksum, const guchar *data, gssize length);
subroutine g_checksum_update(checksum, data, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr), value :: checksum
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: length
end subroutine

! G_CONST_RETURN gchar *g_checksum_get_string (GChecksum *checksum);
function g_checksum_get_string(checksum) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_checksum_get_string
  type(c_ptr), value :: checksum
end function

! void g_checksum_get_digest (GChecksum *checksum, guint8 *buffer, gsize *digest_len);
subroutine g_checksum_get_digest(checksum, buffer, digest_len) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: checksum
  type(c_ptr), value :: buffer
  type(c_ptr), value :: digest_len
end subroutine

!  gchar *g_compute_checksum_for_data (GChecksumType checksum_type, const guchar *data, gsize length);
function g_compute_checksum_for_data(checksum_type, data, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char, c_size_t
  type(c_ptr) :: g_compute_checksum_for_data
  integer(c_int), value :: checksum_type
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: length
end function

! gchar *g_compute_checksum_for_string (GChecksumType checksum_type, const gchar *str, gssize length);
function g_compute_checksum_for_string(checksum_type, str, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char, c_size_t
  type(c_ptr) :: g_compute_checksum_for_string
  integer(c_int), value :: checksum_type
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: length
end function

!   GQuark g_thread_error_quark (void);
function g_thread_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_thread_error_quark
end function

!  guint64 (*g_thread_gettime) (void);
function guint64() bind(c) 
  use iso_c_binding, only: c_int64_t
  integer(c_int64_t) :: guint64
end function

!  void g_thread_init (GThreadFunctions *vtable);
subroutine g_thread_init(vtable) bind(c) 
  use iso_c_binding, only: c_funptr
  type(c_funptr), value :: vtable
end subroutine

!  void g_thread_init_with_errorcheck_mutexes (GThreadFunctions* vtable);
subroutine g_thread_init_with_errorcheck_mutexes(vtable) bind(c) 
  use iso_c_binding, only: c_funptr
  type(c_funptr), value :: vtable
end subroutine

!  gboolean g_thread_get_initialized (void);
function g_thread_get_initialized() bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool) :: g_thread_get_initialized
end function

!  GMutex* g_static_mutex_get_mutex_impl (GMutex **mutex);
function g_static_mutex_get_mutex_impl(mutex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_static_mutex_get_mutex_impl
  type(c_ptr), value :: mutex
end function

!  GThread* g_thread_create_full (GThreadFunc func, gpointer data, gulong stack_size, gboolean joinable, gboolean bound, GThreadPriority priority, GError **error);
function g_thread_create_full(func, data, stack_size, joinable, bound, priority,&
      & error) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr, c_long, c_bool, c_int
  type(c_ptr) :: g_thread_create_full
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  integer(c_long), value :: stack_size
  logical(c_bool), value :: joinable
  logical(c_bool), value :: bound
  integer(c_int), value :: priority
  type(c_ptr), value :: error
end function

! GThread* g_thread_self (void);
function g_thread_self() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_thread_self
end function

! void g_thread_exit (gpointer retval);
subroutine g_thread_exit(retval) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: retval
end subroutine

! gpointer g_thread_join (GThread *thread);
function g_thread_join(thread) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_thread_join
  type(c_ptr), value :: thread
end function

!  void g_thread_set_priority (GThread *thread, GThreadPriority priority);
subroutine g_thread_set_priority(thread, priority) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: thread
  integer(c_int), value :: priority
end subroutine

!  void g_static_mutex_init (GStaticMutex *mutex);
subroutine g_static_mutex_init(mutex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mutex
end subroutine

! void g_static_mutex_free (GStaticMutex *mutex);
subroutine g_static_mutex_free(mutex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mutex
end subroutine

!  void g_static_private_init (GStaticPrivate *private_key);
subroutine g_static_private_init(private_key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: private_key
end subroutine

! gpointer g_static_private_get (GStaticPrivate *private_key);
function g_static_private_get(private_key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_static_private_get
  type(c_ptr), value :: private_key
end function

! void g_static_private_set (GStaticPrivate *private_key, gpointer data, GDestroyNotify notify);
subroutine g_static_private_set(private_key, data, notify) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: private_key
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end subroutine

! void g_static_private_free (GStaticPrivate *private_key);
subroutine g_static_private_free(private_key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: private_key
end subroutine

!  void g_static_rec_mutex_init (GStaticRecMutex *mutex);
subroutine g_static_rec_mutex_init(mutex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mutex
end subroutine

! void g_static_rec_mutex_lock (GStaticRecMutex *mutex);
subroutine g_static_rec_mutex_lock(mutex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mutex
end subroutine

! gboolean g_static_rec_mutex_trylock (GStaticRecMutex *mutex);
function g_static_rec_mutex_trylock(mutex) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_static_rec_mutex_trylock
  type(c_ptr), value :: mutex
end function

! void g_static_rec_mutex_unlock (GStaticRecMutex *mutex);
subroutine g_static_rec_mutex_unlock(mutex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mutex
end subroutine

! void g_static_rec_mutex_lock_full (GStaticRecMutex *mutex, guint depth);
subroutine g_static_rec_mutex_lock_full(mutex, depth) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: mutex
  integer(c_int), value :: depth
end subroutine

! guint g_static_rec_mutex_unlock_full (GStaticRecMutex *mutex);
function g_static_rec_mutex_unlock_full(mutex) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_static_rec_mutex_unlock_full
  type(c_ptr), value :: mutex
end function

! void g_static_rec_mutex_free (GStaticRecMutex *mutex);
subroutine g_static_rec_mutex_free(mutex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mutex
end subroutine

!  void g_static_rw_lock_init (GStaticRWLock* lock);
subroutine g_static_rw_lock_init(lock) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: lock
end subroutine

! void g_static_rw_lock_reader_lock (GStaticRWLock* lock);
subroutine g_static_rw_lock_reader_lock(lock) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: lock
end subroutine

! gboolean g_static_rw_lock_reader_trylock (GStaticRWLock* lock);
function g_static_rw_lock_reader_trylock(lock) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_static_rw_lock_reader_trylock
  type(c_ptr), value :: lock
end function

! void g_static_rw_lock_reader_unlock (GStaticRWLock* lock);
subroutine g_static_rw_lock_reader_unlock(lock) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: lock
end subroutine

! void g_static_rw_lock_writer_lock (GStaticRWLock* lock);
subroutine g_static_rw_lock_writer_lock(lock) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: lock
end subroutine

! gboolean g_static_rw_lock_writer_trylock (GStaticRWLock* lock);
function g_static_rw_lock_writer_trylock(lock) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_static_rw_lock_writer_trylock
  type(c_ptr), value :: lock
end function

! void g_static_rw_lock_writer_unlock (GStaticRWLock* lock);
subroutine g_static_rw_lock_writer_unlock(lock) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: lock
end subroutine

! void g_static_rw_lock_free (GStaticRWLock* lock);
subroutine g_static_rw_lock_free(lock) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: lock
end subroutine

!  void g_thread_foreach (GFunc thread_func, gpointer user_data);
subroutine g_thread_foreach(thread_func, user_data) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr), value :: thread_func
  type(c_ptr), value :: user_data
end subroutine

!  gpointer g_once_impl (GOnce *once, GThreadFunc func, gpointer arg);
function g_once_impl(once, func, arg) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_once_impl
  type(c_ptr), value :: once
  type(c_funptr), value :: func
  type(c_ptr), value :: arg
end function

! gboolean g_once_init_enter_impl (volatile gsize *value_location);
function g_once_init_enter_impl(value_location) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_once_init_enter_impl
  type(c_ptr), value :: value_location
end function

! void g_once_init_leave (volatile gsize *value_location, gsize initialization_value);
subroutine g_once_init_leave(value_location, initialization_value) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: value_location
  integer(c_size_t), value :: initialization_value
end subroutine

!   GTimer* g_timer_new (void);
function g_timer_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_timer_new
end function

! void g_timer_destroy (GTimer *timer);
subroutine g_timer_destroy(timer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: timer
end subroutine

! void g_timer_start (GTimer *timer);
subroutine g_timer_start(timer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: timer
end subroutine

! void g_timer_stop (GTimer *timer);
subroutine g_timer_stop(timer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: timer
end subroutine

! void g_timer_reset (GTimer *timer);
subroutine g_timer_reset(timer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: timer
end subroutine

! void g_timer_continue (GTimer *timer);
subroutine g_timer_continue(timer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: timer
end subroutine

! gdouble g_timer_elapsed (GTimer *timer, gulong *microseconds);
function g_timer_elapsed(timer, microseconds) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: g_timer_elapsed
  type(c_ptr), value :: timer
  type(c_ptr), value :: microseconds
end function

!  void g_usleep (gulong microseconds);
subroutine g_usleep(microseconds) bind(c) 
  use iso_c_binding, only: c_long
  integer(c_long), value :: microseconds
end subroutine

!  void g_time_val_add (GTimeVal *time_, glong microseconds);
subroutine g_time_val_add(time_, microseconds) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr), value :: time_
  integer(c_long), value :: microseconds
end subroutine

! gboolean g_time_val_from_iso8601 (const gchar *iso_date, GTimeVal *time_);
function g_time_val_from_iso8601(iso_date, time_) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_ptr
  logical(c_bool) :: g_time_val_from_iso8601
  character(kind=c_char), dimension(*) :: iso_date
  type(c_ptr), value :: time_
end function

! gchar* g_time_val_to_iso8601 (GTimeVal *time_) G_GNUC_MALLOC;
function g_time_val_to_iso8601(time_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_time_val_to_iso8601
  type(c_ptr), value :: time_
end function

!   GQuark g_bookmark_file_error_quark (void);
function g_bookmark_file_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_bookmark_file_error_quark
end function

!  GBookmarkFile *g_bookmark_file_new (void);
function g_bookmark_file_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_bookmark_file_new
end function

! void g_bookmark_file_free (GBookmarkFile *bookmark);
subroutine g_bookmark_file_free(bookmark) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: bookmark
end subroutine

!  gboolean g_bookmark_file_load_from_file (GBookmarkFile *bookmark, const gchar *filename, GError **error);
function g_bookmark_file_load_from_file(bookmark, filename, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_bookmark_file_load_from_file
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: error
end function

! gboolean g_bookmark_file_load_from_data (GBookmarkFile *bookmark, const gchar *data, gsize length, GError **error);
function g_bookmark_file_load_from_data(bookmark, data, length, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_size_t
  logical(c_bool) :: g_bookmark_file_load_from_data
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: length
  type(c_ptr), value :: error
end function

! gboolean g_bookmark_file_load_from_data_dirs (GBookmarkFile *bookmark, const gchar *file, gchar **full_path, GError **error);
function g_bookmark_file_load_from_data_dirs(bookmark, file, full_path, error) b&
      &ind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_bookmark_file_load_from_data_dirs
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: file
  character(kind=c_char), dimension(*) :: full_path
  type(c_ptr), value :: error
end function

! gchar * g_bookmark_file_to_data (GBookmarkFile *bookmark, gsize *length, GError **error) G_GNUC_MALLOC;
function g_bookmark_file_to_data(bookmark, length, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_bookmark_file_to_data
  type(c_ptr), value :: bookmark
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! gboolean g_bookmark_file_to_file (GBookmarkFile *bookmark, const gchar *filename, GError **error);
function g_bookmark_file_to_file(bookmark, filename, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_bookmark_file_to_file
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: error
end function

!  void g_bookmark_file_set_title (GBookmarkFile *bookmark, const gchar *uri, const gchar *title);
subroutine g_bookmark_file_set_title(bookmark, uri, title) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: title
end subroutine

! gchar * g_bookmark_file_get_title (GBookmarkFile *bookmark, const gchar *uri, GError **error) G_GNUC_MALLOC;
function g_bookmark_file_get_title(bookmark, uri, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_bookmark_file_get_title
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! void g_bookmark_file_set_description (GBookmarkFile *bookmark, const gchar *uri, const gchar *description);
subroutine g_bookmark_file_set_description(bookmark, uri, description) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: description
end subroutine

! gchar * g_bookmark_file_get_description (GBookmarkFile *bookmark, const gchar *uri, GError **error) G_GNUC_MALLOC;
function g_bookmark_file_get_description(bookmark, uri, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_bookmark_file_get_description
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! void g_bookmark_file_set_mime_type (GBookmarkFile *bookmark, const gchar *uri, const gchar *mime_type);
subroutine g_bookmark_file_set_mime_type(bookmark, uri, mime_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: mime_type
end subroutine

! gchar * g_bookmark_file_get_mime_type (GBookmarkFile *bookmark, const gchar *uri, GError **error) G_GNUC_MALLOC;
function g_bookmark_file_get_mime_type(bookmark, uri, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_bookmark_file_get_mime_type
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! void g_bookmark_file_set_groups (GBookmarkFile *bookmark, const gchar *uri, const gchar **groups, gsize length);
subroutine g_bookmark_file_set_groups(bookmark, uri, groups, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: groups
  integer(c_size_t), value :: length
end subroutine

! void g_bookmark_file_add_group (GBookmarkFile *bookmark, const gchar *uri, const gchar *group);
subroutine g_bookmark_file_add_group(bookmark, uri, group) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: group
end subroutine

! gboolean g_bookmark_file_has_group (GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error);
function g_bookmark_file_has_group(bookmark, uri, group, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_bookmark_file_has_group
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: group
  type(c_ptr), value :: error
end function

! gchar ** g_bookmark_file_get_groups (GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error) G_GNUC_MALLOC;
function g_bookmark_file_get_groups(bookmark, uri, length, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_bookmark_file_get_groups
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! void g_bookmark_file_add_application (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec);
subroutine g_bookmark_file_add_application(bookmark, uri, name, exec) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: exec
end subroutine

! gboolean g_bookmark_file_has_application (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error);
function g_bookmark_file_has_application(bookmark, uri, name, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_bookmark_file_has_application
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: error
end function

! gchar ** g_bookmark_file_get_applications (GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error) G_GNUC_MALLOC;
function g_bookmark_file_get_applications(bookmark, uri, length, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_bookmark_file_get_applications
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! gboolean g_bookmark_file_set_app_info (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec, gint count, time_t stamp, GError **error);
function g_bookmark_file_set_app_info(bookmark, uri, name, exec, count, stamp, e&
      &rror) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int, c_long
  logical(c_bool) :: g_bookmark_file_set_app_info
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: exec
  integer(c_int), value :: count
  integer(c_long), value :: stamp
  type(c_ptr), value :: error
end function

! gboolean g_bookmark_file_get_app_info (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, gchar **exec, guint *count, time_t *stamp, GError **error);
function g_bookmark_file_get_app_info(bookmark, uri, name, exec, count, stamp, e&
      &rror) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_bookmark_file_get_app_info
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: exec
  type(c_ptr), value :: count
  type(c_ptr), value :: stamp
  type(c_ptr), value :: error
end function

! void g_bookmark_file_set_is_private (GBookmarkFile *bookmark, const gchar *uri, gboolean is_private);
subroutine g_bookmark_file_set_is_private(bookmark, uri, is_private) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_bool
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  logical(c_bool), value :: is_private
end subroutine

! gboolean g_bookmark_file_get_is_private (GBookmarkFile *bookmark, const gchar *uri, GError **error);
function g_bookmark_file_get_is_private(bookmark, uri, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_bookmark_file_get_is_private
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! void g_bookmark_file_set_icon (GBookmarkFile *bookmark, const gchar *uri, const gchar *href, const gchar *mime_type);
subroutine g_bookmark_file_set_icon(bookmark, uri, href, mime_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: href
  character(kind=c_char), dimension(*) :: mime_type
end subroutine

! gboolean g_bookmark_file_get_icon (GBookmarkFile *bookmark, const gchar *uri, gchar **href, gchar **mime_type, GError **error);
function g_bookmark_file_get_icon(bookmark, uri, href, mime_type, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_bookmark_file_get_icon
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: href
  character(kind=c_char), dimension(*) :: mime_type
  type(c_ptr), value :: error
end function

! void g_bookmark_file_set_added (GBookmarkFile *bookmark, const gchar *uri, time_t added);
subroutine g_bookmark_file_set_added(bookmark, uri, added) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  integer(c_long), value :: added
end subroutine

! time_t g_bookmark_file_get_added (GBookmarkFile *bookmark, const gchar *uri, GError **error);
function g_bookmark_file_get_added(bookmark, uri, error) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_char
  integer(c_long) :: g_bookmark_file_get_added
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! void g_bookmark_file_set_modified (GBookmarkFile *bookmark, const gchar *uri, time_t modified);
subroutine g_bookmark_file_set_modified(bookmark, uri, modified) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  integer(c_long), value :: modified
end subroutine

! time_t g_bookmark_file_get_modified (GBookmarkFile *bookmark, const gchar *uri, GError **error);
function g_bookmark_file_get_modified(bookmark, uri, error) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_char
  integer(c_long) :: g_bookmark_file_get_modified
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! void g_bookmark_file_set_visited (GBookmarkFile *bookmark, const gchar *uri, time_t visited);
subroutine g_bookmark_file_set_visited(bookmark, uri, visited) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  integer(c_long), value :: visited
end subroutine

! time_t g_bookmark_file_get_visited (GBookmarkFile *bookmark, const gchar *uri, GError **error);
function g_bookmark_file_get_visited(bookmark, uri, error) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_char
  integer(c_long) :: g_bookmark_file_get_visited
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! gboolean g_bookmark_file_has_item (GBookmarkFile *bookmark, const gchar *uri);
function g_bookmark_file_has_item(bookmark, uri) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_bookmark_file_has_item
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
end function

! gint g_bookmark_file_get_size (GBookmarkFile *bookmark);
function g_bookmark_file_get_size(bookmark) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_bookmark_file_get_size
  type(c_ptr), value :: bookmark
end function

! gchar ** g_bookmark_file_get_uris (GBookmarkFile *bookmark, gsize *length) G_GNUC_MALLOC;
function g_bookmark_file_get_uris(bookmark, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_bookmark_file_get_uris
  type(c_ptr), value :: bookmark
  type(c_ptr), value :: length
end function

! gboolean g_bookmark_file_remove_group (GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error);
function g_bookmark_file_remove_group(bookmark, uri, group, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_bookmark_file_remove_group
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: group
  type(c_ptr), value :: error
end function

! gboolean g_bookmark_file_remove_application (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error);
function g_bookmark_file_remove_application(bookmark, uri, name, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_bookmark_file_remove_application
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: error
end function

! gboolean g_bookmark_file_remove_item (GBookmarkFile *bookmark, const gchar *uri, GError **error);
function g_bookmark_file_remove_item(bookmark, uri, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_bookmark_file_remove_item
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! gboolean g_bookmark_file_move_item (GBookmarkFile *bookmark, const gchar *old_uri, const gchar *new_uri, GError **error);
function g_bookmark_file_move_item(bookmark, old_uri, new_uri, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_bookmark_file_move_item
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: old_uri
  character(kind=c_char), dimension(*) :: new_uri
  type(c_ptr), value :: error
end function

!   GHashTable* g_hash_table_new (GHashFunc hash_func, GEqualFunc key_equal_func);
function g_hash_table_new(hash_func, key_equal_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_hash_table_new
  type(c_funptr), value :: hash_func
  type(c_funptr), value :: key_equal_func
end function

! GHashTable* g_hash_table_new_full (GHashFunc hash_func, GEqualFunc key_equal_func, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func);
function g_hash_table_new_full(hash_func, key_equal_func, key_destroy_func, valu&
      &e_destroy_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_hash_table_new_full
  type(c_funptr), value :: hash_func
  type(c_funptr), value :: key_equal_func
  type(c_funptr), value :: key_destroy_func
  type(c_funptr), value :: value_destroy_func
end function

! void g_hash_table_destroy (GHashTable *hash_table);
subroutine g_hash_table_destroy(hash_table) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hash_table
end subroutine

! void g_hash_table_insert (GHashTable *hash_table, gpointer key, gpointer value);
subroutine g_hash_table_insert(hash_table, key, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end subroutine

! void g_hash_table_replace (GHashTable *hash_table, gpointer key, gpointer value);
subroutine g_hash_table_replace(hash_table, key, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end subroutine

! gboolean g_hash_table_remove (GHashTable *hash_table, gconstpointer key);
function g_hash_table_remove(hash_table, key) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_hash_table_remove
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: key
end function

! void g_hash_table_remove_all (GHashTable *hash_table);
subroutine g_hash_table_remove_all(hash_table) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hash_table
end subroutine

! gboolean g_hash_table_steal (GHashTable *hash_table, gconstpointer key);
function g_hash_table_steal(hash_table, key) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_hash_table_steal
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: key
end function

! void g_hash_table_steal_all (GHashTable *hash_table);
subroutine g_hash_table_steal_all(hash_table) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hash_table
end subroutine

! gpointer g_hash_table_lookup (GHashTable *hash_table, gconstpointer key);
function g_hash_table_lookup(hash_table, key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_hash_table_lookup
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: key
end function

! gboolean g_hash_table_lookup_extended (GHashTable *hash_table, gconstpointer lookup_key, gpointer *orig_key, gpointer *value);
function g_hash_table_lookup_extended(hash_table, lookup_key, orig_key, value) b&
      &ind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_hash_table_lookup_extended
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: lookup_key
  type(c_ptr), value :: orig_key
  type(c_ptr), value :: value
end function

! void g_hash_table_foreach (GHashTable *hash_table, GHFunc func, gpointer user_data);
subroutine g_hash_table_foreach(hash_table, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: hash_table
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! gpointer g_hash_table_find (GHashTable *hash_table, GHRFunc predicate, gpointer user_data);
function g_hash_table_find(hash_table, predicate, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_hash_table_find
  type(c_ptr), value :: hash_table
  type(c_funptr), value :: predicate
  type(c_ptr), value :: user_data
end function

! guint g_hash_table_foreach_remove (GHashTable *hash_table, GHRFunc func, gpointer user_data);
function g_hash_table_foreach_remove(hash_table, func, user_data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int) :: g_hash_table_foreach_remove
  type(c_ptr), value :: hash_table
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end function

! guint g_hash_table_foreach_steal (GHashTable *hash_table, GHRFunc func, gpointer user_data);
function g_hash_table_foreach_steal(hash_table, func, user_data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int) :: g_hash_table_foreach_steal
  type(c_ptr), value :: hash_table
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end function

! guint g_hash_table_size (GHashTable *hash_table);
function g_hash_table_size(hash_table) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_hash_table_size
  type(c_ptr), value :: hash_table
end function

! GList * g_hash_table_get_keys (GHashTable *hash_table);
function g_hash_table_get_keys(hash_table) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_hash_table_get_keys
  type(c_ptr), value :: hash_table
end function

! GList * g_hash_table_get_values (GHashTable *hash_table);
function g_hash_table_get_values(hash_table) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_hash_table_get_values
  type(c_ptr), value :: hash_table
end function

!  void g_hash_table_iter_init (GHashTableIter *iter, GHashTable *hash_table);
subroutine g_hash_table_iter_init(iter, hash_table) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
  type(c_ptr), value :: hash_table
end subroutine

! gboolean g_hash_table_iter_next (GHashTableIter *iter, gpointer *key, gpointer *value);
function g_hash_table_iter_next(iter, key, value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_hash_table_iter_next
  type(c_ptr), value :: iter
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end function

! GHashTable* g_hash_table_iter_get_hash_table (GHashTableIter *iter);
function g_hash_table_iter_get_hash_table(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_hash_table_iter_get_hash_table
  type(c_ptr), value :: iter
end function

! void g_hash_table_iter_remove (GHashTableIter *iter);
subroutine g_hash_table_iter_remove(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
end subroutine

! void g_hash_table_iter_steal (GHashTableIter *iter);
subroutine g_hash_table_iter_steal(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
end subroutine

!  GHashTable* g_hash_table_ref (GHashTable *hash_table);
function g_hash_table_ref(hash_table) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_hash_table_ref
  type(c_ptr), value :: hash_table
end function

! void g_hash_table_unref (GHashTable *hash_table);
subroutine g_hash_table_unref(hash_table) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hash_table
end subroutine

!  gboolean g_str_equal (gconstpointer v1, gconstpointer v2);
function g_str_equal(v1, v2) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_str_equal
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
end function

! guint g_str_hash (gconstpointer v);
function g_str_hash(v) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_str_hash
  type(c_ptr), value :: v
end function

!  gboolean g_int_equal (gconstpointer v1, gconstpointer v2);
function g_int_equal(v1, v2) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_int_equal
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
end function

! guint g_int_hash (gconstpointer v);
function g_int_hash(v) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_int_hash
  type(c_ptr), value :: v
end function

!  gboolean g_int64_equal (gconstpointer v1, gconstpointer v2);
function g_int64_equal(v1, v2) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_int64_equal
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
end function

! guint g_int64_hash (gconstpointer v);
function g_int64_hash(v) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_int64_hash
  type(c_ptr), value :: v
end function

!  gboolean g_double_equal (gconstpointer v1, gconstpointer v2);
function g_double_equal(v1, v2) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_double_equal
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
end function

! guint g_double_hash (gconstpointer v);
function g_double_hash(v) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_double_hash
  type(c_ptr), value :: v
end function

!  guint g_direct_hash (gconstpointer v) G_GNUC_CONST;
function g_direct_hash(v) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_direct_hash
  type(c_ptr), value :: v
end function

! gboolean g_direct_equal (gconstpointer v1, gconstpointer v2) G_GNUC_CONST;
function g_direct_equal(v1, v2) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_direct_equal
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
end function

!   GQuark g_shell_error_quark (void);
function g_shell_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_shell_error_quark
end function

!  gchar* g_shell_quote (const gchar *unquoted_string);
function g_shell_quote(unquoted_string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_shell_quote
  character(kind=c_char), dimension(*) :: unquoted_string
end function

! gchar* g_shell_unquote (const gchar *quoted_string, GError **error);
function g_shell_unquote(quoted_string, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_shell_unquote
  character(kind=c_char), dimension(*) :: quoted_string
  type(c_ptr), value :: error
end function

! gboolean g_shell_parse_argv (const gchar *command_line, gint *argcp, gchar ***argvp, GError **error);
function g_shell_parse_argv(command_line, argcp, argvp, error) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_ptr
  logical(c_bool) :: g_shell_parse_argv
  character(kind=c_char), dimension(*) :: command_line
  type(c_ptr), value :: argcp
  character(kind=c_char), dimension(*) :: argvp
  type(c_ptr), value :: error
end function

!   GQuark g_markup_error_quark (void);
function g_markup_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_markup_error_quark
end function

!  GMarkupParseContext *g_markup_parse_context_new (const GMarkupParser *parser, GMarkupParseFlags flags, gpointer user_data, GDestroyNotify user_data_dnotify);
function g_markup_parse_context_new(parser, flags, user_data, user_data_dnotify)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr) :: g_markup_parse_context_new
  type(c_ptr), value :: parser
  integer(c_int), value :: flags
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_dnotify
end function

! void g_markup_parse_context_free (GMarkupParseContext *context);
subroutine g_markup_parse_context_free(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

! gboolean g_markup_parse_context_parse (GMarkupParseContext *context, const gchar *text, gssize text_len, GError **error);
function g_markup_parse_context_parse(context, text, text_len, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_size_t
  logical(c_bool) :: g_markup_parse_context_parse
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: text
  integer(c_size_t), value :: text_len
  type(c_ptr), value :: error
end function

! void g_markup_parse_context_push (GMarkupParseContext *context, const GMarkupParser *parser, gpointer user_data);
subroutine g_markup_parse_context_push(context, parser, user_data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: parser
  type(c_ptr), value :: user_data
end subroutine

! gpointer g_markup_parse_context_pop (GMarkupParseContext *context);
function g_markup_parse_context_pop(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_markup_parse_context_pop
  type(c_ptr), value :: context
end function

!  gboolean g_markup_parse_context_end_parse (GMarkupParseContext *context, GError **error);
function g_markup_parse_context_end_parse(context, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_markup_parse_context_end_parse
  type(c_ptr), value :: context
  type(c_ptr), value :: error
end function

! G_CONST_RETURN gchar *g_markup_parse_context_get_element (GMarkupParseContext *context);
function g_markup_parse_context_get_element(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_markup_parse_context_get_element
  type(c_ptr), value :: context
end function

! G_CONST_RETURN GSList *g_markup_parse_context_get_element_stack (GMarkupParseContext *context);
function g_markup_parse_context_get_element_stack(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_markup_parse_context_get_element_stack
  type(c_ptr), value :: context
end function

!  void g_markup_parse_context_get_position (GMarkupParseContext *context, gint *line_number, gint *char_number);
subroutine g_markup_parse_context_get_position(context, line_number, char_number&
      &) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: line_number
  type(c_ptr), value :: char_number
end subroutine

! gpointer g_markup_parse_context_get_user_data (GMarkupParseContext *context);
function g_markup_parse_context_get_user_data(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_markup_parse_context_get_user_data
  type(c_ptr), value :: context
end function

!  gchar* g_markup_escape_text (const gchar *text, gssize length);
function g_markup_escape_text(text, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_markup_escape_text
  character(kind=c_char), dimension(*) :: text
  integer(c_size_t), value :: length
end function

!  gchar *g_markup_printf_escaped (const char *format, ...) G_GNUC_PRINTF (1, 2);
function g_markup_printf_escaped() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_markup_printf_escaped
end function

! gchar *g_markup_vprintf_escaped (const char *format, va_list args);
function g_markup_vprintf_escaped(format, args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_markup_vprintf_escaped
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

!   int g_strcmp0 (const char *str1, const char *str2);
function g_strcmp0(str1, str2) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_strcmp0
  character(kind=c_char), dimension(*) :: str1
  character(kind=c_char), dimension(*) :: str2
end function

!  void g_test_minimized_result (double minimized_quantity, const char *format, ...) G_GNUC_PRINTF (2, 3);
subroutine g_test_minimized_result() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void g_test_maximized_result (double maximized_quantity, const char *format, ...) G_GNUC_PRINTF (2, 3);
subroutine g_test_maximized_result() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  int g_test_run (void);
function g_test_run() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_test_run
end function

!  void g_test_add_func (const char *testpath, GTestFunc test_func);
subroutine g_test_add_func(testpath, test_func) bind(c) 
  use iso_c_binding, only: c_char, c_funptr
  character(kind=c_char), dimension(*) :: testpath
  type(c_funptr), value :: test_func
end subroutine

!  void g_test_add_data_func (const char *testpath, gconstpointer test_data, GTestDataFunc test_func);
subroutine g_test_add_data_func(testpath, test_data, test_func) bind(c) 
  use iso_c_binding, only: c_char, c_ptr, c_funptr
  character(kind=c_char), dimension(*) :: testpath
  type(c_ptr), value :: test_data
  type(c_funptr), value :: test_func
end subroutine

!  void g_test_message (const char *format, ...) G_GNUC_PRINTF (1, 2);
subroutine g_test_message() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void g_test_bug_base (const char *uri_pattern);
subroutine g_test_bug_base(uri_pattern) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: uri_pattern
end subroutine

! void g_test_bug (const char *bug_uri_snippet);
subroutine g_test_bug(bug_uri_snippet) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: bug_uri_snippet
end subroutine

!  void g_test_timer_start (void);
subroutine g_test_timer_start() bind(c) 
  use iso_c_binding, only: 
end subroutine

! double g_test_timer_elapsed (void);
function g_test_timer_elapsed() bind(c) 
  use iso_c_binding, only: c_double
  real(c_double) :: g_test_timer_elapsed
end function

! double g_test_timer_last (void);
function g_test_timer_last() bind(c) 
  use iso_c_binding, only: c_double
  real(c_double) :: g_test_timer_last
end function

!  void g_test_queue_free (gpointer gfree_pointer);
subroutine g_test_queue_free(gfree_pointer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: gfree_pointer
end subroutine

! void g_test_queue_destroy (GDestroyNotify destroy_func, gpointer destroy_data);
subroutine g_test_queue_destroy(destroy_func, destroy_data) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr), value :: destroy_func
  type(c_ptr), value :: destroy_data
end subroutine

!  gboolean g_test_trap_fork (guint64 usec_timeout, GTestTrapFlags test_trap_flags);
function g_test_trap_fork(usec_timeout, test_trap_flags) bind(c) 
  use iso_c_binding, only: c_bool, c_int64_t, c_int
  logical(c_bool) :: g_test_trap_fork
  integer(c_int64_t), value :: usec_timeout
  integer(c_int), value :: test_trap_flags
end function

! gboolean g_test_trap_has_passed (void);
function g_test_trap_has_passed() bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool) :: g_test_trap_has_passed
end function

! gboolean g_test_trap_reached_timeout (void);
function g_test_trap_reached_timeout() bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool) :: g_test_trap_reached_timeout
end function

!  gint32 g_test_rand_int (void);
function g_test_rand_int() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_test_rand_int
end function

! gint32 g_test_rand_int_range (gint32 begin, gint32 end);
function g_test_rand_int_range(begin, end) bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_test_rand_int_range
  integer(c_int32_t), value :: begin
  integer(c_int32_t), value :: end
end function

! double g_test_rand_double (void);
function g_test_rand_double() bind(c) 
  use iso_c_binding, only: c_double
  real(c_double) :: g_test_rand_double
end function

! double g_test_rand_double_range (double range_start, double range_end);
function g_test_rand_double_range(range_start, range_end) bind(c) 
  use iso_c_binding, only: c_double
  real(c_double) :: g_test_rand_double_range
  real(c_double), value :: range_start
  real(c_double), value :: range_end
end function

!  GTestCase* g_test_create_case (const char *test_name, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown);
function g_test_create_case(test_name, data_size, test_data, data_setup, data_te&
      &st, data_teardown) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_funptr
  type(c_ptr) :: g_test_create_case
  character(kind=c_char), dimension(*) :: test_name
  integer(c_size_t), value :: data_size
  type(c_ptr), value :: test_data
  type(c_funptr), value :: data_setup
  type(c_funptr), value :: data_test
  type(c_funptr), value :: data_teardown
end function

! GTestSuite* g_test_create_suite (const char *suite_name);
function g_test_create_suite(suite_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_test_create_suite
  character(kind=c_char), dimension(*) :: suite_name
end function

! GTestSuite* g_test_get_root (void);
function g_test_get_root() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_test_get_root
end function

! void g_test_suite_add (GTestSuite *suite, GTestCase *test_case);
subroutine g_test_suite_add(suite, test_case) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: suite
  type(c_ptr), value :: test_case
end subroutine

! void g_test_suite_add_suite (GTestSuite *suite, GTestSuite *nestedsuite);
subroutine g_test_suite_add_suite(suite, nestedsuite) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: suite
  type(c_ptr), value :: nestedsuite
end subroutine

! int g_test_run_suite (GTestSuite *suite);
function g_test_run_suite(suite) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_test_run_suite
  type(c_ptr), value :: suite
end function

!  void g_test_trap_assertions (const char *domain, const char *file, int line, const char *func, guint64 assertion_flags, const char *pattern);
subroutine g_test_trap_assertions(domain, file, line, func, assertion_flags, pat&
      &tern) bind(c) 
  use iso_c_binding, only: c_char, c_int, c_int64_t
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  integer(c_int64_t), value :: assertion_flags
  character(kind=c_char), dimension(*) :: pattern
end subroutine

! void g_assertion_message (const char *domain, const char *file, int line, const char *func, const char *message) G_GNUC_NORETURN;
subroutine g_assertion_message(domain, file, line, func, message) bind(c) 
  use iso_c_binding, only: c_char, c_int
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  character(kind=c_char), dimension(*) :: message
end subroutine

! void g_assertion_message_expr (const char *domain, const char *file, int line, const char *func, const char *expr) G_GNUC_NORETURN;
subroutine g_assertion_message_expr(domain, file, line, func, expr) bind(c) 
  use iso_c_binding, only: c_char, c_int
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  character(kind=c_char), dimension(*) :: expr
end subroutine

! void g_assertion_message_cmpstr (const char *domain, const char *file, int line, const char *func, const char *expr, const char *arg1, const char *cmp, const char *arg2) G_GNUC_NORETURN;
subroutine g_assertion_message_cmpstr(domain, file, line, func, expr, arg1, cmp,&
      & arg2) bind(c) 
  use iso_c_binding, only: c_char, c_int
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  character(kind=c_char), dimension(*) :: expr
  character(kind=c_char), dimension(*) :: arg1
  character(kind=c_char), dimension(*) :: cmp
  character(kind=c_char), dimension(*) :: arg2
end subroutine

! void g_assertion_message_error (const char *domain, const char *file, int line, const char *func, const char *expr, const GError *error, GQuark error_domain, int error_code) G_GNUC_NORETURN;
subroutine g_assertion_message_error(domain, file, line, func, expr, error, erro&
      &r_domain, error_code) bind(c) 
  use iso_c_binding, only: c_char, c_int, c_ptr, c_int32_t
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  character(kind=c_char), dimension(*) :: expr
  type(c_ptr), value :: error
  integer(c_int32_t), value :: error_domain
  integer(c_int), value :: error_code
end subroutine

! void g_test_add_vtable (const char *testpath, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown);
subroutine g_test_add_vtable(testpath, data_size, test_data, data_setup, data_te&
      &st, data_teardown) bind(c) 
  use iso_c_binding, only: c_char, c_size_t, c_ptr, c_funptr
  character(kind=c_char), dimension(*) :: testpath
  integer(c_size_t), value :: data_size
  type(c_ptr), value :: test_data
  type(c_funptr), value :: data_setup
  type(c_funptr), value :: data_test
  type(c_funptr), value :: data_teardown
end subroutine

!  const char* g_test_log_type_name (GTestLogType log_type);
function g_test_log_type_name(log_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_test_log_type_name
  integer(c_int), value :: log_type
end function

! GTestLogBuffer* g_test_log_buffer_new (void);
function g_test_log_buffer_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_test_log_buffer_new
end function

! void g_test_log_buffer_free (GTestLogBuffer *tbuffer);
subroutine g_test_log_buffer_free(tbuffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tbuffer
end subroutine

! void g_test_log_buffer_push (GTestLogBuffer *tbuffer, guint n_bytes, const guint8 *bytes);
subroutine g_test_log_buffer_push(tbuffer, n_bytes, bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tbuffer
  integer(c_int), value :: n_bytes
  type(c_ptr), value :: bytes
end subroutine

! GTestLogMsg* g_test_log_buffer_pop (GTestLogBuffer *tbuffer);
function g_test_log_buffer_pop(tbuffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_test_log_buffer_pop
  type(c_ptr), value :: tbuffer
end function

! void g_test_log_msg_free (GTestLogMsg *tmsg);
subroutine g_test_log_msg_free(tmsg) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tmsg
end subroutine

!  void g_test_log_set_fatal_handler (GTestLogFatalFunc log_func, gpointer user_data);
subroutine g_test_log_set_fatal_handler(log_func, user_data) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr), value :: log_func
  type(c_ptr), value :: user_data
end subroutine

!   gsize g_printf_string_upper_bound (const gchar* format, va_list args);
function g_printf_string_upper_bound(format, args) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_printf_string_upper_bound
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

!  guint g_log_set_handler (const gchar *log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data);
function g_log_set_handler(log_domain, log_levels, log_func, user_data) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_funptr, c_ptr
  integer(c_int) :: g_log_set_handler
  character(kind=c_char), dimension(*) :: log_domain
  integer(c_int), value :: log_levels
  type(c_funptr), value :: log_func
  type(c_ptr), value :: user_data
end function

! void g_log_remove_handler (const gchar *log_domain, guint handler_id);
subroutine g_log_remove_handler(log_domain, handler_id) bind(c) 
  use iso_c_binding, only: c_char, c_int
  character(kind=c_char), dimension(*) :: log_domain
  integer(c_int), value :: handler_id
end subroutine

! void g_log_default_handler (const gchar *log_domain, GLogLevelFlags log_level, const gchar *message, gpointer unused_data);
subroutine g_log_default_handler(log_domain, log_level, message, unused_data) bi&
      &nd(c) 
  use iso_c_binding, only: c_char, c_int, c_ptr
  character(kind=c_char), dimension(*) :: log_domain
  integer(c_int), value :: log_level
  character(kind=c_char), dimension(*) :: message
  type(c_ptr), value :: unused_data
end subroutine

! GLogFunc g_log_set_default_handler (GLogFunc log_func, gpointer user_data);
function g_log_set_default_handler(log_func, user_data) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr) :: g_log_set_default_handler
  type(c_funptr), value :: log_func
  type(c_ptr), value :: user_data
end function

! void g_log (const gchar *log_domain, GLogLevelFlags log_level, const gchar *format, ...) G_GNUC_PRINTF (3, 4);
subroutine g_log() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void g_logv (const gchar *log_domain, GLogLevelFlags log_level, const gchar *format, va_list args);
subroutine g_logv(log_domain, log_level, format, args) bind(c) 
  use iso_c_binding, only: c_char, c_int, c_ptr
  character(kind=c_char), dimension(*) :: log_domain
  integer(c_int), value :: log_level
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end subroutine

! GLogLevelFlags g_log_set_fatal_mask (const gchar *log_domain, GLogLevelFlags fatal_mask);
function g_log_set_fatal_mask(log_domain, fatal_mask) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_log_set_fatal_mask
  character(kind=c_char), dimension(*) :: log_domain
  integer(c_int), value :: fatal_mask
end function

! GLogLevelFlags g_log_set_always_fatal (GLogLevelFlags fatal_mask);
function g_log_set_always_fatal(fatal_mask) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_log_set_always_fatal
  integer(c_int), value :: fatal_mask
end function

!  void g_return_if_fail_warning (const char *log_domain, const char *pretty_function, const char *expression);
subroutine g_return_if_fail_warning(log_domain, pretty_function, expression) bin&
      &d(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: log_domain
  character(kind=c_char), dimension(*) :: pretty_function
  character(kind=c_char), dimension(*) :: expression
end subroutine

! void g_warn_message (const char *domain, const char *file, int line, const char *func, const char *warnexpr);
subroutine g_warn_message(domain, file, line, func, warnexpr) bind(c) 
  use iso_c_binding, only: c_char, c_int
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  character(kind=c_char), dimension(*) :: warnexpr
end subroutine

! GPrintFunc g_set_print_handler (GPrintFunc func);
function g_set_print_handler(func) bind(c) 
  use iso_c_binding, only: c_funptr
  type(c_funptr) :: g_set_print_handler
  type(c_funptr), value :: func
end function

! void g_printerr (const gchar *format, ...) G_GNUC_PRINTF (1, 2);
subroutine g_printerr() bind(c) 
  use iso_c_binding, only: 
end subroutine

! GPrintFunc g_set_printerr_handler (GPrintFunc func);
function g_set_printerr_handler(func) bind(c) 
  use iso_c_binding, only: c_funptr
  type(c_funptr) :: g_set_printerr_handler
  type(c_funptr), value :: func
end function

!   gboolean g_hostname_is_non_ascii (const gchar *hostname);
function g_hostname_is_non_ascii(hostname) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_hostname_is_non_ascii
  character(kind=c_char), dimension(*) :: hostname
end function

! gboolean g_hostname_is_ascii_encoded (const gchar *hostname);
function g_hostname_is_ascii_encoded(hostname) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_hostname_is_ascii_encoded
  character(kind=c_char), dimension(*) :: hostname
end function

! gboolean g_hostname_is_ip_address (const gchar *hostname);
function g_hostname_is_ip_address(hostname) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_hostname_is_ip_address
  character(kind=c_char), dimension(*) :: hostname
end function

!  gchar *g_hostname_to_ascii (const gchar *hostname);
function g_hostname_to_ascii(hostname) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_hostname_to_ascii
  character(kind=c_char), dimension(*) :: hostname
end function

! gchar *g_hostname_to_unicode (const gchar *hostname);
function g_hostname_to_unicode(hostname) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_hostname_to_unicode
  character(kind=c_char), dimension(*) :: hostname
end function

!   GStringChunk* g_string_chunk_new (gsize size);
function g_string_chunk_new(size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_string_chunk_new
  integer(c_size_t), value :: size
end function

! void g_string_chunk_free (GStringChunk *chunk);
subroutine g_string_chunk_free(chunk) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: chunk
end subroutine

! void g_string_chunk_clear (GStringChunk *chunk);
subroutine g_string_chunk_clear(chunk) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: chunk
end subroutine

! gchar* g_string_chunk_insert (GStringChunk *chunk, const gchar *string);
function g_string_chunk_insert(chunk, string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_string_chunk_insert
  type(c_ptr), value :: chunk
  character(kind=c_char), dimension(*) :: string
end function

! gchar* g_string_chunk_insert_len (GStringChunk *chunk, const gchar *string, gssize len);
function g_string_chunk_insert_len(chunk, string, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_string_chunk_insert_len
  type(c_ptr), value :: chunk
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: len
end function

! gchar* g_string_chunk_insert_const (GStringChunk *chunk, const gchar *string);
function g_string_chunk_insert_const(chunk, string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_string_chunk_insert_const
  type(c_ptr), value :: chunk
  character(kind=c_char), dimension(*) :: string
end function

!  GString* g_string_new (const gchar *init);
function g_string_new(init) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_string_new
  character(kind=c_char), dimension(*) :: init
end function

! GString* g_string_new_len (const gchar *init, gssize len);
function g_string_new_len(init, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_string_new_len
  character(kind=c_char), dimension(*) :: init
  integer(c_size_t), value :: len
end function

! GString* g_string_sized_new (gsize dfl_size);
function g_string_sized_new(dfl_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_string_sized_new
  integer(c_size_t), value :: dfl_size
end function

! gchar* g_string_free (GString *string, gboolean free_segment);
function g_string_free(string, free_segment) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: g_string_free
  type(c_ptr), value :: string
  logical(c_bool), value :: free_segment
end function

! gboolean g_string_equal (const GString *v, const GString *v2);
function g_string_equal(v, v2) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_string_equal
  type(c_ptr), value :: v
  type(c_ptr), value :: v2
end function

! guint g_string_hash (const GString *str);
function g_string_hash(str) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_string_hash
  type(c_ptr), value :: str
end function

! GString* g_string_assign (GString *string, const gchar *rval);
function g_string_assign(string, rval) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_string_assign
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: rval
end function

! GString* g_string_truncate (GString *string, gsize len);
function g_string_truncate(string, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_string_truncate
  type(c_ptr), value :: string
  integer(c_size_t), value :: len
end function

! GString* g_string_set_size (GString *string, gsize len);
function g_string_set_size(string, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_string_set_size
  type(c_ptr), value :: string
  integer(c_size_t), value :: len
end function

! GString* g_string_insert_len (GString *string, gssize pos, const gchar *val, gssize len);
function g_string_insert_len(string, pos, val, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_string_insert_len
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  character(kind=c_char), dimension(*) :: val
  integer(c_size_t), value :: len
end function

! GString* g_string_append (GString *string, const gchar *val);
function g_string_append(string, val) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_string_append
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: val
end function

! GString* g_string_append_len (GString *string, const gchar *val, gssize len);
function g_string_append_len(string, val, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_string_append_len
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: val
  integer(c_size_t), value :: len
end function

! GString* g_string_append_c (GString *string, gchar c);
function g_string_append_c(string, c) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_string_append_c
  type(c_ptr), value :: string
  character(c_char), value :: c
end function

! GString* g_string_append_unichar (GString *string, gunichar wc);
function g_string_append_unichar(string, wc) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_string_append_unichar
  type(c_ptr), value :: string
  integer(c_int32_t), value :: wc
end function

! GString* g_string_prepend (GString *string, const gchar *val);
function g_string_prepend(string, val) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_string_prepend
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: val
end function

! GString* g_string_prepend_c (GString *string, gchar c);
function g_string_prepend_c(string, c) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_string_prepend_c
  type(c_ptr), value :: string
  character(c_char), value :: c
end function

! GString* g_string_prepend_unichar (GString *string, gunichar wc);
function g_string_prepend_unichar(string, wc) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_string_prepend_unichar
  type(c_ptr), value :: string
  integer(c_int32_t), value :: wc
end function

! GString* g_string_prepend_len (GString *string, const gchar *val, gssize len);
function g_string_prepend_len(string, val, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_string_prepend_len
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: val
  integer(c_size_t), value :: len
end function

! GString* g_string_insert (GString *string, gssize pos, const gchar *val);
function g_string_insert(string, pos, val) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_string_insert
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  character(kind=c_char), dimension(*) :: val
end function

! GString* g_string_insert_c (GString *string, gssize pos, gchar c);
function g_string_insert_c(string, pos, c) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_string_insert_c
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  character(c_char), value :: c
end function

! GString* g_string_insert_unichar (GString *string, gssize pos, gunichar wc);
function g_string_insert_unichar(string, pos, wc) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int32_t
  type(c_ptr) :: g_string_insert_unichar
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  integer(c_int32_t), value :: wc
end function

! GString* g_string_overwrite (GString *string, gsize pos, const gchar *val);
function g_string_overwrite(string, pos, val) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_string_overwrite
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  character(kind=c_char), dimension(*) :: val
end function

! GString* g_string_overwrite_len (GString *string, gsize pos, const gchar *val, gssize len);
function g_string_overwrite_len(string, pos, val, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_string_overwrite_len
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  character(kind=c_char), dimension(*) :: val
  integer(c_size_t), value :: len
end function

! GString* g_string_erase (GString *string, gssize pos, gssize len);
function g_string_erase(string, pos, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_string_erase
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  integer(c_size_t), value :: len
end function

! GString* g_string_ascii_down (GString *string);
function g_string_ascii_down(string) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_string_ascii_down
  type(c_ptr), value :: string
end function

! GString* g_string_ascii_up (GString *string);
function g_string_ascii_up(string) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_string_ascii_up
  type(c_ptr), value :: string
end function

! void g_string_vprintf (GString *string, const gchar *format, va_list args);
subroutine g_string_vprintf(string, format, args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end subroutine

! void g_string_printf (GString *string, const gchar *format, ...) G_GNUC_PRINTF (2, 3);
subroutine g_string_printf() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void g_string_append_vprintf (GString *string, const gchar *format, va_list args);
subroutine g_string_append_vprintf(string, format, args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end subroutine

! void g_string_append_printf (GString *string, const gchar *format, ...) G_GNUC_PRINTF (2, 3);
subroutine g_string_append_printf() bind(c) 
  use iso_c_binding, only: 
end subroutine

! GString * g_string_append_uri_escaped(GString *string, const char *unescaped, const char *reserved_chars_allowed, gboolean allow_utf8);
function g_string_append_uri_escaped(string, unescaped, reserved_chars_allowed, &
      &allow_utf8) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_bool
  type(c_ptr) :: g_string_append_uri_escaped
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: unescaped
  character(kind=c_char), dimension(*) :: reserved_chars_allowed
  logical(c_bool), value :: allow_utf8
end function

!  static inline GString* g_string_append_c_inline (GString *gstring, gchar c) { if (gstring->len + 1 < gstring->allocated_len) { gstring->str[gstring->len++] = c;
function g_string_append_c_inline(gstring, c) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_string_append_c_inline
  type(c_ptr), value :: gstring
  character(c_char), value :: c
end function

! GString* g_string_up (GString *string);
function g_string_up(string) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_string_up
  type(c_ptr), value :: string
end function

!   void g_datalist_init (GData **datalist);
subroutine g_datalist_init(datalist) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: datalist
end subroutine

! void g_datalist_clear (GData **datalist);
subroutine g_datalist_clear(datalist) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: datalist
end subroutine

! gpointer g_datalist_id_get_data (GData **datalist, GQuark key_id);
function g_datalist_id_get_data(datalist, key_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_datalist_id_get_data
  type(c_ptr), value :: datalist
  integer(c_int32_t), value :: key_id
end function

! void g_datalist_id_set_data_full (GData **datalist, GQuark key_id, gpointer data, GDestroyNotify destroy_func);
subroutine g_datalist_id_set_data_full(datalist, key_id, data, destroy_func) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_funptr
  type(c_ptr), value :: datalist
  integer(c_int32_t), value :: key_id
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy_func
end subroutine

! gpointer g_datalist_id_remove_no_notify (GData **datalist, GQuark key_id);
function g_datalist_id_remove_no_notify(datalist, key_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_datalist_id_remove_no_notify
  type(c_ptr), value :: datalist
  integer(c_int32_t), value :: key_id
end function

! void g_datalist_foreach (GData **datalist, GDataForeachFunc func, gpointer user_data);
subroutine g_datalist_foreach(datalist, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: datalist
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!  void g_datalist_set_flags (GData **datalist, guint flags);
subroutine g_datalist_set_flags(datalist, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: datalist
  integer(c_int), value :: flags
end subroutine

! void g_datalist_unset_flags (GData **datalist, guint flags);
subroutine g_datalist_unset_flags(datalist, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: datalist
  integer(c_int), value :: flags
end subroutine

! guint g_datalist_get_flags (GData **datalist);
function g_datalist_get_flags(datalist) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_datalist_get_flags
  type(c_ptr), value :: datalist
end function

!  void g_dataset_destroy (gconstpointer dataset_location);
subroutine g_dataset_destroy(dataset_location) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: dataset_location
end subroutine

! gpointer g_dataset_id_get_data (gconstpointer dataset_location, GQuark key_id);
function g_dataset_id_get_data(dataset_location, key_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_dataset_id_get_data
  type(c_ptr), value :: dataset_location
  integer(c_int32_t), value :: key_id
end function

! void g_dataset_id_set_data_full (gconstpointer dataset_location, GQuark key_id, gpointer data, GDestroyNotify destroy_func);
subroutine g_dataset_id_set_data_full(dataset_location, key_id, data, destroy_fu&
      &nc) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_funptr
  type(c_ptr), value :: dataset_location
  integer(c_int32_t), value :: key_id
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy_func
end subroutine

! gpointer g_dataset_id_remove_no_notify (gconstpointer dataset_location, GQuark key_id);
function g_dataset_id_remove_no_notify(dataset_location, key_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_dataset_id_remove_no_notify
  type(c_ptr), value :: dataset_location
  integer(c_int32_t), value :: key_id
end function

! void g_dataset_foreach (gconstpointer dataset_location, GDataForeachFunc func, gpointer user_data);
subroutine g_dataset_foreach(dataset_location, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: dataset_location
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!  gchar g_ascii_tolower (gchar c) G_GNUC_CONST;
function g_ascii_tolower(c) bind(c) 
  use iso_c_binding, only: c_char
  character(c_char) :: g_ascii_tolower
  character(c_char), value :: c
end function

! gchar g_ascii_toupper (gchar c) G_GNUC_CONST;
function g_ascii_toupper(c) bind(c) 
  use iso_c_binding, only: c_char
  character(c_char) :: g_ascii_toupper
  character(c_char), value :: c
end function

!  gint g_ascii_digit_value (gchar c) G_GNUC_CONST;
function g_ascii_digit_value(c) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_ascii_digit_value
  character(c_char), value :: c
end function

! gint g_ascii_xdigit_value (gchar c) G_GNUC_CONST;
function g_ascii_xdigit_value(c) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_ascii_xdigit_value
  character(c_char), value :: c
end function

!  gchar* g_strdelimit (gchar *string, const gchar *delimiters, gchar new_delimiter);
function g_strdelimit(string, delimiters, new_delimiter) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strdelimit
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: delimiters
  character(c_char), value :: new_delimiter
end function

! gchar* g_strcanon (gchar *string, const gchar *valid_chars, gchar substitutor);
function g_strcanon(string, valid_chars, substitutor) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strcanon
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: valid_chars
  character(c_char), value :: substitutor
end function

! G_CONST_RETURN gchar* g_strerror (gint errnum) G_GNUC_CONST;
function g_strerror(errnum) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_strerror
  integer(c_int), value :: errnum
end function

! G_CONST_RETURN gchar* g_strsignal (gint signum) G_GNUC_CONST;
function g_strsignal(signum) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_strsignal
  integer(c_int), value :: signum
end function

! gchar* g_strreverse (gchar *string);
function g_strreverse(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strreverse
  character(kind=c_char), dimension(*) :: string
end function

! gsize g_strlcpy (gchar *dest, const gchar *src, gsize dest_size);
function g_strlcpy(dest, src, dest_size) bind(c) 
  use iso_c_binding, only: c_size_t, c_char
  integer(c_size_t) :: g_strlcpy
  character(kind=c_char), dimension(*) :: dest
  character(kind=c_char), dimension(*) :: src
  integer(c_size_t), value :: dest_size
end function

! gsize g_strlcat (gchar *dest, const gchar *src, gsize dest_size);
function g_strlcat(dest, src, dest_size) bind(c) 
  use iso_c_binding, only: c_size_t, c_char
  integer(c_size_t) :: g_strlcat
  character(kind=c_char), dimension(*) :: dest
  character(kind=c_char), dimension(*) :: src
  integer(c_size_t), value :: dest_size
end function

! gchar * g_strstr_len (const gchar *haystack, gssize haystack_len, const gchar *needle);
function g_strstr_len(haystack, haystack_len, needle) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_strstr_len
  character(kind=c_char), dimension(*) :: haystack
  integer(c_size_t), value :: haystack_len
  character(kind=c_char), dimension(*) :: needle
end function

! gchar * g_strrstr (const gchar *haystack, const gchar *needle);
function g_strrstr(haystack, needle) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strrstr
  character(kind=c_char), dimension(*) :: haystack
  character(kind=c_char), dimension(*) :: needle
end function

! gchar * g_strrstr_len (const gchar *haystack, gssize haystack_len, const gchar *needle);
function g_strrstr_len(haystack, haystack_len, needle) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_strrstr_len
  character(kind=c_char), dimension(*) :: haystack
  integer(c_size_t), value :: haystack_len
  character(kind=c_char), dimension(*) :: needle
end function

!  gboolean g_str_has_suffix (const gchar *str, const gchar *suffix);
function g_str_has_suffix(str, suffix) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_str_has_suffix
  character(kind=c_char), dimension(*) :: str
  character(kind=c_char), dimension(*) :: suffix
end function

! gboolean g_str_has_prefix (const gchar *str, const gchar *prefix);
function g_str_has_prefix(str, prefix) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_str_has_prefix
  character(kind=c_char), dimension(*) :: str
  character(kind=c_char), dimension(*) :: prefix
end function

!  gdouble g_strtod (const gchar *nptr, gchar **endptr);
function g_strtod(nptr, endptr) bind(c) 
  use iso_c_binding, only: c_double, c_char
  real(c_double) :: g_strtod
  character(kind=c_char), dimension(*) :: nptr
  character(kind=c_char), dimension(*) :: endptr
end function

! gdouble g_ascii_strtod (const gchar *nptr, gchar **endptr);
function g_ascii_strtod(nptr, endptr) bind(c) 
  use iso_c_binding, only: c_double, c_char
  real(c_double) :: g_ascii_strtod
  character(kind=c_char), dimension(*) :: nptr
  character(kind=c_char), dimension(*) :: endptr
end function

! guint64 g_ascii_strtoull (const gchar *nptr, gchar **endptr, guint base);
function g_ascii_strtoull(nptr, endptr, base) bind(c) 
  use iso_c_binding, only: c_int64_t, c_char, c_int
  integer(c_int64_t) :: g_ascii_strtoull
  character(kind=c_char), dimension(*) :: nptr
  character(kind=c_char), dimension(*) :: endptr
  integer(c_int), value :: base
end function

! gint64 g_ascii_strtoll (const gchar *nptr, gchar **endptr, guint base);
function g_ascii_strtoll(nptr, endptr, base) bind(c) 
  use iso_c_binding, only: c_int64_t, c_char, c_int
  integer(c_int64_t) :: g_ascii_strtoll
  character(kind=c_char), dimension(*) :: nptr
  character(kind=c_char), dimension(*) :: endptr
  integer(c_int), value :: base
end function

!  gchar * g_ascii_dtostr (gchar *buffer, gint buf_len, gdouble d);
function g_ascii_dtostr(buffer, buf_len, d) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_double
  type(c_ptr) :: g_ascii_dtostr
  character(kind=c_char), dimension(*) :: buffer
  integer(c_int), value :: buf_len
  real(c_double), value :: d
end function

! gchar * g_ascii_formatd (gchar *buffer, gint buf_len, const gchar *format, gdouble d);
function g_ascii_formatd(buffer, buf_len, format, d) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_double
  type(c_ptr) :: g_ascii_formatd
  character(kind=c_char), dimension(*) :: buffer
  integer(c_int), value :: buf_len
  character(kind=c_char), dimension(*) :: format
  real(c_double), value :: d
end function

!  gchar* g_strchug (gchar *string);
function g_strchug(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strchug
  character(kind=c_char), dimension(*) :: string
end function

!  gchar* g_strchomp (gchar *string);
function g_strchomp(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strchomp
  character(kind=c_char), dimension(*) :: string
end function

!  gint g_ascii_strcasecmp (const gchar *s1, const gchar *s2);
function g_ascii_strcasecmp(s1, s2) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_ascii_strcasecmp
  character(kind=c_char), dimension(*) :: s1
  character(kind=c_char), dimension(*) :: s2
end function

! gint g_ascii_strncasecmp (const gchar *s1, const gchar *s2, gsize n);
function g_ascii_strncasecmp(s1, s2, n) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_size_t
  integer(c_int) :: g_ascii_strncasecmp
  character(kind=c_char), dimension(*) :: s1
  character(kind=c_char), dimension(*) :: s2
  integer(c_size_t), value :: n
end function

! gchar* g_ascii_strdown (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_ascii_strdown(str, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_ascii_strdown
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

! gchar* g_ascii_strup (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_ascii_strup(str, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_ascii_strup
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

!  gint g_strcasecmp (const gchar *s1, const gchar *s2);
function g_strcasecmp(s1, s2) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_strcasecmp
  character(kind=c_char), dimension(*) :: s1
  character(kind=c_char), dimension(*) :: s2
end function

! gint g_strncasecmp (const gchar *s1, const gchar *s2, guint n);
function g_strncasecmp(s1, s2, n) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_strncasecmp
  character(kind=c_char), dimension(*) :: s1
  character(kind=c_char), dimension(*) :: s2
  integer(c_int), value :: n
end function

! gchar* g_strdown (gchar *string);
function g_strdown(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strdown
  character(kind=c_char), dimension(*) :: string
end function

! gchar* g_strup (gchar *string);
function g_strup(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strup
  character(kind=c_char), dimension(*) :: string
end function

!  gchar* g_strdup (const gchar *str) G_GNUC_MALLOC;
function g_strdup(str) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strdup
  character(kind=c_char), dimension(*) :: str
end function

! gchar* g_strdup_printf (const gchar *format, ...) G_GNUC_PRINTF (1, 2) G_GNUC_MALLOC;
function g_strdup_printf() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_strdup_printf
end function

! gchar* g_strdup_vprintf (const gchar *format, va_list args) G_GNUC_MALLOC;
function g_strdup_vprintf(format, args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strdup_vprintf
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

! gchar* g_strndup (const gchar *str, gsize n) G_GNUC_MALLOC;
function g_strndup(str, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_strndup
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: n
end function

! gchar* g_strnfill (gsize length, gchar fill_char) G_GNUC_MALLOC;
function g_strnfill(length, fill_char) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_strnfill
  integer(c_size_t), value :: length
  character(c_char), value :: fill_char
end function

!  gchar* g_strcompress (const gchar *source) G_GNUC_MALLOC;
function g_strcompress(source) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strcompress
  character(kind=c_char), dimension(*) :: source
end function

!  gchar* g_strescape (const gchar *source, const gchar *exceptions) G_GNUC_MALLOC;
function g_strescape(source, exceptions) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strescape
  character(kind=c_char), dimension(*) :: source
  character(kind=c_char), dimension(*) :: exceptions
end function

!  gpointer g_memdup (gconstpointer mem, guint byte_size) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(2);
function g_memdup(mem, byte_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_memdup
  type(c_ptr), value :: mem
  integer(c_int), value :: byte_size
end function

!  gchar** g_strsplit (const gchar *string, const gchar *delimiter, gint max_tokens) G_GNUC_MALLOC;
function g_strsplit(string, delimiter, max_tokens) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_strsplit
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: delimiter
  integer(c_int), value :: max_tokens
end function

! gchar ** g_strsplit_set (const gchar *string, const gchar *delimiters, gint max_tokens) G_GNUC_MALLOC;
function g_strsplit_set(string, delimiters, max_tokens) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_strsplit_set
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: delimiters
  integer(c_int), value :: max_tokens
end function

! gchar* g_strjoinv (const gchar *separator, gchar **str_array) G_GNUC_MALLOC;
function g_strjoinv(separator, str_array) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strjoinv
  character(kind=c_char), dimension(*) :: separator
  character(kind=c_char), dimension(*) :: str_array
end function

! void g_strfreev (gchar **str_array);
subroutine g_strfreev(str_array) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: str_array
end subroutine

! gchar** g_strdupv (gchar **str_array) G_GNUC_MALLOC;
function g_strdupv(str_array) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strdupv
  character(kind=c_char), dimension(*) :: str_array
end function

! guint g_strv_length (gchar **str_array);
function g_strv_length(str_array) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_strv_length
  character(kind=c_char), dimension(*) :: str_array
end function

!  gchar* g_stpcpy (gchar *dest, const char *src);
function g_stpcpy(dest, src) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_stpcpy
  character(kind=c_char), dimension(*) :: dest
  character(kind=c_char), dimension(*) :: src
end function

!  G_CONST_RETURN gchar *g_strip_context (const gchar *msgid, const gchar *msgval) G_GNUC_FORMAT(1);
function g_strip_context(msgid, msgval) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strip_context
  character(kind=c_char), dimension(*) :: msgid
  character(kind=c_char), dimension(*) :: msgval
end function

!  G_CONST_RETURN gchar *g_dgettext (const gchar *domain, const gchar *msgid) G_GNUC_FORMAT(2);
function g_dgettext(domain, msgid) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dgettext
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: msgid
end function

! G_CONST_RETURN gchar *g_dcgettext (const gchar *domain, const gchar *msgid, int category) G_GNUC_FORMAT(2);
function g_dcgettext(domain, msgid, category) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_dcgettext
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: msgid
  integer(c_int), value :: category
end function

! G_CONST_RETURN gchar *g_dngettext (const gchar *domain, const gchar *msgid, const gchar *msgid_plural, gulong n) G_GNUC_FORMAT(3);
function g_dngettext(domain, msgid, msgid_plural, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr) :: g_dngettext
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: msgid
  character(kind=c_char), dimension(*) :: msgid_plural
  integer(c_long), value :: n
end function

! G_CONST_RETURN gchar *g_dpgettext (const gchar *domain, const gchar *msgctxtid, gsize msgidoffset) G_GNUC_FORMAT(2);
function g_dpgettext(domain, msgctxtid, msgidoffset) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_dpgettext
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: msgctxtid
  integer(c_size_t), value :: msgidoffset
end function

! G_CONST_RETURN gchar *g_dpgettext2 (const gchar *domain, const gchar *context, const gchar *msgid) G_GNUC_FORMAT(3);
function g_dpgettext2(domain, context, msgid) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dpgettext2
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: context
  character(kind=c_char), dimension(*) :: msgid
end function

!   void g_variant_unref (GVariant *value);
subroutine g_variant_unref(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
end subroutine

! GVariant * g_variant_ref (GVariant *value);
function g_variant_ref(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_ref
  type(c_ptr), value :: value
end function

! GVariant * g_variant_ref_sink (GVariant *value);
function g_variant_ref_sink(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_ref_sink
  type(c_ptr), value :: value
end function

! gboolean g_variant_is_floating (GVariant *value);
function g_variant_is_floating(value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_variant_is_floating
  type(c_ptr), value :: value
end function

!  const GVariantType * g_variant_get_type (GVariant *value);
function g_variant_get_type(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_type
  type(c_ptr), value :: value
end function

! const gchar * g_variant_get_type_string (GVariant *value);
function g_variant_get_type_string(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_type_string
  type(c_ptr), value :: value
end function

! gboolean g_variant_is_of_type (GVariant *value, const GVariantType *type);
function g_variant_is_of_type(value, type) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_variant_is_of_type
  type(c_ptr), value :: value
  type(c_ptr), value :: type
end function

! gboolean g_variant_is_container (GVariant *value);
function g_variant_is_container(value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_variant_is_container
  type(c_ptr), value :: value
end function

! GVariantClass g_variant_classify (GVariant *value);
function g_variant_classify(value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_classify
  type(c_ptr), value :: value
end function

! GVariant * g_variant_new_boolean (gboolean boolean);
function g_variant_new_boolean(boolean) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: g_variant_new_boolean
  logical(c_bool), value :: boolean
end function

! GVariant * g_variant_new_byte (guchar byte);
function g_variant_new_byte(byte) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_new_byte
  character(c_char), value :: byte
end function

! GVariant * g_variant_new_int16 (gint16 int16);
function g_variant_new_int16(int16) bind(c) 
  use iso_c_binding, only: c_ptr, c_int16_t
  type(c_ptr) :: g_variant_new_int16
  integer(c_int16_t), value :: int16
end function

! GVariant * g_variant_new_uint16 (guint16 uint16);
function g_variant_new_uint16(uint16) bind(c) 
  use iso_c_binding, only: c_ptr, c_int16_t
  type(c_ptr) :: g_variant_new_uint16
  integer(c_int16_t), value :: uint16
end function

! GVariant * g_variant_new_int32 (gint32 int32);
function g_variant_new_int32(int32) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_variant_new_int32
  integer(c_int32_t), value :: int32
end function

! GVariant * g_variant_new_uint32 (guint32 uint32);
function g_variant_new_uint32(uint32) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_variant_new_uint32
  integer(c_int32_t), value :: uint32
end function

! GVariant * g_variant_new_int64 (gint64 int64);
function g_variant_new_int64(int64) bind(c) 
  use iso_c_binding, only: c_ptr, c_int64_t
  type(c_ptr) :: g_variant_new_int64
  integer(c_int64_t), value :: int64
end function

! GVariant * g_variant_new_uint64 (guint64 uint64);
function g_variant_new_uint64(uint64) bind(c) 
  use iso_c_binding, only: c_ptr, c_int64_t
  type(c_ptr) :: g_variant_new_uint64
  integer(c_int64_t), value :: uint64
end function

! GVariant * g_variant_new_handle (gint32 handle);
function g_variant_new_handle(handle) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_variant_new_handle
  integer(c_int32_t), value :: handle
end function

! GVariant * g_variant_new_double (gdouble floating);
function g_variant_new_double(floating) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr) :: g_variant_new_double
  real(c_double), value :: floating
end function

! GVariant * g_variant_new_string (const gchar *string);
function g_variant_new_string(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_new_string
  character(kind=c_char), dimension(*) :: string
end function

! GVariant * g_variant_new_object_path (const gchar *object_path);
function g_variant_new_object_path(object_path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_new_object_path
  character(kind=c_char), dimension(*) :: object_path
end function

! gboolean g_variant_is_object_path (const gchar *string);
function g_variant_is_object_path(string) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_variant_is_object_path
  character(kind=c_char), dimension(*) :: string
end function

! GVariant * g_variant_new_signature (const gchar *signature);
function g_variant_new_signature(signature) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_new_signature
  character(kind=c_char), dimension(*) :: signature
end function

! gboolean g_variant_is_signature (const gchar *string);
function g_variant_is_signature(string) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_variant_is_signature
  character(kind=c_char), dimension(*) :: string
end function

! GVariant * g_variant_new_variant (GVariant *value);
function g_variant_new_variant(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_new_variant
  type(c_ptr), value :: value
end function

! GVariant * g_variant_new_strv (const gchar * const *strv, gssize length);
function g_variant_new_strv(strv, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_variant_new_strv
  character(kind=c_char), dimension(*) :: strv
  integer(c_size_t), value :: length
end function

! GVariant * g_variant_new_bytestring (const gchar *string);
function g_variant_new_bytestring(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_new_bytestring
  character(kind=c_char), dimension(*) :: string
end function

! GVariant * g_variant_new_bytestring_array (const gchar * const *strv, gssize length);
function g_variant_new_bytestring_array(strv, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_variant_new_bytestring_array
  character(kind=c_char), dimension(*) :: strv
  integer(c_size_t), value :: length
end function

!  gboolean g_variant_get_boolean (GVariant *value);
function g_variant_get_boolean(value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_variant_get_boolean
  type(c_ptr), value :: value
end function

! guchar g_variant_get_byte (GVariant *value);
function g_variant_get_byte(value) bind(c) 
  use iso_c_binding, only: c_char, c_ptr
  character(c_char) :: g_variant_get_byte
  type(c_ptr), value :: value
end function

! gint16 g_variant_get_int16 (GVariant *value);
function g_variant_get_int16(value) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_variant_get_int16
  type(c_ptr), value :: value
end function

! guint16 g_variant_get_uint16 (GVariant *value);
function g_variant_get_uint16(value) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_variant_get_uint16
  type(c_ptr), value :: value
end function

! gint32 g_variant_get_int32 (GVariant *value);
function g_variant_get_int32(value) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_variant_get_int32
  type(c_ptr), value :: value
end function

! guint32 g_variant_get_uint32 (GVariant *value);
function g_variant_get_uint32(value) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_variant_get_uint32
  type(c_ptr), value :: value
end function

! gint64 g_variant_get_int64 (GVariant *value);
function g_variant_get_int64(value) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_variant_get_int64
  type(c_ptr), value :: value
end function

! guint64 g_variant_get_uint64 (GVariant *value);
function g_variant_get_uint64(value) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_variant_get_uint64
  type(c_ptr), value :: value
end function

! gint32 g_variant_get_handle (GVariant *value);
function g_variant_get_handle(value) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_variant_get_handle
  type(c_ptr), value :: value
end function

! gdouble g_variant_get_double (GVariant *value);
function g_variant_get_double(value) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: g_variant_get_double
  type(c_ptr), value :: value
end function

! GVariant * g_variant_get_variant (GVariant *value);
function g_variant_get_variant(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_variant
  type(c_ptr), value :: value
end function

! const gchar * g_variant_get_string (GVariant *value, gsize *length);
function g_variant_get_string(value, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_string
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! gchar * g_variant_dup_string (GVariant *value, gsize *length);
function g_variant_dup_string(value, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_dup_string
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! const gchar ** g_variant_get_strv (GVariant *value, gsize *length);
function g_variant_get_strv(value, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_strv
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! gchar ** g_variant_dup_strv (GVariant *value, gsize *length);
function g_variant_dup_strv(value, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_dup_strv
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! const gchar * g_variant_get_bytestring (GVariant *value);
function g_variant_get_bytestring(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_bytestring
  type(c_ptr), value :: value
end function

! gchar * g_variant_dup_bytestring (GVariant *value, gsize *length);
function g_variant_dup_bytestring(value, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_dup_bytestring
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! const gchar ** g_variant_get_bytestring_array (GVariant *value, gsize *length);
function g_variant_get_bytestring_array(value, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_bytestring_array
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! gchar ** g_variant_dup_bytestring_array (GVariant *value, gsize *length);
function g_variant_dup_bytestring_array(value, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_dup_bytestring_array
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

!  GVariant * g_variant_new_maybe (const GVariantType *child_type, GVariant *child);
function g_variant_new_maybe(child_type, child) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_new_maybe
  type(c_ptr), value :: child_type
  type(c_ptr), value :: child
end function

! GVariant * g_variant_new_array (const GVariantType *child_type, GVariant * const *children, gsize n_children);
function g_variant_new_array(child_type, children, n_children) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_variant_new_array
  type(c_ptr), value :: child_type
  type(c_ptr), value :: children
  integer(c_size_t), value :: n_children
end function

! GVariant * g_variant_new_tuple (GVariant * const *children, gsize n_children);
function g_variant_new_tuple(children, n_children) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_variant_new_tuple
  type(c_ptr), value :: children
  integer(c_size_t), value :: n_children
end function

! GVariant * g_variant_new_dict_entry (GVariant *key, GVariant *value);
function g_variant_new_dict_entry(key, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_new_dict_entry
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end function

!  GVariant * g_variant_get_maybe (GVariant *value);
function g_variant_get_maybe(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_maybe
  type(c_ptr), value :: value
end function

! gsize g_variant_n_children (GVariant *value);
function g_variant_n_children(value) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_variant_n_children
  type(c_ptr), value :: value
end function

! GVariant * g_variant_get_child_value (GVariant *value, gsize index_);
function g_variant_get_child_value(value, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_variant_get_child_value
  type(c_ptr), value :: value
  integer(c_size_t), value :: index_
end function

! gconstpointer g_variant_get_fixed_array (GVariant *value, gsize *n_elements, gsize element_size);
function g_variant_get_fixed_array(value, n_elements, element_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_variant_get_fixed_array
  type(c_ptr), value :: value
  type(c_ptr), value :: n_elements
  integer(c_size_t), value :: element_size
end function

!  gsize g_variant_get_size (GVariant *value);
function g_variant_get_size(value) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_variant_get_size
  type(c_ptr), value :: value
end function

! gconstpointer g_variant_get_data (GVariant *value);
function g_variant_get_data(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_data
  type(c_ptr), value :: value
end function

! void g_variant_store (GVariant *value, gpointer data);
subroutine g_variant_store(value, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: data
end subroutine

!  gchar * g_variant_print (GVariant *value, gboolean type_annotate);
function g_variant_print(value, type_annotate) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: g_variant_print
  type(c_ptr), value :: value
  logical(c_bool), value :: type_annotate
end function

! GString * g_variant_print_string (GVariant *value, GString *string, gboolean type_annotate);
function g_variant_print_string(value, string, type_annotate) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: g_variant_print_string
  type(c_ptr), value :: value
  type(c_ptr), value :: string
  logical(c_bool), value :: type_annotate
end function

!  guint g_variant_hash (gconstpointer value);
function g_variant_hash(value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_hash
  type(c_ptr), value :: value
end function

! gboolean g_variant_equal (gconstpointer one, gconstpointer two);
function g_variant_equal(one, two) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_variant_equal
  type(c_ptr), value :: one
  type(c_ptr), value :: two
end function

!  GVariant * g_variant_get_normal_form (GVariant *value);
function g_variant_get_normal_form(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_normal_form
  type(c_ptr), value :: value
end function

! gboolean g_variant_is_normal_form (GVariant *value);
function g_variant_is_normal_form(value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_variant_is_normal_form
  type(c_ptr), value :: value
end function

! GVariant * g_variant_byteswap (GVariant *value);
function g_variant_byteswap(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_byteswap
  type(c_ptr), value :: value
end function

! GVariant * g_variant_new_from_data (const GVariantType *type, gconstpointer data, gsize size, gboolean trusted, GDestroyNotify notify, gpointer user_data);
function g_variant_new_from_data(type, data, size, trusted, notify, user_data) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_bool, c_funptr
  type(c_ptr) :: g_variant_new_from_data
  type(c_ptr), value :: type
  type(c_ptr), value :: data
  integer(c_size_t), value :: size
  logical(c_bool), value :: trusted
  type(c_funptr), value :: notify
  type(c_ptr), value :: user_data
end function

!  GVariantIter * g_variant_iter_new (GVariant *value);
function g_variant_iter_new(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_iter_new
  type(c_ptr), value :: value
end function

! gsize g_variant_iter_init (GVariantIter *iter, GVariant *value);
function g_variant_iter_init(iter, value) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_variant_iter_init
  type(c_ptr), value :: iter
  type(c_ptr), value :: value
end function

! GVariantIter * g_variant_iter_copy (GVariantIter *iter);
function g_variant_iter_copy(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_iter_copy
  type(c_ptr), value :: iter
end function

! gsize g_variant_iter_n_children (GVariantIter *iter);
function g_variant_iter_n_children(iter) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_variant_iter_n_children
  type(c_ptr), value :: iter
end function

! void g_variant_iter_free (GVariantIter *iter);
subroutine g_variant_iter_free(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
end subroutine

! GVariant * g_variant_iter_next_value (GVariantIter *iter);
function g_variant_iter_next_value(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_iter_next_value
  type(c_ptr), value :: iter
end function

!  GQuark g_variant_parser_get_error_quark (void);
function g_variant_parser_get_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_variant_parser_get_error_quark
end function

!  GVariantBuilder * g_variant_builder_new (const GVariantType *type);
function g_variant_builder_new(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_builder_new
  type(c_ptr), value :: type
end function

! void g_variant_builder_unref (GVariantBuilder *builder);
subroutine g_variant_builder_unref(builder) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: builder
end subroutine

! GVariantBuilder * g_variant_builder_ref (GVariantBuilder *builder);
function g_variant_builder_ref(builder) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_builder_ref
  type(c_ptr), value :: builder
end function

! void g_variant_builder_init (GVariantBuilder *builder, const GVariantType *type);
subroutine g_variant_builder_init(builder, type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: builder
  type(c_ptr), value :: type
end subroutine

! GVariant * g_variant_builder_end (GVariantBuilder *builder);
function g_variant_builder_end(builder) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_builder_end
  type(c_ptr), value :: builder
end function

! void g_variant_builder_clear (GVariantBuilder *builder);
subroutine g_variant_builder_clear(builder) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: builder
end subroutine

! void g_variant_builder_open (GVariantBuilder *builder, const GVariantType *type);
subroutine g_variant_builder_open(builder, type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: builder
  type(c_ptr), value :: type
end subroutine

! void g_variant_builder_close (GVariantBuilder *builder);
subroutine g_variant_builder_close(builder) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: builder
end subroutine

! void g_variant_builder_add_value (GVariantBuilder *builder, GVariant *value);
subroutine g_variant_builder_add_value(builder, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: builder
  type(c_ptr), value :: value
end subroutine

! GVariant * g_variant_new_va (const gchar *format_string, const gchar **endptr, va_list *app);
function g_variant_new_va(format_string, endptr, app) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_new_va
  character(kind=c_char), dimension(*) :: format_string
  character(kind=c_char), dimension(*) :: endptr
  type(c_ptr), value :: app
end function

! void g_variant_get_va (GVariant *value, const gchar *format_string, const gchar **endptr, va_list *app);
subroutine g_variant_get_va(value, format_string, endptr, app) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: value
  character(kind=c_char), dimension(*) :: format_string
  character(kind=c_char), dimension(*) :: endptr
  type(c_ptr), value :: app
end subroutine

!  GVariant * g_variant_parse (const GVariantType *type, const gchar *text, const gchar *limit, const gchar **endptr, GError **error);
function g_variant_parse(type, text, limit, endptr, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_parse
  type(c_ptr), value :: type
  character(kind=c_char), dimension(*) :: text
  character(kind=c_char), dimension(*) :: limit
  character(kind=c_char), dimension(*) :: endptr
  type(c_ptr), value :: error
end function

! GVariant * g_variant_new_parsed_va (const gchar *format, va_list *app);
function g_variant_new_parsed_va(format, app) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_new_parsed_va
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: app
end function

!  gint g_variant_compare (gconstpointer one, gconstpointer two);
function g_variant_compare(one, two) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_compare
  type(c_ptr), value :: one
  type(c_ptr), value :: two
end function

!   GQuark g_quark_try_string (const gchar *string);
function g_quark_try_string(string) bind(c) 
  use iso_c_binding, only: c_int32_t, c_char
  integer(c_int32_t) :: g_quark_try_string
  character(kind=c_char), dimension(*) :: string
end function

! GQuark g_quark_from_static_string (const gchar *string);
function g_quark_from_static_string(string) bind(c) 
  use iso_c_binding, only: c_int32_t, c_char
  integer(c_int32_t) :: g_quark_from_static_string
  character(kind=c_char), dimension(*) :: string
end function

! GQuark g_quark_from_string (const gchar *string);
function g_quark_from_string(string) bind(c) 
  use iso_c_binding, only: c_int32_t, c_char
  integer(c_int32_t) :: g_quark_from_string
  character(kind=c_char), dimension(*) :: string
end function

! G_CONST_RETURN gchar* g_quark_to_string (GQuark quark) G_GNUC_CONST;
function g_quark_to_string(quark) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_quark_to_string
  integer(c_int32_t), value :: quark
end function

!  G_CONST_RETURN gchar* g_intern_string (const gchar *string);
function g_intern_string(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_intern_string
  character(kind=c_char), dimension(*) :: string
end function

! G_CONST_RETURN gchar* g_intern_static_string (const gchar *string);
function g_intern_static_string(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_intern_static_string
  character(kind=c_char), dimension(*) :: string
end function

!   GQueue* g_queue_new (void);
function g_queue_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_new
end function

! void g_queue_free (GQueue *queue);
subroutine g_queue_free(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
end subroutine

! void g_queue_init (GQueue *queue);
subroutine g_queue_init(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
end subroutine

! void g_queue_clear (GQueue *queue);
subroutine g_queue_clear(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
end subroutine

! gboolean g_queue_is_empty (GQueue *queue);
function g_queue_is_empty(queue) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_queue_is_empty
  type(c_ptr), value :: queue
end function

! guint g_queue_get_length (GQueue *queue);
function g_queue_get_length(queue) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_queue_get_length
  type(c_ptr), value :: queue
end function

! void g_queue_reverse (GQueue *queue);
subroutine g_queue_reverse(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
end subroutine

! GQueue * g_queue_copy (GQueue *queue);
function g_queue_copy(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_copy
  type(c_ptr), value :: queue
end function

! void g_queue_foreach (GQueue *queue, GFunc func, gpointer user_data);
subroutine g_queue_foreach(queue, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GList * g_queue_find (GQueue *queue, gconstpointer data);
function g_queue_find(queue, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_find
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end function

! GList * g_queue_find_custom (GQueue *queue, gconstpointer data, GCompareFunc func);
function g_queue_find_custom(queue, data, func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_queue_find_custom
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
  type(c_funptr), value :: func
end function

! void g_queue_sort (GQueue *queue, GCompareDataFunc compare_func, gpointer user_data);
subroutine g_queue_sort(queue, compare_func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end subroutine

!  void g_queue_push_head (GQueue *queue, gpointer data);
subroutine g_queue_push_head(queue, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end subroutine

! void g_queue_push_tail (GQueue *queue, gpointer data);
subroutine g_queue_push_tail(queue, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end subroutine

! void g_queue_push_nth (GQueue *queue, gpointer data, gint n);
subroutine g_queue_push_nth(queue, data, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
  integer(c_int), value :: n
end subroutine

! gpointer g_queue_pop_head (GQueue *queue);
function g_queue_pop_head(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_pop_head
  type(c_ptr), value :: queue
end function

! gpointer g_queue_pop_tail (GQueue *queue);
function g_queue_pop_tail(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_pop_tail
  type(c_ptr), value :: queue
end function

! gpointer g_queue_pop_nth (GQueue *queue, guint n);
function g_queue_pop_nth(queue, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_queue_pop_nth
  type(c_ptr), value :: queue
  integer(c_int), value :: n
end function

! gpointer g_queue_peek_head (GQueue *queue);
function g_queue_peek_head(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_peek_head
  type(c_ptr), value :: queue
end function

! gpointer g_queue_peek_tail (GQueue *queue);
function g_queue_peek_tail(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_peek_tail
  type(c_ptr), value :: queue
end function

! gpointer g_queue_peek_nth (GQueue *queue, guint n);
function g_queue_peek_nth(queue, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_queue_peek_nth
  type(c_ptr), value :: queue
  integer(c_int), value :: n
end function

! gint g_queue_index (GQueue *queue, gconstpointer data);
function g_queue_index(queue, data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_queue_index
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end function

! void g_queue_remove (GQueue *queue, gconstpointer data);
subroutine g_queue_remove(queue, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end subroutine

! void g_queue_remove_all (GQueue *queue, gconstpointer data);
subroutine g_queue_remove_all(queue, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end subroutine

! void g_queue_insert_before (GQueue *queue, GList *sibling, gpointer data);
subroutine g_queue_insert_before(queue, sibling, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: sibling
  type(c_ptr), value :: data
end subroutine

! void g_queue_insert_after (GQueue *queue, GList *sibling, gpointer data);
subroutine g_queue_insert_after(queue, sibling, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: sibling
  type(c_ptr), value :: data
end subroutine

! void g_queue_insert_sorted (GQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data);
subroutine g_queue_insert_sorted(queue, data, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!  void g_queue_push_head_link (GQueue *queue, GList *link_);
subroutine g_queue_push_head_link(queue, link_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: link_
end subroutine

! void g_queue_push_tail_link (GQueue *queue, GList *link_);
subroutine g_queue_push_tail_link(queue, link_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: link_
end subroutine

! void g_queue_push_nth_link (GQueue *queue, gint n, GList *link_);
subroutine g_queue_push_nth_link(queue, n, link_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: queue
  integer(c_int), value :: n
  type(c_ptr), value :: link_
end subroutine

! GList* g_queue_pop_head_link (GQueue *queue);
function g_queue_pop_head_link(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_pop_head_link
  type(c_ptr), value :: queue
end function

! GList* g_queue_pop_tail_link (GQueue *queue);
function g_queue_pop_tail_link(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_pop_tail_link
  type(c_ptr), value :: queue
end function

! GList* g_queue_pop_nth_link (GQueue *queue, guint n);
function g_queue_pop_nth_link(queue, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_queue_pop_nth_link
  type(c_ptr), value :: queue
  integer(c_int), value :: n
end function

! GList* g_queue_peek_head_link (GQueue *queue);
function g_queue_peek_head_link(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_peek_head_link
  type(c_ptr), value :: queue
end function

! GList* g_queue_peek_tail_link (GQueue *queue);
function g_queue_peek_tail_link(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_peek_tail_link
  type(c_ptr), value :: queue
end function

! GList* g_queue_peek_nth_link (GQueue *queue, guint n);
function g_queue_peek_nth_link(queue, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_queue_peek_nth_link
  type(c_ptr), value :: queue
  integer(c_int), value :: n
end function

! gint g_queue_link_index (GQueue *queue, GList *link_);
function g_queue_link_index(queue, link_) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_queue_link_index
  type(c_ptr), value :: queue
  type(c_ptr), value :: link_
end function

! void g_queue_unlink (GQueue *queue, GList *link_);
subroutine g_queue_unlink(queue, link_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: link_
end subroutine

! void g_queue_delete_link (GQueue *queue, GList *link_);
subroutine g_queue_delete_link(queue, link_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: link_
end subroutine

!     void g_qsort_with_data (gconstpointer pbase, gint total_elems, gsize size, GCompareDataFunc compare_func, gpointer user_data);
subroutine g_qsort_with_data(pbase, total_elems, size, compare_func, user_data) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_size_t, c_funptr
  type(c_ptr), value :: pbase
  integer(c_int), value :: total_elems
  integer(c_size_t), value :: size
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end subroutine

!   GMappedFile *g_mapped_file_new (const gchar *filename, gboolean writable, GError **error) G_GNUC_MALLOC;
function g_mapped_file_new(filename, writable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_bool
  type(c_ptr) :: g_mapped_file_new
  character(kind=c_char), dimension(*) :: filename
  logical(c_bool), value :: writable
  type(c_ptr), value :: error
end function

! gsize g_mapped_file_get_length (GMappedFile *file);
function g_mapped_file_get_length(file) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_mapped_file_get_length
  type(c_ptr), value :: file
end function

! gchar *g_mapped_file_get_contents (GMappedFile *file);
function g_mapped_file_get_contents(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mapped_file_get_contents
  type(c_ptr), value :: file
end function

! GMappedFile *g_mapped_file_ref (GMappedFile *file);
function g_mapped_file_ref(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mapped_file_ref
  type(c_ptr), value :: file
end function

! void g_mapped_file_unref (GMappedFile *file);
subroutine g_mapped_file_unref(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: file
end subroutine

!  void g_mapped_file_free (GMappedFile *file);
subroutine g_mapped_file_free(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: file
end subroutine

!   GTimeZone * g_time_zone_new (const gchar *identifier);
function g_time_zone_new(identifier) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_time_zone_new
  character(kind=c_char), dimension(*) :: identifier
end function

! GTimeZone * g_time_zone_new_utc (void);
function g_time_zone_new_utc() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_time_zone_new_utc
end function

! GTimeZone * g_time_zone_new_local (void);
function g_time_zone_new_local() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_time_zone_new_local
end function

!  GTimeZone * g_time_zone_ref (GTimeZone *tz);
function g_time_zone_ref(tz) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_time_zone_ref
  type(c_ptr), value :: tz
end function

! void g_time_zone_unref (GTimeZone *tz);
subroutine g_time_zone_unref(tz) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tz
end subroutine

!   GSequence * g_sequence_new (GDestroyNotify data_destroy);
function g_sequence_new(data_destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_sequence_new
  type(c_funptr), value :: data_destroy
end function

! void g_sequence_free (GSequence *seq);
subroutine g_sequence_free(seq) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: seq
end subroutine

! gint g_sequence_get_length (GSequence *seq);
function g_sequence_get_length(seq) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_sequence_get_length
  type(c_ptr), value :: seq
end function

! void g_sequence_foreach (GSequence *seq, GFunc func, gpointer user_data);
subroutine g_sequence_foreach(seq, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: seq
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! void g_sequence_foreach_range (GSequenceIter *begin, GSequenceIter *end, GFunc func, gpointer user_data);
subroutine g_sequence_foreach_range(begin, end, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: begin
  type(c_ptr), value :: end
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! void g_sequence_sort (GSequence *seq, GCompareDataFunc cmp_func, gpointer cmp_data);
subroutine g_sequence_sort(seq, cmp_func, cmp_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: seq
  type(c_funptr), value :: cmp_func
  type(c_ptr), value :: cmp_data
end subroutine

! void g_sequence_sort_iter (GSequence *seq, GSequenceIterCompareFunc cmp_func, gpointer cmp_data);
subroutine g_sequence_sort_iter(seq, cmp_func, cmp_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: seq
  type(c_funptr), value :: cmp_func
  type(c_ptr), value :: cmp_data
end subroutine

!  GSequenceIter *g_sequence_get_begin_iter (GSequence *seq);
function g_sequence_get_begin_iter(seq) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_get_begin_iter
  type(c_ptr), value :: seq
end function

! GSequenceIter *g_sequence_get_end_iter (GSequence *seq);
function g_sequence_get_end_iter(seq) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_get_end_iter
  type(c_ptr), value :: seq
end function

! GSequenceIter *g_sequence_get_iter_at_pos (GSequence *seq, gint pos);
function g_sequence_get_iter_at_pos(seq, pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_sequence_get_iter_at_pos
  type(c_ptr), value :: seq
  integer(c_int), value :: pos
end function

! GSequenceIter *g_sequence_append (GSequence *seq, gpointer data);
function g_sequence_append(seq, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_append
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
end function

! GSequenceIter *g_sequence_prepend (GSequence *seq, gpointer data);
function g_sequence_prepend(seq, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_prepend
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
end function

! GSequenceIter *g_sequence_insert_before (GSequenceIter *iter, gpointer data);
function g_sequence_insert_before(iter, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_insert_before
  type(c_ptr), value :: iter
  type(c_ptr), value :: data
end function

! void g_sequence_move (GSequenceIter *src, GSequenceIter *dest);
subroutine g_sequence_move(src, dest) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: src
  type(c_ptr), value :: dest
end subroutine

! void g_sequence_swap (GSequenceIter *a, GSequenceIter *b);
subroutine g_sequence_swap(a, b) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end subroutine

! GSequenceIter *g_sequence_insert_sorted (GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data);
function g_sequence_insert_sorted(seq, data, cmp_func, cmp_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_sequence_insert_sorted
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
  type(c_funptr), value :: cmp_func
  type(c_ptr), value :: cmp_data
end function

! GSequenceIter *g_sequence_insert_sorted_iter (GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
function g_sequence_insert_sorted_iter(seq, data, iter_cmp, cmp_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_sequence_insert_sorted_iter
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
  type(c_funptr), value :: iter_cmp
  type(c_ptr), value :: cmp_data
end function

! void g_sequence_sort_changed (GSequenceIter *iter, GCompareDataFunc cmp_func, gpointer cmp_data);
subroutine g_sequence_sort_changed(iter, cmp_func, cmp_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: iter
  type(c_funptr), value :: cmp_func
  type(c_ptr), value :: cmp_data
end subroutine

! void g_sequence_sort_changed_iter (GSequenceIter *iter, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
subroutine g_sequence_sort_changed_iter(iter, iter_cmp, cmp_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: iter
  type(c_funptr), value :: iter_cmp
  type(c_ptr), value :: cmp_data
end subroutine

! void g_sequence_remove (GSequenceIter *iter);
subroutine g_sequence_remove(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
end subroutine

! void g_sequence_remove_range (GSequenceIter *begin, GSequenceIter *end);
subroutine g_sequence_remove_range(begin, end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: begin
  type(c_ptr), value :: end
end subroutine

! void g_sequence_move_range (GSequenceIter *dest, GSequenceIter *begin, GSequenceIter *end);
subroutine g_sequence_move_range(dest, begin, end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: dest
  type(c_ptr), value :: begin
  type(c_ptr), value :: end
end subroutine

! GSequenceIter *g_sequence_search (GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data);
function g_sequence_search(seq, data, cmp_func, cmp_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_sequence_search
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
  type(c_funptr), value :: cmp_func
  type(c_ptr), value :: cmp_data
end function

! GSequenceIter *g_sequence_search_iter (GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
function g_sequence_search_iter(seq, data, iter_cmp, cmp_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_sequence_search_iter
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
  type(c_funptr), value :: iter_cmp
  type(c_ptr), value :: cmp_data
end function

!  gpointer g_sequence_get (GSequenceIter *iter);
function g_sequence_get(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_get
  type(c_ptr), value :: iter
end function

! void g_sequence_set (GSequenceIter *iter, gpointer data);
subroutine g_sequence_set(iter, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
  type(c_ptr), value :: data
end subroutine

!  gboolean g_sequence_iter_is_begin (GSequenceIter *iter);
function g_sequence_iter_is_begin(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_sequence_iter_is_begin
  type(c_ptr), value :: iter
end function

! gboolean g_sequence_iter_is_end (GSequenceIter *iter);
function g_sequence_iter_is_end(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_sequence_iter_is_end
  type(c_ptr), value :: iter
end function

! GSequenceIter *g_sequence_iter_next (GSequenceIter *iter);
function g_sequence_iter_next(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_iter_next
  type(c_ptr), value :: iter
end function

! GSequenceIter *g_sequence_iter_prev (GSequenceIter *iter);
function g_sequence_iter_prev(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_iter_prev
  type(c_ptr), value :: iter
end function

! gint g_sequence_iter_get_position (GSequenceIter *iter);
function g_sequence_iter_get_position(iter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_sequence_iter_get_position
  type(c_ptr), value :: iter
end function

! GSequenceIter *g_sequence_iter_move (GSequenceIter *iter, gint delta);
function g_sequence_iter_move(iter, delta) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_sequence_iter_move
  type(c_ptr), value :: iter
  integer(c_int), value :: delta
end function

! GSequence * g_sequence_iter_get_sequence (GSequenceIter *iter);
function g_sequence_iter_get_sequence(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_iter_get_sequence
  type(c_ptr), value :: iter
end function

!  gint g_sequence_iter_compare (GSequenceIter *a, GSequenceIter *b);
function g_sequence_iter_compare(a, b) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_sequence_iter_compare
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GSequenceIter *g_sequence_range_get_midpoint (GSequenceIter *begin, GSequenceIter *end);
function g_sequence_range_get_midpoint(begin, end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_range_get_midpoint
  type(c_ptr), value :: begin
  type(c_ptr), value :: end
end function

!   GList* g_list_alloc (void) G_GNUC_WARN_UNUSED_RESULT;
function g_list_alloc() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_alloc
end function

! void g_list_free (GList *list);
subroutine g_list_free(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

! void g_list_free_1 (GList *list);
subroutine g_list_free_1(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

!  GList* g_list_append (GList *list, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_append(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_append
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GList* g_list_prepend (GList *list, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_prepend(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_prepend
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GList* g_list_insert (GList *list, gpointer data, gint position) G_GNUC_WARN_UNUSED_RESULT;
function g_list_insert(list, data, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_list_insert
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  integer(c_int), value :: position
end function

! GList* g_list_insert_sorted (GList *list, gpointer data, GCompareFunc func) G_GNUC_WARN_UNUSED_RESULT;
function g_list_insert_sorted(list, data, func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_list_insert_sorted
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  type(c_funptr), value :: func
end function

! GList* g_list_insert_sorted_with_data (GList *list, gpointer data, GCompareDataFunc func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_insert_sorted_with_data(list, data, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_list_insert_sorted_with_data
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end function

! GList* g_list_insert_before (GList *list, GList *sibling, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_insert_before(list, sibling, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_insert_before
  type(c_ptr), value :: list
  type(c_ptr), value :: sibling
  type(c_ptr), value :: data
end function

! GList* g_list_concat (GList *list1, GList *list2) G_GNUC_WARN_UNUSED_RESULT;
function g_list_concat(list1, list2) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_concat
  type(c_ptr), value :: list1
  type(c_ptr), value :: list2
end function

! GList* g_list_remove (GList *list, gconstpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_remove(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_remove
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GList* g_list_remove_all (GList *list, gconstpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_remove_all(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_remove_all
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GList* g_list_remove_link (GList *list, GList *llink) G_GNUC_WARN_UNUSED_RESULT;
function g_list_remove_link(list, llink) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_remove_link
  type(c_ptr), value :: list
  type(c_ptr), value :: llink
end function

! GList* g_list_delete_link (GList *list, GList *link_) G_GNUC_WARN_UNUSED_RESULT;
function g_list_delete_link(list, link_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_delete_link
  type(c_ptr), value :: list
  type(c_ptr), value :: link_
end function

! GList* g_list_reverse (GList *list) G_GNUC_WARN_UNUSED_RESULT;
function g_list_reverse(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_reverse
  type(c_ptr), value :: list
end function

! GList* g_list_copy (GList *list) G_GNUC_WARN_UNUSED_RESULT;
function g_list_copy(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_copy
  type(c_ptr), value :: list
end function

! GList* g_list_nth (GList *list, guint n);
function g_list_nth(list, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_list_nth
  type(c_ptr), value :: list
  integer(c_int), value :: n
end function

! GList* g_list_nth_prev (GList *list, guint n);
function g_list_nth_prev(list, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_list_nth_prev
  type(c_ptr), value :: list
  integer(c_int), value :: n
end function

! GList* g_list_find (GList *list, gconstpointer data);
function g_list_find(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_find
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GList* g_list_find_custom (GList *list, gconstpointer data, GCompareFunc func);
function g_list_find_custom(list, data, func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_list_find_custom
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  type(c_funptr), value :: func
end function

! gint g_list_position (GList *list, GList *llink);
function g_list_position(list, llink) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_list_position
  type(c_ptr), value :: list
  type(c_ptr), value :: llink
end function

! gint g_list_index (GList *list, gconstpointer data);
function g_list_index(list, data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_list_index
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GList* g_list_last (GList *list);
function g_list_last(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_last
  type(c_ptr), value :: list
end function

! GList* g_list_first (GList *list);
function g_list_first(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_first
  type(c_ptr), value :: list
end function

! guint g_list_length (GList *list);
function g_list_length(list) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_list_length
  type(c_ptr), value :: list
end function

! void g_list_foreach (GList *list, GFunc func, gpointer user_data);
subroutine g_list_foreach(list, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: list
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GList* g_list_sort (GList *list, GCompareFunc compare_func) G_GNUC_WARN_UNUSED_RESULT;
function g_list_sort(list, compare_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_list_sort
  type(c_ptr), value :: list
  type(c_funptr), value :: compare_func
end function

! GList* g_list_sort_with_data (GList *list, GCompareDataFunc compare_func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_sort_with_data(list, compare_func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_list_sort_with_data
  type(c_ptr), value :: list
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end function

! gpointer g_list_nth_data (GList *list, guint n);
function g_list_nth_data(list, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_list_nth_data
  type(c_ptr), value :: list
  integer(c_int), value :: n
end function

!  void g_list_push_allocator (gpointer allocator);
subroutine g_list_push_allocator(allocator) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: allocator
end subroutine

! void g_list_pop_allocator (void);
subroutine g_list_pop_allocator() bind(c) 
  use iso_c_binding, only: 
end subroutine

!   void g_bit_lock (volatile gint *address, gint lock_bit);
subroutine g_bit_lock(address, lock_bit) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: address
  integer(c_int), value :: lock_bit
end subroutine

! gboolean g_bit_trylock (volatile gint *address, gint lock_bit);
function g_bit_trylock(address, lock_bit) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: g_bit_trylock
  type(c_ptr), value :: address
  integer(c_int), value :: lock_bit
end function

! void g_bit_unlock (volatile gint *address, gint lock_bit);
subroutine g_bit_unlock(address, lock_bit) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: address
  integer(c_int), value :: lock_bit
end subroutine

!   GSList* g_slist_alloc (void) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_alloc() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_alloc
end function

! void g_slist_free (GSList *list);
subroutine g_slist_free(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

! void g_slist_free_1 (GSList *list);
subroutine g_slist_free_1(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

!  GSList* g_slist_append (GSList *list, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_append(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_append
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GSList* g_slist_prepend (GSList *list, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_prepend(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_prepend
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GSList* g_slist_insert (GSList *list, gpointer data, gint position) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_insert(list, data, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_slist_insert
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  integer(c_int), value :: position
end function

! GSList* g_slist_insert_sorted (GSList *list, gpointer data, GCompareFunc func) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_insert_sorted(list, data, func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_slist_insert_sorted
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  type(c_funptr), value :: func
end function

! GSList* g_slist_insert_sorted_with_data (GSList *list, gpointer data, GCompareDataFunc func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_insert_sorted_with_data(list, data, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_slist_insert_sorted_with_data
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end function

! GSList* g_slist_insert_before (GSList *slist, GSList *sibling, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_insert_before(slist, sibling, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_insert_before
  type(c_ptr), value :: slist
  type(c_ptr), value :: sibling
  type(c_ptr), value :: data
end function

! GSList* g_slist_concat (GSList *list1, GSList *list2) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_concat(list1, list2) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_concat
  type(c_ptr), value :: list1
  type(c_ptr), value :: list2
end function

! GSList* g_slist_remove (GSList *list, gconstpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_remove(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_remove
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GSList* g_slist_remove_all (GSList *list, gconstpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_remove_all(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_remove_all
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GSList* g_slist_remove_link (GSList *list, GSList *link_) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_remove_link(list, link_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_remove_link
  type(c_ptr), value :: list
  type(c_ptr), value :: link_
end function

! GSList* g_slist_delete_link (GSList *list, GSList *link_) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_delete_link(list, link_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_delete_link
  type(c_ptr), value :: list
  type(c_ptr), value :: link_
end function

! GSList* g_slist_reverse (GSList *list) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_reverse(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_reverse
  type(c_ptr), value :: list
end function

! GSList* g_slist_copy (GSList *list) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_copy(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_copy
  type(c_ptr), value :: list
end function

! GSList* g_slist_nth (GSList *list, guint n);
function g_slist_nth(list, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_slist_nth
  type(c_ptr), value :: list
  integer(c_int), value :: n
end function

! GSList* g_slist_find (GSList *list, gconstpointer data);
function g_slist_find(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_find
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GSList* g_slist_find_custom (GSList *list, gconstpointer data, GCompareFunc func);
function g_slist_find_custom(list, data, func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_slist_find_custom
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  type(c_funptr), value :: func
end function

! gint g_slist_position (GSList *list, GSList *llink);
function g_slist_position(list, llink) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_slist_position
  type(c_ptr), value :: list
  type(c_ptr), value :: llink
end function

! gint g_slist_index (GSList *list, gconstpointer data);
function g_slist_index(list, data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_slist_index
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GSList* g_slist_last (GSList *list);
function g_slist_last(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_last
  type(c_ptr), value :: list
end function

! guint g_slist_length (GSList *list);
function g_slist_length(list) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_slist_length
  type(c_ptr), value :: list
end function

! void g_slist_foreach (GSList *list, GFunc func, gpointer user_data);
subroutine g_slist_foreach(list, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: list
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GSList* g_slist_sort (GSList *list, GCompareFunc compare_func) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_sort(list, compare_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_slist_sort
  type(c_ptr), value :: list
  type(c_funptr), value :: compare_func
end function

! GSList* g_slist_sort_with_data (GSList *list, GCompareDataFunc compare_func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_sort_with_data(list, compare_func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_slist_sort_with_data
  type(c_ptr), value :: list
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end function

! gpointer g_slist_nth_data (GSList *list, guint n);
function g_slist_nth_data(list, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_slist_nth_data
  type(c_ptr), value :: list
  integer(c_int), value :: n
end function

!  void g_slist_push_allocator (gpointer dummy);
subroutine g_slist_push_allocator(dummy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: dummy
end subroutine

! void g_slist_pop_allocator (void);
subroutine g_slist_pop_allocator() bind(c) 
  use iso_c_binding, only: 
end subroutine

!   GCompletion* g_completion_new (GCompletionFunc func);
function g_completion_new(func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_completion_new
  type(c_funptr), value :: func
end function

! void g_completion_add_items (GCompletion* cmp, GList* items);
subroutine g_completion_add_items(cmp, items) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cmp
  type(c_ptr), value :: items
end subroutine

! void g_completion_remove_items (GCompletion* cmp, GList* items);
subroutine g_completion_remove_items(cmp, items) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cmp
  type(c_ptr), value :: items
end subroutine

! void g_completion_clear_items (GCompletion* cmp);
subroutine g_completion_clear_items(cmp) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cmp
end subroutine

! GList* g_completion_complete (GCompletion* cmp, const gchar* prefix, gchar** new_prefix);
function g_completion_complete(cmp, prefix, new_prefix) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_completion_complete
  type(c_ptr), value :: cmp
  character(kind=c_char), dimension(*) :: prefix
  character(kind=c_char), dimension(*) :: new_prefix
end function

! GList* g_completion_complete_utf8 (GCompletion *cmp, const gchar* prefix, gchar** new_prefix);
function g_completion_complete_utf8(cmp, prefix, new_prefix) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_completion_complete_utf8
  type(c_ptr), value :: cmp
  character(kind=c_char), dimension(*) :: prefix
  character(kind=c_char), dimension(*) :: new_prefix
end function

! void g_completion_set_compare (GCompletion *cmp, GCompletionStrncmpFunc strncmp_func);
subroutine g_completion_set_compare(cmp, strncmp_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: cmp
  type(c_funptr), value :: strncmp_func
end subroutine

! void g_completion_free (GCompletion* cmp);
subroutine g_completion_free(cmp) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cmp
end subroutine

!   GQuark g_spawn_error_quark (void);
function g_spawn_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_spawn_error_quark
end function

!  gboolean g_spawn_async (const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, GError **error);
function g_spawn_async(working_directory, argv, envp, flags, child_setup, user_d&
      &ata, child_pid, error) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_int, c_funptr, c_ptr
  logical(c_bool) :: g_spawn_async
  character(kind=c_char), dimension(*) :: working_directory
  character(kind=c_char), dimension(*) :: argv
  character(kind=c_char), dimension(*) :: envp
  integer(c_int), value :: flags
  type(c_funptr), value :: child_setup
  type(c_ptr), value :: user_data
  type(c_ptr), value :: child_pid
  type(c_ptr), value :: error
end function

!  gboolean g_spawn_async_with_pipes (const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid *child_pid, gint *standard_input, gint *standard_output, gint *standard_error, GError **error);
function g_spawn_async_with_pipes(working_directory, argv, envp, flags, child_se&
      &tup, user_data, child_pid, standard_input, standard_output, standard_erro&
      &r, error) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_int, c_funptr, c_ptr
  logical(c_bool) :: g_spawn_async_with_pipes
  character(kind=c_char), dimension(*) :: working_directory
  character(kind=c_char), dimension(*) :: argv
  character(kind=c_char), dimension(*) :: envp
  integer(c_int), value :: flags
  type(c_funptr), value :: child_setup
  type(c_ptr), value :: user_data
  type(c_ptr), value :: child_pid
  type(c_ptr), value :: standard_input
  type(c_ptr), value :: standard_output
  type(c_ptr), value :: standard_error
  type(c_ptr), value :: error
end function

!  gboolean g_spawn_sync (const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gchar **standard_output, gchar **standard_error, gint *exit_status, GError **error);
function g_spawn_sync(working_directory, argv, envp, flags, child_setup, user_da&
      &ta, standard_output, standard_error, exit_status, error) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_int, c_funptr, c_ptr
  logical(c_bool) :: g_spawn_sync
  character(kind=c_char), dimension(*) :: working_directory
  character(kind=c_char), dimension(*) :: argv
  character(kind=c_char), dimension(*) :: envp
  integer(c_int), value :: flags
  type(c_funptr), value :: child_setup
  type(c_ptr), value :: user_data
  character(kind=c_char), dimension(*) :: standard_output
  character(kind=c_char), dimension(*) :: standard_error
  type(c_ptr), value :: exit_status
  type(c_ptr), value :: error
end function

!  gboolean g_spawn_command_line_sync (const gchar *command_line, gchar **standard_output, gchar **standard_error, gint *exit_status, GError **error);
function g_spawn_command_line_sync(command_line, standard_output, standard_error&
      &, exit_status, error) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_ptr
  logical(c_bool) :: g_spawn_command_line_sync
  character(kind=c_char), dimension(*) :: command_line
  character(kind=c_char), dimension(*) :: standard_output
  character(kind=c_char), dimension(*) :: standard_error
  type(c_ptr), value :: exit_status
  type(c_ptr), value :: error
end function

! gboolean g_spawn_command_line_async (const gchar *command_line, GError **error);
function g_spawn_command_line_async(command_line, error) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_ptr
  logical(c_bool) :: g_spawn_command_line_async
  character(kind=c_char), dimension(*) :: command_line
  type(c_ptr), value :: error
end function

!  void g_spawn_close_pid (GPid pid);
subroutine g_spawn_close_pid(pid) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: pid
end subroutine

!   void g_free (gpointer mem);
subroutine g_free(mem) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mem
end subroutine

!  gpointer g_malloc (gsize n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_malloc(n_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_malloc
  integer(c_size_t), value :: n_bytes
end function

! gpointer g_malloc0 (gsize n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_malloc0(n_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_malloc0
  integer(c_size_t), value :: n_bytes
end function

! gpointer g_realloc (gpointer mem, gsize n_bytes) G_GNUC_WARN_UNUSED_RESULT;
function g_realloc(mem, n_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_realloc
  type(c_ptr), value :: mem
  integer(c_size_t), value :: n_bytes
end function

! gpointer g_try_malloc (gsize n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_try_malloc(n_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_try_malloc
  integer(c_size_t), value :: n_bytes
end function

! gpointer g_try_malloc0 (gsize n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_try_malloc0(n_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_try_malloc0
  integer(c_size_t), value :: n_bytes
end function

! gpointer g_try_realloc (gpointer mem, gsize n_bytes) G_GNUC_WARN_UNUSED_RESULT;
function g_try_realloc(mem, n_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_try_realloc
  type(c_ptr), value :: mem
  integer(c_size_t), value :: n_bytes
end function

!  gpointer g_malloc_n (gsize n_blocks, gsize n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
function g_malloc_n(n_blocks, n_block_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_malloc_n
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
end function

! gpointer g_malloc0_n (gsize n_blocks, gsize n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
function g_malloc0_n(n_blocks, n_block_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_malloc0_n
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
end function

! gpointer g_realloc_n (gpointer mem, gsize n_blocks, gsize n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;
function g_realloc_n(mem, n_blocks, n_block_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_realloc_n
  type(c_ptr), value :: mem
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
end function

! gpointer g_try_malloc_n (gsize n_blocks, gsize n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
function g_try_malloc_n(n_blocks, n_block_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_try_malloc_n
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
end function

! gpointer g_try_malloc0_n (gsize n_blocks, gsize n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
function g_try_malloc0_n(n_blocks, n_block_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_try_malloc0_n
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
end function

! gpointer g_try_realloc_n (gpointer mem, gsize n_blocks, gsize n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;
function g_try_realloc_n(mem, n_blocks, n_block_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_try_realloc_n
  type(c_ptr), value :: mem
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
end function

!  void g_mem_set_vtable (GMemVTable *vtable);
subroutine g_mem_set_vtable(vtable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: vtable
end subroutine

! gboolean g_mem_is_system_malloc (void);
function g_mem_is_system_malloc() bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool) :: g_mem_is_system_malloc
end function

! void g_mem_profile (void);
subroutine g_mem_profile() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  GMemChunk* g_mem_chunk_new (const gchar *name, gint atom_size, gsize area_size, gint type);
function g_mem_chunk_new(name, atom_size, area_size, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_size_t
  type(c_ptr) :: g_mem_chunk_new
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: atom_size
  integer(c_size_t), value :: area_size
  integer(c_int), value :: type
end function

! void g_mem_chunk_destroy (GMemChunk *mem_chunk);
subroutine g_mem_chunk_destroy(mem_chunk) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mem_chunk
end subroutine

! gpointer g_mem_chunk_alloc (GMemChunk *mem_chunk);
function g_mem_chunk_alloc(mem_chunk) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mem_chunk_alloc
  type(c_ptr), value :: mem_chunk
end function

! gpointer g_mem_chunk_alloc0 (GMemChunk *mem_chunk);
function g_mem_chunk_alloc0(mem_chunk) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mem_chunk_alloc0
  type(c_ptr), value :: mem_chunk
end function

! void g_mem_chunk_free (GMemChunk *mem_chunk, gpointer mem);
subroutine g_mem_chunk_free(mem_chunk, mem) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mem_chunk
  type(c_ptr), value :: mem
end subroutine

! void g_mem_chunk_clean (GMemChunk *mem_chunk);
subroutine g_mem_chunk_clean(mem_chunk) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mem_chunk
end subroutine

! void g_mem_chunk_reset (GMemChunk *mem_chunk);
subroutine g_mem_chunk_reset(mem_chunk) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mem_chunk
end subroutine

! void g_mem_chunk_print (GMemChunk *mem_chunk);
subroutine g_mem_chunk_print(mem_chunk) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mem_chunk
end subroutine

! void g_mem_chunk_info (void);
subroutine g_mem_chunk_info() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void g_blow_chunks (void);
subroutine g_blow_chunks() bind(c) 
  use iso_c_binding, only: 
end subroutine

! GAllocator*g_allocator_new (const gchar *name, guint n_preallocs);
function g_allocator_new(name, n_preallocs) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_allocator_new
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: n_preallocs
end function

! void g_allocator_free (GAllocator *allocator);
subroutine g_allocator_free(allocator) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: allocator
end subroutine

!   GNode* g_node_new (gpointer data);
function g_node_new(data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_node_new
  type(c_ptr), value :: data
end function

! void g_node_destroy (GNode *root);
subroutine g_node_destroy(root) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: root
end subroutine

! void g_node_unlink (GNode *node);
subroutine g_node_unlink(node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: node
end subroutine

! GNode* g_node_copy_deep (GNode *node, GCopyFunc copy_func, gpointer data);
function g_node_copy_deep(node, copy_func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_node_copy_deep
  type(c_ptr), value :: node
  type(c_funptr), value :: copy_func
  type(c_ptr), value :: data
end function

! GNode* g_node_copy (GNode *node);
function g_node_copy(node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_node_copy
  type(c_ptr), value :: node
end function

! GNode* g_node_insert (GNode *parent, gint position, GNode *node);
function g_node_insert(parent, position, node) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_node_insert
  type(c_ptr), value :: parent
  integer(c_int), value :: position
  type(c_ptr), value :: node
end function

! GNode* g_node_insert_before (GNode *parent, GNode *sibling, GNode *node);
function g_node_insert_before(parent, sibling, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_node_insert_before
  type(c_ptr), value :: parent
  type(c_ptr), value :: sibling
  type(c_ptr), value :: node
end function

! GNode* g_node_insert_after (GNode *parent, GNode *sibling, GNode *node);
function g_node_insert_after(parent, sibling, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_node_insert_after
  type(c_ptr), value :: parent
  type(c_ptr), value :: sibling
  type(c_ptr), value :: node
end function

! GNode* g_node_prepend (GNode *parent, GNode *node);
function g_node_prepend(parent, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_node_prepend
  type(c_ptr), value :: parent
  type(c_ptr), value :: node
end function

! guint g_node_n_nodes (GNode *root, GTraverseFlags flags);
function g_node_n_nodes(root, flags) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_node_n_nodes
  type(c_ptr), value :: root
  integer(c_int), value :: flags
end function

! GNode* g_node_get_root (GNode *node);
function g_node_get_root(node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_node_get_root
  type(c_ptr), value :: node
end function

! gboolean g_node_is_ancestor (GNode *node, GNode *descendant);
function g_node_is_ancestor(node, descendant) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_node_is_ancestor
  type(c_ptr), value :: node
  type(c_ptr), value :: descendant
end function

! guint g_node_depth (GNode *node);
function g_node_depth(node) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_node_depth
  type(c_ptr), value :: node
end function

! GNode* g_node_find (GNode *root, GTraverseType order, GTraverseFlags flags, gpointer data);
function g_node_find(root, order, flags, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_node_find
  type(c_ptr), value :: root
  integer(c_int), value :: order
  integer(c_int), value :: flags
  type(c_ptr), value :: data
end function

!  void g_node_traverse (GNode *root, GTraverseType order, GTraverseFlags flags, gint max_depth, GNodeTraverseFunc func, gpointer data);
subroutine g_node_traverse(root, order, flags, max_depth, func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: root
  integer(c_int), value :: order
  integer(c_int), value :: flags
  integer(c_int), value :: max_depth
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end subroutine

!  guint g_node_max_height (GNode *root);
function g_node_max_height(root) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_node_max_height
  type(c_ptr), value :: root
end function

!  void g_node_children_foreach (GNode *node, GTraverseFlags flags, GNodeForeachFunc func, gpointer data);
subroutine g_node_children_foreach(node, flags, func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: node
  integer(c_int), value :: flags
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end subroutine

! void g_node_reverse_children (GNode *node);
subroutine g_node_reverse_children(node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: node
end subroutine

! guint g_node_n_children (GNode *node);
function g_node_n_children(node) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_node_n_children
  type(c_ptr), value :: node
end function

! GNode* g_node_nth_child (GNode *node, guint n);
function g_node_nth_child(node, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_node_nth_child
  type(c_ptr), value :: node
  integer(c_int), value :: n
end function

! GNode* g_node_last_child (GNode *node);
function g_node_last_child(node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_node_last_child
  type(c_ptr), value :: node
end function

! GNode* g_node_find_child (GNode *node, GTraverseFlags flags, gpointer data);
function g_node_find_child(node, flags, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_node_find_child
  type(c_ptr), value :: node
  integer(c_int), value :: flags
  type(c_ptr), value :: data
end function

! gint g_node_child_position (GNode *node, GNode *child);
function g_node_child_position(node, child) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_node_child_position
  type(c_ptr), value :: node
  type(c_ptr), value :: child
end function

! gint g_node_child_index (GNode *node, gpointer data);
function g_node_child_index(node, data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_node_child_index
  type(c_ptr), value :: node
  type(c_ptr), value :: data
end function

!  GNode* g_node_first_sibling (GNode *node);
function g_node_first_sibling(node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_node_first_sibling
  type(c_ptr), value :: node
end function

! GNode* g_node_last_sibling (GNode *node);
function g_node_last_sibling(node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_node_last_sibling
  type(c_ptr), value :: node
end function

!  void g_node_push_allocator (gpointer dummy);
subroutine g_node_push_allocator(dummy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: dummy
end subroutine

! void g_node_pop_allocator (void);
subroutine g_node_pop_allocator() bind(c) 
  use iso_c_binding, only: 
end subroutine

!   gpointer g_slice_alloc (gsize block_size) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_slice_alloc(block_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_slice_alloc
  integer(c_size_t), value :: block_size
end function

! gpointer g_slice_alloc0 (gsize block_size) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_slice_alloc0(block_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_slice_alloc0
  integer(c_size_t), value :: block_size
end function

! gpointer g_slice_copy (gsize block_size, gconstpointer mem_block) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_slice_copy(block_size, mem_block) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_slice_copy
  integer(c_size_t), value :: block_size
  type(c_ptr), value :: mem_block
end function

! void g_slice_free1 (gsize block_size, gpointer mem_block);
subroutine g_slice_free1(block_size, mem_block) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t), value :: block_size
  type(c_ptr), value :: mem_block
end subroutine

! void g_slice_free_chain_with_offset (gsize block_size, gpointer mem_chain, gsize next_offset);
subroutine g_slice_free_chain_with_offset(block_size, mem_chain, next_offset) bi&
      &nd(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t), value :: block_size
  type(c_ptr), value :: mem_chain
  integer(c_size_t), value :: next_offset
end subroutine

!  void g_slice_set_config (GSliceConfig ckey, gint64 value);
subroutine g_slice_set_config(ckey, value) bind(c) 
  use iso_c_binding, only: c_int, c_int64_t
  integer(c_int), value :: ckey
  integer(c_int64_t), value :: value
end subroutine

! gint64 g_slice_get_config (GSliceConfig ckey);
function g_slice_get_config(ckey) bind(c) 
  use iso_c_binding, only: c_int64_t, c_int
  integer(c_int64_t) :: g_slice_get_config
  integer(c_int), value :: ckey
end function

! gint64* g_slice_get_config_state (GSliceConfig ckey, gint64 address, guint *n_values);
function g_slice_get_config_state(ckey, address, n_values) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int64_t
  type(c_ptr) :: g_slice_get_config_state
  integer(c_int), value :: ckey
  integer(c_int64_t), value :: address
  type(c_ptr), value :: n_values
end function

!   GRelation* g_relation_new (gint fields);
function g_relation_new(fields) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_relation_new
  integer(c_int), value :: fields
end function

! void g_relation_destroy (GRelation *relation);
subroutine g_relation_destroy(relation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: relation
end subroutine

! void g_relation_index (GRelation *relation, gint field, GHashFunc hash_func, GEqualFunc key_equal_func);
subroutine g_relation_index(relation, field, hash_func, key_equal_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: relation
  integer(c_int), value :: field
  type(c_funptr), value :: hash_func
  type(c_funptr), value :: key_equal_func
end subroutine

! gint g_relation_delete (GRelation *relation, gconstpointer key, gint field);
function g_relation_delete(relation, key, field) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_relation_delete
  type(c_ptr), value :: relation
  type(c_ptr), value :: key
  integer(c_int), value :: field
end function

! GTuples* g_relation_select (GRelation *relation, gconstpointer key, gint field);
function g_relation_select(relation, key, field) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_relation_select
  type(c_ptr), value :: relation
  type(c_ptr), value :: key
  integer(c_int), value :: field
end function

! gint g_relation_count (GRelation *relation, gconstpointer key, gint field);
function g_relation_count(relation, key, field) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_relation_count
  type(c_ptr), value :: relation
  type(c_ptr), value :: key
  integer(c_int), value :: field
end function

! void g_relation_print (GRelation *relation);
subroutine g_relation_print(relation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: relation
end subroutine

!  void g_tuples_destroy (GTuples *tuples);
subroutine g_tuples_destroy(tuples) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tuples
end subroutine

! gpointer g_tuples_index (GTuples *tuples, gint index_, gint field);
function g_tuples_index(tuples, index_, field) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_tuples_index
  type(c_ptr), value :: tuples
  integer(c_int), value :: index_
  integer(c_int), value :: field
end function

!   GAsyncQueue* g_async_queue_new (void);
function g_async_queue_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_queue_new
end function

!  GAsyncQueue* g_async_queue_new_full (GDestroyNotify item_free_func);
function g_async_queue_new_full(item_free_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_async_queue_new_full
  type(c_funptr), value :: item_free_func
end function

!  void g_async_queue_lock (GAsyncQueue *queue);
subroutine g_async_queue_lock(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
end subroutine

! void g_async_queue_unlock (GAsyncQueue *queue);
subroutine g_async_queue_unlock(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
end subroutine

!  GAsyncQueue* g_async_queue_ref (GAsyncQueue *queue);
function g_async_queue_ref(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_queue_ref
  type(c_ptr), value :: queue
end function

! void g_async_queue_unref (GAsyncQueue *queue);
subroutine g_async_queue_unref(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
end subroutine

!  void g_async_queue_ref_unlocked (GAsyncQueue *queue);
subroutine g_async_queue_ref_unlocked(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
end subroutine

! void g_async_queue_unref_and_unlock (GAsyncQueue *queue);
subroutine g_async_queue_unref_and_unlock(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
end subroutine

!  void g_async_queue_push (GAsyncQueue *queue, gpointer data);
subroutine g_async_queue_push(queue, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end subroutine

! void g_async_queue_push_unlocked (GAsyncQueue *queue, gpointer data);
subroutine g_async_queue_push_unlocked(queue, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end subroutine

!  void g_async_queue_push_sorted (GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data);
subroutine g_async_queue_push_sorted(queue, data, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! void g_async_queue_push_sorted_unlocked (GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data);
subroutine g_async_queue_push_sorted_unlocked(queue, data, func, user_data) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!  gpointer g_async_queue_pop (GAsyncQueue *queue);
function g_async_queue_pop(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_queue_pop
  type(c_ptr), value :: queue
end function

! gpointer g_async_queue_pop_unlocked (GAsyncQueue *queue);
function g_async_queue_pop_unlocked(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_queue_pop_unlocked
  type(c_ptr), value :: queue
end function

!  gpointer g_async_queue_try_pop (GAsyncQueue *queue);
function g_async_queue_try_pop(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_queue_try_pop
  type(c_ptr), value :: queue
end function

! gpointer g_async_queue_try_pop_unlocked (GAsyncQueue *queue);
function g_async_queue_try_pop_unlocked(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_queue_try_pop_unlocked
  type(c_ptr), value :: queue
end function

!  gpointer g_async_queue_timed_pop (GAsyncQueue *queue, GTimeVal *end_time);
function g_async_queue_timed_pop(queue, end_time) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_queue_timed_pop
  type(c_ptr), value :: queue
  type(c_ptr), value :: end_time
end function

! gpointer g_async_queue_timed_pop_unlocked (GAsyncQueue *queue, GTimeVal *end_time);
function g_async_queue_timed_pop_unlocked(queue, end_time) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_queue_timed_pop_unlocked
  type(c_ptr), value :: queue
  type(c_ptr), value :: end_time
end function

!  gint g_async_queue_length (GAsyncQueue *queue);
function g_async_queue_length(queue) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_async_queue_length
  type(c_ptr), value :: queue
end function

! gint g_async_queue_length_unlocked (GAsyncQueue *queue);
function g_async_queue_length_unlocked(queue) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_async_queue_length_unlocked
  type(c_ptr), value :: queue
end function

! void g_async_queue_sort (GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data);
subroutine g_async_queue_sort(queue, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! void g_async_queue_sort_unlocked (GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data);
subroutine g_async_queue_sort_unlocked(queue, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!   GArray* g_array_new (gboolean zero_terminated, gboolean clear_, guint element_size);
function g_array_new(zero_terminated, clear_, element_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_int
  type(c_ptr) :: g_array_new
  logical(c_bool), value :: zero_terminated
  logical(c_bool), value :: clear_
  integer(c_int), value :: element_size
end function

! GArray* g_array_sized_new (gboolean zero_terminated, gboolean clear_, guint element_size, guint reserved_size);
function g_array_sized_new(zero_terminated, clear_, element_size, reserved_size)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_int
  type(c_ptr) :: g_array_sized_new
  logical(c_bool), value :: zero_terminated
  logical(c_bool), value :: clear_
  integer(c_int), value :: element_size
  integer(c_int), value :: reserved_size
end function

! gchar* g_array_free (GArray *array, gboolean free_segment);
function g_array_free(array, free_segment) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: g_array_free
  type(c_ptr), value :: array
  logical(c_bool), value :: free_segment
end function

! GArray *g_array_ref (GArray *array);
function g_array_ref(array) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_array_ref
  type(c_ptr), value :: array
end function

! void g_array_unref (GArray *array);
subroutine g_array_unref(array) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: array
end subroutine

! guint g_array_get_element_size (GArray *array);
function g_array_get_element_size(array) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_array_get_element_size
  type(c_ptr), value :: array
end function

! GArray* g_array_append_vals (GArray *array, gconstpointer data, guint len);
function g_array_append_vals(array, data, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_array_append_vals
  type(c_ptr), value :: array
  type(c_ptr), value :: data
  integer(c_int), value :: len
end function

! GArray* g_array_prepend_vals (GArray *array, gconstpointer data, guint len);
function g_array_prepend_vals(array, data, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_array_prepend_vals
  type(c_ptr), value :: array
  type(c_ptr), value :: data
  integer(c_int), value :: len
end function

! GArray* g_array_insert_vals (GArray *array, guint index_, gconstpointer data, guint len);
function g_array_insert_vals(array, index_, data, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_array_insert_vals
  type(c_ptr), value :: array
  integer(c_int), value :: index_
  type(c_ptr), value :: data
  integer(c_int), value :: len
end function

! GArray* g_array_set_size (GArray *array, guint length);
function g_array_set_size(array, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_array_set_size
  type(c_ptr), value :: array
  integer(c_int), value :: length
end function

! GArray* g_array_remove_index (GArray *array, guint index_);
function g_array_remove_index(array, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_array_remove_index
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! GArray* g_array_remove_index_fast (GArray *array, guint index_);
function g_array_remove_index_fast(array, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_array_remove_index_fast
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! GArray* g_array_remove_range (GArray *array, guint index_, guint length);
function g_array_remove_range(array, index_, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_array_remove_range
  type(c_ptr), value :: array
  integer(c_int), value :: index_
  integer(c_int), value :: length
end function

! void g_array_sort (GArray *array, GCompareFunc compare_func);
subroutine g_array_sort(array, compare_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: compare_func
end subroutine

! void g_array_sort_with_data (GArray *array, GCompareDataFunc compare_func, gpointer user_data);
subroutine g_array_sort_with_data(array, compare_func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end subroutine

!  GPtrArray* g_ptr_array_new (void);
function g_ptr_array_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_ptr_array_new
end function

! GPtrArray* g_ptr_array_new_with_free_func (GDestroyNotify element_free_func);
function g_ptr_array_new_with_free_func(element_free_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_ptr_array_new_with_free_func
  type(c_funptr), value :: element_free_func
end function

! GPtrArray* g_ptr_array_sized_new (guint reserved_size);
function g_ptr_array_sized_new(reserved_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_ptr_array_sized_new
  integer(c_int), value :: reserved_size
end function

! gpointer* g_ptr_array_free (GPtrArray *array, gboolean free_seg);
function g_ptr_array_free(array, free_seg) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: g_ptr_array_free
  type(c_ptr), value :: array
  logical(c_bool), value :: free_seg
end function

! GPtrArray* g_ptr_array_ref (GPtrArray *array);
function g_ptr_array_ref(array) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_ptr_array_ref
  type(c_ptr), value :: array
end function

! void g_ptr_array_unref (GPtrArray *array);
subroutine g_ptr_array_unref(array) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: array
end subroutine

! void g_ptr_array_set_free_func (GPtrArray *array, GDestroyNotify element_free_func);
subroutine g_ptr_array_set_free_func(array, element_free_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: element_free_func
end subroutine

! void g_ptr_array_set_size (GPtrArray *array, gint length);
subroutine g_ptr_array_set_size(array, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: array
  integer(c_int), value :: length
end subroutine

! gpointer g_ptr_array_remove_index (GPtrArray *array, guint index_);
function g_ptr_array_remove_index(array, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_ptr_array_remove_index
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! gpointer g_ptr_array_remove_index_fast (GPtrArray *array, guint index_);
function g_ptr_array_remove_index_fast(array, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_ptr_array_remove_index_fast
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! gboolean g_ptr_array_remove (GPtrArray *array, gpointer data);
function g_ptr_array_remove(array, data) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_ptr_array_remove
  type(c_ptr), value :: array
  type(c_ptr), value :: data
end function

! gboolean g_ptr_array_remove_fast (GPtrArray *array, gpointer data);
function g_ptr_array_remove_fast(array, data) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_ptr_array_remove_fast
  type(c_ptr), value :: array
  type(c_ptr), value :: data
end function

! void g_ptr_array_remove_range (GPtrArray *array, guint index_, guint length);
subroutine g_ptr_array_remove_range(array, index_, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: array
  integer(c_int), value :: index_
  integer(c_int), value :: length
end subroutine

! void g_ptr_array_add (GPtrArray *array, gpointer data);
subroutine g_ptr_array_add(array, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: array
  type(c_ptr), value :: data
end subroutine

! void g_ptr_array_sort (GPtrArray *array, GCompareFunc compare_func);
subroutine g_ptr_array_sort(array, compare_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: compare_func
end subroutine

! void g_ptr_array_sort_with_data (GPtrArray *array, GCompareDataFunc compare_func, gpointer user_data);
subroutine g_ptr_array_sort_with_data(array, compare_func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end subroutine

! void g_ptr_array_foreach (GPtrArray *array, GFunc func, gpointer user_data);
subroutine g_ptr_array_foreach(array, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!  GByteArray* g_byte_array_new (void);
function g_byte_array_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_byte_array_new
end function

! GByteArray* g_byte_array_sized_new (guint reserved_size);
function g_byte_array_sized_new(reserved_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_byte_array_sized_new
  integer(c_int), value :: reserved_size
end function

! guint8* g_byte_array_free (GByteArray *array, gboolean free_segment);
function g_byte_array_free(array, free_segment) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: g_byte_array_free
  type(c_ptr), value :: array
  logical(c_bool), value :: free_segment
end function

! GByteArray *g_byte_array_ref (GByteArray *array);
function g_byte_array_ref(array) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_byte_array_ref
  type(c_ptr), value :: array
end function

! void g_byte_array_unref (GByteArray *array);
subroutine g_byte_array_unref(array) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: array
end subroutine

! GByteArray* g_byte_array_append (GByteArray *array, const guint8 *data, guint len);
function g_byte_array_append(array, data, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_byte_array_append
  type(c_ptr), value :: array
  type(c_ptr), value :: data
  integer(c_int), value :: len
end function

! GByteArray* g_byte_array_prepend (GByteArray *array, const guint8 *data, guint len);
function g_byte_array_prepend(array, data, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_byte_array_prepend
  type(c_ptr), value :: array
  type(c_ptr), value :: data
  integer(c_int), value :: len
end function

! GByteArray* g_byte_array_set_size (GByteArray *array, guint length);
function g_byte_array_set_size(array, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_byte_array_set_size
  type(c_ptr), value :: array
  integer(c_int), value :: length
end function

! GByteArray* g_byte_array_remove_index (GByteArray *array, guint index_);
function g_byte_array_remove_index(array, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_byte_array_remove_index
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! GByteArray* g_byte_array_remove_index_fast (GByteArray *array, guint index_);
function g_byte_array_remove_index_fast(array, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_byte_array_remove_index_fast
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! GByteArray* g_byte_array_remove_range (GByteArray *array, guint index_, guint length);
function g_byte_array_remove_range(array, index_, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_byte_array_remove_range
  type(c_ptr), value :: array
  integer(c_int), value :: index_
  integer(c_int), value :: length
end function

! void g_byte_array_sort (GByteArray *array, GCompareFunc compare_func);
subroutine g_byte_array_sort(array, compare_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: compare_func
end subroutine

! void g_byte_array_sort_with_data (GByteArray *array, GCompareDataFunc compare_func, gpointer user_data);
subroutine g_byte_array_sort_with_data(array, compare_func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end subroutine

!   GMainContext *g_main_context_new (void);
function g_main_context_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_main_context_new
end function

! GMainContext *g_main_context_ref (GMainContext *context);
function g_main_context_ref(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_main_context_ref
  type(c_ptr), value :: context
end function

! void g_main_context_unref (GMainContext *context);
subroutine g_main_context_unref(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

! GMainContext *g_main_context_default (void);
function g_main_context_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_main_context_default
end function

!  gboolean g_main_context_iteration (GMainContext *context, gboolean may_block);
function g_main_context_iteration(context, may_block) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_main_context_iteration
  type(c_ptr), value :: context
  logical(c_bool), value :: may_block
end function

! gboolean g_main_context_pending (GMainContext *context);
function g_main_context_pending(context) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_main_context_pending
  type(c_ptr), value :: context
end function

!  GSource *g_main_context_find_source_by_id (GMainContext *context, guint source_id);
function g_main_context_find_source_by_id(context, source_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_main_context_find_source_by_id
  type(c_ptr), value :: context
  integer(c_int), value :: source_id
end function

! GSource *g_main_context_find_source_by_user_data (GMainContext *context, gpointer user_data);
function g_main_context_find_source_by_user_data(context, user_data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_main_context_find_source_by_user_data
  type(c_ptr), value :: context
  type(c_ptr), value :: user_data
end function

! GSource *g_main_context_find_source_by_funcs_user_data (GMainContext *context, GSourceFuncs *funcs, gpointer user_data);
function g_main_context_find_source_by_funcs_user_data(context, funcs, user_data&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_main_context_find_source_by_funcs_user_data
  type(c_ptr), value :: context
  type(c_funptr), value :: funcs
  type(c_ptr), value :: user_data
end function

!  void g_main_context_wakeup (GMainContext *context);
subroutine g_main_context_wakeup(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

! gboolean g_main_context_acquire (GMainContext *context);
function g_main_context_acquire(context) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_main_context_acquire
  type(c_ptr), value :: context
end function

! void g_main_context_release (GMainContext *context);
subroutine g_main_context_release(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

! gboolean g_main_context_is_owner (GMainContext *context);
function g_main_context_is_owner(context) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_main_context_is_owner
  type(c_ptr), value :: context
end function

! gboolean g_main_context_wait (GMainContext *context, GCond *cond, GMutex *mutex);
function g_main_context_wait(context, cond, mutex) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_main_context_wait
  type(c_ptr), value :: context
  type(c_ptr), value :: cond
  type(c_ptr), value :: mutex
end function

!  gboolean g_main_context_prepare (GMainContext *context, gint *priority);
function g_main_context_prepare(context, priority) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_main_context_prepare
  type(c_ptr), value :: context
  type(c_ptr), value :: priority
end function

! gint g_main_context_query (GMainContext *context, gint max_priority, gint *timeout_, GPollFD *fds, gint n_fds);
function g_main_context_query(context, max_priority, timeout_, fds, n_fds) bind(&
      &c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_main_context_query
  type(c_ptr), value :: context
  integer(c_int), value :: max_priority
  type(c_ptr), value :: timeout_
  type(c_ptr), value :: fds
  integer(c_int), value :: n_fds
end function

! gint g_main_context_check (GMainContext *context, gint max_priority, GPollFD *fds, gint n_fds);
function g_main_context_check(context, max_priority, fds, n_fds) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_main_context_check
  type(c_ptr), value :: context
  integer(c_int), value :: max_priority
  type(c_ptr), value :: fds
  integer(c_int), value :: n_fds
end function

! void g_main_context_dispatch (GMainContext *context);
subroutine g_main_context_dispatch(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

!  void g_main_context_set_poll_func (GMainContext *context, GPollFunc func);
subroutine g_main_context_set_poll_func(context, func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: context
  type(c_funptr), value :: func
end subroutine

! GPollFunc g_main_context_get_poll_func (GMainContext *context);
function g_main_context_get_poll_func(context) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr) :: g_main_context_get_poll_func
  type(c_ptr), value :: context
end function

!  void g_main_context_add_poll (GMainContext *context, GPollFD *fd, gint priority);
subroutine g_main_context_add_poll(context, fd, priority) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: context
  type(c_ptr), value :: fd
  integer(c_int), value :: priority
end subroutine

! void g_main_context_remove_poll (GMainContext *context, GPollFD *fd);
subroutine g_main_context_remove_poll(context, fd) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: fd
end subroutine

!  gint g_main_depth (void);
function g_main_depth() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_main_depth
end function

! GSource *g_main_current_source (void);
function g_main_current_source() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_main_current_source
end function

!  void g_main_context_push_thread_default (GMainContext *context);
subroutine g_main_context_push_thread_default(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

! void g_main_context_pop_thread_default (GMainContext *context);
subroutine g_main_context_pop_thread_default(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

! GMainContext *g_main_context_get_thread_default (void);
function g_main_context_get_thread_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_main_context_get_thread_default
end function

!  GMainLoop *g_main_loop_new (GMainContext *context, gboolean is_running);
function g_main_loop_new(context, is_running) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: g_main_loop_new
  type(c_ptr), value :: context
  logical(c_bool), value :: is_running
end function

! void g_main_loop_run (GMainLoop *loop);
subroutine g_main_loop_run(loop) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: loop
end subroutine

! void g_main_loop_quit (GMainLoop *loop);
subroutine g_main_loop_quit(loop) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: loop
end subroutine

! GMainLoop *g_main_loop_ref (GMainLoop *loop);
function g_main_loop_ref(loop) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_main_loop_ref
  type(c_ptr), value :: loop
end function

! void g_main_loop_unref (GMainLoop *loop);
subroutine g_main_loop_unref(loop) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: loop
end subroutine

! gboolean g_main_loop_is_running (GMainLoop *loop);
function g_main_loop_is_running(loop) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_main_loop_is_running
  type(c_ptr), value :: loop
end function

! GMainContext *g_main_loop_get_context (GMainLoop *loop);
function g_main_loop_get_context(loop) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_main_loop_get_context
  type(c_ptr), value :: loop
end function

!  GSource *g_source_new (GSourceFuncs *source_funcs, guint struct_size);
function g_source_new(source_funcs, struct_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr, c_int
  type(c_ptr) :: g_source_new
  type(c_funptr), value :: source_funcs
  integer(c_int), value :: struct_size
end function

! GSource *g_source_ref (GSource *source);
function g_source_ref(source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_source_ref
  type(c_ptr), value :: source
end function

! void g_source_unref (GSource *source);
subroutine g_source_unref(source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source
end subroutine

!  guint g_source_attach (GSource *source, GMainContext *context);
function g_source_attach(source, context) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_source_attach
  type(c_ptr), value :: source
  type(c_ptr), value :: context
end function

! void g_source_destroy (GSource *source);
subroutine g_source_destroy(source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source
end subroutine

!  void g_source_set_priority (GSource *source, gint priority);
subroutine g_source_set_priority(source, priority) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: source
  integer(c_int), value :: priority
end subroutine

! gint g_source_get_priority (GSource *source);
function g_source_get_priority(source) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_source_get_priority
  type(c_ptr), value :: source
end function

! void g_source_set_can_recurse (GSource *source, gboolean can_recurse);
subroutine g_source_set_can_recurse(source, can_recurse) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: source
  logical(c_bool), value :: can_recurse
end subroutine

! gboolean g_source_get_can_recurse (GSource *source);
function g_source_get_can_recurse(source) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_source_get_can_recurse
  type(c_ptr), value :: source
end function

! guint g_source_get_id (GSource *source);
function g_source_get_id(source) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_source_get_id
  type(c_ptr), value :: source
end function

!  GMainContext *g_source_get_context (GSource *source);
function g_source_get_context(source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_source_get_context
  type(c_ptr), value :: source
end function

!  void g_source_set_callback (GSource *source, GSourceFunc func, gpointer data, GDestroyNotify notify);
subroutine g_source_set_callback(source, func, data, notify) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: source
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end subroutine

!  void g_source_set_funcs (GSource *source, GSourceFuncs *funcs);
subroutine g_source_set_funcs(source, funcs) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: source
  type(c_funptr), value :: funcs
end subroutine

! gboolean g_source_is_destroyed (GSource *source);
function g_source_is_destroyed(source) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_source_is_destroyed
  type(c_ptr), value :: source
end function

!  void g_source_set_name (GSource *source, const char *name);
subroutine g_source_set_name(source, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: source
  character(kind=c_char), dimension(*) :: name
end subroutine

! G_CONST_RETURN char* g_source_get_name (GSource *source);
function g_source_get_name(source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_source_get_name
  type(c_ptr), value :: source
end function

! void g_source_set_name_by_id (guint tag, const char *name);
subroutine g_source_set_name_by_id(tag, name) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int), value :: tag
  character(kind=c_char), dimension(*) :: name
end subroutine

!  void g_source_set_callback_indirect (GSource *source, gpointer callback_data, GSourceCallbackFuncs *callback_funcs);
subroutine g_source_set_callback_indirect(source, callback_data, callback_funcs)&
      & bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: callback_data
  type(c_ptr), value :: callback_funcs
end subroutine

!  void g_source_add_poll (GSource *source, GPollFD *fd);
subroutine g_source_add_poll(source, fd) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: fd
end subroutine

! void g_source_remove_poll (GSource *source, GPollFD *fd);
subroutine g_source_remove_poll(source, fd) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: fd
end subroutine

!  void g_source_get_current_time (GSource *source, GTimeVal *timeval);
subroutine g_source_get_current_time(source, timeval) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: timeval
end subroutine

!    GSource *g_idle_source_new (void);
function g_idle_source_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_idle_source_new
end function

! GSource *g_child_watch_source_new (GPid pid);
function g_child_watch_source_new(pid) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_child_watch_source_new
  integer(c_int), value :: pid
end function

! GSource *g_timeout_source_new (guint interval);
function g_timeout_source_new(interval) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_timeout_source_new
  integer(c_int), value :: interval
end function

! GSource *g_timeout_source_new_seconds (guint interval);
function g_timeout_source_new_seconds(interval) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_timeout_source_new_seconds
  integer(c_int), value :: interval
end function

!  void g_get_current_time (GTimeVal *result);
subroutine g_get_current_time(result) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: result
end subroutine

!  gboolean g_source_remove (guint tag);
function g_source_remove(tag) bind(c) 
  use iso_c_binding, only: c_bool, c_int
  logical(c_bool) :: g_source_remove
  integer(c_int), value :: tag
end function

! gboolean g_source_remove_by_user_data (gpointer user_data);
function g_source_remove_by_user_data(user_data) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_source_remove_by_user_data
  type(c_ptr), value :: user_data
end function

! gboolean g_source_remove_by_funcs_user_data (GSourceFuncs *funcs, gpointer user_data);
function g_source_remove_by_funcs_user_data(funcs, user_data) bind(c) 
  use iso_c_binding, only: c_bool, c_funptr, c_ptr
  logical(c_bool) :: g_source_remove_by_funcs_user_data
  type(c_funptr), value :: funcs
  type(c_ptr), value :: user_data
end function

!  guint g_timeout_add_full (gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify);
function g_timeout_add_full(priority, interval, function, data, notify) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: g_timeout_add_full
  integer(c_int), value :: priority
  integer(c_int), value :: interval
  type(c_funptr), value :: function
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end function

! guint g_timeout_add (guint interval, GSourceFunc function, gpointer data);
function g_timeout_add(interval, function, data) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: g_timeout_add
  integer(c_int), value :: interval
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

! guint g_timeout_add_seconds_full (gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify);
function g_timeout_add_seconds_full(priority, interval, function, data, notify) &
      &bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: g_timeout_add_seconds_full
  integer(c_int), value :: priority
  integer(c_int), value :: interval
  type(c_funptr), value :: function
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end function

! guint g_timeout_add_seconds (guint interval, GSourceFunc function, gpointer data);
function g_timeout_add_seconds(interval, function, data) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: g_timeout_add_seconds
  integer(c_int), value :: interval
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

! guint g_child_watch_add_full (gint priority, GPid pid, GChildWatchFunc function, gpointer data, GDestroyNotify notify);
function g_child_watch_add_full(priority, pid, function, data, notify) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: g_child_watch_add_full
  integer(c_int), value :: priority
  integer(c_int), value :: pid
  type(c_funptr), value :: function
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end function

! guint g_child_watch_add (GPid pid, GChildWatchFunc function, gpointer data);
function g_child_watch_add(pid, function, data) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: g_child_watch_add
  integer(c_int), value :: pid
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

! guint g_idle_add (GSourceFunc function, gpointer data);
function g_idle_add(function, data) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: g_idle_add
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

! guint g_idle_add_full (gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify);
function g_idle_add_full(priority, function, data, notify) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: g_idle_add_full
  integer(c_int), value :: priority
  type(c_funptr), value :: function
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end function

! gboolean g_idle_remove_by_data (gpointer data);
function g_idle_remove_by_data(data) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_idle_remove_by_data
  type(c_ptr), value :: data
end function

!   gint g_win32_ftruncate (gint f, guint size);
function g_win32_ftruncate(f, size) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_win32_ftruncate
  integer(c_int), value :: f
  integer(c_int), value :: size
end function

!  gchar* g_win32_getlocale (void);
function g_win32_getlocale() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_win32_getlocale
end function

!  gchar* g_win32_error_message (gint error);
function g_win32_error_message(error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_win32_error_message
  integer(c_int), value :: error
end function

!  gchar* g_win32_get_package_installation_directory (const gchar *package, const gchar *dll_name);
function g_win32_get_package_installation_directory(package, dll_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_win32_get_package_installation_directory
  character(kind=c_char), dimension(*) :: package
  character(kind=c_char), dimension(*) :: dll_name
end function

!  gchar* g_win32_get_package_installation_subdirectory (const gchar *package, const gchar *dll_name, const gchar *subdir);
function g_win32_get_package_installation_subdirectory(package, dll_name, subdir&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_win32_get_package_installation_subdirectory
  character(kind=c_char), dimension(*) :: package
  character(kind=c_char), dimension(*) :: dll_name
  character(kind=c_char), dimension(*) :: subdir
end function

!  gchar* g_win32_get_package_installation_directory_of_module (gpointer hmodule);
function g_win32_get_package_installation_directory_of_module(hmodule) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_win32_get_package_installation_directory_of_module
  type(c_ptr), value :: hmodule
end function

!  guint g_win32_get_windows_version (void);
function g_win32_get_windows_version() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_win32_get_windows_version
end function

!  gchar* g_win32_locale_filename_from_utf8 (const gchar *utf8filename);
function g_win32_locale_filename_from_utf8(utf8filename) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_win32_locale_filename_from_utf8
  character(kind=c_char), dimension(*) :: utf8filename
end function

!   GQuark g_key_file_error_quark (void);
function g_key_file_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_key_file_error_quark
end function

!  GKeyFile *g_key_file_new (void);
function g_key_file_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_key_file_new
end function

! void g_key_file_free (GKeyFile *key_file);
subroutine g_key_file_free(key_file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: key_file
end subroutine

! void g_key_file_set_list_separator (GKeyFile *key_file, gchar separator);
subroutine g_key_file_set_list_separator(key_file, separator) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: key_file
  character(c_char), value :: separator
end subroutine

! gboolean g_key_file_load_from_file (GKeyFile *key_file, const gchar *file, GKeyFileFlags flags, GError **error);
function g_key_file_load_from_file(key_file, file, flags, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: g_key_file_load_from_file
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! gboolean g_key_file_load_from_data (GKeyFile *key_file, const gchar *data, gsize length, GKeyFileFlags flags, GError **error);
function g_key_file_load_from_data(key_file, data, length, flags, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_size_t, c_int
  logical(c_bool) :: g_key_file_load_from_data
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: length
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! gboolean g_key_file_load_from_dirs (GKeyFile *key_file, const gchar *file, const gchar **search_dirs, gchar **full_path, GKeyFileFlags flags, GError **error);
function g_key_file_load_from_dirs(key_file, file, search_dirs, full_path, flags&
      &, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: g_key_file_load_from_dirs
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: file
  character(kind=c_char), dimension(*) :: search_dirs
  character(kind=c_char), dimension(*) :: full_path
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! gboolean g_key_file_load_from_data_dirs (GKeyFile *key_file, const gchar *file, gchar **full_path, GKeyFileFlags flags, GError **error);
function g_key_file_load_from_data_dirs(key_file, file, full_path, flags, error)&
      & bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: g_key_file_load_from_data_dirs
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: file
  character(kind=c_char), dimension(*) :: full_path
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! gchar *g_key_file_to_data (GKeyFile *key_file, gsize *length, GError **error) G_GNUC_MALLOC;
function g_key_file_to_data(key_file, length, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_key_file_to_data
  type(c_ptr), value :: key_file
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! gchar *g_key_file_get_start_group (GKeyFile *key_file) G_GNUC_MALLOC;
function g_key_file_get_start_group(key_file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_key_file_get_start_group
  type(c_ptr), value :: key_file
end function

! gchar **g_key_file_get_groups (GKeyFile *key_file, gsize *length) G_GNUC_MALLOC;
function g_key_file_get_groups(key_file, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_key_file_get_groups
  type(c_ptr), value :: key_file
  type(c_ptr), value :: length
end function

! gchar **g_key_file_get_keys (GKeyFile *key_file, const gchar *group_name, gsize *length, GError **error) G_GNUC_MALLOC;
function g_key_file_get_keys(key_file, group_name, length, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_keys
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! gboolean g_key_file_has_group (GKeyFile *key_file, const gchar *group_name);
function g_key_file_has_group(key_file, group_name) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_key_file_has_group
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
end function

! gboolean g_key_file_has_key (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_has_key(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_key_file_has_key
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! gchar *g_key_file_get_value (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) G_GNUC_MALLOC;
function g_key_file_get_value(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_value
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! void g_key_file_set_value (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *value);
subroutine g_key_file_set_value(key_file, group_name, key, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: value
end subroutine

! gchar *g_key_file_get_string (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) G_GNUC_MALLOC;
function g_key_file_get_string(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_string
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! void g_key_file_set_string (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *string);
subroutine g_key_file_set_string(key_file, group_name, key, string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: string
end subroutine

! gchar *g_key_file_get_locale_string (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, GError **error) G_GNUC_MALLOC;
function g_key_file_get_locale_string(key_file, group_name, key, locale, error) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_locale_string
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: locale
  type(c_ptr), value :: error
end function

! void g_key_file_set_locale_string (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar *string);
subroutine g_key_file_set_locale_string(key_file, group_name, key, locale, strin&
      &g) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: locale
  character(kind=c_char), dimension(*) :: string
end subroutine

! gboolean g_key_file_get_boolean (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_get_boolean(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_key_file_get_boolean
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! void g_key_file_set_boolean (GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean value);
subroutine g_key_file_set_boolean(key_file, group_name, key, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_bool
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  logical(c_bool), value :: value
end subroutine

! gint g_key_file_get_integer (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_get_integer(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_get_integer
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! void g_key_file_set_integer (GKeyFile *key_file, const gchar *group_name, const gchar *key, gint value);
subroutine g_key_file_set_integer(key_file, group_name, key, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: value
end subroutine

! gint64 g_key_file_get_int64 (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_get_int64(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr, c_char
  integer(c_int64_t) :: g_key_file_get_int64
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! void g_key_file_set_int64 (GKeyFile *key_file, const gchar *group_name, const gchar *key, gint64 value);
subroutine g_key_file_set_int64(key_file, group_name, key, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int64_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  integer(c_int64_t), value :: value
end subroutine

! guint64 g_key_file_get_uint64 (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_get_uint64(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr, c_char
  integer(c_int64_t) :: g_key_file_get_uint64
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! void g_key_file_set_uint64 (GKeyFile *key_file, const gchar *group_name, const gchar *key, guint64 value);
subroutine g_key_file_set_uint64(key_file, group_name, key, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int64_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  integer(c_int64_t), value :: value
end subroutine

! gdouble g_key_file_get_double (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_get_double(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_double, c_ptr, c_char
  real(c_double) :: g_key_file_get_double
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! void g_key_file_set_double (GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble value);
subroutine g_key_file_set_double(key_file, group_name, key, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_double
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  real(c_double), value :: value
end subroutine

! gchar **g_key_file_get_string_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error) G_GNUC_MALLOC;
function g_key_file_get_string_list(key_file, group_name, key, length, error) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_string_list
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! void g_key_file_set_string_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar * const list[], gsize length);
subroutine g_key_file_set_string_list(key_file, group_name, key, list, length) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: list
  integer(c_size_t), value :: length
end subroutine

! gchar **g_key_file_get_locale_string_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, gsize *length, GError **error) G_GNUC_MALLOC;
function g_key_file_get_locale_string_list(key_file, group_name, key, locale, le&
      &ngth, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_locale_string_list
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: locale
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! void g_key_file_set_locale_string_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar * const list[], gsize length);
subroutine g_key_file_set_locale_string_list(key_file, group_name, key, locale, &
      &list, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: locale
  character(kind=c_char), dimension(*) :: list
  integer(c_size_t), value :: length
end subroutine

! gboolean *g_key_file_get_boolean_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error) G_GNUC_MALLOC;
function g_key_file_get_boolean_list(key_file, group_name, key, length, error) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_boolean_list
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! void g_key_file_set_boolean_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean list[], gsize length);
subroutine g_key_file_set_boolean_list(key_file, group_name, key, list, length) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_bool, c_size_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  logical(c_bool), dimension(*) :: list
  integer(c_size_t), value :: length
end subroutine

! gint *g_key_file_get_integer_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error) G_GNUC_MALLOC;
function g_key_file_get_integer_list(key_file, group_name, key, length, error) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_integer_list
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! void g_key_file_set_double_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble list[], gsize length);
subroutine g_key_file_set_double_list(key_file, group_name, key, list, length) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_double, c_size_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  real(c_double), dimension(*) :: list
  integer(c_size_t), value :: length
end subroutine

! gdouble *g_key_file_get_double_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error) G_GNUC_MALLOC;
function g_key_file_get_double_list(key_file, group_name, key, length, error) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_double_list
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! void g_key_file_set_integer_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gint list[], gsize length);
subroutine g_key_file_set_integer_list(key_file, group_name, key, list, length) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_size_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  integer(c_int), dimension(*) :: list
  integer(c_size_t), value :: length
end subroutine

! gboolean g_key_file_set_comment (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *comment, GError **error);
function g_key_file_set_comment(key_file, group_name, key, comment, error) bind(&
      &c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_key_file_set_comment
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: comment
  type(c_ptr), value :: error
end function

! gchar *g_key_file_get_comment (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) G_GNUC_MALLOC;
function g_key_file_get_comment(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_comment
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

!  gboolean g_key_file_remove_comment (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_remove_comment(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_key_file_remove_comment
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! gboolean g_key_file_remove_key (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_remove_key(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_key_file_remove_key
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! gboolean g_key_file_remove_group (GKeyFile *key_file, const gchar *group_name, GError **error);
function g_key_file_remove_group(key_file, group_name, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_key_file_remove_group
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  type(c_ptr), value :: error
end function

!   GThreadPool* g_thread_pool_new (GFunc func, gpointer user_data, gint max_threads, gboolean exclusive, GError **error);
function g_thread_pool_new(func, user_data, max_threads, exclusive, error) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_funptr, c_int, c_bool
  type(c_ptr) :: g_thread_pool_new
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
  integer(c_int), value :: max_threads
  logical(c_bool), value :: exclusive
  type(c_ptr), value :: error
end function

!  void g_thread_pool_push (GThreadPool *pool, gpointer data, GError **error);
subroutine g_thread_pool_push(pool, data, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pool
  type(c_ptr), value :: data
  type(c_ptr), value :: error
end subroutine

!  void g_thread_pool_set_max_threads (GThreadPool *pool, gint max_threads, GError **error);
subroutine g_thread_pool_set_max_threads(pool, max_threads, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: pool
  integer(c_int), value :: max_threads
  type(c_ptr), value :: error
end subroutine

! gint g_thread_pool_get_max_threads (GThreadPool *pool);
function g_thread_pool_get_max_threads(pool) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_thread_pool_get_max_threads
  type(c_ptr), value :: pool
end function

!  guint g_thread_pool_get_num_threads (GThreadPool *pool);
function g_thread_pool_get_num_threads(pool) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_thread_pool_get_num_threads
  type(c_ptr), value :: pool
end function

!  guint g_thread_pool_unprocessed (GThreadPool *pool);
function g_thread_pool_unprocessed(pool) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_thread_pool_unprocessed
  type(c_ptr), value :: pool
end function

!  void g_thread_pool_free (GThreadPool *pool, gboolean immediate, gboolean wait_);
subroutine g_thread_pool_free(pool, immediate, wait_) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: pool
  logical(c_bool), value :: immediate
  logical(c_bool), value :: wait_
end subroutine

!  void g_thread_pool_set_max_unused_threads (gint max_threads);
subroutine g_thread_pool_set_max_unused_threads(max_threads) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: max_threads
end subroutine

! gint g_thread_pool_get_max_unused_threads (void);
function g_thread_pool_get_max_unused_threads() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_thread_pool_get_max_unused_threads
end function

! guint g_thread_pool_get_num_unused_threads (void);
function g_thread_pool_get_num_unused_threads() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_thread_pool_get_num_unused_threads
end function

!  void g_thread_pool_stop_unused_threads (void);
subroutine g_thread_pool_stop_unused_threads() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  void g_thread_pool_set_sort_function (GThreadPool *pool, GCompareDataFunc func, gpointer user_data);
subroutine g_thread_pool_set_sort_function(pool, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: pool
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!  void g_thread_pool_set_max_idle_time (guint interval);
subroutine g_thread_pool_set_max_idle_time(interval) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: interval
end subroutine

! guint g_thread_pool_get_max_idle_time (void);
function g_thread_pool_get_max_idle_time() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_thread_pool_get_max_idle_time
end function

!   GTree* g_tree_new (GCompareFunc key_compare_func);
function g_tree_new(key_compare_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_tree_new
  type(c_funptr), value :: key_compare_func
end function

! GTree* g_tree_new_with_data (GCompareDataFunc key_compare_func, gpointer key_compare_data);
function g_tree_new_with_data(key_compare_func, key_compare_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_tree_new_with_data
  type(c_funptr), value :: key_compare_func
  type(c_ptr), value :: key_compare_data
end function

! GTree* g_tree_new_full (GCompareDataFunc key_compare_func, gpointer key_compare_data, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func);
function g_tree_new_full(key_compare_func, key_compare_data, key_destroy_func, v&
      &alue_destroy_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_tree_new_full
  type(c_funptr), value :: key_compare_func
  type(c_ptr), value :: key_compare_data
  type(c_funptr), value :: key_destroy_func
  type(c_funptr), value :: value_destroy_func
end function

! GTree* g_tree_ref (GTree *tree);
function g_tree_ref(tree) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_tree_ref
  type(c_ptr), value :: tree
end function

! void g_tree_unref (GTree *tree);
subroutine g_tree_unref(tree) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree
end subroutine

! void g_tree_destroy (GTree *tree);
subroutine g_tree_destroy(tree) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree
end subroutine

! void g_tree_insert (GTree *tree, gpointer key, gpointer value);
subroutine g_tree_insert(tree, key, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end subroutine

! void g_tree_replace (GTree *tree, gpointer key, gpointer value);
subroutine g_tree_replace(tree, key, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end subroutine

! gboolean g_tree_remove (GTree *tree, gconstpointer key);
function g_tree_remove(tree, key) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_tree_remove
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
end function

! gboolean g_tree_steal (GTree *tree, gconstpointer key);
function g_tree_steal(tree, key) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_tree_steal
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
end function

! gpointer g_tree_lookup (GTree *tree, gconstpointer key);
function g_tree_lookup(tree, key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_tree_lookup
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
end function

! gboolean g_tree_lookup_extended (GTree *tree, gconstpointer lookup_key, gpointer *orig_key, gpointer *value);
function g_tree_lookup_extended(tree, lookup_key, orig_key, value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_tree_lookup_extended
  type(c_ptr), value :: tree
  type(c_ptr), value :: lookup_key
  type(c_ptr), value :: orig_key
  type(c_ptr), value :: value
end function

! void g_tree_foreach (GTree *tree, GTraverseFunc func, gpointer user_data);
subroutine g_tree_foreach(tree, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: tree
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!  void g_tree_traverse (GTree *tree, GTraverseFunc traverse_func, GTraverseType traverse_type, gpointer user_data);
subroutine g_tree_traverse(tree, traverse_func, traverse_type, user_data) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_funptr, c_int
  type(c_ptr), value :: tree
  type(c_funptr), value :: traverse_func
  integer(c_int), value :: traverse_type
  type(c_ptr), value :: user_data
end subroutine

!  gpointer g_tree_search (GTree *tree, GCompareFunc search_func, gconstpointer user_data);
function g_tree_search(tree, search_func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_tree_search
  type(c_ptr), value :: tree
  type(c_funptr), value :: search_func
  type(c_ptr), value :: user_data
end function

! gint g_tree_height (GTree *tree);
function g_tree_height(tree) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_tree_height
  type(c_ptr), value :: tree
end function

! gint g_tree_nnodes (GTree *tree);
function g_tree_nnodes(tree) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_tree_nnodes
  type(c_ptr), value :: tree
end function

!     char *alloca ();
function alloca() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: alloca
end function

!   guint g_spaced_primes_closest (guint num) G_GNUC_CONST;
function g_spaced_primes_closest(num) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_spaced_primes_closest
  integer(c_int), value :: num
end function

!   GDate* g_date_new (void);
function g_date_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_new
end function

! GDate* g_date_new_dmy (GDateDay day, GDateMonth month, GDateYear year);
function g_date_new_dmy(day, month, year) bind(c) 
  use iso_c_binding, only: c_ptr, c_int8_t, c_int, c_int16_t
  type(c_ptr) :: g_date_new_dmy
  integer(c_int8_t), value :: day
  integer(c_int), value :: month
  integer(c_int16_t), value :: year
end function

! GDate* g_date_new_julian (guint32 julian_day);
function g_date_new_julian(julian_day) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_date_new_julian
  integer(c_int32_t), value :: julian_day
end function

! void g_date_free (GDate *date);
subroutine g_date_free(date) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: date
end subroutine

!  gboolean g_date_valid (const GDate *date);
function g_date_valid(date) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_date_valid
  type(c_ptr), value :: date
end function

! gboolean g_date_valid_day (GDateDay day) G_GNUC_CONST;
function g_date_valid_day(day) bind(c) 
  use iso_c_binding, only: c_bool, c_int8_t
  logical(c_bool) :: g_date_valid_day
  integer(c_int8_t), value :: day
end function

! gboolean g_date_valid_month (GDateMonth month) G_GNUC_CONST;
function g_date_valid_month(month) bind(c) 
  use iso_c_binding, only: c_bool, c_int
  logical(c_bool) :: g_date_valid_month
  integer(c_int), value :: month
end function

! gboolean g_date_valid_year (GDateYear year) G_GNUC_CONST;
function g_date_valid_year(year) bind(c) 
  use iso_c_binding, only: c_bool, c_int16_t
  logical(c_bool) :: g_date_valid_year
  integer(c_int16_t), value :: year
end function

! gboolean g_date_valid_weekday (GDateWeekday weekday) G_GNUC_CONST;
function g_date_valid_weekday(weekday) bind(c) 
  use iso_c_binding, only: c_bool, c_int
  logical(c_bool) :: g_date_valid_weekday
  integer(c_int), value :: weekday
end function

! gboolean g_date_valid_julian (guint32 julian_date) G_GNUC_CONST;
function g_date_valid_julian(julian_date) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: g_date_valid_julian
  integer(c_int32_t), value :: julian_date
end function

! gboolean g_date_valid_dmy (GDateDay day, GDateMonth month, GDateYear year) G_GNUC_CONST;
function g_date_valid_dmy(day, month, year) bind(c) 
  use iso_c_binding, only: c_bool, c_int8_t, c_int, c_int16_t
  logical(c_bool) :: g_date_valid_dmy
  integer(c_int8_t), value :: day
  integer(c_int), value :: month
  integer(c_int16_t), value :: year
end function

!  GDateWeekday g_date_get_weekday (const GDate *date);
function g_date_get_weekday(date) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_get_weekday
  type(c_ptr), value :: date
end function

! GDateMonth g_date_get_month (const GDate *date);
function g_date_get_month(date) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_get_month
  type(c_ptr), value :: date
end function

! GDateYear g_date_get_year (const GDate *date);
function g_date_get_year(date) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_date_get_year
  type(c_ptr), value :: date
end function

! GDateDay g_date_get_day (const GDate *date);
function g_date_get_day(date) bind(c) 
  use iso_c_binding, only: c_int8_t, c_ptr
  integer(c_int8_t) :: g_date_get_day
  type(c_ptr), value :: date
end function

! guint32 g_date_get_julian (const GDate *date);
function g_date_get_julian(date) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_date_get_julian
  type(c_ptr), value :: date
end function

! guint g_date_get_day_of_year (const GDate *date);
function g_date_get_day_of_year(date) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_get_day_of_year
  type(c_ptr), value :: date
end function

!  guint g_date_get_monday_week_of_year (const GDate *date);
function g_date_get_monday_week_of_year(date) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_get_monday_week_of_year
  type(c_ptr), value :: date
end function

! guint g_date_get_sunday_week_of_year (const GDate *date);
function g_date_get_sunday_week_of_year(date) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_get_sunday_week_of_year
  type(c_ptr), value :: date
end function

! guint g_date_get_iso8601_week_of_year (const GDate *date);
function g_date_get_iso8601_week_of_year(date) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_get_iso8601_week_of_year
  type(c_ptr), value :: date
end function

!  void g_date_clear (GDate *date, guint n_dates);
subroutine g_date_clear(date, n_dates) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_dates
end subroutine

!  void g_date_set_parse (GDate *date, const gchar *str);
subroutine g_date_set_parse(date, str) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: date
  character(kind=c_char), dimension(*) :: str
end subroutine

! void g_date_set_time_t (GDate *date, time_t timet);
subroutine g_date_set_time_t(date, timet) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr), value :: date
  integer(c_long), value :: timet
end subroutine

! void g_date_set_time_val (GDate *date, GTimeVal *timeval);
subroutine g_date_set_time_val(date, timeval) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: date
  type(c_ptr), value :: timeval
end subroutine

!  void g_date_set_time (GDate *date, GTime time_);
subroutine g_date_set_time(date, time_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: date
  integer(c_int32_t), value :: time_
end subroutine

!  void g_date_set_month (GDate *date, GDateMonth month);
subroutine g_date_set_month(date, month) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: month
end subroutine

! void g_date_set_day (GDate *date, GDateDay day);
subroutine g_date_set_day(date, day) bind(c) 
  use iso_c_binding, only: c_ptr, c_int8_t
  type(c_ptr), value :: date
  integer(c_int8_t), value :: day
end subroutine

! void g_date_set_year (GDate *date, GDateYear year);
subroutine g_date_set_year(date, year) bind(c) 
  use iso_c_binding, only: c_ptr, c_int16_t
  type(c_ptr), value :: date
  integer(c_int16_t), value :: year
end subroutine

! void g_date_set_dmy (GDate *date, GDateDay day, GDateMonth month, GDateYear y);
subroutine g_date_set_dmy(date, day, month, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int8_t, c_int, c_int16_t
  type(c_ptr), value :: date
  integer(c_int8_t), value :: day
  integer(c_int), value :: month
  integer(c_int16_t), value :: y
end subroutine

! void g_date_set_julian (GDate *date, guint32 julian_date);
subroutine g_date_set_julian(date, julian_date) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: date
  integer(c_int32_t), value :: julian_date
end subroutine

! gboolean g_date_is_first_of_month (const GDate *date);
function g_date_is_first_of_month(date) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_date_is_first_of_month
  type(c_ptr), value :: date
end function

! gboolean g_date_is_last_of_month (const GDate *date);
function g_date_is_last_of_month(date) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_date_is_last_of_month
  type(c_ptr), value :: date
end function

!  void g_date_add_days (GDate *date, guint n_days);
subroutine g_date_add_days(date, n_days) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_days
end subroutine

! void g_date_subtract_days (GDate *date, guint n_days);
subroutine g_date_subtract_days(date, n_days) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_days
end subroutine

!  void g_date_add_months (GDate *date, guint n_months);
subroutine g_date_add_months(date, n_months) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_months
end subroutine

! void g_date_subtract_months (GDate *date, guint n_months);
subroutine g_date_subtract_months(date, n_months) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_months
end subroutine

!  void g_date_add_years (GDate *date, guint n_years);
subroutine g_date_add_years(date, n_years) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_years
end subroutine

! void g_date_subtract_years (GDate *date, guint n_years);
subroutine g_date_subtract_years(date, n_years) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_years
end subroutine

! gboolean g_date_is_leap_year (GDateYear year) G_GNUC_CONST;
function g_date_is_leap_year(year) bind(c) 
  use iso_c_binding, only: c_bool, c_int16_t
  logical(c_bool) :: g_date_is_leap_year
  integer(c_int16_t), value :: year
end function

! guint8 g_date_get_days_in_month (GDateMonth month, GDateYear year) G_GNUC_CONST;
function g_date_get_days_in_month(month, year) bind(c) 
  use iso_c_binding, only: c_int8_t, c_int, c_int16_t
  integer(c_int8_t) :: g_date_get_days_in_month
  integer(c_int), value :: month
  integer(c_int16_t), value :: year
end function

! guint8 g_date_get_monday_weeks_in_year (GDateYear year) G_GNUC_CONST;
function g_date_get_monday_weeks_in_year(year) bind(c) 
  use iso_c_binding, only: c_int8_t, c_int16_t
  integer(c_int8_t) :: g_date_get_monday_weeks_in_year
  integer(c_int16_t), value :: year
end function

! guint8 g_date_get_sunday_weeks_in_year (GDateYear year) G_GNUC_CONST;
function g_date_get_sunday_weeks_in_year(year) bind(c) 
  use iso_c_binding, only: c_int8_t, c_int16_t
  integer(c_int8_t) :: g_date_get_sunday_weeks_in_year
  integer(c_int16_t), value :: year
end function

!  gint g_date_days_between (const GDate *date1, const GDate *date2);
function g_date_days_between(date1, date2) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_days_between
  type(c_ptr), value :: date1
  type(c_ptr), value :: date2
end function

!  gint g_date_compare (const GDate *lhs, const GDate *rhs);
function g_date_compare(lhs, rhs) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_compare
  type(c_ptr), value :: lhs
  type(c_ptr), value :: rhs
end function

! void g_date_to_struct_tm (const GDate *date, struct tm *tm);
subroutine g_date_to_struct_tm(date, tm) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: date
  type(c_ptr), value :: tm
end subroutine

!  void g_date_clamp (GDate *date, const GDate *min_date, const GDate *max_date);
subroutine g_date_clamp(date, min_date, max_date) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: date
  type(c_ptr), value :: min_date
  type(c_ptr), value :: max_date
end subroutine

!  void g_date_order (GDate *date1, GDate *date2);
subroutine g_date_order(date1, date2) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: date1
  type(c_ptr), value :: date2
end subroutine

!  gsize g_date_strftime (gchar *s, gsize slen, const gchar *format, const GDate *date);
function g_date_strftime(s, slen, format, date) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_date_strftime
  character(kind=c_char), dimension(*) :: s
  integer(c_size_t), value :: slen
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: date
end function

!   GQuark g_file_error_quark (void);
function g_file_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_file_error_quark
end function

!  GFileError g_file_error_from_errno (gint err_no);
function g_file_error_from_errno(err_no) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_file_error_from_errno
  integer(c_int), value :: err_no
end function

!  gboolean g_file_test (const gchar *filename, GFileTest test);
function g_file_test(filename, test) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_int
  logical(c_bool) :: g_file_test
  character(kind=c_char), dimension(*) :: filename
  integer(c_int), value :: test
end function

! gboolean g_file_get_contents (const gchar *filename, gchar **contents, gsize *length, GError **error);
function g_file_get_contents(filename, contents, length, error) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_ptr
  logical(c_bool) :: g_file_get_contents
  character(kind=c_char), dimension(*) :: filename
  character(kind=c_char), dimension(*) :: contents
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! gboolean g_file_set_contents (const gchar *filename, const gchar *contents, gssize length, GError **error);
function g_file_set_contents(filename, contents, length, error) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_size_t, c_ptr
  logical(c_bool) :: g_file_set_contents
  character(kind=c_char), dimension(*) :: filename
  character(kind=c_char), dimension(*) :: contents
  integer(c_size_t), value :: length
  type(c_ptr), value :: error
end function

! gchar *g_file_read_link (const gchar *filename, GError **error);
function g_file_read_link(filename, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_read_link
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: error
end function

!  gint g_mkstemp (gchar *tmpl);
function g_mkstemp(tmpl) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_mkstemp
  character(kind=c_char), dimension(*) :: tmpl
end function

! gint g_mkstemp_full (gchar *tmpl, int flags, int mode);
function g_mkstemp_full(tmpl, flags, mode) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_mkstemp_full
  character(kind=c_char), dimension(*) :: tmpl
  integer(c_int), value :: flags
  integer(c_int), value :: mode
end function

!  gint g_file_open_tmp (const gchar *tmpl, gchar **name_used, GError **error);
function g_file_open_tmp(tmpl, name_used, error) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_ptr
  integer(c_int) :: g_file_open_tmp
  character(kind=c_char), dimension(*) :: tmpl
  character(kind=c_char), dimension(*) :: name_used
  type(c_ptr), value :: error
end function

!  char *g_format_size_for_display (goffset size);
function g_format_size_for_display(size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int64_t
  type(c_ptr) :: g_format_size_for_display
  integer(c_int64_t), value :: size
end function

! gchar *g_build_pathv (const gchar *separator, gchar **args) G_GNUC_MALLOC;
function g_build_pathv(separator, args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_build_pathv
  character(kind=c_char), dimension(*) :: separator
  character(kind=c_char), dimension(*) :: args
end function

! gchar *g_build_filenamev (gchar **args) G_GNUC_MALLOC;
function g_build_filenamev(args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_build_filenamev
  character(kind=c_char), dimension(*) :: args
end function

!  int g_mkdir_with_parents (const gchar *pathname, int mode);
function g_mkdir_with_parents(pathname, mode) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_mkdir_with_parents
  character(kind=c_char), dimension(*) :: pathname
  integer(c_int), value :: mode
end function

!   GQuark g_regex_error_quark (void);
function g_regex_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_regex_error_quark
end function

!  GRegex *g_regex_new (const gchar *pattern, GRegexCompileFlags compile_options, GRegexMatchFlags match_options, GError **error);
function g_regex_new(pattern, compile_options, match_options, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_regex_new
  character(kind=c_char), dimension(*) :: pattern
  integer(c_int), value :: compile_options
  integer(c_int), value :: match_options
  type(c_ptr), value :: error
end function

! GRegex *g_regex_ref (GRegex *regex);
function g_regex_ref(regex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_regex_ref
  type(c_ptr), value :: regex
end function

! void g_regex_unref (GRegex *regex);
subroutine g_regex_unref(regex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: regex
end subroutine

! const gchar *g_regex_get_pattern (const GRegex *regex);
function g_regex_get_pattern(regex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_regex_get_pattern
  type(c_ptr), value :: regex
end function

! gint g_regex_get_max_backref (const GRegex *regex);
function g_regex_get_max_backref(regex) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_regex_get_max_backref
  type(c_ptr), value :: regex
end function

! gint g_regex_get_capture_count (const GRegex *regex);
function g_regex_get_capture_count(regex) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_regex_get_capture_count
  type(c_ptr), value :: regex
end function

! gint g_regex_get_string_number (const GRegex *regex, const gchar *name);
function g_regex_get_string_number(regex, name) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_regex_get_string_number
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: name
end function

! gchar *g_regex_escape_string (const gchar *string, gint length);
function g_regex_escape_string(string, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_regex_escape_string
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: length
end function

!  GRegexCompileFlags g_regex_get_compile_flags (const GRegex *regex);
function g_regex_get_compile_flags(regex) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_regex_get_compile_flags
  type(c_ptr), value :: regex
end function

! GRegexMatchFlags g_regex_get_match_flags (const GRegex *regex);
function g_regex_get_match_flags(regex) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_regex_get_match_flags
  type(c_ptr), value :: regex
end function

!  gboolean g_regex_match_simple (const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options);
function g_regex_match_simple(pattern, string, compile_options, match_options) b&
      &ind(c) 
  use iso_c_binding, only: c_bool, c_char, c_int
  logical(c_bool) :: g_regex_match_simple
  character(kind=c_char), dimension(*) :: pattern
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: compile_options
  integer(c_int), value :: match_options
end function

! gboolean g_regex_match (const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info);
function g_regex_match(regex, string, match_options, match_info) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: g_regex_match
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: match_options
  type(c_ptr), value :: match_info
end function

! gboolean g_regex_match_full (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error);
function g_regex_match_full(regex, string, string_len, start_position, match_opt&
      &ions, match_info, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_size_t, c_int
  logical(c_bool) :: g_regex_match_full
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: string_len
  integer(c_int), value :: start_position
  integer(c_int), value :: match_options
  type(c_ptr), value :: match_info
  type(c_ptr), value :: error
end function

! gboolean g_regex_match_all (const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info);
function g_regex_match_all(regex, string, match_options, match_info) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: g_regex_match_all
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: match_options
  type(c_ptr), value :: match_info
end function

! gboolean g_regex_match_all_full (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error);
function g_regex_match_all_full(regex, string, string_len, start_position, match&
      &_options, match_info, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_size_t, c_int
  logical(c_bool) :: g_regex_match_all_full
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: string_len
  integer(c_int), value :: start_position
  integer(c_int), value :: match_options
  type(c_ptr), value :: match_info
  type(c_ptr), value :: error
end function

!  gchar **g_regex_split_simple (const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options);
function g_regex_split_simple(pattern, string, compile_options, match_options) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_regex_split_simple
  character(kind=c_char), dimension(*) :: pattern
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: compile_options
  integer(c_int), value :: match_options
end function

! gchar **g_regex_split (const GRegex *regex, const gchar *string, GRegexMatchFlags match_options);
function g_regex_split(regex, string, match_options) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_regex_split
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: match_options
end function

! gchar **g_regex_split_full (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, gint max_tokens, GError **error);
function g_regex_split_full(regex, string, string_len, start_position, match_opt&
      &ions, max_tokens, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_regex_split_full
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: string_len
  integer(c_int), value :: start_position
  integer(c_int), value :: match_options
  integer(c_int), value :: max_tokens
  type(c_ptr), value :: error
end function

!  gchar *g_regex_replace (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error);
function g_regex_replace(regex, string, string_len, start_position, replacement,&
      & match_options, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_regex_replace
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: string_len
  integer(c_int), value :: start_position
  character(kind=c_char), dimension(*) :: replacement
  integer(c_int), value :: match_options
  type(c_ptr), value :: error
end function

! gchar *g_regex_replace_literal (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error);
function g_regex_replace_literal(regex, string, string_len, start_position, repl&
      &acement, match_options, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_regex_replace_literal
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: string_len
  integer(c_int), value :: start_position
  character(kind=c_char), dimension(*) :: replacement
  integer(c_int), value :: match_options
  type(c_ptr), value :: error
end function

! gchar *g_regex_replace_eval (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GRegexEvalCallback eval, gpointer user_data, GError **error);
function g_regex_replace_eval(regex, string, string_len, start_position, match_o&
      &ptions, eval, user_data, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int, c_funptr
  type(c_ptr) :: g_regex_replace_eval
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: string_len
  integer(c_int), value :: start_position
  integer(c_int), value :: match_options
  type(c_funptr), value :: eval
  type(c_ptr), value :: user_data
  type(c_ptr), value :: error
end function

! gboolean g_regex_check_replacement (const gchar *replacement, gboolean *has_references, GError **error);
function g_regex_check_replacement(replacement, has_references, error) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_ptr
  logical(c_bool) :: g_regex_check_replacement
  character(kind=c_char), dimension(*) :: replacement
  type(c_ptr), value :: has_references
  type(c_ptr), value :: error
end function

!  GRegex *g_match_info_get_regex (const GMatchInfo *match_info);
function g_match_info_get_regex(match_info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_match_info_get_regex
  type(c_ptr), value :: match_info
end function

! const gchar *g_match_info_get_string (const GMatchInfo *match_info);
function g_match_info_get_string(match_info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_match_info_get_string
  type(c_ptr), value :: match_info
end function

!  void g_match_info_free (GMatchInfo *match_info);
subroutine g_match_info_free(match_info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: match_info
end subroutine

! gboolean g_match_info_next (GMatchInfo *match_info, GError **error);
function g_match_info_next(match_info, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_match_info_next
  type(c_ptr), value :: match_info
  type(c_ptr), value :: error
end function

! gboolean g_match_info_matches (const GMatchInfo *match_info);
function g_match_info_matches(match_info) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_match_info_matches
  type(c_ptr), value :: match_info
end function

! gint g_match_info_get_match_count (const GMatchInfo *match_info);
function g_match_info_get_match_count(match_info) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_match_info_get_match_count
  type(c_ptr), value :: match_info
end function

! gboolean g_match_info_is_partial_match (const GMatchInfo *match_info);
function g_match_info_is_partial_match(match_info) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_match_info_is_partial_match
  type(c_ptr), value :: match_info
end function

! gchar *g_match_info_expand_references(const GMatchInfo *match_info, const gchar *string_to_expand, GError **error);
function g_match_info_expand_references(match_info, string_to_expand, error) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_match_info_expand_references
  type(c_ptr), value :: match_info
  character(kind=c_char), dimension(*) :: string_to_expand
  type(c_ptr), value :: error
end function

! gchar *g_match_info_fetch (const GMatchInfo *match_info, gint match_num);
function g_match_info_fetch(match_info, match_num) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_match_info_fetch
  type(c_ptr), value :: match_info
  integer(c_int), value :: match_num
end function

! gboolean g_match_info_fetch_pos (const GMatchInfo *match_info, gint match_num, gint *start_pos, gint *end_pos);
function g_match_info_fetch_pos(match_info, match_num, start_pos, end_pos) bind(&
      &c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: g_match_info_fetch_pos
  type(c_ptr), value :: match_info
  integer(c_int), value :: match_num
  type(c_ptr), value :: start_pos
  type(c_ptr), value :: end_pos
end function

! gchar *g_match_info_fetch_named (const GMatchInfo *match_info, const gchar *name);
function g_match_info_fetch_named(match_info, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_match_info_fetch_named
  type(c_ptr), value :: match_info
  character(kind=c_char), dimension(*) :: name
end function

! gboolean g_match_info_fetch_named_pos (const GMatchInfo *match_info, const gchar *name, gint *start_pos, gint *end_pos);
function g_match_info_fetch_named_pos(match_info, name, start_pos, end_pos) bind&
      &(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: g_match_info_fetch_named_pos
  type(c_ptr), value :: match_info
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: start_pos
  type(c_ptr), value :: end_pos
end function

! gchar **g_match_info_fetch_all (const GMatchInfo *match_info);
function g_match_info_fetch_all(match_info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_match_info_fetch_all
  type(c_ptr), value :: match_info
end function

!   char * g_uri_unescape_string (const char *escaped_string, const char *illegal_characters);
function g_uri_unescape_string(escaped_string, illegal_characters) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_uri_unescape_string
  character(kind=c_char), dimension(*) :: escaped_string
  character(kind=c_char), dimension(*) :: illegal_characters
end function

! char * g_uri_unescape_segment (const char *escaped_string, const char *escaped_string_end, const char *illegal_characters);
function g_uri_unescape_segment(escaped_string, escaped_string_end, illegal_char&
      &acters) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_uri_unescape_segment
  character(kind=c_char), dimension(*) :: escaped_string
  character(kind=c_char), dimension(*) :: escaped_string_end
  character(kind=c_char), dimension(*) :: illegal_characters
end function

! char * g_uri_parse_scheme (const char *uri);
function g_uri_parse_scheme(uri) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_uri_parse_scheme
  character(kind=c_char), dimension(*) :: uri
end function

! char * g_uri_escape_string (const char *unescaped, const char *reserved_chars_allowed, gboolean allow_utf8);
function g_uri_escape_string(unescaped, reserved_chars_allowed, allow_utf8) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_char, c_bool
  type(c_ptr) :: g_uri_escape_string
  character(kind=c_char), dimension(*) :: unescaped
  character(kind=c_char), dimension(*) :: reserved_chars_allowed
  logical(c_bool), value :: allow_utf8
end function

!   void g_on_error_query (const gchar *prg_name);
subroutine g_on_error_query(prg_name) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: prg_name
end subroutine

! void g_on_error_stack_trace (const gchar *prg_name);
subroutine g_on_error_stack_trace(prg_name) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: prg_name
end subroutine

!   GScanner* g_scanner_new (const GScannerConfig *config_templ);
function g_scanner_new(config_templ) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_scanner_new
  type(c_ptr), value :: config_templ
end function

! void g_scanner_destroy (GScanner *scanner);
subroutine g_scanner_destroy(scanner) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: scanner
end subroutine

! void g_scanner_input_file (GScanner *scanner, gint input_fd);
subroutine g_scanner_input_file(scanner, input_fd) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: scanner
  integer(c_int), value :: input_fd
end subroutine

! void g_scanner_sync_file_offset (GScanner *scanner);
subroutine g_scanner_sync_file_offset(scanner) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: scanner
end subroutine

! void g_scanner_input_text (GScanner *scanner, const gchar *text, guint text_len);
subroutine g_scanner_input_text(scanner, text, text_len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: scanner
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: text_len
end subroutine

! GTokenType g_scanner_get_next_token (GScanner *scanner);
function g_scanner_get_next_token(scanner) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_scanner_get_next_token
  type(c_ptr), value :: scanner
end function

! GTokenType g_scanner_peek_next_token (GScanner *scanner);
function g_scanner_peek_next_token(scanner) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_scanner_peek_next_token
  type(c_ptr), value :: scanner
end function

! GTokenType g_scanner_cur_token (GScanner *scanner);
function g_scanner_cur_token(scanner) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_scanner_cur_token
  type(c_ptr), value :: scanner
end function

! guint g_scanner_cur_line (GScanner *scanner);
function g_scanner_cur_line(scanner) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_scanner_cur_line
  type(c_ptr), value :: scanner
end function

! guint g_scanner_cur_position (GScanner *scanner);
function g_scanner_cur_position(scanner) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_scanner_cur_position
  type(c_ptr), value :: scanner
end function

! gboolean g_scanner_eof (GScanner *scanner);
function g_scanner_eof(scanner) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: g_scanner_eof
  type(c_ptr), value :: scanner
end function

! guint g_scanner_set_scope (GScanner *scanner, guint scope_id);
function g_scanner_set_scope(scanner, scope_id) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_scanner_set_scope
  type(c_ptr), value :: scanner
  integer(c_int), value :: scope_id
end function

! void g_scanner_scope_add_symbol (GScanner *scanner, guint scope_id, const gchar *symbol, gpointer value);
subroutine g_scanner_scope_add_symbol(scanner, scope_id, symbol, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: scanner
  integer(c_int), value :: scope_id
  character(kind=c_char), dimension(*) :: symbol
  type(c_ptr), value :: value
end subroutine

! void g_scanner_scope_remove_symbol (GScanner *scanner, guint scope_id, const gchar *symbol);
subroutine g_scanner_scope_remove_symbol(scanner, scope_id, symbol) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: scanner
  integer(c_int), value :: scope_id
  character(kind=c_char), dimension(*) :: symbol
end subroutine

! gpointer g_scanner_scope_lookup_symbol (GScanner *scanner, guint scope_id, const gchar *symbol);
function g_scanner_scope_lookup_symbol(scanner, scope_id, symbol) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr) :: g_scanner_scope_lookup_symbol
  type(c_ptr), value :: scanner
  integer(c_int), value :: scope_id
  character(kind=c_char), dimension(*) :: symbol
end function

! void g_scanner_scope_foreach_symbol (GScanner *scanner, guint scope_id, GHFunc func, gpointer user_data);
subroutine g_scanner_scope_foreach_symbol(scanner, scope_id, func, user_data) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: scanner
  integer(c_int), value :: scope_id
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! gpointer g_scanner_lookup_symbol (GScanner *scanner, const gchar *symbol);
function g_scanner_lookup_symbol(scanner, symbol) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_scanner_lookup_symbol
  type(c_ptr), value :: scanner
  character(kind=c_char), dimension(*) :: symbol
end function

! void g_scanner_unexp_token (GScanner *scanner, GTokenType expected_token, const gchar *identifier_spec, const gchar *symbol_spec, const gchar *symbol_name, const gchar *message, gint is_error);
subroutine g_scanner_unexp_token(scanner, expected_token, identifier_spec, symbo&
      &l_spec, symbol_name, message, is_error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: scanner
  integer(c_int), value :: expected_token
  character(kind=c_char), dimension(*) :: identifier_spec
  character(kind=c_char), dimension(*) :: symbol_spec
  character(kind=c_char), dimension(*) :: symbol_name
  character(kind=c_char), dimension(*) :: message
  integer(c_int), value :: is_error
end subroutine

! void g_scanner_error (GScanner *scanner, const gchar *format, ...) G_GNUC_PRINTF (2,3);
subroutine g_scanner_error() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void g_scanner_warn (GScanner *scanner, const gchar *format, ...) G_GNUC_PRINTF (2,3);
subroutine g_scanner_warn() bind(c) 
  use iso_c_binding, only: 
end subroutine

!   GQuark g_convert_error_quark (void);
function g_convert_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_convert_error_quark
end function

!  GIConv g_iconv_open (const gchar *to_codeset, const gchar *from_codeset);
function g_iconv_open(to_codeset, from_codeset) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_iconv_open
  character(kind=c_char), dimension(*) :: to_codeset
  character(kind=c_char), dimension(*) :: from_codeset
end function

! gsize g_iconv (GIConv converter, gchar **inbuf, gsize *inbytes_left, gchar **outbuf, gsize *outbytes_left);
function g_iconv(converter, inbuf, inbytes_left, outbuf, outbytes_left) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char
  integer(c_size_t) :: g_iconv
  type(c_ptr), value :: converter
  character(kind=c_char), dimension(*) :: inbuf
  type(c_ptr), value :: inbytes_left
  character(kind=c_char), dimension(*) :: outbuf
  type(c_ptr), value :: outbytes_left
end function

! gint g_iconv_close (GIConv converter);
function g_iconv_close(converter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_iconv_close
  type(c_ptr), value :: converter
end function

!  gchar* g_convert (const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
function g_convert(str, len, to_codeset, from_codeset, bytes_read, bytes_written&
      &, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_convert
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
  character(kind=c_char), dimension(*) :: to_codeset
  character(kind=c_char), dimension(*) :: from_codeset
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! gchar* g_convert_with_iconv (const gchar *str, gssize len, GIConv converter, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
function g_convert_with_iconv(str, len, converter, bytes_read, bytes_written, er&
      &ror) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_convert_with_iconv
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
  type(c_ptr), value :: converter
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! gchar* g_convert_with_fallback (const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, const gchar *fallback, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
function g_convert_with_fallback(str, len, to_codeset, from_codeset, fallback, b&
      &ytes_read, bytes_written, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_convert_with_fallback
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
  character(kind=c_char), dimension(*) :: to_codeset
  character(kind=c_char), dimension(*) :: from_codeset
  character(kind=c_char), dimension(*) :: fallback
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

!  gchar* g_locale_to_utf8 (const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
function g_locale_to_utf8(opsysstring, len, bytes_read, bytes_written, error) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_locale_to_utf8
  character(kind=c_char), dimension(*) :: opsysstring
  integer(c_size_t), value :: len
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! gchar* g_locale_from_utf8 (const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
function g_locale_from_utf8(utf8string, len, bytes_read, bytes_written, error) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_locale_from_utf8
  character(kind=c_char), dimension(*) :: utf8string
  integer(c_size_t), value :: len
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

!  gchar* g_filename_to_utf8 (const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
function g_filename_to_utf8(opsysstring, len, bytes_read, bytes_written, error) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_filename_to_utf8
  character(kind=c_char), dimension(*) :: opsysstring
  integer(c_size_t), value :: len
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! gchar* g_filename_from_utf8 (const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
function g_filename_from_utf8(utf8string, len, bytes_read, bytes_written, error)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_filename_from_utf8
  character(kind=c_char), dimension(*) :: utf8string
  integer(c_size_t), value :: len
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

!  gchar *g_filename_from_uri (const gchar *uri, gchar **hostname, GError **error) G_GNUC_MALLOC;
function g_filename_from_uri(uri, hostname, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_filename_from_uri
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: hostname
  type(c_ptr), value :: error
end function

!  gchar *g_filename_to_uri (const gchar *filename, const gchar *hostname, GError **error) G_GNUC_MALLOC;
function g_filename_to_uri(filename, hostname, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_filename_to_uri
  character(kind=c_char), dimension(*) :: filename
  character(kind=c_char), dimension(*) :: hostname
  type(c_ptr), value :: error
end function

! gchar *g_filename_display_name (const gchar *filename) G_GNUC_MALLOC;
function g_filename_display_name(filename) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_filename_display_name
  character(kind=c_char), dimension(*) :: filename
end function

! gboolean g_get_filename_charsets (G_CONST_RETURN gchar ***charsets);
function g_get_filename_charsets(charsets) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: g_get_filename_charsets
  character(kind=c_char), dimension(*) :: charsets
end function

!  gchar *g_filename_display_basename (const gchar *filename) G_GNUC_MALLOC;
function g_filename_display_basename(filename) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_filename_display_basename
  character(kind=c_char), dimension(*) :: filename
end function

!  gchar **g_uri_list_extract_uris (const gchar *uri_list) G_GNUC_MALLOC;
function g_uri_list_extract_uris(uri_list) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_uri_list_extract_uris
  character(kind=c_char), dimension(*) :: uri_list
end function

!   GType gdk_image_get_type (void) G_GNUC_CONST;
function gdk_image_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_image_get_type
end function

!  GdkImage* gdk_image_new (GdkImageType type, GdkVisual *visual, gint width, gint height);
function gdk_image_new(type, visual, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_image_new
  integer(c_int), value :: type
  type(c_ptr), value :: visual
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

!  GdkImage* gdk_image_get (GdkDrawable *drawable, gint x, gint y, gint width, gint height);
function gdk_image_get(drawable, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_image_get
  type(c_ptr), value :: drawable
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

!  GdkImage * gdk_image_ref (GdkImage *image);
function gdk_image_ref(image) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_image_ref
  type(c_ptr), value :: image
end function

! void gdk_image_unref (GdkImage *image);
subroutine gdk_image_unref(image) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: image
end subroutine

!  void gdk_image_put_pixel (GdkImage *image, gint x, gint y, guint32 pixel);
subroutine gdk_image_put_pixel(image, x, y, pixel) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int32_t
  type(c_ptr), value :: image
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int32_t), value :: pixel
end subroutine

! guint32 gdk_image_get_pixel (GdkImage *image, gint x, gint y);
function gdk_image_get_pixel(image, x, y) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr, c_int
  integer(c_int32_t) :: gdk_image_get_pixel
  type(c_ptr), value :: image
  integer(c_int), value :: x
  integer(c_int), value :: y
end function

!  void gdk_image_set_colormap (GdkImage *image, GdkColormap *colormap);
subroutine gdk_image_set_colormap(image, colormap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: image
  type(c_ptr), value :: colormap
end subroutine

! GdkColormap* gdk_image_get_colormap (GdkImage *image);
function gdk_image_get_colormap(image) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_image_get_colormap
  type(c_ptr), value :: image
end function

!  GdkImageType gdk_image_get_image_type (GdkImage *image);
function gdk_image_get_image_type(image) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_image_get_image_type
  type(c_ptr), value :: image
end function

! GdkVisual *gdk_image_get_visual (GdkImage *image);
function gdk_image_get_visual(image) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_image_get_visual
  type(c_ptr), value :: image
end function

! GdkByteOrder gdk_image_get_byte_order (GdkImage *image);
function gdk_image_get_byte_order(image) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_image_get_byte_order
  type(c_ptr), value :: image
end function

! gint gdk_image_get_width (GdkImage *image);
function gdk_image_get_width(image) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_image_get_width
  type(c_ptr), value :: image
end function

! gint gdk_image_get_height (GdkImage *image);
function gdk_image_get_height(image) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_image_get_height
  type(c_ptr), value :: image
end function

! guint16 gdk_image_get_depth (GdkImage *image);
function gdk_image_get_depth(image) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: gdk_image_get_depth
  type(c_ptr), value :: image
end function

! guint16 gdk_image_get_bytes_per_pixel(GdkImage *image);
function gdk_image_get_bytes_per_pixel(image) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: gdk_image_get_bytes_per_pixel
  type(c_ptr), value :: image
end function

! guint16 gdk_image_get_bytes_per_line (GdkImage *image);
function gdk_image_get_bytes_per_line(image) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: gdk_image_get_bytes_per_line
  type(c_ptr), value :: image
end function

! guint16 gdk_image_get_bits_per_pixel (GdkImage *image);
function gdk_image_get_bits_per_pixel(image) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: gdk_image_get_bits_per_pixel
  type(c_ptr), value :: image
end function

! gpointer gdk_image_get_pixels (GdkImage *image);
function gdk_image_get_pixels(image) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_image_get_pixels
  type(c_ptr), value :: image
end function

!  GdkImage* gdk_image_new_bitmap (GdkVisual *visual, gpointer data, gint width, gint height);
function gdk_image_new_bitmap(visual, data, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_image_new_bitmap
  type(c_ptr), value :: visual
  type(c_ptr), value :: data
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

!   gboolean gdk_spawn_on_screen (GdkScreen *screen, const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gint *child_pid, GError **error);
function gdk_spawn_on_screen(screen, working_directory, argv, envp, flags, child&
      &_setup, user_data, child_pid, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int, c_funptr
  logical(c_bool) :: gdk_spawn_on_screen
  type(c_ptr), value :: screen
  character(kind=c_char), dimension(*) :: working_directory
  character(kind=c_char), dimension(*) :: argv
  character(kind=c_char), dimension(*) :: envp
  integer(c_int), value :: flags
  type(c_funptr), value :: child_setup
  type(c_ptr), value :: user_data
  type(c_ptr), value :: child_pid
  type(c_ptr), value :: error
end function

!  gboolean gdk_spawn_on_screen_with_pipes (GdkScreen *screen, const gchar *working_directory, gchar **argv, gchar **envp, GSpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, gint *child_pid, gint *standard_input, gint *standard_output, gint *standard_error, GError **error);
function gdk_spawn_on_screen_with_pipes(screen, working_directory, argv, envp, f&
      &lags, child_setup, user_data, child_pid, standard_input, standard_output,&
      & standard_error, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int, c_funptr
  logical(c_bool) :: gdk_spawn_on_screen_with_pipes
  type(c_ptr), value :: screen
  character(kind=c_char), dimension(*) :: working_directory
  character(kind=c_char), dimension(*) :: argv
  character(kind=c_char), dimension(*) :: envp
  integer(c_int), value :: flags
  type(c_funptr), value :: child_setup
  type(c_ptr), value :: user_data
  type(c_ptr), value :: child_pid
  type(c_ptr), value :: standard_input
  type(c_ptr), value :: standard_output
  type(c_ptr), value :: standard_error
  type(c_ptr), value :: error
end function

!  gboolean gdk_spawn_command_line_on_screen (GdkScreen *screen, const gchar *command_line, GError **error);
function gdk_spawn_command_line_on_screen(screen, command_line, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gdk_spawn_command_line_on_screen
  type(c_ptr), value :: screen
  character(kind=c_char), dimension(*) :: command_line
  type(c_ptr), value :: error
end function

!   GType gdk_cursor_type_get_type (void) G_GNUC_CONST;
function gdk_cursor_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_cursor_type_get_type
end function

!  GType gdk_drag_action_get_type (void) G_GNUC_CONST;
function gdk_drag_action_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_drag_action_get_type
end function

!  GType gdk_drag_protocol_get_type (void) G_GNUC_CONST;
function gdk_drag_protocol_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_drag_protocol_get_type
end function

!  GType gdk_filter_return_get_type (void) G_GNUC_CONST;
function gdk_filter_return_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_filter_return_get_type
end function

!  GType gdk_event_type_get_type (void) G_GNUC_CONST;
function gdk_event_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_event_type_get_type
end function

!  GType gdk_event_mask_get_type (void) G_GNUC_CONST;
function gdk_event_mask_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_event_mask_get_type
end function

!  GType gdk_visibility_state_get_type (void) G_GNUC_CONST;
function gdk_visibility_state_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_visibility_state_get_type
end function

!  GType gdk_scroll_direction_get_type (void) G_GNUC_CONST;
function gdk_scroll_direction_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_scroll_direction_get_type
end function

!  GType gdk_notify_type_get_type (void) G_GNUC_CONST;
function gdk_notify_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_notify_type_get_type
end function

!  GType gdk_crossing_mode_get_type (void) G_GNUC_CONST;
function gdk_crossing_mode_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_crossing_mode_get_type
end function

!  GType gdk_property_state_get_type (void) G_GNUC_CONST;
function gdk_property_state_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_property_state_get_type
end function

!  GType gdk_window_state_get_type (void) G_GNUC_CONST;
function gdk_window_state_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_window_state_get_type
end function

!  GType gdk_setting_action_get_type (void) G_GNUC_CONST;
function gdk_setting_action_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_setting_action_get_type
end function

!  GType gdk_owner_change_get_type (void) G_GNUC_CONST;
function gdk_owner_change_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_owner_change_get_type
end function

!  GType gdk_font_type_get_type (void) G_GNUC_CONST;
function gdk_font_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_font_type_get_type
end function

!  GType gdk_cap_style_get_type (void) G_GNUC_CONST;
function gdk_cap_style_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_cap_style_get_type
end function

!  GType gdk_fill_get_type (void) G_GNUC_CONST;
function gdk_fill_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_fill_get_type
end function

!  GType gdk_function_get_type (void) G_GNUC_CONST;
function gdk_function_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_function_get_type
end function

!  GType gdk_join_style_get_type (void) G_GNUC_CONST;
function gdk_join_style_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_join_style_get_type
end function

!  GType gdk_line_style_get_type (void) G_GNUC_CONST;
function gdk_line_style_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_line_style_get_type
end function

!  GType gdk_subwindow_mode_get_type (void) G_GNUC_CONST;
function gdk_subwindow_mode_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_subwindow_mode_get_type
end function

!  GType gdk_gc_values_mask_get_type (void) G_GNUC_CONST;
function gdk_gc_values_mask_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_gc_values_mask_get_type
end function

!  GType gdk_image_type_get_type (void) G_GNUC_CONST;
function gdk_image_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_image_type_get_type
end function

!  GType gdk_extension_mode_get_type (void) G_GNUC_CONST;
function gdk_extension_mode_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_extension_mode_get_type
end function

!  GType gdk_input_source_get_type (void) G_GNUC_CONST;
function gdk_input_source_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_input_source_get_type
end function

!  GType gdk_input_mode_get_type (void) G_GNUC_CONST;
function gdk_input_mode_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_input_mode_get_type
end function

!  GType gdk_axis_use_get_type (void) G_GNUC_CONST;
function gdk_axis_use_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_axis_use_get_type
end function

!  GType gdk_prop_mode_get_type (void) G_GNUC_CONST;
function gdk_prop_mode_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_prop_mode_get_type
end function

!  GType gdk_fill_rule_get_type (void) G_GNUC_CONST;
function gdk_fill_rule_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_fill_rule_get_type
end function

!  GType gdk_overlap_type_get_type (void) G_GNUC_CONST;
function gdk_overlap_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_overlap_type_get_type
end function

!  GType gdk_rgb_dither_get_type (void) G_GNUC_CONST;
function gdk_rgb_dither_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_rgb_dither_get_type
end function

!  GType gdk_byte_order_get_type (void) G_GNUC_CONST;
function gdk_byte_order_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_byte_order_get_type
end function

!  GType gdk_modifier_type_get_type (void) G_GNUC_CONST;
function gdk_modifier_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_modifier_type_get_type
end function

!  GType gdk_input_condition_get_type (void) G_GNUC_CONST;
function gdk_input_condition_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_input_condition_get_type
end function

!  GType gdk_status_get_type (void) G_GNUC_CONST;
function gdk_status_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_status_get_type
end function

!  GType gdk_grab_status_get_type (void) G_GNUC_CONST;
function gdk_grab_status_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_grab_status_get_type
end function

!  GType gdk_visual_type_get_type (void) G_GNUC_CONST;
function gdk_visual_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_visual_type_get_type
end function

!  GType gdk_window_class_get_type (void) G_GNUC_CONST;
function gdk_window_class_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_window_class_get_type
end function

!  GType gdk_window_type_get_type (void) G_GNUC_CONST;
function gdk_window_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_window_type_get_type
end function

!  GType gdk_window_attributes_type_get_type (void) G_GNUC_CONST;
function gdk_window_attributes_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_window_attributes_type_get_type
end function

!  GType gdk_window_hints_get_type (void) G_GNUC_CONST;
function gdk_window_hints_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_window_hints_get_type
end function

!  GType gdk_window_type_hint_get_type (void) G_GNUC_CONST;
function gdk_window_type_hint_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_window_type_hint_get_type
end function

!  GType gdk_wm_decoration_get_type (void) G_GNUC_CONST;
function gdk_wm_decoration_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_wm_decoration_get_type
end function

!  GType gdk_wm_function_get_type (void) G_GNUC_CONST;
function gdk_wm_function_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_wm_function_get_type
end function

!  GType gdk_gravity_get_type (void) G_GNUC_CONST;
function gdk_gravity_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_gravity_get_type
end function

!  GType gdk_window_edge_get_type (void) G_GNUC_CONST;
function gdk_window_edge_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_window_edge_get_type
end function

!   GType gdk_device_get_type (void) G_GNUC_CONST;
function gdk_device_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_device_get_type
end function

!   GList * gdk_devices_list (void);
function gdk_devices_list() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_devices_list
end function

!  G_CONST_RETURN gchar *gdk_device_get_name (GdkDevice *device);
function gdk_device_get_name(device) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_device_get_name
  type(c_ptr), value :: device
end function

! GdkInputSource gdk_device_get_source (GdkDevice *device);
function gdk_device_get_source(device) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_device_get_source
  type(c_ptr), value :: device
end function

! GdkInputMode gdk_device_get_mode (GdkDevice *device);
function gdk_device_get_mode(device) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_device_get_mode
  type(c_ptr), value :: device
end function

! gboolean gdk_device_get_has_cursor (GdkDevice *device);
function gdk_device_get_has_cursor(device) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_device_get_has_cursor
  type(c_ptr), value :: device
end function

!  void gdk_device_get_key (GdkDevice *device, guint index, guint *keyval, GdkModifierType *modifiers);
subroutine gdk_device_get_key(device, index, keyval, modifiers) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: device
  integer(c_int), value :: index
  type(c_ptr), value :: keyval
  integer(c_int), value :: modifiers
end subroutine

! GdkAxisUse gdk_device_get_axis_use (GdkDevice *device, guint index);
function gdk_device_get_axis_use(device, index) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_device_get_axis_use
  type(c_ptr), value :: device
  integer(c_int), value :: index
end function

! gint gdk_device_get_n_axes (GdkDevice *device);
function gdk_device_get_n_axes(device) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_device_get_n_axes
  type(c_ptr), value :: device
end function

!  void gdk_device_set_source (GdkDevice *device, GdkInputSource source);
subroutine gdk_device_set_source(device, source) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: device
  integer(c_int), value :: source
end subroutine

!  gboolean gdk_device_set_mode (GdkDevice *device, GdkInputMode mode);
function gdk_device_set_mode(device, mode) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gdk_device_set_mode
  type(c_ptr), value :: device
  integer(c_int), value :: mode
end function

!  void gdk_device_set_key (GdkDevice *device, guint index_, guint keyval, GdkModifierType modifiers);
subroutine gdk_device_set_key(device, index_, keyval, modifiers) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: device
  integer(c_int), value :: index_
  integer(c_int), value :: keyval
  integer(c_int), value :: modifiers
end subroutine

!  void gdk_device_set_axis_use (GdkDevice *device, guint index_, GdkAxisUse use);
subroutine gdk_device_set_axis_use(device, index_, use) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: device
  integer(c_int), value :: index_
  integer(c_int), value :: use
end subroutine

!  void gdk_device_get_state (GdkDevice *device, GdkWindow *window, gdouble *axes, GdkModifierType *mask);
subroutine gdk_device_get_state(device, window, axes, mask) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: device
  type(c_ptr), value :: window
  type(c_ptr), value :: axes
  integer(c_int), value :: mask
end subroutine

!  gboolean gdk_device_get_history (GdkDevice *device, GdkWindow *window, guint32 start, guint32 stop, GdkTimeCoord ***events, gint *n_events);
function gdk_device_get_history(device, window, start, stop, events, n_events) b&
      &ind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int32_t
  logical(c_bool) :: gdk_device_get_history
  type(c_ptr), value :: device
  type(c_ptr), value :: window
  integer(c_int32_t), value :: start
  integer(c_int32_t), value :: stop
  type(c_ptr), value :: events
  type(c_ptr), value :: n_events
end function

!  void gdk_device_free_history (GdkTimeCoord **events, gint n_events);
subroutine gdk_device_free_history(events, n_events) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: events
  integer(c_int), value :: n_events
end subroutine

! gboolean gdk_device_get_axis (GdkDevice *device, gdouble *axes, GdkAxisUse use, gdouble *value);
function gdk_device_get_axis(device, axes, use, value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gdk_device_get_axis
  type(c_ptr), value :: device
  type(c_ptr), value :: axes
  integer(c_int), value :: use
  type(c_ptr), value :: value
end function

!  void gdk_input_set_extension_events (GdkWindow *window, gint mask, GdkExtensionMode mode);
subroutine gdk_input_set_extension_events(window, mask, mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: mask
  integer(c_int), value :: mode
end subroutine

!  GdkDevice *gdk_device_get_core_pointer (void);
function gdk_device_get_core_pointer() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_device_get_core_pointer
end function

!   void gdk_window_destroy_notify (GdkWindow *window);
subroutine gdk_window_destroy_notify(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

!  void gdk_synthesize_window_state (GdkWindow *window, GdkWindowState unset_flags, GdkWindowState set_flags);
subroutine gdk_synthesize_window_state(window, unset_flags, set_flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: unset_flags
  integer(c_int), value :: set_flags
end subroutine

!   GType gdk_cursor_get_type (void) G_GNUC_CONST;
function gdk_cursor_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_cursor_get_type
end function

!  GdkCursor* gdk_cursor_new_for_display (GdkDisplay *display, GdkCursorType cursor_type);
function gdk_cursor_new_for_display(display, cursor_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_cursor_new_for_display
  type(c_ptr), value :: display
  integer(c_int), value :: cursor_type
end function

!  GdkCursor* gdk_cursor_new (GdkCursorType cursor_type);
function gdk_cursor_new(cursor_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_cursor_new
  integer(c_int), value :: cursor_type
end function

!  GdkCursor* gdk_cursor_new_from_pixmap (GdkPixmap *source, GdkPixmap *mask, const GdkColor *fg, const GdkColor *bg, gint x, gint y);
function gdk_cursor_new_from_pixmap(source, mask, fg, bg, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_cursor_new_from_pixmap
  type(c_ptr), value :: source
  type(c_ptr), value :: mask
  type(c_ptr), value :: fg
  type(c_ptr), value :: bg
  integer(c_int), value :: x
  integer(c_int), value :: y
end function

! GdkCursor* gdk_cursor_new_from_pixbuf (GdkDisplay *display, GdkPixbuf *pixbuf, gint x, gint y);
function gdk_cursor_new_from_pixbuf(display, pixbuf, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_cursor_new_from_pixbuf
  type(c_ptr), value :: display
  type(c_ptr), value :: pixbuf
  integer(c_int), value :: x
  integer(c_int), value :: y
end function

! GdkDisplay* gdk_cursor_get_display (GdkCursor *cursor);
function gdk_cursor_get_display(cursor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_cursor_get_display
  type(c_ptr), value :: cursor
end function

! GdkCursor* gdk_cursor_ref (GdkCursor *cursor);
function gdk_cursor_ref(cursor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_cursor_ref
  type(c_ptr), value :: cursor
end function

! void gdk_cursor_unref (GdkCursor *cursor);
subroutine gdk_cursor_unref(cursor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cursor
end subroutine

! GdkCursor* gdk_cursor_new_from_name (GdkDisplay *display, const gchar *name);
function gdk_cursor_new_from_name(display, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_cursor_new_from_name
  type(c_ptr), value :: display
  character(kind=c_char), dimension(*) :: name
end function

! GdkPixbuf* gdk_cursor_get_image (GdkCursor *cursor);
function gdk_cursor_get_image(cursor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_cursor_get_image
  type(c_ptr), value :: cursor
end function

! GdkCursorType gdk_cursor_get_cursor_type (GdkCursor *cursor);
function gdk_cursor_get_cursor_type(cursor) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_cursor_get_cursor_type
  type(c_ptr), value :: cursor
end function

!   GType gdk_pixmap_get_type (void) G_GNUC_CONST;
function gdk_pixmap_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_pixmap_get_type
end function

!  GdkPixmap* gdk_pixmap_new (GdkDrawable *drawable, gint width, gint height, gint depth);
function gdk_pixmap_new(drawable, width, height, depth) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_pixmap_new
  type(c_ptr), value :: drawable
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: depth
end function

!  GdkBitmap* gdk_bitmap_create_from_data (GdkDrawable *drawable, const gchar *data, gint width, gint height);
function gdk_bitmap_create_from_data(drawable, data, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: gdk_bitmap_create_from_data
  type(c_ptr), value :: drawable
  character(kind=c_char), dimension(*) :: data
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

! GdkPixmap* gdk_pixmap_create_from_data (GdkDrawable *drawable, const gchar *data, gint width, gint height, gint depth, const GdkColor *fg, const GdkColor *bg);
function gdk_pixmap_create_from_data(drawable, data, width, height, depth, fg, b&
      &g) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: gdk_pixmap_create_from_data
  type(c_ptr), value :: drawable
  character(kind=c_char), dimension(*) :: data
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: depth
  type(c_ptr), value :: fg
  type(c_ptr), value :: bg
end function

!  GdkPixmap* gdk_pixmap_create_from_xpm (GdkDrawable *drawable, GdkBitmap **mask, const GdkColor *transparent_color, const gchar *filename);
function gdk_pixmap_create_from_xpm(drawable, mask, transparent_color, filename)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_pixmap_create_from_xpm
  type(c_ptr), value :: drawable
  type(c_ptr), value :: mask
  type(c_ptr), value :: transparent_color
  character(kind=c_char), dimension(*) :: filename
end function

! GdkPixmap* gdk_pixmap_colormap_create_from_xpm (GdkDrawable *drawable, GdkColormap *colormap, GdkBitmap **mask, const GdkColor *transparent_color, const gchar *filename);
function gdk_pixmap_colormap_create_from_xpm(drawable, colormap, mask, transpare&
      &nt_color, filename) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_pixmap_colormap_create_from_xpm
  type(c_ptr), value :: drawable
  type(c_ptr), value :: colormap
  type(c_ptr), value :: mask
  type(c_ptr), value :: transparent_color
  character(kind=c_char), dimension(*) :: filename
end function

! GdkPixmap* gdk_pixmap_create_from_xpm_d (GdkDrawable *drawable, GdkBitmap **mask, const GdkColor *transparent_color, gchar **data);
function gdk_pixmap_create_from_xpm_d(drawable, mask, transparent_color, data) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_pixmap_create_from_xpm_d
  type(c_ptr), value :: drawable
  type(c_ptr), value :: mask
  type(c_ptr), value :: transparent_color
  character(kind=c_char), dimension(*) :: data
end function

! GdkPixmap* gdk_pixmap_colormap_create_from_xpm_d (GdkDrawable *drawable, GdkColormap *colormap, GdkBitmap **mask, const GdkColor *transparent_color, gchar **data);
function gdk_pixmap_colormap_create_from_xpm_d(drawable, colormap, mask, transpa&
      &rent_color, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_pixmap_colormap_create_from_xpm_d
  type(c_ptr), value :: drawable
  type(c_ptr), value :: colormap
  type(c_ptr), value :: mask
  type(c_ptr), value :: transparent_color
  character(kind=c_char), dimension(*) :: data
end function

!  GdkPixmap* gdk_pixmap_foreign_new (GdkNativeWindow anid);
function gdk_pixmap_foreign_new(anid) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixmap_foreign_new
  type(c_ptr), value :: anid
end function

! GdkPixmap* gdk_pixmap_lookup (GdkNativeWindow anid);
function gdk_pixmap_lookup(anid) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixmap_lookup
  type(c_ptr), value :: anid
end function

!  GdkPixmap* gdk_pixmap_foreign_new_for_display (GdkDisplay *display, GdkNativeWindow anid);
function gdk_pixmap_foreign_new_for_display(display, anid) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixmap_foreign_new_for_display
  type(c_ptr), value :: display
  type(c_ptr), value :: anid
end function

! GdkPixmap* gdk_pixmap_lookup_for_display (GdkDisplay *display, GdkNativeWindow anid);
function gdk_pixmap_lookup_for_display(display, anid) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixmap_lookup_for_display
  type(c_ptr), value :: display
  type(c_ptr), value :: anid
end function

! GdkPixmap* gdk_pixmap_foreign_new_for_screen (GdkScreen *screen, GdkNativeWindow anid, gint width, gint height, gint depth);
function gdk_pixmap_foreign_new_for_screen(screen, anid, width, height, depth) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_pixmap_foreign_new_for_screen
  type(c_ptr), value :: screen
  type(c_ptr), value :: anid
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: depth
end function

!  GType gdk_display_get_type (void) G_GNUC_CONST;
function gdk_display_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_display_get_type
end function

! GdkDisplay *gdk_display_open (const gchar *display_name);
function gdk_display_open(display_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_display_open
  character(kind=c_char), dimension(*) :: display_name
end function

!  G_CONST_RETURN gchar * gdk_display_get_name (GdkDisplay *display);
function gdk_display_get_name(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_display_get_name
  type(c_ptr), value :: display
end function

!  gint gdk_display_get_n_screens (GdkDisplay *display);
function gdk_display_get_n_screens(display) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_display_get_n_screens
  type(c_ptr), value :: display
end function

! GdkScreen * gdk_display_get_screen (GdkDisplay *display, gint screen_num);
function gdk_display_get_screen(display, screen_num) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_display_get_screen
  type(c_ptr), value :: display
  integer(c_int), value :: screen_num
end function

! GdkScreen * gdk_display_get_default_screen (GdkDisplay *display);
function gdk_display_get_default_screen(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_display_get_default_screen
  type(c_ptr), value :: display
end function

! void gdk_display_pointer_ungrab (GdkDisplay *display, guint32 time_);
subroutine gdk_display_pointer_ungrab(display, time_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: display
  integer(c_int32_t), value :: time_
end subroutine

! void gdk_display_keyboard_ungrab (GdkDisplay *display, guint32 time_);
subroutine gdk_display_keyboard_ungrab(display, time_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: display
  integer(c_int32_t), value :: time_
end subroutine

! gboolean gdk_display_pointer_is_grabbed (GdkDisplay *display);
function gdk_display_pointer_is_grabbed(display) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_display_pointer_is_grabbed
  type(c_ptr), value :: display
end function

! void gdk_display_beep (GdkDisplay *display);
subroutine gdk_display_beep(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: display
end subroutine

! void gdk_display_sync (GdkDisplay *display);
subroutine gdk_display_sync(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: display
end subroutine

! void gdk_display_flush (GdkDisplay *display);
subroutine gdk_display_flush(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: display
end subroutine

!  void gdk_display_close (GdkDisplay *display);
subroutine gdk_display_close(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: display
end subroutine

! gboolean gdk_display_is_closed (GdkDisplay *display);
function gdk_display_is_closed(display) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_display_is_closed
  type(c_ptr), value :: display
end function

!  GList * gdk_display_list_devices (GdkDisplay *display);
function gdk_display_list_devices(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_display_list_devices
  type(c_ptr), value :: display
end function

!  GdkEvent* gdk_display_get_event (GdkDisplay *display);
function gdk_display_get_event(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_display_get_event
  type(c_ptr), value :: display
end function

! GdkEvent* gdk_display_peek_event (GdkDisplay *display);
function gdk_display_peek_event(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_display_peek_event
  type(c_ptr), value :: display
end function

! void gdk_display_put_event (GdkDisplay *display, const GdkEvent *event);
subroutine gdk_display_put_event(display, event) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: display
  type(c_ptr), value :: event
end subroutine

!  void gdk_display_add_client_message_filter (GdkDisplay *display, GdkAtom message_type, GdkFilterFunc func, gpointer data);
subroutine gdk_display_add_client_message_filter(display, message_type, func, da&
      &ta) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: display
  type(c_ptr), value :: message_type
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end subroutine

!  void gdk_display_set_double_click_time (GdkDisplay *display, guint msec);
subroutine gdk_display_set_double_click_time(display, msec) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: display
  integer(c_int), value :: msec
end subroutine

! void gdk_display_set_double_click_distance (GdkDisplay *display, guint distance);
subroutine gdk_display_set_double_click_distance(display, distance) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: display
  integer(c_int), value :: distance
end subroutine

!  GdkDisplay *gdk_display_get_default (void);
function gdk_display_get_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_display_get_default
end function

!  GdkDevice *gdk_display_get_core_pointer (GdkDisplay *display);
function gdk_display_get_core_pointer(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_display_get_core_pointer
  type(c_ptr), value :: display
end function

!  void gdk_display_get_pointer (GdkDisplay *display, GdkScreen **screen, gint *x, gint *y, GdkModifierType *mask);
subroutine gdk_display_get_pointer(display, screen, x, y, mask) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: display
  type(c_ptr), value :: screen
  type(c_ptr), value :: x
  type(c_ptr), value :: y
  integer(c_int), value :: mask
end subroutine

! GdkWindow * gdk_display_get_window_at_pointer (GdkDisplay *display, gint *win_x, gint *win_y);
function gdk_display_get_window_at_pointer(display, win_x, win_y) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_display_get_window_at_pointer
  type(c_ptr), value :: display
  type(c_ptr), value :: win_x
  type(c_ptr), value :: win_y
end function

! void gdk_display_warp_pointer (GdkDisplay *display, GdkScreen *screen, gint x, gint y);
subroutine gdk_display_warp_pointer(display, screen, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: display
  type(c_ptr), value :: screen
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

!  GdkDisplayPointerHooks *gdk_display_set_pointer_hooks (GdkDisplay *display, const GdkDisplayPointerHooks *new_hooks);
function gdk_display_set_pointer_hooks(display, new_hooks) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_display_set_pointer_hooks
  type(c_ptr), value :: display
  type(c_ptr), value :: new_hooks
end function

!  GdkDisplay *gdk_display_open_default_libgtk_only (void);
function gdk_display_open_default_libgtk_only() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_display_open_default_libgtk_only
end function

!  gboolean gdk_display_supports_cursor_alpha (GdkDisplay *display);
function gdk_display_supports_cursor_alpha(display) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_display_supports_cursor_alpha
  type(c_ptr), value :: display
end function

! gboolean gdk_display_supports_cursor_color (GdkDisplay *display);
function gdk_display_supports_cursor_color(display) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_display_supports_cursor_color
  type(c_ptr), value :: display
end function

! guint gdk_display_get_default_cursor_size (GdkDisplay *display);
function gdk_display_get_default_cursor_size(display) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_display_get_default_cursor_size
  type(c_ptr), value :: display
end function

! void gdk_display_get_maximal_cursor_size (GdkDisplay *display, guint *width, guint *height);
subroutine gdk_display_get_maximal_cursor_size(display, width, height) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: display
  type(c_ptr), value :: width
  type(c_ptr), value :: height
end subroutine

!  GdkWindow *gdk_display_get_default_group (GdkDisplay *display);
function gdk_display_get_default_group(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_display_get_default_group
  type(c_ptr), value :: display
end function

!  gboolean gdk_display_supports_selection_notification (GdkDisplay *display);
function gdk_display_supports_selection_notification(display) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_display_supports_selection_notification
  type(c_ptr), value :: display
end function

! gboolean gdk_display_request_selection_notification (GdkDisplay *display, GdkAtom selection);
function gdk_display_request_selection_notification(display, selection) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_display_request_selection_notification
  type(c_ptr), value :: display
  type(c_ptr), value :: selection
end function

!  gboolean gdk_display_supports_clipboard_persistence (GdkDisplay *display);
function gdk_display_supports_clipboard_persistence(display) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_display_supports_clipboard_persistence
  type(c_ptr), value :: display
end function

! void gdk_display_store_clipboard (GdkDisplay *display, GdkWindow *clipboard_window, guint32 time_, const GdkAtom *targets, gint n_targets);
subroutine gdk_display_store_clipboard(display, clipboard_window, time_, targets&
      &, n_targets) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_int
  type(c_ptr), value :: display
  type(c_ptr), value :: clipboard_window
  integer(c_int32_t), value :: time_
  type(c_ptr), value :: targets
  integer(c_int), value :: n_targets
end subroutine

!  gboolean gdk_display_supports_shapes (GdkDisplay *display);
function gdk_display_supports_shapes(display) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_display_supports_shapes
  type(c_ptr), value :: display
end function

! gboolean gdk_display_supports_input_shapes (GdkDisplay *display);
function gdk_display_supports_input_shapes(display) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_display_supports_input_shapes
  type(c_ptr), value :: display
end function

! gboolean gdk_display_supports_composite (GdkDisplay *display);
function gdk_display_supports_composite(display) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_display_supports_composite
  type(c_ptr), value :: display
end function

!  Display *gdk_x11_drawable_get_xdisplay (GdkDrawable *drawable);
function gdk_x11_drawable_get_xdisplay(drawable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_x11_drawable_get_xdisplay
  type(c_ptr), value :: drawable
end function

! XID gdk_x11_drawable_get_xid (GdkDrawable *drawable);
function gdk_x11_drawable_get_xid(drawable) bind(c) 
  use iso_c_binding, only: c_long, c_ptr
  integer(c_long) :: gdk_x11_drawable_get_xid
  type(c_ptr), value :: drawable
end function

! GdkDrawable *gdk_x11_window_get_drawable_impl (GdkWindow *window);
function gdk_x11_window_get_drawable_impl(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_x11_window_get_drawable_impl
  type(c_ptr), value :: window
end function

! GdkDrawable *gdk_x11_pixmap_get_drawable_impl (GdkPixmap *pixmap);
function gdk_x11_pixmap_get_drawable_impl(pixmap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_x11_pixmap_get_drawable_impl
  type(c_ptr), value :: pixmap
end function

! Display *gdk_x11_image_get_xdisplay (GdkImage *image);
function gdk_x11_image_get_xdisplay(image) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_x11_image_get_xdisplay
  type(c_ptr), value :: image
end function

! XImage *gdk_x11_image_get_ximage (GdkImage *image);
function gdk_x11_image_get_ximage(image) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_x11_image_get_ximage
  type(c_ptr), value :: image
end function

! Display *gdk_x11_colormap_get_xdisplay (GdkColormap *colormap);
function gdk_x11_colormap_get_xdisplay(colormap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_x11_colormap_get_xdisplay
  type(c_ptr), value :: colormap
end function

! Colormap gdk_x11_colormap_get_xcolormap (GdkColormap *colormap);
function gdk_x11_colormap_get_xcolormap(colormap) bind(c) 
  use iso_c_binding, only: c_long, c_ptr
  integer(c_long) :: gdk_x11_colormap_get_xcolormap
  type(c_ptr), value :: colormap
end function

! Display *gdk_x11_cursor_get_xdisplay (GdkCursor *cursor);
function gdk_x11_cursor_get_xdisplay(cursor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_x11_cursor_get_xdisplay
  type(c_ptr), value :: cursor
end function

! Cursor gdk_x11_cursor_get_xcursor (GdkCursor *cursor);
function gdk_x11_cursor_get_xcursor(cursor) bind(c) 
  use iso_c_binding, only: c_long, c_ptr
  integer(c_long) :: gdk_x11_cursor_get_xcursor
  type(c_ptr), value :: cursor
end function

! Display *gdk_x11_display_get_xdisplay (GdkDisplay *display);
function gdk_x11_display_get_xdisplay(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_x11_display_get_xdisplay
  type(c_ptr), value :: display
end function

! Visual * gdk_x11_visual_get_xvisual (GdkVisual *visual);
function gdk_x11_visual_get_xvisual(visual) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_x11_visual_get_xvisual
  type(c_ptr), value :: visual
end function

!  Display *gdk_x11_gc_get_xdisplay (GdkGC *gc);
function gdk_x11_gc_get_xdisplay(gc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_x11_gc_get_xdisplay
  type(c_ptr), value :: gc
end function

! GC gdk_x11_gc_get_xgc (GdkGC *gc);
function gdk_x11_gc_get_xgc(gc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_x11_gc_get_xgc
  type(c_ptr), value :: gc
end function

!  Screen * gdk_x11_screen_get_xscreen (GdkScreen *screen);
function gdk_x11_screen_get_xscreen(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_x11_screen_get_xscreen
  type(c_ptr), value :: screen
end function

! int gdk_x11_screen_get_screen_number (GdkScreen *screen);
function gdk_x11_screen_get_screen_number(screen) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_x11_screen_get_screen_number
  type(c_ptr), value :: screen
end function

! void gdk_x11_window_set_user_time (GdkWindow *window, guint32 timestamp);
subroutine gdk_x11_window_set_user_time(window, timestamp) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: window
  integer(c_int32_t), value :: timestamp
end subroutine

! void gdk_x11_window_move_to_current_desktop (GdkWindow *window);
subroutine gdk_x11_window_move_to_current_desktop(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

!  const char* gdk_x11_screen_get_window_manager_name (GdkScreen *screen);
function gdk_x11_screen_get_window_manager_name(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_x11_screen_get_window_manager_name
  type(c_ptr), value :: screen
end function

!  Window gdk_x11_get_default_root_xwindow (void);
function gdk_x11_get_default_root_xwindow() bind(c) 
  use iso_c_binding, only: c_long
  integer(c_long) :: gdk_x11_get_default_root_xwindow
end function

! Display *gdk_x11_get_default_xdisplay (void);
function gdk_x11_get_default_xdisplay() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_x11_get_default_xdisplay
end function

! gint gdk_x11_get_default_screen (void);
function gdk_x11_get_default_screen() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gdk_x11_get_default_screen
end function

!  GdkVisual* gdk_x11_screen_lookup_visual (GdkScreen *screen, VisualID xvisualid);
function gdk_x11_screen_lookup_visual(screen, xvisualid) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr) :: gdk_x11_screen_lookup_visual
  type(c_ptr), value :: screen
  integer(c_long), value :: xvisualid
end function

!  GdkVisual* gdkx_visual_get (VisualID xvisualid);
function gdkx_visual_get(xvisualid) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr) :: gdkx_visual_get
  integer(c_long), value :: xvisualid
end function

!  GdkColormap* gdkx_colormap_get (Colormap xcolormap);
function gdkx_colormap_get(xcolormap) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr) :: gdkx_colormap_get
  integer(c_long), value :: xcolormap
end function

!  GdkColormap *gdk_x11_colormap_foreign_new (GdkVisual *visual, Colormap xcolormap);
function gdk_x11_colormap_foreign_new(visual, xcolormap) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr) :: gdk_x11_colormap_foreign_new
  type(c_ptr), value :: visual
  integer(c_long), value :: xcolormap
end function

!   gpointer gdk_xid_table_lookup_for_display (GdkDisplay *display, XID xid);
function gdk_xid_table_lookup_for_display(display, xid) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr) :: gdk_xid_table_lookup_for_display
  type(c_ptr), value :: display
  integer(c_long), value :: xid
end function

! guint32 gdk_x11_get_server_time (GdkWindow *window);
function gdk_x11_get_server_time(window) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: gdk_x11_get_server_time
  type(c_ptr), value :: window
end function

! guint32 gdk_x11_display_get_user_time (GdkDisplay *display);
function gdk_x11_display_get_user_time(display) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: gdk_x11_display_get_user_time
  type(c_ptr), value :: display
end function

!  G_CONST_RETURN gchar *gdk_x11_display_get_startup_notification_id (GdkDisplay *display);
function gdk_x11_display_get_startup_notification_id(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_x11_display_get_startup_notification_id
  type(c_ptr), value :: display
end function

!  gboolean gdk_x11_screen_supports_net_wm_hint (GdkScreen *screen, GdkAtom property);
function gdk_x11_screen_supports_net_wm_hint(screen, property) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_x11_screen_supports_net_wm_hint
  type(c_ptr), value :: screen
  type(c_ptr), value :: property
end function

!  XID gdk_x11_screen_get_monitor_output (GdkScreen *screen, gint monitor_num);
function gdk_x11_screen_get_monitor_output(screen, monitor_num) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_int
  integer(c_long) :: gdk_x11_screen_get_monitor_output
  type(c_ptr), value :: screen
  integer(c_int), value :: monitor_num
end function

!  gpointer gdk_xid_table_lookup (XID xid);
function gdk_xid_table_lookup(xid) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr) :: gdk_xid_table_lookup
  integer(c_long), value :: xid
end function

! gboolean gdk_net_wm_supports (GdkAtom property);
function gdk_net_wm_supports(property) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_net_wm_supports
  type(c_ptr), value :: property
end function

! void gdk_x11_grab_server (void);
subroutine gdk_x11_grab_server() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void gdk_x11_ungrab_server (void);
subroutine gdk_x11_ungrab_server() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  GdkDisplay *gdk_x11_lookup_xdisplay (Display *xdisplay);
function gdk_x11_lookup_xdisplay(xdisplay) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_x11_lookup_xdisplay
  type(c_ptr), value :: xdisplay
end function

!  Atom gdk_x11_atom_to_xatom_for_display (GdkDisplay *display, GdkAtom atom);
function gdk_x11_atom_to_xatom_for_display(display, atom) bind(c) 
  use iso_c_binding, only: c_long, c_ptr
  integer(c_long) :: gdk_x11_atom_to_xatom_for_display
  type(c_ptr), value :: display
  type(c_ptr), value :: atom
end function

! GdkAtom gdk_x11_xatom_to_atom_for_display (GdkDisplay *display, Atom xatom);
function gdk_x11_xatom_to_atom_for_display(display, xatom) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr) :: gdk_x11_xatom_to_atom_for_display
  type(c_ptr), value :: display
  integer(c_long), value :: xatom
end function

! Atom gdk_x11_get_xatom_by_name_for_display (GdkDisplay *display, const gchar *atom_name);
function gdk_x11_get_xatom_by_name_for_display(display, atom_name) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_char
  integer(c_long) :: gdk_x11_get_xatom_by_name_for_display
  type(c_ptr), value :: display
  character(kind=c_char), dimension(*) :: atom_name
end function

! G_CONST_RETURN gchar *gdk_x11_get_xatom_name_for_display (GdkDisplay *display, Atom xatom);
function gdk_x11_get_xatom_name_for_display(display, xatom) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr) :: gdk_x11_get_xatom_name_for_display
  type(c_ptr), value :: display
  integer(c_long), value :: xatom
end function

!  Atom gdk_x11_atom_to_xatom (GdkAtom atom);
function gdk_x11_atom_to_xatom(atom) bind(c) 
  use iso_c_binding, only: c_long, c_ptr
  integer(c_long) :: gdk_x11_atom_to_xatom
  type(c_ptr), value :: atom
end function

! GdkAtom gdk_x11_xatom_to_atom (Atom xatom);
function gdk_x11_xatom_to_atom(xatom) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr) :: gdk_x11_xatom_to_atom
  integer(c_long), value :: xatom
end function

! Atom gdk_x11_get_xatom_by_name (const gchar *atom_name);
function gdk_x11_get_xatom_by_name(atom_name) bind(c) 
  use iso_c_binding, only: c_long, c_char
  integer(c_long) :: gdk_x11_get_xatom_by_name
  character(kind=c_char), dimension(*) :: atom_name
end function

! G_CONST_RETURN gchar *gdk_x11_get_xatom_name (Atom xatom);
function gdk_x11_get_xatom_name(xatom) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr) :: gdk_x11_get_xatom_name
  integer(c_long), value :: xatom
end function

!  void gdk_x11_display_grab (GdkDisplay *display);
subroutine gdk_x11_display_grab(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: display
end subroutine

! void gdk_x11_display_ungrab (GdkDisplay *display);
subroutine gdk_x11_display_ungrab(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: display
end subroutine

! void gdk_x11_register_standard_event_type (GdkDisplay *display, gint event_base, gint n_events);
subroutine gdk_x11_register_standard_event_type(display, event_base, n_events) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: display
  integer(c_int), value :: event_base
  integer(c_int), value :: n_events
end subroutine

!  gpointer gdk_x11_font_get_xfont (GdkFont *font);
function gdk_x11_font_get_xfont(font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_x11_font_get_xfont
  type(c_ptr), value :: font
end function

!  Display * gdk_x11_font_get_xdisplay (GdkFont *font);
function gdk_x11_font_get_xdisplay(font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_x11_font_get_xdisplay
  type(c_ptr), value :: font
end function

! G_CONST_RETURN char *gdk_x11_font_get_name (GdkFont *font);
function gdk_x11_font_get_name(font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_x11_font_get_name
  type(c_ptr), value :: font
end function

!     GType gdk_drawable_get_type (void) G_GNUC_CONST;
function gdk_drawable_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_drawable_get_type
end function

!  void gdk_drawable_set_data (GdkDrawable *drawable, const gchar *key, gpointer data, GDestroyNotify destroy_func);
subroutine gdk_drawable_set_data(drawable, key, data, destroy_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr), value :: drawable
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy_func
end subroutine

! gpointer gdk_drawable_get_data (GdkDrawable *drawable, const gchar *key);
function gdk_drawable_get_data(drawable, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_drawable_get_data
  type(c_ptr), value :: drawable
  character(kind=c_char), dimension(*) :: key
end function

!  void gdk_drawable_get_size (GdkDrawable *drawable, gint *width, gint *height);
subroutine gdk_drawable_get_size(drawable, width, height) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: drawable
  type(c_ptr), value :: width
  type(c_ptr), value :: height
end subroutine

! void gdk_drawable_set_colormap (GdkDrawable *drawable, GdkColormap *colormap);
subroutine gdk_drawable_set_colormap(drawable, colormap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: drawable
  type(c_ptr), value :: colormap
end subroutine

! GdkColormap* gdk_drawable_get_colormap (GdkDrawable *drawable);
function gdk_drawable_get_colormap(drawable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_drawable_get_colormap
  type(c_ptr), value :: drawable
end function

! GdkVisual* gdk_drawable_get_visual (GdkDrawable *drawable);
function gdk_drawable_get_visual(drawable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_drawable_get_visual
  type(c_ptr), value :: drawable
end function

! gint gdk_drawable_get_depth (GdkDrawable *drawable);
function gdk_drawable_get_depth(drawable) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_drawable_get_depth
  type(c_ptr), value :: drawable
end function

! GdkScreen* gdk_drawable_get_screen (GdkDrawable *drawable);
function gdk_drawable_get_screen(drawable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_drawable_get_screen
  type(c_ptr), value :: drawable
end function

! GdkDisplay* gdk_drawable_get_display (GdkDrawable *drawable);
function gdk_drawable_get_display(drawable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_drawable_get_display
  type(c_ptr), value :: drawable
end function

!  GdkDrawable* gdk_drawable_ref (GdkDrawable *drawable);
function gdk_drawable_ref(drawable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_drawable_ref
  type(c_ptr), value :: drawable
end function

! void gdk_drawable_unref (GdkDrawable *drawable);
subroutine gdk_drawable_unref(drawable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: drawable
end subroutine

!  void gdk_draw_point (GdkDrawable *drawable, GdkGC *gc, gint x, gint y);
subroutine gdk_draw_point(drawable, gc, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void gdk_draw_line (GdkDrawable *drawable, GdkGC *gc, gint x1_, gint y1_, gint x2_, gint y2_);
subroutine gdk_draw_line(drawable, gc, x1_, y1_, x2_, y2_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  integer(c_int), value :: x1_
  integer(c_int), value :: y1_
  integer(c_int), value :: x2_
  integer(c_int), value :: y2_
end subroutine

! void gdk_draw_rectangle (GdkDrawable *drawable, GdkGC *gc, gboolean filled, gint x, gint y, gint width, gint height);
subroutine gdk_draw_rectangle(drawable, gc, filled, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_int
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  logical(c_bool), value :: filled
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gdk_draw_arc (GdkDrawable *drawable, GdkGC *gc, gboolean filled, gint x, gint y, gint width, gint height, gint angle1, gint angle2);
subroutine gdk_draw_arc(drawable, gc, filled, x, y, width, height, angle1, angle&
      &2) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_int
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  logical(c_bool), value :: filled
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: angle1
  integer(c_int), value :: angle2
end subroutine

! void gdk_draw_polygon (GdkDrawable *drawable, GdkGC *gc, gboolean filled, const GdkPoint *points, gint n_points);
subroutine gdk_draw_polygon(drawable, gc, filled, points, n_points) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_int
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  logical(c_bool), value :: filled
  type(c_ptr), value :: points
  integer(c_int), value :: n_points
end subroutine

! void gdk_draw_string (GdkDrawable *drawable, GdkFont *font, GdkGC *gc, gint x, gint y, const gchar *string);
subroutine gdk_draw_string(drawable, font, gc, x, y, string) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: drawable
  type(c_ptr), value :: font
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
  character(kind=c_char), dimension(*) :: string
end subroutine

! void gdk_draw_text (GdkDrawable *drawable, GdkFont *font, GdkGC *gc, gint x, gint y, const gchar *text, gint text_length);
subroutine gdk_draw_text(drawable, font, gc, x, y, text, text_length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: drawable
  type(c_ptr), value :: font
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: text_length
end subroutine

! void gdk_draw_text_wc (GdkDrawable *drawable, GdkFont *font, GdkGC *gc, gint x, gint y, const GdkWChar *text, gint text_length);
subroutine gdk_draw_text_wc(drawable, font, gc, x, y, text, text_length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: drawable
  type(c_ptr), value :: font
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
  type(c_ptr), value :: text
  integer(c_int), value :: text_length
end subroutine

! void gdk_draw_drawable (GdkDrawable *drawable, GdkGC *gc, GdkDrawable *src, gint xsrc, gint ysrc, gint xdest, gint ydest, gint width, gint height);
subroutine gdk_draw_drawable(drawable, gc, src, xsrc, ysrc, xdest, ydest, width,&
      & height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  type(c_ptr), value :: src
  integer(c_int), value :: xsrc
  integer(c_int), value :: ysrc
  integer(c_int), value :: xdest
  integer(c_int), value :: ydest
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gdk_draw_image (GdkDrawable *drawable, GdkGC *gc, GdkImage *image, gint xsrc, gint ysrc, gint xdest, gint ydest, gint width, gint height);
subroutine gdk_draw_image(drawable, gc, image, xsrc, ysrc, xdest, ydest, width, &
      &height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  type(c_ptr), value :: image
  integer(c_int), value :: xsrc
  integer(c_int), value :: ysrc
  integer(c_int), value :: xdest
  integer(c_int), value :: ydest
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gdk_draw_points (GdkDrawable *drawable, GdkGC *gc, const GdkPoint *points, gint n_points);
subroutine gdk_draw_points(drawable, gc, points, n_points) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  type(c_ptr), value :: points
  integer(c_int), value :: n_points
end subroutine

! void gdk_draw_segments (GdkDrawable *drawable, GdkGC *gc, const GdkSegment *segs, gint n_segs);
subroutine gdk_draw_segments(drawable, gc, segs, n_segs) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  type(c_ptr), value :: segs
  integer(c_int), value :: n_segs
end subroutine

! void gdk_draw_lines (GdkDrawable *drawable, GdkGC *gc, const GdkPoint *points, gint n_points);
subroutine gdk_draw_lines(drawable, gc, points, n_points) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  type(c_ptr), value :: points
  integer(c_int), value :: n_points
end subroutine

! void gdk_draw_pixbuf (GdkDrawable *drawable, GdkGC *gc, const GdkPixbuf *pixbuf, gint src_x, gint src_y, gint dest_x, gint dest_y, gint width, gint height, GdkRgbDither dither, gint x_dither, gint y_dither);
subroutine gdk_draw_pixbuf(drawable, gc, pixbuf, src_x, src_y, dest_x, dest_y, w&
      &idth, height, dither, x_dither, y_dither) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  type(c_ptr), value :: pixbuf
  integer(c_int), value :: src_x
  integer(c_int), value :: src_y
  integer(c_int), value :: dest_x
  integer(c_int), value :: dest_y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: dither
  integer(c_int), value :: x_dither
  integer(c_int), value :: y_dither
end subroutine

!  void gdk_draw_glyphs (GdkDrawable *drawable, GdkGC *gc, PangoFont *font, gint x, gint y, PangoGlyphString *glyphs);
subroutine gdk_draw_glyphs(drawable, gc, font, x, y, glyphs) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  type(c_ptr), value :: font
  integer(c_int), value :: x
  integer(c_int), value :: y
  type(c_ptr), value :: glyphs
end subroutine

! void gdk_draw_layout_line (GdkDrawable *drawable, GdkGC *gc, gint x, gint y, PangoLayoutLine *line);
subroutine gdk_draw_layout_line(drawable, gc, x, y, line) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
  type(c_ptr), value :: line
end subroutine

! void gdk_draw_layout (GdkDrawable *drawable, GdkGC *gc, gint x, gint y, PangoLayout *layout);
subroutine gdk_draw_layout(drawable, gc, x, y, layout) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
  type(c_ptr), value :: layout
end subroutine

!  void gdk_draw_layout_line_with_colors (GdkDrawable *drawable, GdkGC *gc, gint x, gint y, PangoLayoutLine *line, const GdkColor *foreground, const GdkColor *background);
subroutine gdk_draw_layout_line_with_colors(drawable, gc, x, y, line, foreground&
      &, background) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
  type(c_ptr), value :: line
  type(c_ptr), value :: foreground
  type(c_ptr), value :: background
end subroutine

! void gdk_draw_layout_with_colors (GdkDrawable *drawable, GdkGC *gc, gint x, gint y, PangoLayout *layout, const GdkColor *foreground, const GdkColor *background);
subroutine gdk_draw_layout_with_colors(drawable, gc, x, y, layout, foreground, b&
      &ackground) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
  type(c_ptr), value :: layout
  type(c_ptr), value :: foreground
  type(c_ptr), value :: background
end subroutine

!  void gdk_draw_glyphs_transformed (GdkDrawable *drawable, GdkGC *gc, const PangoMatrix *matrix, PangoFont *font, gint x, gint y, PangoGlyphString *glyphs);
subroutine gdk_draw_glyphs_transformed(drawable, gc, matrix, font, x, y, glyphs)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  type(c_ptr), value :: matrix
  type(c_ptr), value :: font
  integer(c_int), value :: x
  integer(c_int), value :: y
  type(c_ptr), value :: glyphs
end subroutine

! void gdk_draw_trapezoids (GdkDrawable *drawable, GdkGC *gc, const GdkTrapezoid *trapezoids, gint n_trapezoids);
subroutine gdk_draw_trapezoids(drawable, gc, trapezoids, n_trapezoids) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  type(c_ptr), value :: trapezoids
  integer(c_int), value :: n_trapezoids
end subroutine

!  GdkImage* gdk_drawable_get_image (GdkDrawable *drawable, gint x, gint y, gint width, gint height);
function gdk_drawable_get_image(drawable, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_drawable_get_image
  type(c_ptr), value :: drawable
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

! GdkImage *gdk_drawable_copy_to_image (GdkDrawable *drawable, GdkImage *image, gint src_x, gint src_y, gint dest_x, gint dest_y, gint width, gint height);
function gdk_drawable_copy_to_image(drawable, image, src_x, src_y, dest_x, dest_&
      &y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_drawable_copy_to_image
  type(c_ptr), value :: drawable
  type(c_ptr), value :: image
  integer(c_int), value :: src_x
  integer(c_int), value :: src_y
  integer(c_int), value :: dest_x
  integer(c_int), value :: dest_y
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

!  GdkRegion *gdk_drawable_get_clip_region (GdkDrawable *drawable);
function gdk_drawable_get_clip_region(drawable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_drawable_get_clip_region
  type(c_ptr), value :: drawable
end function

! GdkRegion *gdk_drawable_get_visible_region (GdkDrawable *drawable);
function gdk_drawable_get_visible_region(drawable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_drawable_get_visible_region
  type(c_ptr), value :: drawable
end function

!   GType gdk_font_get_type (void) G_GNUC_CONST;
function gdk_font_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_font_get_type
end function

!  GdkFont* gdk_font_ref (GdkFont *font);
function gdk_font_ref(font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_font_ref
  type(c_ptr), value :: font
end function

! void gdk_font_unref (GdkFont *font);
subroutine gdk_font_unref(font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: font
end subroutine

! gint gdk_font_id (const GdkFont *font);
function gdk_font_id(font) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_font_id
  type(c_ptr), value :: font
end function

! gboolean gdk_font_equal (const GdkFont *fonta, const GdkFont *fontb);
function gdk_font_equal(fonta, fontb) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_font_equal
  type(c_ptr), value :: fonta
  type(c_ptr), value :: fontb
end function

!  GdkFont *gdk_font_load_for_display (GdkDisplay *display, const gchar *font_name);
function gdk_font_load_for_display(display, font_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_font_load_for_display
  type(c_ptr), value :: display
  character(kind=c_char), dimension(*) :: font_name
end function

! GdkFont *gdk_fontset_load_for_display (GdkDisplay *display, const gchar *fontset_name);
function gdk_fontset_load_for_display(display, fontset_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_fontset_load_for_display
  type(c_ptr), value :: display
  character(kind=c_char), dimension(*) :: fontset_name
end function

! GdkFont *gdk_font_from_description_for_display (GdkDisplay *display, PangoFontDescription *font_desc);
function gdk_font_from_description_for_display(display, font_desc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_font_from_description_for_display
  type(c_ptr), value :: display
  type(c_ptr), value :: font_desc
end function

!  GdkFont* gdk_font_load (const gchar *font_name);
function gdk_font_load(font_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_font_load
  character(kind=c_char), dimension(*) :: font_name
end function

! GdkFont* gdk_fontset_load (const gchar *fontset_name);
function gdk_fontset_load(fontset_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_fontset_load
  character(kind=c_char), dimension(*) :: fontset_name
end function

! GdkFont* gdk_font_from_description (PangoFontDescription *font_desc);
function gdk_font_from_description(font_desc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_font_from_description
  type(c_ptr), value :: font_desc
end function

!  gint gdk_string_width (GdkFont *font, const gchar *string);
function gdk_string_width(font, string) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gdk_string_width
  type(c_ptr), value :: font
  character(kind=c_char), dimension(*) :: string
end function

! gint gdk_text_width (GdkFont *font, const gchar *text, gint text_length);
function gdk_text_width(font, text, text_length) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gdk_text_width
  type(c_ptr), value :: font
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: text_length
end function

! gint gdk_text_width_wc (GdkFont *font, const GdkWChar *text, gint text_length);
function gdk_text_width_wc(font, text, text_length) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_text_width_wc
  type(c_ptr), value :: font
  type(c_ptr), value :: text
  integer(c_int), value :: text_length
end function

! gint gdk_char_width (GdkFont *font, gchar character);
function gdk_char_width(font, character) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gdk_char_width
  type(c_ptr), value :: font
  character(c_char), value :: character
end function

! gint gdk_char_width_wc (GdkFont *font, GdkWChar character);
function gdk_char_width_wc(font, character) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int32_t
  integer(c_int) :: gdk_char_width_wc
  type(c_ptr), value :: font
  integer(c_int32_t), value :: character
end function

! gint gdk_string_measure (GdkFont *font, const gchar *string);
function gdk_string_measure(font, string) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gdk_string_measure
  type(c_ptr), value :: font
  character(kind=c_char), dimension(*) :: string
end function

! gint gdk_text_measure (GdkFont *font, const gchar *text, gint text_length);
function gdk_text_measure(font, text, text_length) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gdk_text_measure
  type(c_ptr), value :: font
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: text_length
end function

! gint gdk_char_measure (GdkFont *font, gchar character);
function gdk_char_measure(font, character) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gdk_char_measure
  type(c_ptr), value :: font
  character(c_char), value :: character
end function

! gint gdk_string_height (GdkFont *font, const gchar *string);
function gdk_string_height(font, string) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gdk_string_height
  type(c_ptr), value :: font
  character(kind=c_char), dimension(*) :: string
end function

! gint gdk_text_height (GdkFont *font, const gchar *text, gint text_length);
function gdk_text_height(font, text, text_length) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gdk_text_height
  type(c_ptr), value :: font
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: text_length
end function

! gint gdk_char_height (GdkFont *font, gchar character);
function gdk_char_height(font, character) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gdk_char_height
  type(c_ptr), value :: font
  character(c_char), value :: character
end function

!  void gdk_text_extents (GdkFont *font, const gchar *text, gint text_length, gint *lbearing, gint *rbearing, gint *width, gint *ascent, gint *descent);
subroutine gdk_text_extents(font, text, text_length, lbearing, rbearing, width, &
      &ascent, descent) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: font
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: text_length
  type(c_ptr), value :: lbearing
  type(c_ptr), value :: rbearing
  type(c_ptr), value :: width
  type(c_ptr), value :: ascent
  type(c_ptr), value :: descent
end subroutine

! void gdk_text_extents_wc (GdkFont *font, const GdkWChar *text, gint text_length, gint *lbearing, gint *rbearing, gint *width, gint *ascent, gint *descent);
subroutine gdk_text_extents_wc(font, text, text_length, lbearing, rbearing, widt&
      &h, ascent, descent) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: font
  type(c_ptr), value :: text
  integer(c_int), value :: text_length
  type(c_ptr), value :: lbearing
  type(c_ptr), value :: rbearing
  type(c_ptr), value :: width
  type(c_ptr), value :: ascent
  type(c_ptr), value :: descent
end subroutine

! void gdk_string_extents (GdkFont *font, const gchar *string, gint *lbearing, gint *rbearing, gint *width, gint *ascent, gint *descent);
subroutine gdk_string_extents(font, string, lbearing, rbearing, width, ascent, d&
      &escent) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: font
  character(kind=c_char), dimension(*) :: string
  type(c_ptr), value :: lbearing
  type(c_ptr), value :: rbearing
  type(c_ptr), value :: width
  type(c_ptr), value :: ascent
  type(c_ptr), value :: descent
end subroutine

!  GdkDisplay * gdk_font_get_display (GdkFont *font);
function gdk_font_get_display(font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_font_get_display
  type(c_ptr), value :: font
end function

!   void gdk_rgb_init (void);
subroutine gdk_rgb_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  gulong gdk_rgb_xpixel_from_rgb (guint32 rgb) G_GNUC_CONST;
function gdk_rgb_xpixel_from_rgb(rgb) bind(c) 
  use iso_c_binding, only: c_long, c_int32_t
  integer(c_long) :: gdk_rgb_xpixel_from_rgb
  integer(c_int32_t), value :: rgb
end function

! void gdk_rgb_gc_set_foreground (GdkGC *gc, guint32 rgb);
subroutine gdk_rgb_gc_set_foreground(gc, rgb) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: gc
  integer(c_int32_t), value :: rgb
end subroutine

! void gdk_rgb_gc_set_background (GdkGC *gc, guint32 rgb);
subroutine gdk_rgb_gc_set_background(gc, rgb) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: gc
  integer(c_int32_t), value :: rgb
end subroutine

!  void gdk_rgb_find_color (GdkColormap *colormap, GdkColor *color);
subroutine gdk_rgb_find_color(colormap, color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: colormap
  type(c_ptr), value :: color
end subroutine

!  void gdk_draw_rgb_image (GdkDrawable *drawable, GdkGC *gc, gint x, gint y, gint width, gint height, GdkRgbDither dith, const guchar *rgb_buf, gint rowstride);
subroutine gdk_draw_rgb_image(drawable, gc, x, y, width, height, dith, rgb_buf, &
      &rowstride) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: dith
  character(kind=c_char), dimension(*) :: rgb_buf
  integer(c_int), value :: rowstride
end subroutine

! void gdk_draw_rgb_image_dithalign (GdkDrawable *drawable, GdkGC *gc, gint x, gint y, gint width, gint height, GdkRgbDither dith, const guchar *rgb_buf, gint rowstride, gint xdith, gint ydith);
subroutine gdk_draw_rgb_image_dithalign(drawable, gc, x, y, width, height, dith,&
      & rgb_buf, rowstride, xdith, ydith) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: dith
  character(kind=c_char), dimension(*) :: rgb_buf
  integer(c_int), value :: rowstride
  integer(c_int), value :: xdith
  integer(c_int), value :: ydith
end subroutine

! void gdk_draw_rgb_32_image (GdkDrawable *drawable, GdkGC *gc, gint x, gint y, gint width, gint height, GdkRgbDither dith, const guchar *buf, gint rowstride);
subroutine gdk_draw_rgb_32_image(drawable, gc, x, y, width, height, dith, buf, r&
      &owstride) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: dith
  character(kind=c_char), dimension(*) :: buf
  integer(c_int), value :: rowstride
end subroutine

! void gdk_draw_rgb_32_image_dithalign (GdkDrawable *drawable, GdkGC *gc, gint x, gint y, gint width, gint height, GdkRgbDither dith, const guchar *buf, gint rowstride, gint xdith, gint ydith);
subroutine gdk_draw_rgb_32_image_dithalign(drawable, gc, x, y, width, height, di&
      &th, buf, rowstride, xdith, ydith) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: dith
  character(kind=c_char), dimension(*) :: buf
  integer(c_int), value :: rowstride
  integer(c_int), value :: xdith
  integer(c_int), value :: ydith
end subroutine

! void gdk_draw_gray_image (GdkDrawable *drawable, GdkGC *gc, gint x, gint y, gint width, gint height, GdkRgbDither dith, const guchar *buf, gint rowstride);
subroutine gdk_draw_gray_image(drawable, gc, x, y, width, height, dith, buf, row&
      &stride) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: dith
  character(kind=c_char), dimension(*) :: buf
  integer(c_int), value :: rowstride
end subroutine

! void gdk_draw_indexed_image (GdkDrawable *drawable, GdkGC *gc, gint x, gint y, gint width, gint height, GdkRgbDither dith, const guchar *buf, gint rowstride, GdkRgbCmap *cmap);
subroutine gdk_draw_indexed_image(drawable, gc, x, y, width, height, dith, buf, &
      &rowstride, cmap) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: dith
  character(kind=c_char), dimension(*) :: buf
  integer(c_int), value :: rowstride
  type(c_ptr), value :: cmap
end subroutine

! GdkRgbCmap *gdk_rgb_cmap_new (guint32 *colors, gint n_colors);
function gdk_rgb_cmap_new(colors, n_colors) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_rgb_cmap_new
  type(c_ptr), value :: colors
  integer(c_int), value :: n_colors
end function

! void gdk_rgb_cmap_free (GdkRgbCmap *cmap);
subroutine gdk_rgb_cmap_free(cmap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cmap
end subroutine

!  void gdk_rgb_set_verbose (gboolean verbose);
subroutine gdk_rgb_set_verbose(verbose) bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool), value :: verbose
end subroutine

!  void gdk_rgb_set_install (gboolean install);
subroutine gdk_rgb_set_install(install) bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool), value :: install
end subroutine

! void gdk_rgb_set_min_colors (gint min_colors);
subroutine gdk_rgb_set_min_colors(min_colors) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: min_colors
end subroutine

!  GdkColormap *gdk_rgb_get_colormap (void);
function gdk_rgb_get_colormap() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_rgb_get_colormap
end function

! GdkVisual * gdk_rgb_get_visual (void);
function gdk_rgb_get_visual() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_rgb_get_visual
end function

! gboolean gdk_rgb_ditherable (void);
function gdk_rgb_ditherable() bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool) :: gdk_rgb_ditherable
end function

! gboolean gdk_rgb_colormap_ditherable (GdkColormap *cmap);
function gdk_rgb_colormap_ditherable(cmap) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_rgb_colormap_ditherable
  type(c_ptr), value :: cmap
end function

!   GdkAtom gdk_atom_intern (const gchar *atom_name, gboolean only_if_exists);
function gdk_atom_intern(atom_name, only_if_exists) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_bool
  type(c_ptr) :: gdk_atom_intern
  character(kind=c_char), dimension(*) :: atom_name
  logical(c_bool), value :: only_if_exists
end function

! GdkAtom gdk_atom_intern_static_string (const gchar *atom_name);
function gdk_atom_intern_static_string(atom_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_atom_intern_static_string
  character(kind=c_char), dimension(*) :: atom_name
end function

! gchar* gdk_atom_name (GdkAtom atom);
function gdk_atom_name(atom) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_atom_name
  type(c_ptr), value :: atom
end function

!  gboolean gdk_property_get (GdkWindow *window, GdkAtom property, GdkAtom type, gulong offset, gulong length, gint pdelete, GdkAtom *actual_property_type, gint *actual_format, gint *actual_length, guchar **data);
function gdk_property_get(window, property, type, offset, length, pdelete, actua&
      &l_property_type, actual_format, actual_length, data) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_long, c_int, c_char
  logical(c_bool) :: gdk_property_get
  type(c_ptr), value :: window
  type(c_ptr), value :: property
  type(c_ptr), value :: type
  integer(c_long), value :: offset
  integer(c_long), value :: length
  integer(c_int), value :: pdelete
  type(c_ptr), value :: actual_property_type
  type(c_ptr), value :: actual_format
  type(c_ptr), value :: actual_length
  character(kind=c_char), dimension(*) :: data
end function

! void gdk_property_change (GdkWindow *window, GdkAtom property, GdkAtom type, gint format, GdkPropMode mode, const guchar *data, gint nelements);
subroutine gdk_property_change(window, property, type, format, mode, data, nelem&
      &ents) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: window
  type(c_ptr), value :: property
  type(c_ptr), value :: type
  integer(c_int), value :: format
  integer(c_int), value :: mode
  character(kind=c_char), dimension(*) :: data
  integer(c_int), value :: nelements
end subroutine

! void gdk_property_delete (GdkWindow *window, GdkAtom property);
subroutine gdk_property_delete(window, property) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: property
end subroutine

!  gint gdk_text_property_to_text_list (GdkAtom encoding, gint format, const guchar *text, gint length, gchar ***list);
function gdk_text_property_to_text_list(encoding, format, text, length, list) bi&
      &nd(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gdk_text_property_to_text_list
  type(c_ptr), value :: encoding
  integer(c_int), value :: format
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: length
  character(kind=c_char), dimension(*) :: list
end function

! gint gdk_text_property_to_utf8_list (GdkAtom encoding, gint format, const guchar *text, gint length, gchar ***list);
function gdk_text_property_to_utf8_list(encoding, format, text, length, list) bi&
      &nd(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gdk_text_property_to_utf8_list
  type(c_ptr), value :: encoding
  integer(c_int), value :: format
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: length
  character(kind=c_char), dimension(*) :: list
end function

! gboolean gdk_utf8_to_compound_text (const gchar *str, GdkAtom *encoding, gint *format, guchar **ctext, gint *length);
function gdk_utf8_to_compound_text(str, encoding, format, ctext, length) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_ptr
  logical(c_bool) :: gdk_utf8_to_compound_text
  character(kind=c_char), dimension(*) :: str
  type(c_ptr), value :: encoding
  type(c_ptr), value :: format
  character(kind=c_char), dimension(*) :: ctext
  type(c_ptr), value :: length
end function

! gint gdk_string_to_compound_text (const gchar *str, GdkAtom *encoding, gint *format, guchar **ctext, gint *length);
function gdk_string_to_compound_text(str, encoding, format, ctext, length) bind(&
      &c) 
  use iso_c_binding, only: c_int, c_char, c_ptr
  integer(c_int) :: gdk_string_to_compound_text
  character(kind=c_char), dimension(*) :: str
  type(c_ptr), value :: encoding
  type(c_ptr), value :: format
  character(kind=c_char), dimension(*) :: ctext
  type(c_ptr), value :: length
end function

!  gint gdk_text_property_to_text_list_for_display (GdkDisplay *display, GdkAtom encoding, gint format, const guchar *text, gint length, gchar ***list);
function gdk_text_property_to_text_list_for_display(display, encoding, format, t&
      &ext, length, list) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gdk_text_property_to_text_list_for_display
  type(c_ptr), value :: display
  type(c_ptr), value :: encoding
  integer(c_int), value :: format
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: length
  character(kind=c_char), dimension(*) :: list
end function

! gint gdk_text_property_to_utf8_list_for_display (GdkDisplay *display, GdkAtom encoding, gint format, const guchar *text, gint length, gchar ***list);
function gdk_text_property_to_utf8_list_for_display(display, encoding, format, t&
      &ext, length, list) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gdk_text_property_to_utf8_list_for_display
  type(c_ptr), value :: display
  type(c_ptr), value :: encoding
  integer(c_int), value :: format
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: length
  character(kind=c_char), dimension(*) :: list
end function

!  gchar *gdk_utf8_to_string_target (const gchar *str);
function gdk_utf8_to_string_target(str) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_utf8_to_string_target
  character(kind=c_char), dimension(*) :: str
end function

! gint gdk_string_to_compound_text_for_display (GdkDisplay *display, const gchar *str, GdkAtom *encoding, gint *format, guchar **ctext, gint *length);
function gdk_string_to_compound_text_for_display(display, str, encoding, format,&
      & ctext, length) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gdk_string_to_compound_text_for_display
  type(c_ptr), value :: display
  character(kind=c_char), dimension(*) :: str
  type(c_ptr), value :: encoding
  type(c_ptr), value :: format
  character(kind=c_char), dimension(*) :: ctext
  type(c_ptr), value :: length
end function

! gboolean gdk_utf8_to_compound_text_for_display (GdkDisplay *display, const gchar *str, GdkAtom *encoding, gint *format, guchar **ctext, gint *length);
function gdk_utf8_to_compound_text_for_display(display, str, encoding, format, c&
      &text, length) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gdk_utf8_to_compound_text_for_display
  type(c_ptr), value :: display
  character(kind=c_char), dimension(*) :: str
  type(c_ptr), value :: encoding
  type(c_ptr), value :: format
  character(kind=c_char), dimension(*) :: ctext
  type(c_ptr), value :: length
end function

!  void gdk_free_text_list (gchar **list);
subroutine gdk_free_text_list(list) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: list
end subroutine

! void gdk_free_compound_text (guchar *ctext);
subroutine gdk_free_compound_text(ctext) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: ctext
end subroutine

!   cairo_t *gdk_cairo_create (GdkDrawable *drawable);
function gdk_cairo_create(drawable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_cairo_create
  type(c_ptr), value :: drawable
end function

! void gdk_cairo_reset_clip (cairo_t *cr, GdkDrawable *drawable);
subroutine gdk_cairo_reset_clip(cr, drawable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: drawable
end subroutine

!  void gdk_cairo_set_source_color (cairo_t *cr, const GdkColor *color);
subroutine gdk_cairo_set_source_color(cr, color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: color
end subroutine

! void gdk_cairo_set_source_pixbuf (cairo_t *cr, const GdkPixbuf *pixbuf, double pixbuf_x, double pixbuf_y);
subroutine gdk_cairo_set_source_pixbuf(cr, pixbuf, pixbuf_x, pixbuf_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  type(c_ptr), value :: pixbuf
  real(c_double), value :: pixbuf_x
  real(c_double), value :: pixbuf_y
end subroutine

! void gdk_cairo_set_source_pixmap (cairo_t *cr, GdkPixmap *pixmap, double pixmap_x, double pixmap_y);
subroutine gdk_cairo_set_source_pixmap(cr, pixmap, pixmap_x, pixmap_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  type(c_ptr), value :: pixmap
  real(c_double), value :: pixmap_x
  real(c_double), value :: pixmap_y
end subroutine

!  void gdk_cairo_rectangle (cairo_t *cr, const GdkRectangle *rectangle);
subroutine gdk_cairo_rectangle(cr, rectangle) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: rectangle
end subroutine

! void gdk_cairo_region (cairo_t *cr, const GdkRegion *region);
subroutine gdk_cairo_region(cr, region) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: region
end subroutine

!   GType gdk_colormap_get_type (void) G_GNUC_CONST;
function gdk_colormap_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_colormap_get_type
end function

!  GdkColormap* gdk_colormap_new (GdkVisual *visual, gboolean allocate);
function gdk_colormap_new(visual, allocate) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: gdk_colormap_new
  type(c_ptr), value :: visual
  logical(c_bool), value :: allocate
end function

!  GdkColormap* gdk_colormap_ref (GdkColormap *cmap);
function gdk_colormap_ref(cmap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_colormap_ref
  type(c_ptr), value :: cmap
end function

! void gdk_colormap_unref (GdkColormap *cmap);
subroutine gdk_colormap_unref(cmap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cmap
end subroutine

!  GdkColormap* gdk_colormap_get_system (void);
function gdk_colormap_get_system() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_colormap_get_system
end function

!  GdkScreen *gdk_colormap_get_screen (GdkColormap *cmap);
function gdk_colormap_get_screen(cmap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_colormap_get_screen
  type(c_ptr), value :: cmap
end function

!  gint gdk_colormap_get_system_size (void);
function gdk_colormap_get_system_size() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gdk_colormap_get_system_size
end function

!  void gdk_colormap_change (GdkColormap *colormap, gint ncolors);
subroutine gdk_colormap_change(colormap, ncolors) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: colormap
  integer(c_int), value :: ncolors
end subroutine

!  gint gdk_colormap_alloc_colors (GdkColormap *colormap, GdkColor *colors, gint n_colors, gboolean writeable, gboolean best_match, gboolean *success);
function gdk_colormap_alloc_colors(colormap, colors, n_colors, writeable, best_m&
      &atch, success) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_bool
  integer(c_int) :: gdk_colormap_alloc_colors
  type(c_ptr), value :: colormap
  type(c_ptr), value :: colors
  integer(c_int), value :: n_colors
  logical(c_bool), value :: writeable
  logical(c_bool), value :: best_match
  type(c_ptr), value :: success
end function

! gboolean gdk_colormap_alloc_color (GdkColormap *colormap, GdkColor *color, gboolean writeable, gboolean best_match);
function gdk_colormap_alloc_color(colormap, color, writeable, best_match) bind(c&
      &) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_colormap_alloc_color
  type(c_ptr), value :: colormap
  type(c_ptr), value :: color
  logical(c_bool), value :: writeable
  logical(c_bool), value :: best_match
end function

! void gdk_colormap_free_colors (GdkColormap *colormap, const GdkColor *colors, gint n_colors);
subroutine gdk_colormap_free_colors(colormap, colors, n_colors) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: colormap
  type(c_ptr), value :: colors
  integer(c_int), value :: n_colors
end subroutine

! void gdk_colormap_query_color (GdkColormap *colormap, gulong pixel, GdkColor *result);
subroutine gdk_colormap_query_color(colormap, pixel, result) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr), value :: colormap
  integer(c_long), value :: pixel
  type(c_ptr), value :: result
end subroutine

!  GdkVisual *gdk_colormap_get_visual (GdkColormap *colormap);
function gdk_colormap_get_visual(colormap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_colormap_get_visual
  type(c_ptr), value :: colormap
end function

!  GdkColor *gdk_color_copy (const GdkColor *color);
function gdk_color_copy(color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_color_copy
  type(c_ptr), value :: color
end function

! void gdk_color_free (GdkColor *color);
subroutine gdk_color_free(color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: color
end subroutine

! gboolean gdk_color_parse (const gchar *spec, GdkColor *color);
function gdk_color_parse(spec, color) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_ptr
  logical(c_bool) :: gdk_color_parse
  character(kind=c_char), dimension(*) :: spec
  type(c_ptr), value :: color
end function

! guint gdk_color_hash (const GdkColor *colora);
function gdk_color_hash(colora) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_color_hash
  type(c_ptr), value :: colora
end function

! gboolean gdk_color_equal (const GdkColor *colora, const GdkColor *colorb);
function gdk_color_equal(colora, colorb) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_color_equal
  type(c_ptr), value :: colora
  type(c_ptr), value :: colorb
end function

! gchar * gdk_color_to_string (const GdkColor *color);
function gdk_color_to_string(color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_color_to_string
  type(c_ptr), value :: color
end function

!  GType gdk_color_get_type (void) G_GNUC_CONST;
function gdk_color_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_color_get_type
end function

!  void gdk_colors_store (GdkColormap *colormap, GdkColor *colors, gint ncolors);
subroutine gdk_colors_store(colormap, colors, ncolors) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: colormap
  type(c_ptr), value :: colors
  integer(c_int), value :: ncolors
end subroutine

! gint gdk_color_white (GdkColormap *colormap, GdkColor *color);
function gdk_color_white(colormap, color) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_color_white
  type(c_ptr), value :: colormap
  type(c_ptr), value :: color
end function

! gint gdk_color_black (GdkColormap *colormap, GdkColor *color);
function gdk_color_black(colormap, color) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_color_black
  type(c_ptr), value :: colormap
  type(c_ptr), value :: color
end function

! gint gdk_color_alloc (GdkColormap *colormap, GdkColor *color);
function gdk_color_alloc(colormap, color) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_color_alloc
  type(c_ptr), value :: colormap
  type(c_ptr), value :: color
end function

! gint gdk_color_change (GdkColormap *colormap, GdkColor *color);
function gdk_color_change(colormap, color) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_color_change
  type(c_ptr), value :: colormap
  type(c_ptr), value :: color
end function

!  gint gdk_colors_alloc (GdkColormap *colormap, gboolean contiguous, gulong *planes, gint nplanes, gulong *pixels, gint npixels);
function gdk_colors_alloc(colormap, contiguous, planes, nplanes, pixels, npixels&
      &) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_bool
  integer(c_int) :: gdk_colors_alloc
  type(c_ptr), value :: colormap
  logical(c_bool), value :: contiguous
  type(c_ptr), value :: planes
  integer(c_int), value :: nplanes
  type(c_ptr), value :: pixels
  integer(c_int), value :: npixels
end function

! void gdk_colors_free (GdkColormap *colormap, gulong *pixels, gint npixels, gulong planes);
subroutine gdk_colors_free(colormap, pixels, npixels, planes) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_long
  type(c_ptr), value :: colormap
  type(c_ptr), value :: pixels
  integer(c_int), value :: npixels
  integer(c_long), value :: planes
end subroutine

!   GType gdk_screen_get_type (void) G_GNUC_CONST;
function gdk_screen_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_screen_get_type
end function

! GdkColormap *gdk_screen_get_default_colormap (GdkScreen *screen);
function gdk_screen_get_default_colormap(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_screen_get_default_colormap
  type(c_ptr), value :: screen
end function

! void gdk_screen_set_default_colormap (GdkScreen *screen, GdkColormap *colormap);
subroutine gdk_screen_set_default_colormap(screen, colormap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: screen
  type(c_ptr), value :: colormap
end subroutine

! GdkColormap* gdk_screen_get_system_colormap (GdkScreen *screen);
function gdk_screen_get_system_colormap(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_screen_get_system_colormap
  type(c_ptr), value :: screen
end function

! GdkVisual* gdk_screen_get_system_visual (GdkScreen *screen);
function gdk_screen_get_system_visual(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_screen_get_system_visual
  type(c_ptr), value :: screen
end function

! GdkColormap *gdk_screen_get_rgb_colormap (GdkScreen *screen);
function gdk_screen_get_rgb_colormap(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_screen_get_rgb_colormap
  type(c_ptr), value :: screen
end function

! GdkVisual * gdk_screen_get_rgb_visual (GdkScreen *screen);
function gdk_screen_get_rgb_visual(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_screen_get_rgb_visual
  type(c_ptr), value :: screen
end function

! GdkColormap *gdk_screen_get_rgba_colormap (GdkScreen *screen);
function gdk_screen_get_rgba_colormap(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_screen_get_rgba_colormap
  type(c_ptr), value :: screen
end function

! GdkVisual * gdk_screen_get_rgba_visual (GdkScreen *screen);
function gdk_screen_get_rgba_visual(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_screen_get_rgba_visual
  type(c_ptr), value :: screen
end function

! gboolean gdk_screen_is_composited (GdkScreen *screen);
function gdk_screen_is_composited(screen) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_screen_is_composited
  type(c_ptr), value :: screen
end function

!  GdkWindow * gdk_screen_get_root_window (GdkScreen *screen);
function gdk_screen_get_root_window(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_screen_get_root_window
  type(c_ptr), value :: screen
end function

! GdkDisplay * gdk_screen_get_display (GdkScreen *screen);
function gdk_screen_get_display(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_screen_get_display
  type(c_ptr), value :: screen
end function

! gint gdk_screen_get_number (GdkScreen *screen);
function gdk_screen_get_number(screen) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_screen_get_number
  type(c_ptr), value :: screen
end function

! gint gdk_screen_get_width (GdkScreen *screen);
function gdk_screen_get_width(screen) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_screen_get_width
  type(c_ptr), value :: screen
end function

! gint gdk_screen_get_height (GdkScreen *screen);
function gdk_screen_get_height(screen) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_screen_get_height
  type(c_ptr), value :: screen
end function

! gint gdk_screen_get_width_mm (GdkScreen *screen);
function gdk_screen_get_width_mm(screen) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_screen_get_width_mm
  type(c_ptr), value :: screen
end function

! gint gdk_screen_get_height_mm (GdkScreen *screen);
function gdk_screen_get_height_mm(screen) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_screen_get_height_mm
  type(c_ptr), value :: screen
end function

!  GList * gdk_screen_list_visuals (GdkScreen *screen);
function gdk_screen_list_visuals(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_screen_list_visuals
  type(c_ptr), value :: screen
end function

! GList * gdk_screen_get_toplevel_windows (GdkScreen *screen);
function gdk_screen_get_toplevel_windows(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_screen_get_toplevel_windows
  type(c_ptr), value :: screen
end function

! gchar * gdk_screen_make_display_name (GdkScreen *screen);
function gdk_screen_make_display_name(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_screen_make_display_name
  type(c_ptr), value :: screen
end function

!  gint gdk_screen_get_n_monitors (GdkScreen *screen);
function gdk_screen_get_n_monitors(screen) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_screen_get_n_monitors
  type(c_ptr), value :: screen
end function

! gint gdk_screen_get_primary_monitor (GdkScreen *screen);
function gdk_screen_get_primary_monitor(screen) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_screen_get_primary_monitor
  type(c_ptr), value :: screen
end function

! void gdk_screen_get_monitor_geometry (GdkScreen *screen, gint monitor_num, GdkRectangle *dest);
subroutine gdk_screen_get_monitor_geometry(screen, monitor_num, dest) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: screen
  integer(c_int), value :: monitor_num
  type(c_ptr), value :: dest
end subroutine

! gint gdk_screen_get_monitor_at_point (GdkScreen *screen, gint x, gint y);
function gdk_screen_get_monitor_at_point(screen, x, y) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_screen_get_monitor_at_point
  type(c_ptr), value :: screen
  integer(c_int), value :: x
  integer(c_int), value :: y
end function

! gint gdk_screen_get_monitor_at_window (GdkScreen *screen, GdkWindow *window);
function gdk_screen_get_monitor_at_window(screen, window) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_screen_get_monitor_at_window
  type(c_ptr), value :: screen
  type(c_ptr), value :: window
end function

! gint gdk_screen_get_monitor_width_mm (GdkScreen *screen, gint monitor_num);
function gdk_screen_get_monitor_width_mm(screen, monitor_num) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_screen_get_monitor_width_mm
  type(c_ptr), value :: screen
  integer(c_int), value :: monitor_num
end function

! gint gdk_screen_get_monitor_height_mm (GdkScreen *screen, gint monitor_num);
function gdk_screen_get_monitor_height_mm(screen, monitor_num) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_screen_get_monitor_height_mm
  type(c_ptr), value :: screen
  integer(c_int), value :: monitor_num
end function

! gchar * gdk_screen_get_monitor_plug_name (GdkScreen *screen, gint monitor_num);
function gdk_screen_get_monitor_plug_name(screen, monitor_num) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_screen_get_monitor_plug_name
  type(c_ptr), value :: screen
  integer(c_int), value :: monitor_num
end function

!  void gdk_screen_broadcast_client_message (GdkScreen *screen, GdkEvent *event);
subroutine gdk_screen_broadcast_client_message(screen, event) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: screen
  type(c_ptr), value :: event
end subroutine

!  GdkScreen *gdk_screen_get_default (void);
function gdk_screen_get_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_screen_get_default
end function

!  gboolean gdk_screen_get_setting (GdkScreen *screen, const gchar *name, GValue *value);
function gdk_screen_get_setting(screen, name, value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gdk_screen_get_setting
  type(c_ptr), value :: screen
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: value
end function

!  void gdk_screen_set_font_options (GdkScreen *screen, const cairo_font_options_t *options);
subroutine gdk_screen_set_font_options(screen, options) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: screen
  type(c_ptr), value :: options
end subroutine

! const cairo_font_options_t *gdk_screen_get_font_options (GdkScreen *screen);
function gdk_screen_get_font_options(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_screen_get_font_options
  type(c_ptr), value :: screen
end function

!  void gdk_screen_set_resolution (GdkScreen *screen, gdouble dpi);
subroutine gdk_screen_set_resolution(screen, dpi) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: screen
  real(c_double), value :: dpi
end subroutine

! gdouble gdk_screen_get_resolution (GdkScreen *screen);
function gdk_screen_get_resolution(screen) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gdk_screen_get_resolution
  type(c_ptr), value :: screen
end function

!  GdkWindow *gdk_screen_get_active_window (GdkScreen *screen);
function gdk_screen_get_active_window(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_screen_get_active_window
  type(c_ptr), value :: screen
end function

! GList *gdk_screen_get_window_stack (GdkScreen *screen);
function gdk_screen_get_window_stack(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_screen_get_window_stack
  type(c_ptr), value :: screen
end function

!   void gdk_test_render_sync (GdkWindow *window);
subroutine gdk_test_render_sync(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! gboolean gdk_test_simulate_key (GdkWindow *window, gint x, gint y, guint keyval, GdkModifierType modifiers, GdkEventType key_pressrelease);
function gdk_test_simulate_key(window, x, y, keyval, modifiers, key_pressrelease&
      &) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gdk_test_simulate_key
  type(c_ptr), value :: window
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: keyval
  integer(c_int), value :: modifiers
  integer(c_int), value :: key_pressrelease
end function

! gboolean gdk_test_simulate_button (GdkWindow *window, gint x, gint y, guint button, GdkModifierType modifiers, GdkEventType button_pressrelease);
function gdk_test_simulate_button(window, x, y, button, modifiers, button_pressr&
      &elease) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gdk_test_simulate_button
  type(c_ptr), value :: window
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: button
  integer(c_int), value :: modifiers
  integer(c_int), value :: button_pressrelease
end function

!   GdkRegion * gdk_region_new (void);
function gdk_region_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_region_new
end function

!  GdkRegion * gdk_region_polygon (const GdkPoint *points, gint n_points, GdkFillRule fill_rule);
function gdk_region_polygon(points, n_points, fill_rule) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_region_polygon
  type(c_ptr), value :: points
  integer(c_int), value :: n_points
  integer(c_int), value :: fill_rule
end function

!  GdkRegion * gdk_region_copy (const GdkRegion *region);
function gdk_region_copy(region) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_region_copy
  type(c_ptr), value :: region
end function

! GdkRegion * gdk_region_rectangle (const GdkRectangle *rectangle);
function gdk_region_rectangle(rectangle) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_region_rectangle
  type(c_ptr), value :: rectangle
end function

! void gdk_region_destroy (GdkRegion *region);
subroutine gdk_region_destroy(region) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: region
end subroutine

!  void gdk_region_get_clipbox (const GdkRegion *region, GdkRectangle *rectangle);
subroutine gdk_region_get_clipbox(region, rectangle) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: region
  type(c_ptr), value :: rectangle
end subroutine

! void gdk_region_get_rectangles (const GdkRegion *region, GdkRectangle **rectangles, gint *n_rectangles);
subroutine gdk_region_get_rectangles(region, rectangles, n_rectangles) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: region
  type(c_ptr), value :: rectangles
  type(c_ptr), value :: n_rectangles
end subroutine

!  gboolean gdk_region_empty (const GdkRegion *region);
function gdk_region_empty(region) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_region_empty
  type(c_ptr), value :: region
end function

! gboolean gdk_region_equal (const GdkRegion *region1, const GdkRegion *region2);
function gdk_region_equal(region1, region2) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_region_equal
  type(c_ptr), value :: region1
  type(c_ptr), value :: region2
end function

!  gboolean gdk_region_rect_equal (const GdkRegion *region, const GdkRectangle *rectangle);
function gdk_region_rect_equal(region, rectangle) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_region_rect_equal
  type(c_ptr), value :: region
  type(c_ptr), value :: rectangle
end function

!  gboolean gdk_region_point_in (const GdkRegion *region, int x, int y);
function gdk_region_point_in(region, x, y) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gdk_region_point_in
  type(c_ptr), value :: region
  integer(c_int), value :: x
  integer(c_int), value :: y
end function

! GdkOverlapType gdk_region_rect_in (const GdkRegion *region, const GdkRectangle *rectangle);
function gdk_region_rect_in(region, rectangle) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_region_rect_in
  type(c_ptr), value :: region
  type(c_ptr), value :: rectangle
end function

!  void gdk_region_offset (GdkRegion *region, gint dx, gint dy);
subroutine gdk_region_offset(region, dx, dy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: region
  integer(c_int), value :: dx
  integer(c_int), value :: dy
end subroutine

!  void gdk_region_shrink (GdkRegion *region, gint dx, gint dy);
subroutine gdk_region_shrink(region, dx, dy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: region
  integer(c_int), value :: dx
  integer(c_int), value :: dy
end subroutine

!  void gdk_region_union_with_rect (GdkRegion *region, const GdkRectangle *rect);
subroutine gdk_region_union_with_rect(region, rect) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: region
  type(c_ptr), value :: rect
end subroutine

! void gdk_region_intersect (GdkRegion *source1, const GdkRegion *source2);
subroutine gdk_region_intersect(source1, source2) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source1
  type(c_ptr), value :: source2
end subroutine

! void gdk_region_union (GdkRegion *source1, const GdkRegion *source2);
subroutine gdk_region_union(source1, source2) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source1
  type(c_ptr), value :: source2
end subroutine

! void gdk_region_subtract (GdkRegion *source1, const GdkRegion *source2);
subroutine gdk_region_subtract(source1, source2) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source1
  type(c_ptr), value :: source2
end subroutine

! void gdk_region_xor (GdkRegion *source1, const GdkRegion *source2);
subroutine gdk_region_xor(source1, source2) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source1
  type(c_ptr), value :: source2
end subroutine

!  void gdk_region_spans_intersect_foreach (GdkRegion *region, const GdkSpan *spans, int n_spans, gboolean sorted, GdkSpanFunc function, gpointer data);
subroutine gdk_region_spans_intersect_foreach(region, spans, n_spans, sorted, fu&
      &nction, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool, c_funptr
  type(c_ptr), value :: region
  type(c_ptr), value :: spans
  integer(c_int), value :: n_spans
  logical(c_bool), value :: sorted
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end subroutine

!   GType gdk_app_launch_context_get_type (void);
function gdk_app_launch_context_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_app_launch_context_get_type
end function

!  GdkAppLaunchContext *gdk_app_launch_context_new (void);
function gdk_app_launch_context_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_app_launch_context_new
end function

! void gdk_app_launch_context_set_display (GdkAppLaunchContext *context, GdkDisplay *display);
subroutine gdk_app_launch_context_set_display(context, display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: display
end subroutine

! void gdk_app_launch_context_set_screen (GdkAppLaunchContext *context, GdkScreen *screen);
subroutine gdk_app_launch_context_set_screen(context, screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: screen
end subroutine

! void gdk_app_launch_context_set_desktop (GdkAppLaunchContext *context, gint desktop);
subroutine gdk_app_launch_context_set_desktop(context, desktop) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: context
  integer(c_int), value :: desktop
end subroutine

! void gdk_app_launch_context_set_timestamp (GdkAppLaunchContext *context, guint32 timestamp);
subroutine gdk_app_launch_context_set_timestamp(context, timestamp) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: context
  integer(c_int32_t), value :: timestamp
end subroutine

! void gdk_app_launch_context_set_icon (GdkAppLaunchContext *context, GIcon *icon);
subroutine gdk_app_launch_context_set_icon(context, icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: icon
end subroutine

! void gdk_app_launch_context_set_icon_name (GdkAppLaunchContext *context, const char *icon_name);
subroutine gdk_app_launch_context_set_icon_name(context, icon_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: icon_name
end subroutine

!   void gdk_pixbuf_render_threshold_alpha (GdkPixbuf *pixbuf, GdkBitmap *bitmap, int src_x, int src_y, int dest_x, int dest_y, int width, int height, int alpha_threshold);
subroutine gdk_pixbuf_render_threshold_alpha(pixbuf, bitmap, src_x, src_y, dest_&
      &x, dest_y, width, height, alpha_threshold) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: pixbuf
  type(c_ptr), value :: bitmap
  integer(c_int), value :: src_x
  integer(c_int), value :: src_y
  integer(c_int), value :: dest_x
  integer(c_int), value :: dest_y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: alpha_threshold
end subroutine

!  void gdk_pixbuf_render_to_drawable (GdkPixbuf *pixbuf, GdkDrawable *drawable, GdkGC *gc, int src_x, int src_y, int dest_x, int dest_y, int width, int height, GdkRgbDither dither, int x_dither, int y_dither);
subroutine gdk_pixbuf_render_to_drawable(pixbuf, drawable, gc, src_x, src_y, des&
      &t_x, dest_y, width, height, dither, x_dither, y_dither) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: pixbuf
  type(c_ptr), value :: drawable
  type(c_ptr), value :: gc
  integer(c_int), value :: src_x
  integer(c_int), value :: src_y
  integer(c_int), value :: dest_x
  integer(c_int), value :: dest_y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: dither
  integer(c_int), value :: x_dither
  integer(c_int), value :: y_dither
end subroutine

! void gdk_pixbuf_render_to_drawable_alpha (GdkPixbuf *pixbuf, GdkDrawable *drawable, int src_x, int src_y, int dest_x, int dest_y, int width, int height, GdkPixbufAlphaMode alpha_mode, int alpha_threshold, GdkRgbDither dither, int x_dither, int y_dither);
subroutine gdk_pixbuf_render_to_drawable_alpha(pixbuf, drawable, src_x, src_y, d&
      &est_x, dest_y, width, height, alpha_mode, alpha_threshold, dither, x_dith&
      &er, y_dither) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: pixbuf
  type(c_ptr), value :: drawable
  integer(c_int), value :: src_x
  integer(c_int), value :: src_y
  integer(c_int), value :: dest_x
  integer(c_int), value :: dest_y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: alpha_mode
  integer(c_int), value :: alpha_threshold
  integer(c_int), value :: dither
  integer(c_int), value :: x_dither
  integer(c_int), value :: y_dither
end subroutine

!  void gdk_pixbuf_render_pixmap_and_mask_for_colormap (GdkPixbuf *pixbuf, GdkColormap *colormap, GdkPixmap **pixmap_return, GdkBitmap **mask_return, int alpha_threshold);
subroutine gdk_pixbuf_render_pixmap_and_mask_for_colormap(pixbuf, colormap, pixm&
      &ap_return, mask_return, alpha_threshold) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: pixbuf
  type(c_ptr), value :: colormap
  type(c_ptr), value :: pixmap_return
  type(c_ptr), value :: mask_return
  integer(c_int), value :: alpha_threshold
end subroutine

!  void gdk_pixbuf_render_pixmap_and_mask (GdkPixbuf *pixbuf, GdkPixmap **pixmap_return, GdkBitmap **mask_return, int alpha_threshold);
subroutine gdk_pixbuf_render_pixmap_and_mask(pixbuf, pixmap_return, mask_return,&
      & alpha_threshold) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: pixbuf
  type(c_ptr), value :: pixmap_return
  type(c_ptr), value :: mask_return
  integer(c_int), value :: alpha_threshold
end subroutine

!  GdkPixbuf *gdk_pixbuf_get_from_drawable (GdkPixbuf *dest, GdkDrawable *src, GdkColormap *cmap, int src_x, int src_y, int dest_x, int dest_y, int width, int height);
function gdk_pixbuf_get_from_drawable(dest, src, cmap, src_x, src_y, dest_x, des&
      &t_y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_pixbuf_get_from_drawable
  type(c_ptr), value :: dest
  type(c_ptr), value :: src
  type(c_ptr), value :: cmap
  integer(c_int), value :: src_x
  integer(c_int), value :: src_y
  integer(c_int), value :: dest_x
  integer(c_int), value :: dest_y
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

!  GdkPixbuf *gdk_pixbuf_get_from_image (GdkPixbuf *dest, GdkImage *src, GdkColormap *cmap, int src_x, int src_y, int dest_x, int dest_y, int width, int height);
function gdk_pixbuf_get_from_image(dest, src, cmap, src_x, src_y, dest_x, dest_y&
      &, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_pixbuf_get_from_image
  type(c_ptr), value :: dest
  type(c_ptr), value :: src
  type(c_ptr), value :: cmap
  integer(c_int), value :: src_x
  integer(c_int), value :: src_y
  integer(c_int), value :: dest_x
  integer(c_int), value :: dest_y
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

!   GType gdk_display_manager_get_type (void) G_GNUC_CONST;
function gdk_display_manager_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_display_manager_get_type
end function

!  GdkDisplayManager *gdk_display_manager_get (void);
function gdk_display_manager_get() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_display_manager_get
end function

! GdkDisplay * gdk_display_manager_get_default_display (GdkDisplayManager *display_manager);
function gdk_display_manager_get_default_display(display_manager) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_display_manager_get_default_display
  type(c_ptr), value :: display_manager
end function

! void gdk_display_manager_set_default_display (GdkDisplayManager *display_manager, GdkDisplay *display);
subroutine gdk_display_manager_set_default_display(display_manager, display) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: display_manager
  type(c_ptr), value :: display
end subroutine

! GSList * gdk_display_manager_list_displays (GdkDisplayManager *display_manager);
function gdk_display_manager_list_displays(display_manager) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_display_manager_list_displays
  type(c_ptr), value :: display_manager
end function

!   GType gdk_visual_get_type (void) G_GNUC_CONST;
function gdk_visual_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_visual_get_type
end function

!  gint gdk_visual_get_best_depth (void);
function gdk_visual_get_best_depth() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gdk_visual_get_best_depth
end function

! GdkVisualType gdk_visual_get_best_type (void);
function gdk_visual_get_best_type() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gdk_visual_get_best_type
end function

! GdkVisual* gdk_visual_get_system (void);
function gdk_visual_get_system() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_visual_get_system
end function

! GdkVisual* gdk_visual_get_best (void);
function gdk_visual_get_best() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_visual_get_best
end function

! GdkVisual* gdk_visual_get_best_with_depth (gint depth);
function gdk_visual_get_best_with_depth(depth) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_visual_get_best_with_depth
  integer(c_int), value :: depth
end function

! GdkVisual* gdk_visual_get_best_with_type (GdkVisualType visual_type);
function gdk_visual_get_best_with_type(visual_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_visual_get_best_with_type
  integer(c_int), value :: visual_type
end function

! GdkVisual* gdk_visual_get_best_with_both (gint depth, GdkVisualType visual_type);
function gdk_visual_get_best_with_both(depth, visual_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_visual_get_best_with_both
  integer(c_int), value :: depth
  integer(c_int), value :: visual_type
end function

!  void gdk_query_depths (gint **depths, gint *count);
subroutine gdk_query_depths(depths, count) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: depths
  type(c_ptr), value :: count
end subroutine

! void gdk_query_visual_types (GdkVisualType **visual_types, gint *count);
subroutine gdk_query_visual_types(visual_types, count) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int), value :: visual_types
  type(c_ptr), value :: count
end subroutine

!  GList* gdk_list_visuals (void);
function gdk_list_visuals() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_list_visuals
end function

!  GdkScreen *gdk_visual_get_screen (GdkVisual *visual);
function gdk_visual_get_screen(visual) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_visual_get_screen
  type(c_ptr), value :: visual
end function

!  GdkVisualType gdk_visual_get_visual_type (GdkVisual *visual);
function gdk_visual_get_visual_type(visual) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_visual_get_visual_type
  type(c_ptr), value :: visual
end function

! gint gdk_visual_get_depth (GdkVisual *visual);
function gdk_visual_get_depth(visual) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_visual_get_depth
  type(c_ptr), value :: visual
end function

! GdkByteOrder gdk_visual_get_byte_order (GdkVisual *visual);
function gdk_visual_get_byte_order(visual) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_visual_get_byte_order
  type(c_ptr), value :: visual
end function

! gint gdk_visual_get_colormap_size (GdkVisual *visual);
function gdk_visual_get_colormap_size(visual) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_visual_get_colormap_size
  type(c_ptr), value :: visual
end function

! gint gdk_visual_get_bits_per_rgb (GdkVisual *visual);
function gdk_visual_get_bits_per_rgb(visual) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_visual_get_bits_per_rgb
  type(c_ptr), value :: visual
end function

! void gdk_visual_get_red_pixel_details (GdkVisual *visual, guint32 *mask, gint *shift, gint *precision);
subroutine gdk_visual_get_red_pixel_details(visual, mask, shift, precision) bind&
      &(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: visual
  type(c_ptr), value :: mask
  type(c_ptr), value :: shift
  type(c_ptr), value :: precision
end subroutine

! void gdk_visual_get_green_pixel_details (GdkVisual *visual, guint32 *mask, gint *shift, gint *precision);
subroutine gdk_visual_get_green_pixel_details(visual, mask, shift, precision) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: visual
  type(c_ptr), value :: mask
  type(c_ptr), value :: shift
  type(c_ptr), value :: precision
end subroutine

! void gdk_visual_get_blue_pixel_details (GdkVisual *visual, guint32 *mask, gint *shift, gint *precision);
subroutine gdk_visual_get_blue_pixel_details(visual, mask, shift, precision) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: visual
  type(c_ptr), value :: mask
  type(c_ptr), value :: shift
  type(c_ptr), value :: precision
end subroutine

!   GType gdk_window_object_get_type (void) G_GNUC_CONST;
function gdk_window_object_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_window_object_get_type
end function

! GdkWindow* gdk_window_new (GdkWindow *parent, GdkWindowAttr *attributes, gint attributes_mask);
function gdk_window_new(parent, attributes, attributes_mask) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_window_new
  type(c_ptr), value :: parent
  type(c_ptr), value :: attributes
  integer(c_int), value :: attributes_mask
end function

! void gdk_window_destroy (GdkWindow *window);
subroutine gdk_window_destroy(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! GdkWindowType gdk_window_get_window_type (GdkWindow *window);
function gdk_window_get_window_type(window) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_window_get_window_type
  type(c_ptr), value :: window
end function

! gboolean gdk_window_is_destroyed (GdkWindow *window);
function gdk_window_is_destroyed(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_window_is_destroyed
  type(c_ptr), value :: window
end function

! GdkWindow* gdk_window_at_pointer (gint *win_x, gint *win_y);
function gdk_window_at_pointer(win_x, win_y) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_window_at_pointer
  type(c_ptr), value :: win_x
  type(c_ptr), value :: win_y
end function

! void gdk_window_show (GdkWindow *window);
subroutine gdk_window_show(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_hide (GdkWindow *window);
subroutine gdk_window_hide(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_withdraw (GdkWindow *window);
subroutine gdk_window_withdraw(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_show_unraised (GdkWindow *window);
subroutine gdk_window_show_unraised(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_move (GdkWindow *window, gint x, gint y);
subroutine gdk_window_move(window, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void gdk_window_resize (GdkWindow *window, gint width, gint height);
subroutine gdk_window_resize(window, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gdk_window_move_resize (GdkWindow *window, gint x, gint y, gint width, gint height);
subroutine gdk_window_move_resize(window, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gdk_window_reparent (GdkWindow *window, GdkWindow *new_parent, gint x, gint y);
subroutine gdk_window_reparent(window, new_parent, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  type(c_ptr), value :: new_parent
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void gdk_window_clear (GdkWindow *window);
subroutine gdk_window_clear(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_clear_area (GdkWindow *window, gint x, gint y, gint width, gint height);
subroutine gdk_window_clear_area(window, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gdk_window_clear_area_e (GdkWindow *window, gint x, gint y, gint width, gint height);
subroutine gdk_window_clear_area_e(window, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gdk_window_raise (GdkWindow *window);
subroutine gdk_window_raise(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_lower (GdkWindow *window);
subroutine gdk_window_lower(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_restack (GdkWindow *window, GdkWindow *sibling, gboolean above);
subroutine gdk_window_restack(window, sibling, above) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  type(c_ptr), value :: sibling
  logical(c_bool), value :: above
end subroutine

! void gdk_window_focus (GdkWindow *window, guint32 timestamp);
subroutine gdk_window_focus(window, timestamp) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: window
  integer(c_int32_t), value :: timestamp
end subroutine

! void gdk_window_set_user_data (GdkWindow *window, gpointer user_data);
subroutine gdk_window_set_user_data(window, user_data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: user_data
end subroutine

! void gdk_window_set_override_redirect (GdkWindow *window, gboolean override_redirect);
subroutine gdk_window_set_override_redirect(window, override_redirect) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: override_redirect
end subroutine

! gboolean gdk_window_get_accept_focus (GdkWindow *window);
function gdk_window_get_accept_focus(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_window_get_accept_focus
  type(c_ptr), value :: window
end function

! void gdk_window_set_accept_focus (GdkWindow *window, gboolean accept_focus);
subroutine gdk_window_set_accept_focus(window, accept_focus) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: accept_focus
end subroutine

! gboolean gdk_window_get_focus_on_map (GdkWindow *window);
function gdk_window_get_focus_on_map(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_window_get_focus_on_map
  type(c_ptr), value :: window
end function

! void gdk_window_set_focus_on_map (GdkWindow *window, gboolean focus_on_map);
subroutine gdk_window_set_focus_on_map(window, focus_on_map) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: focus_on_map
end subroutine

! void gdk_window_add_filter (GdkWindow *window, GdkFilterFunc function, gpointer data);
subroutine gdk_window_add_filter(window, function, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: window
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end subroutine

! void gdk_window_remove_filter (GdkWindow *window, GdkFilterFunc function, gpointer data);
subroutine gdk_window_remove_filter(window, function, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: window
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end subroutine

! void gdk_window_scroll (GdkWindow *window, gint dx, gint dy);
subroutine gdk_window_scroll(window, dx, dy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: dx
  integer(c_int), value :: dy
end subroutine

! void gdk_window_move_region (GdkWindow *window, const GdkRegion *region, gint dx, gint dy);
subroutine gdk_window_move_region(window, region, dx, dy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  type(c_ptr), value :: region
  integer(c_int), value :: dx
  integer(c_int), value :: dy
end subroutine

! gboolean gdk_window_ensure_native (GdkWindow *window);
function gdk_window_ensure_native(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_window_ensure_native
  type(c_ptr), value :: window
end function

!  void gdk_window_shape_combine_mask (GdkWindow *window, GdkBitmap *mask, gint x, gint y);
subroutine gdk_window_shape_combine_mask(window, mask, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  type(c_ptr), value :: mask
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void gdk_window_shape_combine_region (GdkWindow *window, const GdkRegion *shape_region, gint offset_x, gint offset_y);
subroutine gdk_window_shape_combine_region(window, shape_region, offset_x, offse&
      &t_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  type(c_ptr), value :: shape_region
  integer(c_int), value :: offset_x
  integer(c_int), value :: offset_y
end subroutine

!  void gdk_window_set_child_shapes (GdkWindow *window);
subroutine gdk_window_set_child_shapes(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

!  gboolean gdk_window_get_composited (GdkWindow *window);
function gdk_window_get_composited(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_window_get_composited
  type(c_ptr), value :: window
end function

! void gdk_window_set_composited (GdkWindow *window, gboolean composited);
subroutine gdk_window_set_composited(window, composited) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: composited
end subroutine

!  void gdk_window_merge_child_shapes (GdkWindow *window);
subroutine gdk_window_merge_child_shapes(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

!  void gdk_window_input_shape_combine_mask (GdkWindow *window, GdkBitmap *mask, gint x, gint y);
subroutine gdk_window_input_shape_combine_mask(window, mask, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  type(c_ptr), value :: mask
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void gdk_window_input_shape_combine_region (GdkWindow *window, const GdkRegion *shape_region, gint offset_x, gint offset_y);
subroutine gdk_window_input_shape_combine_region(window, shape_region, offset_x,&
      & offset_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  type(c_ptr), value :: shape_region
  integer(c_int), value :: offset_x
  integer(c_int), value :: offset_y
end subroutine

! void gdk_window_set_child_input_shapes (GdkWindow *window);
subroutine gdk_window_set_child_input_shapes(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_merge_child_input_shapes (GdkWindow *window);
subroutine gdk_window_merge_child_input_shapes(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

!  gboolean gdk_window_is_visible (GdkWindow *window);
function gdk_window_is_visible(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_window_is_visible
  type(c_ptr), value :: window
end function

! gboolean gdk_window_is_viewable (GdkWindow *window);
function gdk_window_is_viewable(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_window_is_viewable
  type(c_ptr), value :: window
end function

! gboolean gdk_window_is_input_only (GdkWindow *window);
function gdk_window_is_input_only(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_window_is_input_only
  type(c_ptr), value :: window
end function

! gboolean gdk_window_is_shaped (GdkWindow *window);
function gdk_window_is_shaped(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_window_is_shaped
  type(c_ptr), value :: window
end function

!  GdkWindowState gdk_window_get_state (GdkWindow *window);
function gdk_window_get_state(window) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_window_get_state
  type(c_ptr), value :: window
end function

!  gboolean gdk_window_set_static_gravities (GdkWindow *window, gboolean use_static);
function gdk_window_set_static_gravities(window, use_static) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_window_set_static_gravities
  type(c_ptr), value :: window
  logical(c_bool), value :: use_static
end function

!    GdkWindow* gdk_window_foreign_new (GdkNativeWindow anid);
function gdk_window_foreign_new(anid) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_window_foreign_new
  type(c_ptr), value :: anid
end function

! GdkWindow* gdk_window_lookup (GdkNativeWindow anid);
function gdk_window_lookup(anid) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_window_lookup
  type(c_ptr), value :: anid
end function

!  GdkWindow *gdk_window_foreign_new_for_display (GdkDisplay *display, GdkNativeWindow anid);
function gdk_window_foreign_new_for_display(display, anid) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_window_foreign_new_for_display
  type(c_ptr), value :: display
  type(c_ptr), value :: anid
end function

! GdkWindow* gdk_window_lookup_for_display (GdkDisplay *display, GdkNativeWindow anid);
function gdk_window_lookup_for_display(display, anid) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_window_lookup_for_display
  type(c_ptr), value :: display
  type(c_ptr), value :: anid
end function

!  gboolean gdk_window_has_native (GdkWindow *window);
function gdk_window_has_native(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_window_has_native
  type(c_ptr), value :: window
end function

!  void gdk_window_set_hints (GdkWindow *window, gint x, gint y, gint min_width, gint min_height, gint max_width, gint max_height, gint flags);
subroutine gdk_window_set_hints(window, x, y, min_width, min_height, max_width, &
      &max_height, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: min_width
  integer(c_int), value :: min_height
  integer(c_int), value :: max_width
  integer(c_int), value :: max_height
  integer(c_int), value :: flags
end subroutine

!  void gdk_window_set_type_hint (GdkWindow *window, GdkWindowTypeHint hint);
subroutine gdk_window_set_type_hint(window, hint) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: hint
end subroutine

! GdkWindowTypeHint gdk_window_get_type_hint (GdkWindow *window);
function gdk_window_get_type_hint(window) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_window_get_type_hint
  type(c_ptr), value :: window
end function

!  gboolean gdk_window_get_modal_hint (GdkWindow *window);
function gdk_window_get_modal_hint(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_window_get_modal_hint
  type(c_ptr), value :: window
end function

! void gdk_window_set_modal_hint (GdkWindow *window, gboolean modal);
subroutine gdk_window_set_modal_hint(window, modal) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: modal
end subroutine

!  void gdk_window_set_skip_taskbar_hint (GdkWindow *window, gboolean skips_taskbar);
subroutine gdk_window_set_skip_taskbar_hint(window, skips_taskbar) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: skips_taskbar
end subroutine

! void gdk_window_set_skip_pager_hint (GdkWindow *window, gboolean skips_pager);
subroutine gdk_window_set_skip_pager_hint(window, skips_pager) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: skips_pager
end subroutine

! void gdk_window_set_urgency_hint (GdkWindow *window, gboolean urgent);
subroutine gdk_window_set_urgency_hint(window, urgent) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: urgent
end subroutine

!  void gdk_window_set_geometry_hints (GdkWindow *window, const GdkGeometry *geometry, GdkWindowHints geom_mask);
subroutine gdk_window_set_geometry_hints(window, geometry, geom_mask) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  type(c_ptr), value :: geometry
  integer(c_int), value :: geom_mask
end subroutine

! void gdk_set_sm_client_id (const gchar *sm_client_id);
subroutine gdk_set_sm_client_id(sm_client_id) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: sm_client_id
end subroutine

!  void gdk_window_begin_paint_rect (GdkWindow *window, const GdkRectangle *rectangle);
subroutine gdk_window_begin_paint_rect(window, rectangle) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: rectangle
end subroutine

! void gdk_window_begin_paint_region (GdkWindow *window, const GdkRegion *region);
subroutine gdk_window_begin_paint_region(window, region) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: region
end subroutine

! void gdk_window_end_paint (GdkWindow *window);
subroutine gdk_window_end_paint(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_flush (GdkWindow *window);
subroutine gdk_window_flush(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

!  void gdk_window_set_title (GdkWindow *window, const gchar *title);
subroutine gdk_window_set_title(window, title) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: window
  character(kind=c_char), dimension(*) :: title
end subroutine

! void gdk_window_set_role (GdkWindow *window, const gchar *role);
subroutine gdk_window_set_role(window, role) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: window
  character(kind=c_char), dimension(*) :: role
end subroutine

! void gdk_window_set_startup_id (GdkWindow *window, const gchar *startup_id);
subroutine gdk_window_set_startup_id(window, startup_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: window
  character(kind=c_char), dimension(*) :: startup_id
end subroutine

! void gdk_window_set_transient_for (GdkWindow *window, GdkWindow *parent);
subroutine gdk_window_set_transient_for(window, parent) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: parent
end subroutine

! void gdk_window_set_background (GdkWindow *window, const GdkColor *color);
subroutine gdk_window_set_background(window, color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: color
end subroutine

! void gdk_window_set_back_pixmap (GdkWindow *window, GdkPixmap *pixmap, gboolean parent_relative);
subroutine gdk_window_set_back_pixmap(window, pixmap, parent_relative) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  type(c_ptr), value :: pixmap
  logical(c_bool), value :: parent_relative
end subroutine

! cairo_pattern_t *gdk_window_get_background_pattern (GdkWindow *window);
function gdk_window_get_background_pattern(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_window_get_background_pattern
  type(c_ptr), value :: window
end function

!  void gdk_window_set_cursor (GdkWindow *window, GdkCursor *cursor);
subroutine gdk_window_set_cursor(window, cursor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: cursor
end subroutine

! GdkCursor *gdk_window_get_cursor (GdkWindow *window);
function gdk_window_get_cursor(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_window_get_cursor
  type(c_ptr), value :: window
end function

! void gdk_window_get_user_data (GdkWindow *window, gpointer *data);
subroutine gdk_window_get_user_data(window, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: data
end subroutine

! void gdk_window_get_geometry (GdkWindow *window, gint *x, gint *y, gint *width, gint *height, gint *depth);
subroutine gdk_window_get_geometry(window, x, y, width, height, depth) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: x
  type(c_ptr), value :: y
  type(c_ptr), value :: width
  type(c_ptr), value :: height
  type(c_ptr), value :: depth
end subroutine

! void gdk_window_get_position (GdkWindow *window, gint *x, gint *y);
subroutine gdk_window_get_position(window, x, y) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: x
  type(c_ptr), value :: y
end subroutine

! gint gdk_window_get_origin (GdkWindow *window, gint *x, gint *y);
function gdk_window_get_origin(window, x, y) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_window_get_origin
  type(c_ptr), value :: window
  type(c_ptr), value :: x
  type(c_ptr), value :: y
end function

! void gdk_window_get_root_coords (GdkWindow *window, gint x, gint y, gint *root_x, gint *root_y);
subroutine gdk_window_get_root_coords(window, x, y, root_x, root_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: x
  integer(c_int), value :: y
  type(c_ptr), value :: root_x
  type(c_ptr), value :: root_y
end subroutine

! void gdk_window_coords_to_parent (GdkWindow *window, gdouble x, gdouble y, gdouble *parent_x, gdouble *parent_y);
subroutine gdk_window_coords_to_parent(window, x, y, parent_x, parent_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: window
  real(c_double), value :: x
  real(c_double), value :: y
  type(c_ptr), value :: parent_x
  type(c_ptr), value :: parent_y
end subroutine

! void gdk_window_coords_from_parent (GdkWindow *window, gdouble parent_x, gdouble parent_y, gdouble *x, gdouble *y);
subroutine gdk_window_coords_from_parent(window, parent_x, parent_y, x, y) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: window
  real(c_double), value :: parent_x
  real(c_double), value :: parent_y
  type(c_ptr), value :: x
  type(c_ptr), value :: y
end subroutine

!  gboolean gdk_window_get_deskrelative_origin (GdkWindow *window, gint *x, gint *y);
function gdk_window_get_deskrelative_origin(window, x, y) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_window_get_deskrelative_origin
  type(c_ptr), value :: window
  type(c_ptr), value :: x
  type(c_ptr), value :: y
end function

!  void gdk_window_get_root_origin (GdkWindow *window, gint *x, gint *y);
subroutine gdk_window_get_root_origin(window, x, y) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: x
  type(c_ptr), value :: y
end subroutine

! void gdk_window_get_frame_extents (GdkWindow *window, GdkRectangle *rect);
subroutine gdk_window_get_frame_extents(window, rect) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: rect
end subroutine

! GdkWindow* gdk_window_get_pointer (GdkWindow *window, gint *x, gint *y, GdkModifierType *mask);
function gdk_window_get_pointer(window, x, y, mask) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_window_get_pointer
  type(c_ptr), value :: window
  type(c_ptr), value :: x
  type(c_ptr), value :: y
  integer(c_int), value :: mask
end function

! GdkWindow * gdk_window_get_parent (GdkWindow *window);
function gdk_window_get_parent(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_window_get_parent
  type(c_ptr), value :: window
end function

! GdkWindow * gdk_window_get_toplevel (GdkWindow *window);
function gdk_window_get_toplevel(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_window_get_toplevel
  type(c_ptr), value :: window
end function

!  GdkWindow * gdk_window_get_effective_parent (GdkWindow *window);
function gdk_window_get_effective_parent(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_window_get_effective_parent
  type(c_ptr), value :: window
end function

! GdkWindow * gdk_window_get_effective_toplevel (GdkWindow *window);
function gdk_window_get_effective_toplevel(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_window_get_effective_toplevel
  type(c_ptr), value :: window
end function

!  GList * gdk_window_get_children (GdkWindow *window);
function gdk_window_get_children(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_window_get_children
  type(c_ptr), value :: window
end function

! GList * gdk_window_peek_children (GdkWindow *window);
function gdk_window_peek_children(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_window_peek_children
  type(c_ptr), value :: window
end function

! GdkEventMask gdk_window_get_events (GdkWindow *window);
function gdk_window_get_events(window) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_window_get_events
  type(c_ptr), value :: window
end function

! void gdk_window_set_events (GdkWindow *window, GdkEventMask event_mask);
subroutine gdk_window_set_events(window, event_mask) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: event_mask
end subroutine

!  void gdk_window_set_icon_list (GdkWindow *window, GList *pixbufs);
subroutine gdk_window_set_icon_list(window, pixbufs) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: pixbufs
end subroutine

! void gdk_window_set_icon (GdkWindow *window, GdkWindow *icon_window, GdkPixmap *pixmap, GdkBitmap *mask);
subroutine gdk_window_set_icon(window, icon_window, pixmap, mask) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: icon_window
  type(c_ptr), value :: pixmap
  type(c_ptr), value :: mask
end subroutine

! void gdk_window_set_icon_name (GdkWindow *window, const gchar *name);
subroutine gdk_window_set_icon_name(window, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: window
  character(kind=c_char), dimension(*) :: name
end subroutine

! void gdk_window_set_group (GdkWindow *window, GdkWindow *leader);
subroutine gdk_window_set_group(window, leader) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: leader
end subroutine

! GdkWindow* gdk_window_get_group (GdkWindow *window);
function gdk_window_get_group(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_window_get_group
  type(c_ptr), value :: window
end function

! void gdk_window_set_decorations (GdkWindow *window, GdkWMDecoration decorations);
subroutine gdk_window_set_decorations(window, decorations) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: decorations
end subroutine

! gboolean gdk_window_get_decorations (GdkWindow *window, GdkWMDecoration *decorations);
function gdk_window_get_decorations(window, decorations) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gdk_window_get_decorations
  type(c_ptr), value :: window
  integer(c_int), value :: decorations
end function

! void gdk_window_set_functions (GdkWindow *window, GdkWMFunction functions);
subroutine gdk_window_set_functions(window, functions) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: functions
end subroutine

!  GList * gdk_window_get_toplevels (void);
function gdk_window_get_toplevels() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_window_get_toplevels
end function

!  cairo_surface_t * gdk_window_create_similar_surface (GdkWindow *window, cairo_content_t content, int width, int height);
function gdk_window_create_similar_surface(window, content, width, height) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_window_create_similar_surface
  type(c_ptr), value :: window
  integer(c_int), value :: content
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

!  void gdk_window_beep (GdkWindow *window);
subroutine gdk_window_beep(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_iconify (GdkWindow *window);
subroutine gdk_window_iconify(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_deiconify (GdkWindow *window);
subroutine gdk_window_deiconify(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_stick (GdkWindow *window);
subroutine gdk_window_stick(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_unstick (GdkWindow *window);
subroutine gdk_window_unstick(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_maximize (GdkWindow *window);
subroutine gdk_window_maximize(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_unmaximize (GdkWindow *window);
subroutine gdk_window_unmaximize(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_fullscreen (GdkWindow *window);
subroutine gdk_window_fullscreen(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_unfullscreen (GdkWindow *window);
subroutine gdk_window_unfullscreen(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_set_keep_above (GdkWindow *window, gboolean setting);
subroutine gdk_window_set_keep_above(window, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: setting
end subroutine

! void gdk_window_set_keep_below (GdkWindow *window, gboolean setting);
subroutine gdk_window_set_keep_below(window, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: setting
end subroutine

! void gdk_window_set_opacity (GdkWindow *window, gdouble opacity);
subroutine gdk_window_set_opacity(window, opacity) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: window
  real(c_double), value :: opacity
end subroutine

! void gdk_window_register_dnd (GdkWindow *window);
subroutine gdk_window_register_dnd(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

!  void gdk_window_begin_resize_drag (GdkWindow *window, GdkWindowEdge edge, gint button, gint root_x, gint root_y, guint32 timestamp);
subroutine gdk_window_begin_resize_drag(window, edge, button, root_x, root_y, ti&
      &mestamp) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int32_t
  type(c_ptr), value :: window
  integer(c_int), value :: edge
  integer(c_int), value :: button
  integer(c_int), value :: root_x
  integer(c_int), value :: root_y
  integer(c_int32_t), value :: timestamp
end subroutine

! void gdk_window_begin_move_drag (GdkWindow *window, gint button, gint root_x, gint root_y, guint32 timestamp);
subroutine gdk_window_begin_move_drag(window, button, root_x, root_y, timestamp)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int32_t
  type(c_ptr), value :: window
  integer(c_int), value :: button
  integer(c_int), value :: root_x
  integer(c_int), value :: root_y
  integer(c_int32_t), value :: timestamp
end subroutine

!  void gdk_window_invalidate_rect (GdkWindow *window, const GdkRectangle *rect, gboolean invalidate_children);
subroutine gdk_window_invalidate_rect(window, rect, invalidate_children) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  type(c_ptr), value :: rect
  logical(c_bool), value :: invalidate_children
end subroutine

! void gdk_window_invalidate_region (GdkWindow *window, const GdkRegion *region, gboolean invalidate_children);
subroutine gdk_window_invalidate_region(window, region, invalidate_children) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  type(c_ptr), value :: region
  logical(c_bool), value :: invalidate_children
end subroutine

! void gdk_window_invalidate_maybe_recurse (GdkWindow *window, const GdkRegion *region, gboolean (*child_func) (GdkWindow *, gpointer), gpointer user_data);
subroutine gdk_window_invalidate_maybe_recurse() bind(c) 
  use iso_c_binding, only: 
end subroutine

! GdkRegion *gdk_window_get_update_area (GdkWindow *window);
function gdk_window_get_update_area(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_window_get_update_area
  type(c_ptr), value :: window
end function

!  void gdk_window_freeze_updates (GdkWindow *window);
subroutine gdk_window_freeze_updates(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_thaw_updates (GdkWindow *window);
subroutine gdk_window_thaw_updates(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

!  void gdk_window_freeze_toplevel_updates_libgtk_only (GdkWindow *window);
subroutine gdk_window_freeze_toplevel_updates_libgtk_only(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_thaw_toplevel_updates_libgtk_only (GdkWindow *window);
subroutine gdk_window_thaw_toplevel_updates_libgtk_only(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

!  void gdk_window_process_all_updates (void);
subroutine gdk_window_process_all_updates() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void gdk_window_process_updates (GdkWindow *window, gboolean update_children);
subroutine gdk_window_process_updates(window, update_children) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: update_children
end subroutine

!  void gdk_window_set_debug_updates (gboolean setting);
subroutine gdk_window_set_debug_updates(setting) bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool), value :: setting
end subroutine

!  void gdk_window_constrain_size (GdkGeometry *geometry, guint flags, gint width, gint height, gint *new_width, gint *new_height);
subroutine gdk_window_constrain_size(geometry, flags, width, height, new_width, &
      &new_height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: geometry
  integer(c_int), value :: flags
  integer(c_int), value :: width
  integer(c_int), value :: height
  type(c_ptr), value :: new_width
  type(c_ptr), value :: new_height
end subroutine

!  void gdk_window_get_internal_paint_info (GdkWindow *window, GdkDrawable **real_drawable, gint *x_offset, gint *y_offset);
subroutine gdk_window_get_internal_paint_info(window, real_drawable, x_offset, y&
      &_offset) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: real_drawable
  type(c_ptr), value :: x_offset
  type(c_ptr), value :: y_offset
end subroutine

!  void gdk_window_enable_synchronized_configure (GdkWindow *window);
subroutine gdk_window_enable_synchronized_configure(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gdk_window_configure_finished (GdkWindow *window);
subroutine gdk_window_configure_finished(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

!  GdkPointerHooks *gdk_set_pointer_hooks (const GdkPointerHooks *new_hooks);
function gdk_set_pointer_hooks(new_hooks) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_set_pointer_hooks
  type(c_ptr), value :: new_hooks
end function

!  GdkWindow *gdk_get_default_root_window (void);
function gdk_get_default_root_window() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_get_default_root_window
end function

!  GdkPixmap *gdk_offscreen_window_get_pixmap (GdkWindow *window);
function gdk_offscreen_window_get_pixmap(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_offscreen_window_get_pixmap
  type(c_ptr), value :: window
end function

! void gdk_offscreen_window_set_embedder (GdkWindow *window, GdkWindow *embedder);
subroutine gdk_offscreen_window_set_embedder(window, embedder) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: embedder
end subroutine

! GdkWindow *gdk_offscreen_window_get_embedder (GdkWindow *window);
function gdk_offscreen_window_get_embedder(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_offscreen_window_get_embedder
  type(c_ptr), value :: window
end function

! void gdk_window_geometry_changed (GdkWindow *window);
subroutine gdk_window_geometry_changed(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

!  void gdk_window_redirect_to_drawable (GdkWindow *window, GdkDrawable *drawable, gint src_x, gint src_y, gint dest_x, gint dest_y, gint width, gint height);
subroutine gdk_window_redirect_to_drawable(window, drawable, src_x, src_y, dest_&
      &x, dest_y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  type(c_ptr), value :: drawable
  integer(c_int), value :: src_x
  integer(c_int), value :: src_y
  integer(c_int), value :: dest_x
  integer(c_int), value :: dest_y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gdk_window_remove_redirection (GdkWindow *window);
subroutine gdk_window_remove_redirection(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

!   gboolean gdk_selection_owner_set (GdkWindow *owner, GdkAtom selection, guint32 time_, gboolean send_event);
function gdk_selection_owner_set(owner, selection, time_, send_event) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int32_t
  logical(c_bool) :: gdk_selection_owner_set
  type(c_ptr), value :: owner
  type(c_ptr), value :: selection
  integer(c_int32_t), value :: time_
  logical(c_bool), value :: send_event
end function

! GdkWindow* gdk_selection_owner_get (GdkAtom selection);
function gdk_selection_owner_get(selection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_selection_owner_get
  type(c_ptr), value :: selection
end function

!  gboolean gdk_selection_owner_set_for_display (GdkDisplay *display, GdkWindow *owner, GdkAtom selection, guint32 time_, gboolean send_event);
function gdk_selection_owner_set_for_display(display, owner, selection, time_, s&
      &end_event) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int32_t
  logical(c_bool) :: gdk_selection_owner_set_for_display
  type(c_ptr), value :: display
  type(c_ptr), value :: owner
  type(c_ptr), value :: selection
  integer(c_int32_t), value :: time_
  logical(c_bool), value :: send_event
end function

! GdkWindow *gdk_selection_owner_get_for_display (GdkDisplay *display, GdkAtom selection);
function gdk_selection_owner_get_for_display(display, selection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_selection_owner_get_for_display
  type(c_ptr), value :: display
  type(c_ptr), value :: selection
end function

!  void gdk_selection_convert (GdkWindow *requestor, GdkAtom selection, GdkAtom target, guint32 time_);
subroutine gdk_selection_convert(requestor, selection, target, time_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: requestor
  type(c_ptr), value :: selection
  type(c_ptr), value :: target
  integer(c_int32_t), value :: time_
end subroutine

! gint gdk_selection_property_get (GdkWindow *requestor, guchar **data, GdkAtom *prop_type, gint *prop_format);
function gdk_selection_property_get(requestor, data, prop_type, prop_format) bin&
      &d(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gdk_selection_property_get
  type(c_ptr), value :: requestor
  character(kind=c_char), dimension(*) :: data
  type(c_ptr), value :: prop_type
  type(c_ptr), value :: prop_format
end function

!  void gdk_selection_send_notify (GdkNativeWindow requestor, GdkAtom selection, GdkAtom target, GdkAtom property, guint32 time_);
subroutine gdk_selection_send_notify(requestor, selection, target, property, tim&
      &e_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: requestor
  type(c_ptr), value :: selection
  type(c_ptr), value :: target
  type(c_ptr), value :: property
  integer(c_int32_t), value :: time_
end subroutine

!  void gdk_selection_send_notify_for_display (GdkDisplay *display, GdkNativeWindow requestor, GdkAtom selection, GdkAtom target, GdkAtom property, guint32 time_);
subroutine gdk_selection_send_notify_for_display(display, requestor, selection, &
      &target, property, time_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: display
  type(c_ptr), value :: requestor
  type(c_ptr), value :: selection
  type(c_ptr), value :: target
  type(c_ptr), value :: property
  integer(c_int32_t), value :: time_
end subroutine

!   GType gdk_gc_get_type (void) G_GNUC_CONST;
function gdk_gc_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_gc_get_type
end function

! GdkGC *gdk_gc_new (GdkDrawable *drawable);
function gdk_gc_new(drawable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_gc_new
  type(c_ptr), value :: drawable
end function

! GdkGC *gdk_gc_new_with_values (GdkDrawable *drawable, GdkGCValues *values, GdkGCValuesMask values_mask);
function gdk_gc_new_with_values(drawable, values, values_mask) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_gc_new_with_values
  type(c_ptr), value :: drawable
  type(c_ptr), value :: values
  integer(c_int), value :: values_mask
end function

!  GdkGC *gdk_gc_ref (GdkGC *gc);
function gdk_gc_ref(gc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_gc_ref
  type(c_ptr), value :: gc
end function

! void gdk_gc_unref (GdkGC *gc);
subroutine gdk_gc_unref(gc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: gc
end subroutine

!  void gdk_gc_get_values (GdkGC *gc, GdkGCValues *values);
subroutine gdk_gc_get_values(gc, values) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: gc
  type(c_ptr), value :: values
end subroutine

! void gdk_gc_set_values (GdkGC *gc, GdkGCValues *values, GdkGCValuesMask values_mask);
subroutine gdk_gc_set_values(gc, values, values_mask) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: gc
  type(c_ptr), value :: values
  integer(c_int), value :: values_mask
end subroutine

! void gdk_gc_set_foreground (GdkGC *gc, const GdkColor *color);
subroutine gdk_gc_set_foreground(gc, color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: gc
  type(c_ptr), value :: color
end subroutine

! void gdk_gc_set_background (GdkGC *gc, const GdkColor *color);
subroutine gdk_gc_set_background(gc, color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: gc
  type(c_ptr), value :: color
end subroutine

! void gdk_gc_set_font (GdkGC *gc, GdkFont *font);
subroutine gdk_gc_set_font(gc, font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: gc
  type(c_ptr), value :: font
end subroutine

! void gdk_gc_set_function (GdkGC *gc, GdkFunction function);
subroutine gdk_gc_set_function(gc, function) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: gc
  integer(c_int), value :: function
end subroutine

! void gdk_gc_set_fill (GdkGC *gc, GdkFill fill);
subroutine gdk_gc_set_fill(gc, fill) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: gc
  integer(c_int), value :: fill
end subroutine

! void gdk_gc_set_tile (GdkGC *gc, GdkPixmap *tile);
subroutine gdk_gc_set_tile(gc, tile) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: gc
  type(c_ptr), value :: tile
end subroutine

! void gdk_gc_set_stipple (GdkGC *gc, GdkPixmap *stipple);
subroutine gdk_gc_set_stipple(gc, stipple) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: gc
  type(c_ptr), value :: stipple
end subroutine

! void gdk_gc_set_ts_origin (GdkGC *gc, gint x, gint y);
subroutine gdk_gc_set_ts_origin(gc, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void gdk_gc_set_clip_origin (GdkGC *gc, gint x, gint y);
subroutine gdk_gc_set_clip_origin(gc, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void gdk_gc_set_clip_mask (GdkGC *gc, GdkBitmap *mask);
subroutine gdk_gc_set_clip_mask(gc, mask) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: gc
  type(c_ptr), value :: mask
end subroutine

! void gdk_gc_set_clip_rectangle (GdkGC *gc, const GdkRectangle *rectangle);
subroutine gdk_gc_set_clip_rectangle(gc, rectangle) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: gc
  type(c_ptr), value :: rectangle
end subroutine

! void gdk_gc_set_clip_region (GdkGC *gc, const GdkRegion *region);
subroutine gdk_gc_set_clip_region(gc, region) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: gc
  type(c_ptr), value :: region
end subroutine

! void gdk_gc_set_subwindow (GdkGC *gc, GdkSubwindowMode mode);
subroutine gdk_gc_set_subwindow(gc, mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: gc
  integer(c_int), value :: mode
end subroutine

! void gdk_gc_set_exposures (GdkGC *gc, gboolean exposures);
subroutine gdk_gc_set_exposures(gc, exposures) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: gc
  logical(c_bool), value :: exposures
end subroutine

! void gdk_gc_set_line_attributes (GdkGC *gc, gint line_width, GdkLineStyle line_style, GdkCapStyle cap_style, GdkJoinStyle join_style);
subroutine gdk_gc_set_line_attributes(gc, line_width, line_style, cap_style, joi&
      &n_style) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: gc
  integer(c_int), value :: line_width
  integer(c_int), value :: line_style
  integer(c_int), value :: cap_style
  integer(c_int), value :: join_style
end subroutine

! void gdk_gc_set_dashes (GdkGC *gc, gint dash_offset, gint8 dash_list[], gint n);
subroutine gdk_gc_set_dashes(gc, dash_offset, dash_list, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int8_t
  type(c_ptr), value :: gc
  integer(c_int), value :: dash_offset
  integer(c_int8_t), dimension(*) :: dash_list
  integer(c_int), value :: n
end subroutine

! void gdk_gc_offset (GdkGC *gc, gint x_offset, gint y_offset);
subroutine gdk_gc_offset(gc, x_offset, y_offset) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: gc
  integer(c_int), value :: x_offset
  integer(c_int), value :: y_offset
end subroutine

! void gdk_gc_copy (GdkGC *dst_gc, GdkGC *src_gc);
subroutine gdk_gc_copy(dst_gc, src_gc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: dst_gc
  type(c_ptr), value :: src_gc
end subroutine

!  void gdk_gc_set_colormap (GdkGC *gc, GdkColormap *colormap);
subroutine gdk_gc_set_colormap(gc, colormap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: gc
  type(c_ptr), value :: colormap
end subroutine

! GdkColormap *gdk_gc_get_colormap (GdkGC *gc);
function gdk_gc_get_colormap(gc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_gc_get_colormap
  type(c_ptr), value :: gc
end function

! void gdk_gc_set_rgb_fg_color (GdkGC *gc, const GdkColor *color);
subroutine gdk_gc_set_rgb_fg_color(gc, color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: gc
  type(c_ptr), value :: color
end subroutine

! void gdk_gc_set_rgb_bg_color (GdkGC *gc, const GdkColor *color);
subroutine gdk_gc_set_rgb_bg_color(gc, color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: gc
  type(c_ptr), value :: color
end subroutine

! GdkScreen * gdk_gc_get_screen (GdkGC *gc);
function gdk_gc_get_screen(gc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_gc_get_screen
  type(c_ptr), value :: gc
end function

!   GType gdk_keymap_get_type (void) G_GNUC_CONST;
function gdk_keymap_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_keymap_get_type
end function

!  GdkKeymap* gdk_keymap_get_default (void);
function gdk_keymap_get_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_keymap_get_default
end function

!  GdkKeymap* gdk_keymap_get_for_display (GdkDisplay *display);
function gdk_keymap_get_for_display(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_keymap_get_for_display
  type(c_ptr), value :: display
end function

!  guint gdk_keymap_lookup_key (GdkKeymap *keymap, const GdkKeymapKey *key);
function gdk_keymap_lookup_key(keymap, key) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_keymap_lookup_key
  type(c_ptr), value :: keymap
  type(c_ptr), value :: key
end function

! gboolean gdk_keymap_translate_keyboard_state (GdkKeymap *keymap, guint hardware_keycode, GdkModifierType state, gint group, guint *keyval, gint *effective_group, gint *level, GdkModifierType *consumed_modifiers);
function gdk_keymap_translate_keyboard_state(keymap, hardware_keycode, state, gr&
      &oup, keyval, effective_group, level, consumed_modifiers) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gdk_keymap_translate_keyboard_state
  type(c_ptr), value :: keymap
  integer(c_int), value :: hardware_keycode
  integer(c_int), value :: state
  integer(c_int), value :: group
  type(c_ptr), value :: keyval
  type(c_ptr), value :: effective_group
  type(c_ptr), value :: level
  integer(c_int), value :: consumed_modifiers
end function

! gboolean gdk_keymap_get_entries_for_keyval (GdkKeymap *keymap, guint keyval, GdkKeymapKey **keys, gint *n_keys);
function gdk_keymap_get_entries_for_keyval(keymap, keyval, keys, n_keys) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gdk_keymap_get_entries_for_keyval
  type(c_ptr), value :: keymap
  integer(c_int), value :: keyval
  type(c_ptr), value :: keys
  type(c_ptr), value :: n_keys
end function

! gboolean gdk_keymap_get_entries_for_keycode (GdkKeymap *keymap, guint hardware_keycode, GdkKeymapKey **keys, guint **keyvals, gint *n_entries);
function gdk_keymap_get_entries_for_keycode(keymap, hardware_keycode, keys, keyv&
      &als, n_entries) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gdk_keymap_get_entries_for_keycode
  type(c_ptr), value :: keymap
  integer(c_int), value :: hardware_keycode
  type(c_ptr), value :: keys
  type(c_ptr), value :: keyvals
  type(c_ptr), value :: n_entries
end function

! PangoDirection gdk_keymap_get_direction (GdkKeymap *keymap);
function gdk_keymap_get_direction(keymap) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_keymap_get_direction
  type(c_ptr), value :: keymap
end function

! gboolean gdk_keymap_have_bidi_layouts (GdkKeymap *keymap);
function gdk_keymap_have_bidi_layouts(keymap) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_keymap_have_bidi_layouts
  type(c_ptr), value :: keymap
end function

! gboolean gdk_keymap_get_caps_lock_state (GdkKeymap *keymap);
function gdk_keymap_get_caps_lock_state(keymap) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_keymap_get_caps_lock_state
  type(c_ptr), value :: keymap
end function

! void gdk_keymap_add_virtual_modifiers (GdkKeymap *keymap, GdkModifierType *state);
subroutine gdk_keymap_add_virtual_modifiers(keymap, state) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: keymap
  integer(c_int), value :: state
end subroutine

! gboolean gdk_keymap_map_virtual_modifiers (GdkKeymap *keymap, GdkModifierType *state);
function gdk_keymap_map_virtual_modifiers(keymap, state) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gdk_keymap_map_virtual_modifiers
  type(c_ptr), value :: keymap
  integer(c_int), value :: state
end function

!  gchar* gdk_keyval_name (guint keyval) G_GNUC_CONST;
function gdk_keyval_name(keyval) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_keyval_name
  integer(c_int), value :: keyval
end function

! guint gdk_keyval_from_name (const gchar *keyval_name);
function gdk_keyval_from_name(keyval_name) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: gdk_keyval_from_name
  character(kind=c_char), dimension(*) :: keyval_name
end function

! void gdk_keyval_convert_case (guint symbol, guint *lower, guint *upper);
subroutine gdk_keyval_convert_case(symbol, lower, upper) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int), value :: symbol
  type(c_ptr), value :: lower
  type(c_ptr), value :: upper
end subroutine

! guint gdk_keyval_to_upper (guint keyval) G_GNUC_CONST;
function gdk_keyval_to_upper(keyval) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gdk_keyval_to_upper
  integer(c_int), value :: keyval
end function

! guint gdk_keyval_to_lower (guint keyval) G_GNUC_CONST;
function gdk_keyval_to_lower(keyval) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gdk_keyval_to_lower
  integer(c_int), value :: keyval
end function

! gboolean gdk_keyval_is_upper (guint keyval) G_GNUC_CONST;
function gdk_keyval_is_upper(keyval) bind(c) 
  use iso_c_binding, only: c_bool, c_int
  logical(c_bool) :: gdk_keyval_is_upper
  integer(c_int), value :: keyval
end function

! gboolean gdk_keyval_is_lower (guint keyval) G_GNUC_CONST;
function gdk_keyval_is_lower(keyval) bind(c) 
  use iso_c_binding, only: c_bool, c_int
  logical(c_bool) :: gdk_keyval_is_lower
  integer(c_int), value :: keyval
end function

!  guint32 gdk_keyval_to_unicode (guint keyval) G_GNUC_CONST;
function gdk_keyval_to_unicode(keyval) bind(c) 
  use iso_c_binding, only: c_int32_t, c_int
  integer(c_int32_t) :: gdk_keyval_to_unicode
  integer(c_int), value :: keyval
end function

! guint gdk_unicode_to_keyval (guint32 wc) G_GNUC_CONST;
function gdk_unicode_to_keyval(wc) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: gdk_unicode_to_keyval
  integer(c_int32_t), value :: wc
end function

!   GType gdk_pango_renderer_get_type (void) G_GNUC_CONST;
function gdk_pango_renderer_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_pango_renderer_get_type
end function

!  PangoRenderer *gdk_pango_renderer_new (GdkScreen *screen);
function gdk_pango_renderer_new(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pango_renderer_new
  type(c_ptr), value :: screen
end function

! PangoRenderer *gdk_pango_renderer_get_default (GdkScreen *screen);
function gdk_pango_renderer_get_default(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pango_renderer_get_default
  type(c_ptr), value :: screen
end function

!  void gdk_pango_renderer_set_drawable (GdkPangoRenderer *gdk_renderer, GdkDrawable *drawable);
subroutine gdk_pango_renderer_set_drawable(gdk_renderer, drawable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: gdk_renderer
  type(c_ptr), value :: drawable
end subroutine

! void gdk_pango_renderer_set_gc (GdkPangoRenderer *gdk_renderer, GdkGC *gc);
subroutine gdk_pango_renderer_set_gc(gdk_renderer, gc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: gdk_renderer
  type(c_ptr), value :: gc
end subroutine

! void gdk_pango_renderer_set_stipple (GdkPangoRenderer *gdk_renderer, PangoRenderPart part, GdkBitmap *stipple);
subroutine gdk_pango_renderer_set_stipple(gdk_renderer, part, stipple) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: gdk_renderer
  integer(c_int), value :: part
  type(c_ptr), value :: stipple
end subroutine

! void gdk_pango_renderer_set_override_color (GdkPangoRenderer *gdk_renderer, PangoRenderPart part, const GdkColor *color);
subroutine gdk_pango_renderer_set_override_color(gdk_renderer, part, color) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: gdk_renderer
  integer(c_int), value :: part
  type(c_ptr), value :: color
end subroutine

!  PangoContext *gdk_pango_context_get_for_screen (GdkScreen *screen);
function gdk_pango_context_get_for_screen(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pango_context_get_for_screen
  type(c_ptr), value :: screen
end function

!  PangoContext *gdk_pango_context_get (void);
function gdk_pango_context_get() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pango_context_get
end function

!  void gdk_pango_context_set_colormap (PangoContext *context, GdkColormap *colormap);
subroutine gdk_pango_context_set_colormap(context, colormap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: colormap
end subroutine

!  GdkRegion *gdk_pango_layout_line_get_clip_region (PangoLayoutLine *line, gint x_origin, gint y_origin, const gint *index_ranges, gint n_ranges);
function gdk_pango_layout_line_get_clip_region(line, x_origin, y_origin, index_r&
      &anges, n_ranges) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_pango_layout_line_get_clip_region
  type(c_ptr), value :: line
  integer(c_int), value :: x_origin
  integer(c_int), value :: y_origin
  type(c_ptr), value :: index_ranges
  integer(c_int), value :: n_ranges
end function

! GdkRegion *gdk_pango_layout_get_clip_region (PangoLayout *layout, gint x_origin, gint y_origin, const gint *index_ranges, gint n_ranges);
function gdk_pango_layout_get_clip_region(layout, x_origin, y_origin, index_rang&
      &es, n_ranges) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_pango_layout_get_clip_region
  type(c_ptr), value :: layout
  integer(c_int), value :: x_origin
  integer(c_int), value :: y_origin
  type(c_ptr), value :: index_ranges
  integer(c_int), value :: n_ranges
end function

!  PangoAttribute *gdk_pango_attr_stipple_new (GdkBitmap *stipple);
function gdk_pango_attr_stipple_new(stipple) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pango_attr_stipple_new
  type(c_ptr), value :: stipple
end function

! PangoAttribute *gdk_pango_attr_embossed_new (gboolean embossed);
function gdk_pango_attr_embossed_new(embossed) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: gdk_pango_attr_embossed_new
  logical(c_bool), value :: embossed
end function

! PangoAttribute *gdk_pango_attr_emboss_color_new (const GdkColor *color);
function gdk_pango_attr_emboss_color_new(color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pango_attr_emboss_color_new
  type(c_ptr), value :: color
end function

!   void gdk_parse_args (gint *argc, gchar ***argv);
subroutine gdk_parse_args(argc, argv) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: argc
  character(kind=c_char), dimension(*) :: argv
end subroutine

! void gdk_init (gint *argc, gchar ***argv);
subroutine gdk_init(argc, argv) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: argc
  character(kind=c_char), dimension(*) :: argv
end subroutine

! gboolean gdk_init_check (gint *argc, gchar ***argv);
function gdk_init_check(argc, argv) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gdk_init_check
  type(c_ptr), value :: argc
  character(kind=c_char), dimension(*) :: argv
end function

! void gdk_add_option_entries_libgtk_only (GOptionGroup *group);
subroutine gdk_add_option_entries_libgtk_only(group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: group
end subroutine

! void gdk_pre_parse_libgtk_only (void);
subroutine gdk_pre_parse_libgtk_only() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  void gdk_exit (gint error_code);
subroutine gdk_exit(error_code) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: error_code
end subroutine

!  gchar* gdk_set_locale (void);
function gdk_set_locale() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_set_locale
end function

!  G_CONST_RETURN char *gdk_get_program_class (void);
function gdk_get_program_class() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_get_program_class
end function

! void gdk_set_program_class (const char *program_class);
subroutine gdk_set_program_class(program_class) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: program_class
end subroutine

!  void gdk_error_trap_push (void);
subroutine gdk_error_trap_push() bind(c) 
  use iso_c_binding, only: 
end subroutine

! gint gdk_error_trap_pop (void);
function gdk_error_trap_pop() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gdk_error_trap_pop
end function

!  void gdk_set_use_xshm (gboolean use_xshm);
subroutine gdk_set_use_xshm(use_xshm) bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool), value :: use_xshm
end subroutine

! gboolean gdk_get_use_xshm (void);
function gdk_get_use_xshm() bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool) :: gdk_get_use_xshm
end function

!  gchar* gdk_get_display (void);
function gdk_get_display() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_get_display
end function

! G_CONST_RETURN gchar* gdk_get_display_arg_name (void);
function gdk_get_display_arg_name() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_get_display_arg_name
end function

!  gint gdk_input_add_full (gint source, GdkInputCondition condition, GdkInputFunction function, gpointer data, GDestroyNotify destroy);
function gdk_input_add_full(source, condition, function, data, destroy) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: gdk_input_add_full
  integer(c_int), value :: source
  integer(c_int), value :: condition
  type(c_funptr), value :: function
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end function

!  gint gdk_input_add (gint source, GdkInputCondition condition, GdkInputFunction function, gpointer data);
function gdk_input_add(source, condition, function, data) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: gdk_input_add
  integer(c_int), value :: source
  integer(c_int), value :: condition
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

! void gdk_input_remove (gint tag);
subroutine gdk_input_remove(tag) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: tag
end subroutine

!  GdkGrabStatus gdk_pointer_grab (GdkWindow *window, gboolean owner_events, GdkEventMask event_mask, GdkWindow *confine_to, GdkCursor *cursor, guint32 time_);
function gdk_pointer_grab(window, owner_events, event_mask, confine_to, cursor, &
      &time_) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_bool, c_int32_t
  integer(c_int) :: gdk_pointer_grab
  type(c_ptr), value :: window
  logical(c_bool), value :: owner_events
  integer(c_int), value :: event_mask
  type(c_ptr), value :: confine_to
  type(c_ptr), value :: cursor
  integer(c_int32_t), value :: time_
end function

! GdkGrabStatus gdk_keyboard_grab (GdkWindow *window, gboolean owner_events, guint32 time_);
function gdk_keyboard_grab(window, owner_events, time_) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_bool, c_int32_t
  integer(c_int) :: gdk_keyboard_grab
  type(c_ptr), value :: window
  logical(c_bool), value :: owner_events
  integer(c_int32_t), value :: time_
end function

!  gboolean gdk_pointer_grab_info_libgtk_only (GdkDisplay *display, GdkWindow **grab_window, gboolean *owner_events);
function gdk_pointer_grab_info_libgtk_only(display, grab_window, owner_events) b&
      &ind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_pointer_grab_info_libgtk_only
  type(c_ptr), value :: display
  type(c_ptr), value :: grab_window
  type(c_ptr), value :: owner_events
end function

! gboolean gdk_keyboard_grab_info_libgtk_only (GdkDisplay *display, GdkWindow **grab_window, gboolean *owner_events);
function gdk_keyboard_grab_info_libgtk_only(display, grab_window, owner_events) &
      &bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_keyboard_grab_info_libgtk_only
  type(c_ptr), value :: display
  type(c_ptr), value :: grab_window
  type(c_ptr), value :: owner_events
end function

!  void gdk_pointer_ungrab (guint32 time_);
subroutine gdk_pointer_ungrab(time_) bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t), value :: time_
end subroutine

! void gdk_keyboard_ungrab (guint32 time_);
subroutine gdk_keyboard_ungrab(time_) bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t), value :: time_
end subroutine

! gboolean gdk_pointer_is_grabbed (void);
function gdk_pointer_is_grabbed() bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool) :: gdk_pointer_is_grabbed
end function

!  gint gdk_screen_width (void) G_GNUC_CONST;
function gdk_screen_width() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gdk_screen_width
end function

! gint gdk_screen_height (void) G_GNUC_CONST;
function gdk_screen_height() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gdk_screen_height
end function

!  gint gdk_screen_width_mm (void) G_GNUC_CONST;
function gdk_screen_width_mm() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gdk_screen_width_mm
end function

! gint gdk_screen_height_mm (void) G_GNUC_CONST;
function gdk_screen_height_mm() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gdk_screen_height_mm
end function

!  void gdk_beep (void);
subroutine gdk_beep() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  void gdk_flush (void);
subroutine gdk_flush() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  void gdk_set_double_click_time (guint msec);
subroutine gdk_set_double_click_time(msec) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: msec
end subroutine

!  gboolean gdk_rectangle_intersect (const GdkRectangle *src1, const GdkRectangle *src2, GdkRectangle *dest);
function gdk_rectangle_intersect(src1, src2, dest) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_rectangle_intersect
  type(c_ptr), value :: src1
  type(c_ptr), value :: src2
  type(c_ptr), value :: dest
end function

! void gdk_rectangle_union (const GdkRectangle *src1, const GdkRectangle *src2, GdkRectangle *dest);
subroutine gdk_rectangle_union(src1, src2, dest) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: src1
  type(c_ptr), value :: src2
  type(c_ptr), value :: dest
end subroutine

!  GType gdk_rectangle_get_type (void) G_GNUC_CONST;
function gdk_rectangle_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_rectangle_get_type
end function

!  gchar *gdk_wcstombs (const GdkWChar *src);
function gdk_wcstombs(src) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_wcstombs
  type(c_ptr), value :: src
end function

! gint gdk_mbstowcs (GdkWChar *dest, const gchar *src, gint dest_max);
function gdk_mbstowcs(dest, src, dest_max) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gdk_mbstowcs
  type(c_ptr), value :: dest
  character(kind=c_char), dimension(*) :: src
  integer(c_int), value :: dest_max
end function

!  gboolean gdk_event_send_client_message (GdkEvent *event, GdkNativeWindow winid);
function gdk_event_send_client_message(event, winid) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_event_send_client_message
  type(c_ptr), value :: event
  type(c_ptr), value :: winid
end function

! void gdk_event_send_clientmessage_toall (GdkEvent *event);
subroutine gdk_event_send_clientmessage_toall(event) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: event
end subroutine

!  gboolean gdk_event_send_client_message_for_display (GdkDisplay *display, GdkEvent *event, GdkNativeWindow winid);
function gdk_event_send_client_message_for_display(display, event, winid) bind(c&
      &) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_event_send_client_message_for_display
  type(c_ptr), value :: display
  type(c_ptr), value :: event
  type(c_ptr), value :: winid
end function

!  void gdk_notify_startup_complete (void);
subroutine gdk_notify_startup_complete() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  void gdk_notify_startup_complete_with_id (const gchar* startup_id);
subroutine gdk_notify_startup_complete_with_id(startup_id) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: startup_id
end subroutine

!  void gdk_threads_enter (void);
subroutine gdk_threads_enter() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void gdk_threads_leave (void);
subroutine gdk_threads_leave() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void gdk_threads_init (void);
subroutine gdk_threads_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void gdk_threads_set_lock_functions (GCallback enter_fn, GCallback leave_fn);
subroutine gdk_threads_set_lock_functions(enter_fn, leave_fn) bind(c) 
  use iso_c_binding, only: c_funptr
  type(c_funptr), value :: enter_fn
  type(c_funptr), value :: leave_fn
end subroutine

!  guint gdk_threads_add_idle_full (gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify);
function gdk_threads_add_idle_full(priority, function, data, notify) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: gdk_threads_add_idle_full
  integer(c_int), value :: priority
  type(c_funptr), value :: function
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end function

! guint gdk_threads_add_idle (GSourceFunc function, gpointer data);
function gdk_threads_add_idle(function, data) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: gdk_threads_add_idle
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

! guint gdk_threads_add_timeout_full (gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify);
function gdk_threads_add_timeout_full(priority, interval, function, data, notify&
      &) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: gdk_threads_add_timeout_full
  integer(c_int), value :: priority
  integer(c_int), value :: interval
  type(c_funptr), value :: function
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end function

! guint gdk_threads_add_timeout (guint interval, GSourceFunc function, gpointer data);
function gdk_threads_add_timeout(interval, function, data) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: gdk_threads_add_timeout
  integer(c_int), value :: interval
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

! guint gdk_threads_add_timeout_seconds_full (gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify);
function gdk_threads_add_timeout_seconds_full(priority, interval, function, data&
      &, notify) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: gdk_threads_add_timeout_seconds_full
  integer(c_int), value :: priority
  integer(c_int), value :: interval
  type(c_funptr), value :: function
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end function

! guint gdk_threads_add_timeout_seconds (guint interval, GSourceFunc function, gpointer data);
function gdk_threads_add_timeout_seconds(interval, function, data) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: gdk_threads_add_timeout_seconds
  integer(c_int), value :: interval
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

!  GType gdk_event_get_type (void) G_GNUC_CONST;
function gdk_event_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_event_get_type
end function

!  gboolean gdk_events_pending (void);
function gdk_events_pending() bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool) :: gdk_events_pending
end function

! GdkEvent* gdk_event_get (void);
function gdk_event_get() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_event_get
end function

!  GdkEvent* gdk_event_peek (void);
function gdk_event_peek() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_event_peek
end function

!  GdkEvent* gdk_event_get_graphics_expose (GdkWindow *window);
function gdk_event_get_graphics_expose(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_event_get_graphics_expose
  type(c_ptr), value :: window
end function

!  void gdk_event_put (const GdkEvent *event);
subroutine gdk_event_put(event) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: event
end subroutine

!  GdkEvent* gdk_event_new (GdkEventType type);
function gdk_event_new(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_event_new
  integer(c_int), value :: type
end function

! GdkEvent* gdk_event_copy (const GdkEvent *event);
function gdk_event_copy(event) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_event_copy
  type(c_ptr), value :: event
end function

! void gdk_event_free (GdkEvent *event);
subroutine gdk_event_free(event) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: event
end subroutine

!  guint32 gdk_event_get_time (const GdkEvent *event);
function gdk_event_get_time(event) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: gdk_event_get_time
  type(c_ptr), value :: event
end function

! gboolean gdk_event_get_state (const GdkEvent *event, GdkModifierType *state);
function gdk_event_get_state(event, state) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gdk_event_get_state
  type(c_ptr), value :: event
  integer(c_int), value :: state
end function

! gboolean gdk_event_get_coords (const GdkEvent *event, gdouble *x_win, gdouble *y_win);
function gdk_event_get_coords(event, x_win, y_win) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_event_get_coords
  type(c_ptr), value :: event
  type(c_ptr), value :: x_win
  type(c_ptr), value :: y_win
end function

! gboolean gdk_event_get_root_coords (const GdkEvent *event, gdouble *x_root, gdouble *y_root);
function gdk_event_get_root_coords(event, x_root, y_root) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_event_get_root_coords
  type(c_ptr), value :: event
  type(c_ptr), value :: x_root
  type(c_ptr), value :: y_root
end function

! gboolean gdk_event_get_axis (const GdkEvent *event, GdkAxisUse axis_use, gdouble *value);
function gdk_event_get_axis(event, axis_use, value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gdk_event_get_axis
  type(c_ptr), value :: event
  integer(c_int), value :: axis_use
  type(c_ptr), value :: value
end function

! void gdk_event_request_motions (const GdkEventMotion *event);
subroutine gdk_event_request_motions(event) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: event
end subroutine

! void gdk_event_handler_set (GdkEventFunc func, gpointer data, GDestroyNotify notify);
subroutine gdk_event_handler_set(func, data, notify) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end subroutine

!  void gdk_event_set_screen (GdkEvent *event, GdkScreen *screen);
subroutine gdk_event_set_screen(event, screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: event
  type(c_ptr), value :: screen
end subroutine

! GdkScreen *gdk_event_get_screen (const GdkEvent *event);
function gdk_event_get_screen(event) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_event_get_screen
  type(c_ptr), value :: event
end function

!  void gdk_set_show_events (gboolean show_events);
subroutine gdk_set_show_events(show_events) bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool), value :: show_events
end subroutine

! gboolean gdk_get_show_events (void);
function gdk_get_show_events() bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool) :: gdk_get_show_events
end function

!  void gdk_add_client_message_filter (GdkAtom message_type, GdkFilterFunc func, gpointer data);
subroutine gdk_add_client_message_filter(message_type, func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: message_type
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end subroutine

!  gboolean gdk_setting_get (const gchar *name, GValue *value);
function gdk_setting_get(name, value) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_ptr
  logical(c_bool) :: gdk_setting_get
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: value
end function

!   GType gdk_drag_context_get_type (void) G_GNUC_CONST;
function gdk_drag_context_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_drag_context_get_type
end function

! GdkDragContext * gdk_drag_context_new (void);
function gdk_drag_context_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_drag_context_new
end function

!  GList *gdk_drag_context_list_targets (GdkDragContext *context);
function gdk_drag_context_list_targets(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_drag_context_list_targets
  type(c_ptr), value :: context
end function

! GdkDragAction gdk_drag_context_get_actions (GdkDragContext *context);
function gdk_drag_context_get_actions(context) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_drag_context_get_actions
  type(c_ptr), value :: context
end function

! GdkDragAction gdk_drag_context_get_suggested_action (GdkDragContext *context);
function gdk_drag_context_get_suggested_action(context) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_drag_context_get_suggested_action
  type(c_ptr), value :: context
end function

! GdkDragAction gdk_drag_context_get_selected_action (GdkDragContext *context);
function gdk_drag_context_get_selected_action(context) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_drag_context_get_selected_action
  type(c_ptr), value :: context
end function

!  GdkWindow *gdk_drag_context_get_source_window (GdkDragContext *context);
function gdk_drag_context_get_source_window(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_drag_context_get_source_window
  type(c_ptr), value :: context
end function

!  void gdk_drag_context_ref (GdkDragContext *context);
subroutine gdk_drag_context_ref(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

! void gdk_drag_context_unref (GdkDragContext *context);
subroutine gdk_drag_context_unref(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

!  void gdk_drag_status (GdkDragContext *context, GdkDragAction action, guint32 time_);
subroutine gdk_drag_status(context, action, time_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int32_t
  type(c_ptr), value :: context
  integer(c_int), value :: action
  integer(c_int32_t), value :: time_
end subroutine

! void gdk_drop_reply (GdkDragContext *context, gboolean ok, guint32 time_);
subroutine gdk_drop_reply(context, ok, time_) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_int32_t
  type(c_ptr), value :: context
  logical(c_bool), value :: ok
  integer(c_int32_t), value :: time_
end subroutine

! void gdk_drop_finish (GdkDragContext *context, gboolean success, guint32 time_);
subroutine gdk_drop_finish(context, success, time_) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_int32_t
  type(c_ptr), value :: context
  logical(c_bool), value :: success
  integer(c_int32_t), value :: time_
end subroutine

! GdkAtom gdk_drag_get_selection (GdkDragContext *context);
function gdk_drag_get_selection(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_drag_get_selection
  type(c_ptr), value :: context
end function

!  GdkDragContext * gdk_drag_begin (GdkWindow *window, GList *targets);
function gdk_drag_begin(window, targets) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_drag_begin
  type(c_ptr), value :: window
  type(c_ptr), value :: targets
end function

!  GdkNativeWindow gdk_drag_get_protocol_for_display (GdkDisplay *display, GdkNativeWindow xid, GdkDragProtocol *protocol);
function gdk_drag_get_protocol_for_display(display, xid, protocol) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_drag_get_protocol_for_display
  type(c_ptr), value :: display
  type(c_ptr), value :: xid
  integer(c_int), value :: protocol
end function

!  void gdk_drag_find_window_for_screen (GdkDragContext *context, GdkWindow *drag_window, GdkScreen *screen, gint x_root, gint y_root, GdkWindow **dest_window, GdkDragProtocol *protocol);
subroutine gdk_drag_find_window_for_screen(context, drag_window, screen, x_root,&
      & y_root, dest_window, protocol) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: context
  type(c_ptr), value :: drag_window
  type(c_ptr), value :: screen
  integer(c_int), value :: x_root
  integer(c_int), value :: y_root
  type(c_ptr), value :: dest_window
  integer(c_int), value :: protocol
end subroutine

!  GdkNativeWindow gdk_drag_get_protocol (GdkNativeWindow xid, GdkDragProtocol *protocol);
function gdk_drag_get_protocol(xid, protocol) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_drag_get_protocol
  type(c_ptr), value :: xid
  integer(c_int), value :: protocol
end function

!  void gdk_drag_find_window (GdkDragContext *context, GdkWindow *drag_window, gint x_root, gint y_root, GdkWindow **dest_window, GdkDragProtocol *protocol);
subroutine gdk_drag_find_window(context, drag_window, x_root, y_root, dest_windo&
      &w, protocol) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: context
  type(c_ptr), value :: drag_window
  integer(c_int), value :: x_root
  integer(c_int), value :: y_root
  type(c_ptr), value :: dest_window
  integer(c_int), value :: protocol
end subroutine

!  gboolean gdk_drag_motion (GdkDragContext *context, GdkWindow *dest_window, GdkDragProtocol protocol, gint x_root, gint y_root, GdkDragAction suggested_action, GdkDragAction possible_actions, guint32 time_);
function gdk_drag_motion(context, dest_window, protocol, x_root, y_root, suggest&
      &ed_action, possible_actions, time_) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int, c_int32_t
  logical(c_bool) :: gdk_drag_motion
  type(c_ptr), value :: context
  type(c_ptr), value :: dest_window
  integer(c_int), value :: protocol
  integer(c_int), value :: x_root
  integer(c_int), value :: y_root
  integer(c_int), value :: suggested_action
  integer(c_int), value :: possible_actions
  integer(c_int32_t), value :: time_
end function

! void gdk_drag_drop (GdkDragContext *context, guint32 time_);
subroutine gdk_drag_drop(context, time_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: context
  integer(c_int32_t), value :: time_
end subroutine

! void gdk_drag_abort (GdkDragContext *context, guint32 time_);
subroutine gdk_drag_abort(context, time_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: context
  integer(c_int32_t), value :: time_
end subroutine

! gboolean gdk_drag_drop_succeeded (GdkDragContext *context);
function gdk_drag_drop_succeeded(context) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_drag_drop_succeeded
  type(c_ptr), value :: context
end function

!   GType gtk_assistant_get_type (void) G_GNUC_CONST;
function gtk_assistant_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_assistant_get_type
end function

! GtkWidget *gtk_assistant_new (void);
function gtk_assistant_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_assistant_new
end function

! gint gtk_assistant_get_current_page (GtkAssistant *assistant);
function gtk_assistant_get_current_page(assistant) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_assistant_get_current_page
  type(c_ptr), value :: assistant
end function

! void gtk_assistant_set_current_page (GtkAssistant *assistant, gint page_num);
subroutine gtk_assistant_set_current_page(assistant, page_num) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: assistant
  integer(c_int), value :: page_num
end subroutine

! gint gtk_assistant_get_n_pages (GtkAssistant *assistant);
function gtk_assistant_get_n_pages(assistant) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_assistant_get_n_pages
  type(c_ptr), value :: assistant
end function

! GtkWidget *gtk_assistant_get_nth_page (GtkAssistant *assistant, gint page_num);
function gtk_assistant_get_nth_page(assistant, page_num) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_assistant_get_nth_page
  type(c_ptr), value :: assistant
  integer(c_int), value :: page_num
end function

! gint gtk_assistant_prepend_page (GtkAssistant *assistant, GtkWidget *page);
function gtk_assistant_prepend_page(assistant, page) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_assistant_prepend_page
  type(c_ptr), value :: assistant
  type(c_ptr), value :: page
end function

! gint gtk_assistant_append_page (GtkAssistant *assistant, GtkWidget *page);
function gtk_assistant_append_page(assistant, page) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_assistant_append_page
  type(c_ptr), value :: assistant
  type(c_ptr), value :: page
end function

! gint gtk_assistant_insert_page (GtkAssistant *assistant, GtkWidget *page, gint position);
function gtk_assistant_insert_page(assistant, page, position) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_assistant_insert_page
  type(c_ptr), value :: assistant
  type(c_ptr), value :: page
  integer(c_int), value :: position
end function

! void gtk_assistant_set_forward_page_func (GtkAssistant *assistant, GtkAssistantPageFunc page_func, gpointer data, GDestroyNotify destroy);
subroutine gtk_assistant_set_forward_page_func(assistant, page_func, data, destr&
      &oy) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: assistant
  type(c_funptr), value :: page_func
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

! void gtk_assistant_set_page_type (GtkAssistant *assistant, GtkWidget *page, GtkAssistantPageType type);
subroutine gtk_assistant_set_page_type(assistant, page, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: assistant
  type(c_ptr), value :: page
  integer(c_int), value :: type
end subroutine

! GtkAssistantPageType gtk_assistant_get_page_type (GtkAssistant *assistant, GtkWidget *page);
function gtk_assistant_get_page_type(assistant, page) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_assistant_get_page_type
  type(c_ptr), value :: assistant
  type(c_ptr), value :: page
end function

! void gtk_assistant_set_page_title (GtkAssistant *assistant, GtkWidget *page, const gchar *title);
subroutine gtk_assistant_set_page_title(assistant, page, title) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: assistant
  type(c_ptr), value :: page
  character(kind=c_char), dimension(*) :: title
end subroutine

! G_CONST_RETURN gchar *gtk_assistant_get_page_title (GtkAssistant *assistant, GtkWidget *page);
function gtk_assistant_get_page_title(assistant, page) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_assistant_get_page_title
  type(c_ptr), value :: assistant
  type(c_ptr), value :: page
end function

! void gtk_assistant_set_page_header_image (GtkAssistant *assistant, GtkWidget *page, GdkPixbuf *pixbuf);
subroutine gtk_assistant_set_page_header_image(assistant, page, pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: assistant
  type(c_ptr), value :: page
  type(c_ptr), value :: pixbuf
end subroutine

! GdkPixbuf *gtk_assistant_get_page_header_image (GtkAssistant *assistant, GtkWidget *page);
function gtk_assistant_get_page_header_image(assistant, page) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_assistant_get_page_header_image
  type(c_ptr), value :: assistant
  type(c_ptr), value :: page
end function

! void gtk_assistant_set_page_side_image (GtkAssistant *assistant, GtkWidget *page, GdkPixbuf *pixbuf);
subroutine gtk_assistant_set_page_side_image(assistant, page, pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: assistant
  type(c_ptr), value :: page
  type(c_ptr), value :: pixbuf
end subroutine

! GdkPixbuf *gtk_assistant_get_page_side_image (GtkAssistant *assistant, GtkWidget *page);
function gtk_assistant_get_page_side_image(assistant, page) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_assistant_get_page_side_image
  type(c_ptr), value :: assistant
  type(c_ptr), value :: page
end function

! void gtk_assistant_set_page_complete (GtkAssistant *assistant, GtkWidget *page, gboolean complete);
subroutine gtk_assistant_set_page_complete(assistant, page, complete) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: assistant
  type(c_ptr), value :: page
  logical(c_bool), value :: complete
end subroutine

! gboolean gtk_assistant_get_page_complete (GtkAssistant *assistant, GtkWidget *page);
function gtk_assistant_get_page_complete(assistant, page) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_assistant_get_page_complete
  type(c_ptr), value :: assistant
  type(c_ptr), value :: page
end function

! void gtk_assistant_add_action_widget (GtkAssistant *assistant, GtkWidget *child);
subroutine gtk_assistant_add_action_widget(assistant, child) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: assistant
  type(c_ptr), value :: child
end subroutine

! void gtk_assistant_remove_action_widget (GtkAssistant *assistant, GtkWidget *child);
subroutine gtk_assistant_remove_action_widget(assistant, child) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: assistant
  type(c_ptr), value :: child
end subroutine

!  void gtk_assistant_update_buttons_state (GtkAssistant *assistant);
subroutine gtk_assistant_update_buttons_state(assistant) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: assistant
end subroutine

! void gtk_assistant_commit (GtkAssistant *assistant);
subroutine gtk_assistant_commit(assistant) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: assistant
end subroutine

!   GType gtk_misc_get_type (void) G_GNUC_CONST;
function gtk_misc_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_misc_get_type
end function

! void gtk_misc_set_alignment (GtkMisc *misc, gfloat xalign, gfloat yalign);
subroutine gtk_misc_set_alignment(misc, xalign, yalign) bind(c) 
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: misc
  real(c_float), value :: xalign
  real(c_float), value :: yalign
end subroutine

! void gtk_misc_get_alignment (GtkMisc *misc, gfloat *xalign, gfloat *yalign);
subroutine gtk_misc_get_alignment(misc, xalign, yalign) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: misc
  type(c_ptr), value :: xalign
  type(c_ptr), value :: yalign
end subroutine

! void gtk_misc_set_padding (GtkMisc *misc, gint xpad, gint ypad);
subroutine gtk_misc_set_padding(misc, xpad, ypad) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: misc
  integer(c_int), value :: xpad
  integer(c_int), value :: ypad
end subroutine

! void gtk_misc_get_padding (GtkMisc *misc, gint *xpad, gint *ypad);
subroutine gtk_misc_get_padding(misc, xpad, ypad) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: misc
  type(c_ptr), value :: xpad
  type(c_ptr), value :: ypad
end subroutine

!   GType gtk_paned_get_type (void) G_GNUC_CONST;
function gtk_paned_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_paned_get_type
end function

! void gtk_paned_add1 (GtkPaned *paned, GtkWidget *child);
subroutine gtk_paned_add1(paned, child) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: paned
  type(c_ptr), value :: child
end subroutine

! void gtk_paned_add2 (GtkPaned *paned, GtkWidget *child);
subroutine gtk_paned_add2(paned, child) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: paned
  type(c_ptr), value :: child
end subroutine

! void gtk_paned_pack1 (GtkPaned *paned, GtkWidget *child, gboolean resize, gboolean shrink);
subroutine gtk_paned_pack1(paned, child, resize, shrink) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: paned
  type(c_ptr), value :: child
  logical(c_bool), value :: resize
  logical(c_bool), value :: shrink
end subroutine

! void gtk_paned_pack2 (GtkPaned *paned, GtkWidget *child, gboolean resize, gboolean shrink);
subroutine gtk_paned_pack2(paned, child, resize, shrink) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: paned
  type(c_ptr), value :: child
  logical(c_bool), value :: resize
  logical(c_bool), value :: shrink
end subroutine

!  gint gtk_paned_get_position (GtkPaned *paned);
function gtk_paned_get_position(paned) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_paned_get_position
  type(c_ptr), value :: paned
end function

! void gtk_paned_set_position (GtkPaned *paned, gint position);
subroutine gtk_paned_set_position(paned, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: paned
  integer(c_int), value :: position
end subroutine

!  GtkWidget * gtk_paned_get_child1 (GtkPaned *paned);
function gtk_paned_get_child1(paned) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_paned_get_child1
  type(c_ptr), value :: paned
end function

! GtkWidget * gtk_paned_get_child2 (GtkPaned *paned);
function gtk_paned_get_child2(paned) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_paned_get_child2
  type(c_ptr), value :: paned
end function

!  GdkWindow * gtk_paned_get_handle_window (GtkPaned *paned);
function gtk_paned_get_handle_window(paned) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_paned_get_handle_window
  type(c_ptr), value :: paned
end function

!  void gtk_paned_compute_position (GtkPaned *paned, gint allocation, gint child1_req, gint child2_req);
subroutine gtk_paned_compute_position(paned, allocation, child1_req, child2_req)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: paned
  integer(c_int), value :: allocation
  integer(c_int), value :: child1_req
  integer(c_int), value :: child2_req
end subroutine

!   GType gtk_tool_button_get_type (void) G_GNUC_CONST;
function gtk_tool_button_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tool_button_get_type
end function

! GtkToolItem *gtk_tool_button_new (GtkWidget *icon_widget, const gchar *label);
function gtk_tool_button_new(icon_widget, label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_tool_button_new
  type(c_ptr), value :: icon_widget
  character(kind=c_char), dimension(*) :: label
end function

! GtkToolItem *gtk_tool_button_new_from_stock (const gchar *stock_id);
function gtk_tool_button_new_from_stock(stock_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_tool_button_new_from_stock
  character(kind=c_char), dimension(*) :: stock_id
end function

!  void gtk_tool_button_set_label (GtkToolButton *button, const gchar *label);
subroutine gtk_tool_button_set_label(button, label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: button
  character(kind=c_char), dimension(*) :: label
end subroutine

! G_CONST_RETURN gchar *gtk_tool_button_get_label (GtkToolButton *button);
function gtk_tool_button_get_label(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tool_button_get_label
  type(c_ptr), value :: button
end function

! void gtk_tool_button_set_use_underline (GtkToolButton *button, gboolean use_underline);
subroutine gtk_tool_button_set_use_underline(button, use_underline) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: button
  logical(c_bool), value :: use_underline
end subroutine

! gboolean gtk_tool_button_get_use_underline (GtkToolButton *button);
function gtk_tool_button_get_use_underline(button) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tool_button_get_use_underline
  type(c_ptr), value :: button
end function

! void gtk_tool_button_set_stock_id (GtkToolButton *button, const gchar *stock_id);
subroutine gtk_tool_button_set_stock_id(button, stock_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: button
  character(kind=c_char), dimension(*) :: stock_id
end subroutine

! G_CONST_RETURN gchar *gtk_tool_button_get_stock_id (GtkToolButton *button);
function gtk_tool_button_get_stock_id(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tool_button_get_stock_id
  type(c_ptr), value :: button
end function

! void gtk_tool_button_set_icon_name (GtkToolButton *button, const gchar *icon_name);
subroutine gtk_tool_button_set_icon_name(button, icon_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: button
  character(kind=c_char), dimension(*) :: icon_name
end subroutine

! G_CONST_RETURN gchar *gtk_tool_button_get_icon_name (GtkToolButton *button);
function gtk_tool_button_get_icon_name(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tool_button_get_icon_name
  type(c_ptr), value :: button
end function

! void gtk_tool_button_set_icon_widget (GtkToolButton *button, GtkWidget *icon_widget);
subroutine gtk_tool_button_set_icon_widget(button, icon_widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: button
  type(c_ptr), value :: icon_widget
end subroutine

! GtkWidget * gtk_tool_button_get_icon_widget (GtkToolButton *button);
function gtk_tool_button_get_icon_widget(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tool_button_get_icon_widget
  type(c_ptr), value :: button
end function

! void gtk_tool_button_set_label_widget (GtkToolButton *button, GtkWidget *label_widget);
subroutine gtk_tool_button_set_label_widget(button, label_widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: button
  type(c_ptr), value :: label_widget
end subroutine

! GtkWidget * gtk_tool_button_get_label_widget (GtkToolButton *button);
function gtk_tool_button_get_label_widget(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tool_button_get_label_widget
  type(c_ptr), value :: button
end function

!   GType gtk_settings_get_type (void) G_GNUC_CONST;
function gtk_settings_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_settings_get_type
end function

!  GtkSettings* gtk_settings_get_default (void);
function gtk_settings_get_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_settings_get_default
end function

!  GtkSettings* gtk_settings_get_for_screen (GdkScreen *screen);
function gtk_settings_get_for_screen(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_settings_get_for_screen
  type(c_ptr), value :: screen
end function

!  void gtk_settings_install_property (GParamSpec *pspec);
subroutine gtk_settings_install_property(pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pspec
end subroutine

! void gtk_settings_install_property_parser (GParamSpec *pspec, GtkRcPropertyParser parser);
subroutine gtk_settings_install_property_parser(pspec, parser) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: pspec
  type(c_funptr), value :: parser
end subroutine

!  gboolean gtk_rc_property_parse_color (const GParamSpec *pspec, const GString *gstring, GValue *property_value);
function gtk_rc_property_parse_color(pspec, gstring, property_value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_rc_property_parse_color
  type(c_ptr), value :: pspec
  type(c_ptr), value :: gstring
  type(c_ptr), value :: property_value
end function

! gboolean gtk_rc_property_parse_enum (const GParamSpec *pspec, const GString *gstring, GValue *property_value);
function gtk_rc_property_parse_enum(pspec, gstring, property_value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_rc_property_parse_enum
  type(c_ptr), value :: pspec
  type(c_ptr), value :: gstring
  type(c_ptr), value :: property_value
end function

! gboolean gtk_rc_property_parse_flags (const GParamSpec *pspec, const GString *gstring, GValue *property_value);
function gtk_rc_property_parse_flags(pspec, gstring, property_value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_rc_property_parse_flags
  type(c_ptr), value :: pspec
  type(c_ptr), value :: gstring
  type(c_ptr), value :: property_value
end function

! gboolean gtk_rc_property_parse_requisition (const GParamSpec *pspec, const GString *gstring, GValue *property_value);
function gtk_rc_property_parse_requisition(pspec, gstring, property_value) bind(&
      &c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_rc_property_parse_requisition
  type(c_ptr), value :: pspec
  type(c_ptr), value :: gstring
  type(c_ptr), value :: property_value
end function

! gboolean gtk_rc_property_parse_border (const GParamSpec *pspec, const GString *gstring, GValue *property_value);
function gtk_rc_property_parse_border(pspec, gstring, property_value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_rc_property_parse_border
  type(c_ptr), value :: pspec
  type(c_ptr), value :: gstring
  type(c_ptr), value :: property_value
end function

!  void gtk_settings_set_property_value (GtkSettings *settings, const gchar *name, const GtkSettingsValue *svalue);
subroutine gtk_settings_set_property_value(settings, name, svalue) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: svalue
end subroutine

! void gtk_settings_set_string_property (GtkSettings *settings, const gchar *name, const gchar *v_string, const gchar *origin);
subroutine gtk_settings_set_string_property(settings, name, v_string, origin) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: v_string
  character(kind=c_char), dimension(*) :: origin
end subroutine

! void gtk_settings_set_long_property (GtkSettings *settings, const gchar *name, glong v_long, const gchar *origin);
subroutine gtk_settings_set_long_property(settings, name, v_long, origin) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: name
  integer(c_long), value :: v_long
  character(kind=c_char), dimension(*) :: origin
end subroutine

! void gtk_settings_set_double_property (GtkSettings *settings, const gchar *name, gdouble v_double, const gchar *origin);
subroutine gtk_settings_set_double_property(settings, name, v_double, origin) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_char, c_double
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: name
  real(c_double), value :: v_double
  character(kind=c_char), dimension(*) :: origin
end subroutine

!   GType gtk_toggle_button_get_type (void) G_GNUC_CONST;
function gtk_toggle_button_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_toggle_button_get_type
end function

!  GtkWidget* gtk_toggle_button_new (void);
function gtk_toggle_button_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_toggle_button_new
end function

! GtkWidget* gtk_toggle_button_new_with_label (const gchar *label);
function gtk_toggle_button_new_with_label(label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_toggle_button_new_with_label
  character(kind=c_char), dimension(*) :: label
end function

! GtkWidget* gtk_toggle_button_new_with_mnemonic (const gchar *label);
function gtk_toggle_button_new_with_mnemonic(label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_toggle_button_new_with_mnemonic
  character(kind=c_char), dimension(*) :: label
end function

! void gtk_toggle_button_set_mode (GtkToggleButton *toggle_button, gboolean draw_indicator);
subroutine gtk_toggle_button_set_mode(toggle_button, draw_indicator) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: toggle_button
  logical(c_bool), value :: draw_indicator
end subroutine

! gboolean gtk_toggle_button_get_mode (GtkToggleButton *toggle_button);
function gtk_toggle_button_get_mode(toggle_button) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_toggle_button_get_mode
  type(c_ptr), value :: toggle_button
end function

! void gtk_toggle_button_set_active (GtkToggleButton *toggle_button, gboolean is_active);
subroutine gtk_toggle_button_set_active(toggle_button, is_active) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: toggle_button
  logical(c_bool), value :: is_active
end subroutine

! gboolean gtk_toggle_button_get_active (GtkToggleButton *toggle_button);
function gtk_toggle_button_get_active(toggle_button) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_toggle_button_get_active
  type(c_ptr), value :: toggle_button
end function

! void gtk_toggle_button_toggled (GtkToggleButton *toggle_button);
subroutine gtk_toggle_button_toggled(toggle_button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: toggle_button
end subroutine

! void gtk_toggle_button_set_inconsistent (GtkToggleButton *toggle_button, gboolean setting);
subroutine gtk_toggle_button_set_inconsistent(toggle_button, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: toggle_button
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_toggle_button_get_inconsistent (GtkToggleButton *toggle_button);
function gtk_toggle_button_get_inconsistent(toggle_button) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_toggle_button_get_inconsistent
  type(c_ptr), value :: toggle_button
end function

!   GType gtk_handle_box_get_type (void) G_GNUC_CONST;
function gtk_handle_box_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_handle_box_get_type
end function

! GtkWidget* gtk_handle_box_new (void);
function gtk_handle_box_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_handle_box_new
end function

! void gtk_handle_box_set_shadow_type (GtkHandleBox *handle_box, GtkShadowType type);
subroutine gtk_handle_box_set_shadow_type(handle_box, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: handle_box
  integer(c_int), value :: type
end subroutine

! GtkShadowType gtk_handle_box_get_shadow_type (GtkHandleBox *handle_box);
function gtk_handle_box_get_shadow_type(handle_box) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_handle_box_get_shadow_type
  type(c_ptr), value :: handle_box
end function

! void gtk_handle_box_set_handle_position (GtkHandleBox *handle_box, GtkPositionType position);
subroutine gtk_handle_box_set_handle_position(handle_box, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: handle_box
  integer(c_int), value :: position
end subroutine

! GtkPositionType gtk_handle_box_get_handle_position(GtkHandleBox *handle_box);
function gtk_handle_box_get_handle_position(handle_box) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_handle_box_get_handle_position
  type(c_ptr), value :: handle_box
end function

! void gtk_handle_box_set_snap_edge (GtkHandleBox *handle_box, GtkPositionType edge);
subroutine gtk_handle_box_set_snap_edge(handle_box, edge) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: handle_box
  integer(c_int), value :: edge
end subroutine

! GtkPositionType gtk_handle_box_get_snap_edge (GtkHandleBox *handle_box);
function gtk_handle_box_get_snap_edge(handle_box) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_handle_box_get_snap_edge
  type(c_ptr), value :: handle_box
end function

! gboolean gtk_handle_box_get_child_detached (GtkHandleBox *handle_box);
function gtk_handle_box_get_child_detached(handle_box) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_handle_box_get_child_detached
  type(c_ptr), value :: handle_box
end function

!   GType gtk_file_chooser_button_get_type (void) G_GNUC_CONST;
function gtk_file_chooser_button_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_file_chooser_button_get_type
end function

! GtkWidget * gtk_file_chooser_button_new (const gchar *title, GtkFileChooserAction action);
function gtk_file_chooser_button_new(title, action) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: gtk_file_chooser_button_new
  character(kind=c_char), dimension(*) :: title
  integer(c_int), value :: action
end function

!  GtkWidget * gtk_file_chooser_button_new_with_backend (const gchar *title, GtkFileChooserAction action, const gchar *backend);
function gtk_file_chooser_button_new_with_backend(title, action, backend) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: gtk_file_chooser_button_new_with_backend
  character(kind=c_char), dimension(*) :: title
  integer(c_int), value :: action
  character(kind=c_char), dimension(*) :: backend
end function

!  GtkWidget * gtk_file_chooser_button_new_with_dialog (GtkWidget *dialog);
function gtk_file_chooser_button_new_with_dialog(dialog) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_button_new_with_dialog
  type(c_ptr), value :: dialog
end function

! G_CONST_RETURN gchar *gtk_file_chooser_button_get_title (GtkFileChooserButton *button);
function gtk_file_chooser_button_get_title(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_button_get_title
  type(c_ptr), value :: button
end function

! void gtk_file_chooser_button_set_title (GtkFileChooserButton *button, const gchar *title);
subroutine gtk_file_chooser_button_set_title(button, title) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: button
  character(kind=c_char), dimension(*) :: title
end subroutine

! gint gtk_file_chooser_button_get_width_chars (GtkFileChooserButton *button);
function gtk_file_chooser_button_get_width_chars(button) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_file_chooser_button_get_width_chars
  type(c_ptr), value :: button
end function

! void gtk_file_chooser_button_set_width_chars (GtkFileChooserButton *button, gint n_chars);
subroutine gtk_file_chooser_button_set_width_chars(button, n_chars) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: button
  integer(c_int), value :: n_chars
end subroutine

! gboolean gtk_file_chooser_button_get_focus_on_click (GtkFileChooserButton *button);
function gtk_file_chooser_button_get_focus_on_click(button) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_file_chooser_button_get_focus_on_click
  type(c_ptr), value :: button
end function

! void gtk_file_chooser_button_set_focus_on_click (GtkFileChooserButton *button, gboolean focus_on_click);
subroutine gtk_file_chooser_button_set_focus_on_click(button, focus_on_click) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: button
  logical(c_bool), value :: focus_on_click
end subroutine

!   GType gtk_accel_flags_get_type (void) G_GNUC_CONST;
function gtk_accel_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_accel_flags_get_type
end function

!  GType gtk_assistant_page_type_get_type (void) G_GNUC_CONST;
function gtk_assistant_page_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_assistant_page_type_get_type
end function

!  GType gtk_builder_error_get_type (void) G_GNUC_CONST;
function gtk_builder_error_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_builder_error_get_type
end function

!  GType gtk_calendar_display_options_get_type (void) G_GNUC_CONST;
function gtk_calendar_display_options_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_calendar_display_options_get_type
end function

!  GType gtk_cell_renderer_state_get_type (void) G_GNUC_CONST;
function gtk_cell_renderer_state_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_cell_renderer_state_get_type
end function

!  GType gtk_cell_renderer_mode_get_type (void) G_GNUC_CONST;
function gtk_cell_renderer_mode_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_cell_renderer_mode_get_type
end function

!  GType gtk_cell_renderer_accel_mode_get_type (void) G_GNUC_CONST;
function gtk_cell_renderer_accel_mode_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_cell_renderer_accel_mode_get_type
end function

!  GType gtk_debug_flag_get_type (void) G_GNUC_CONST;
function gtk_debug_flag_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_debug_flag_get_type
end function

!  GType gtk_dialog_flags_get_type (void) G_GNUC_CONST;
function gtk_dialog_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_dialog_flags_get_type
end function

!  GType gtk_response_type_get_type (void) G_GNUC_CONST;
function gtk_response_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_response_type_get_type
end function

!  GType gtk_dest_defaults_get_type (void) G_GNUC_CONST;
function gtk_dest_defaults_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_dest_defaults_get_type
end function

!  GType gtk_target_flags_get_type (void) G_GNUC_CONST;
function gtk_target_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_target_flags_get_type
end function

!  GType gtk_entry_icon_position_get_type (void) G_GNUC_CONST;
function gtk_entry_icon_position_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_entry_icon_position_get_type
end function

!  GType gtk_anchor_type_get_type (void) G_GNUC_CONST;
function gtk_anchor_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_anchor_type_get_type
end function

!  GType gtk_arrow_placement_get_type (void) G_GNUC_CONST;
function gtk_arrow_placement_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_arrow_placement_get_type
end function

!  GType gtk_arrow_type_get_type (void) G_GNUC_CONST;
function gtk_arrow_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_arrow_type_get_type
end function

!  GType gtk_attach_options_get_type (void) G_GNUC_CONST;
function gtk_attach_options_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_attach_options_get_type
end function

!  GType gtk_button_box_style_get_type (void) G_GNUC_CONST;
function gtk_button_box_style_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_button_box_style_get_type
end function

!  GType gtk_curve_type_get_type (void) G_GNUC_CONST;
function gtk_curve_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_curve_type_get_type
end function

!  GType gtk_delete_type_get_type (void) G_GNUC_CONST;
function gtk_delete_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_delete_type_get_type
end function

!  GType gtk_direction_type_get_type (void) G_GNUC_CONST;
function gtk_direction_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_direction_type_get_type
end function

!  GType gtk_expander_style_get_type (void) G_GNUC_CONST;
function gtk_expander_style_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_expander_style_get_type
end function

!  GType gtk_icon_size_get_type (void) G_GNUC_CONST;
function gtk_icon_size_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_icon_size_get_type
end function

!  GType gtk_sensitivity_type_get_type (void) G_GNUC_CONST;
function gtk_sensitivity_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_sensitivity_type_get_type
end function

!  GType gtk_side_type_get_type (void) G_GNUC_CONST;
function gtk_side_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_side_type_get_type
end function

!  GType gtk_text_direction_get_type (void) G_GNUC_CONST;
function gtk_text_direction_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_text_direction_get_type
end function

!  GType gtk_justification_get_type (void) G_GNUC_CONST;
function gtk_justification_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_justification_get_type
end function

!  GType gtk_match_type_get_type (void) G_GNUC_CONST;
function gtk_match_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_match_type_get_type
end function

!  GType gtk_menu_direction_type_get_type (void) G_GNUC_CONST;
function gtk_menu_direction_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_menu_direction_type_get_type
end function

!  GType gtk_message_type_get_type (void) G_GNUC_CONST;
function gtk_message_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_message_type_get_type
end function

!  GType gtk_metric_type_get_type (void) G_GNUC_CONST;
function gtk_metric_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_metric_type_get_type
end function

!  GType gtk_movement_step_get_type (void) G_GNUC_CONST;
function gtk_movement_step_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_movement_step_get_type
end function

!  GType gtk_scroll_step_get_type (void) G_GNUC_CONST;
function gtk_scroll_step_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_scroll_step_get_type
end function

!  GType gtk_orientation_get_type (void) G_GNUC_CONST;
function gtk_orientation_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_orientation_get_type
end function

!  GType gtk_corner_type_get_type (void) G_GNUC_CONST;
function gtk_corner_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_corner_type_get_type
end function

!  GType gtk_pack_type_get_type (void) G_GNUC_CONST;
function gtk_pack_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_pack_type_get_type
end function

!  GType gtk_path_priority_type_get_type (void) G_GNUC_CONST;
function gtk_path_priority_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_path_priority_type_get_type
end function

!  GType gtk_path_type_get_type (void) G_GNUC_CONST;
function gtk_path_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_path_type_get_type
end function

!  GType gtk_policy_type_get_type (void) G_GNUC_CONST;
function gtk_policy_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_policy_type_get_type
end function

!  GType gtk_position_type_get_type (void) G_GNUC_CONST;
function gtk_position_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_position_type_get_type
end function

!  GType gtk_preview_type_get_type (void) G_GNUC_CONST;
function gtk_preview_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_preview_type_get_type
end function

!  GType gtk_relief_style_get_type (void) G_GNUC_CONST;
function gtk_relief_style_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_relief_style_get_type
end function

!  GType gtk_resize_mode_get_type (void) G_GNUC_CONST;
function gtk_resize_mode_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_resize_mode_get_type
end function

!  GType gtk_signal_run_type_get_type (void) G_GNUC_CONST;
function gtk_signal_run_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_signal_run_type_get_type
end function

!  GType gtk_scroll_type_get_type (void) G_GNUC_CONST;
function gtk_scroll_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_scroll_type_get_type
end function

!  GType gtk_selection_mode_get_type (void) G_GNUC_CONST;
function gtk_selection_mode_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_selection_mode_get_type
end function

!  GType gtk_shadow_type_get_type (void) G_GNUC_CONST;
function gtk_shadow_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_shadow_type_get_type
end function

!  GType gtk_state_type_get_type (void) G_GNUC_CONST;
function gtk_state_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_state_type_get_type
end function

!  GType gtk_submenu_direction_get_type (void) G_GNUC_CONST;
function gtk_submenu_direction_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_submenu_direction_get_type
end function

!  GType gtk_submenu_placement_get_type (void) G_GNUC_CONST;
function gtk_submenu_placement_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_submenu_placement_get_type
end function

!  GType gtk_toolbar_style_get_type (void) G_GNUC_CONST;
function gtk_toolbar_style_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_toolbar_style_get_type
end function

!  GType gtk_update_type_get_type (void) G_GNUC_CONST;
function gtk_update_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_update_type_get_type
end function

!  GType gtk_visibility_get_type (void) G_GNUC_CONST;
function gtk_visibility_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_visibility_get_type
end function

!  GType gtk_window_position_get_type (void) G_GNUC_CONST;
function gtk_window_position_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_window_position_get_type
end function

!  GType gtk_window_type_get_type (void) G_GNUC_CONST;
function gtk_window_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_window_type_get_type
end function

!  GType gtk_wrap_mode_get_type (void) G_GNUC_CONST;
function gtk_wrap_mode_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_wrap_mode_get_type
end function

!  GType gtk_sort_type_get_type (void) G_GNUC_CONST;
function gtk_sort_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_sort_type_get_type
end function

!  GType gtk_im_preedit_style_get_type (void) G_GNUC_CONST;
function gtk_im_preedit_style_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_im_preedit_style_get_type
end function

!  GType gtk_im_status_style_get_type (void) G_GNUC_CONST;
function gtk_im_status_style_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_im_status_style_get_type
end function

!  GType gtk_pack_direction_get_type (void) G_GNUC_CONST;
function gtk_pack_direction_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_pack_direction_get_type
end function

!  GType gtk_print_pages_get_type (void) G_GNUC_CONST;
function gtk_print_pages_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_print_pages_get_type
end function

!  GType gtk_page_set_get_type (void) G_GNUC_CONST;
function gtk_page_set_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_page_set_get_type
end function

!  GType gtk_number_up_layout_get_type (void) G_GNUC_CONST;
function gtk_number_up_layout_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_number_up_layout_get_type
end function

!  GType gtk_page_orientation_get_type (void) G_GNUC_CONST;
function gtk_page_orientation_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_page_orientation_get_type
end function

!  GType gtk_print_quality_get_type (void) G_GNUC_CONST;
function gtk_print_quality_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_print_quality_get_type
end function

!  GType gtk_print_duplex_get_type (void) G_GNUC_CONST;
function gtk_print_duplex_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_print_duplex_get_type
end function

!  GType gtk_unit_get_type (void) G_GNUC_CONST;
function gtk_unit_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_unit_get_type
end function

!  GType gtk_tree_view_grid_lines_get_type (void) G_GNUC_CONST;
function gtk_tree_view_grid_lines_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_view_grid_lines_get_type
end function

!  GType gtk_drag_result_get_type (void) G_GNUC_CONST;
function gtk_drag_result_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_drag_result_get_type
end function

!  GType gtk_file_chooser_action_get_type (void) G_GNUC_CONST;
function gtk_file_chooser_action_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_file_chooser_action_get_type
end function

!  GType gtk_file_chooser_confirmation_get_type (void) G_GNUC_CONST;
function gtk_file_chooser_confirmation_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_file_chooser_confirmation_get_type
end function

!  GType gtk_file_chooser_error_get_type (void) G_GNUC_CONST;
function gtk_file_chooser_error_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_file_chooser_error_get_type
end function

!  GType gtk_file_filter_flags_get_type (void) G_GNUC_CONST;
function gtk_file_filter_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_file_filter_flags_get_type
end function

!  GType gtk_icon_lookup_flags_get_type (void) G_GNUC_CONST;
function gtk_icon_lookup_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_icon_lookup_flags_get_type
end function

!  GType gtk_icon_theme_error_get_type (void) G_GNUC_CONST;
function gtk_icon_theme_error_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_icon_theme_error_get_type
end function

!  GType gtk_icon_view_drop_position_get_type (void) G_GNUC_CONST;
function gtk_icon_view_drop_position_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_icon_view_drop_position_get_type
end function

!  GType gtk_image_type_get_type (void) G_GNUC_CONST;
function gtk_image_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_image_type_get_type
end function

!  GType gtk_buttons_type_get_type (void) G_GNUC_CONST;
function gtk_buttons_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_buttons_type_get_type
end function

!  GType gtk_notebook_tab_get_type (void) G_GNUC_CONST;
function gtk_notebook_tab_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_notebook_tab_get_type
end function

!  GType gtk_object_flags_get_type (void) G_GNUC_CONST;
function gtk_object_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_object_flags_get_type
end function

!  GType gtk_arg_flags_get_type (void) G_GNUC_CONST;
function gtk_arg_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_arg_flags_get_type
end function

!  GType gtk_print_status_get_type (void) G_GNUC_CONST;
function gtk_print_status_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_print_status_get_type
end function

!  GType gtk_print_operation_result_get_type (void) G_GNUC_CONST;
function gtk_print_operation_result_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_print_operation_result_get_type
end function

!  GType gtk_print_operation_action_get_type (void) G_GNUC_CONST;
function gtk_print_operation_action_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_print_operation_action_get_type
end function

!  GType gtk_print_error_get_type (void) G_GNUC_CONST;
function gtk_print_error_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_print_error_get_type
end function

!  GType gtk_private_flags_get_type (void) G_GNUC_CONST;
function gtk_private_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_private_flags_get_type
end function

!  GType gtk_progress_bar_style_get_type (void) G_GNUC_CONST;
function gtk_progress_bar_style_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_progress_bar_style_get_type
end function

!  GType gtk_progress_bar_orientation_get_type (void) G_GNUC_CONST;
function gtk_progress_bar_orientation_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_progress_bar_orientation_get_type
end function

!  GType gtk_rc_flags_get_type (void) G_GNUC_CONST;
function gtk_rc_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_rc_flags_get_type
end function

!  GType gtk_rc_token_type_get_type (void) G_GNUC_CONST;
function gtk_rc_token_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_rc_token_type_get_type
end function

!  GType gtk_recent_sort_type_get_type (void) G_GNUC_CONST;
function gtk_recent_sort_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_recent_sort_type_get_type
end function

!  GType gtk_recent_chooser_error_get_type (void) G_GNUC_CONST;
function gtk_recent_chooser_error_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_recent_chooser_error_get_type
end function

!  GType gtk_recent_filter_flags_get_type (void) G_GNUC_CONST;
function gtk_recent_filter_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_recent_filter_flags_get_type
end function

!  GType gtk_recent_manager_error_get_type (void) G_GNUC_CONST;
function gtk_recent_manager_error_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_recent_manager_error_get_type
end function

!  GType gtk_size_group_mode_get_type (void) G_GNUC_CONST;
function gtk_size_group_mode_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_size_group_mode_get_type
end function

!  GType gtk_spin_button_update_policy_get_type (void) G_GNUC_CONST;
function gtk_spin_button_update_policy_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_spin_button_update_policy_get_type
end function

!  GType gtk_spin_type_get_type (void) G_GNUC_CONST;
function gtk_spin_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_spin_type_get_type
end function

!  GType gtk_text_buffer_target_info_get_type (void) G_GNUC_CONST;
function gtk_text_buffer_target_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_text_buffer_target_info_get_type
end function

!  GType gtk_text_search_flags_get_type (void) G_GNUC_CONST;
function gtk_text_search_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_text_search_flags_get_type
end function

!  GType gtk_text_window_type_get_type (void) G_GNUC_CONST;
function gtk_text_window_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_text_window_type_get_type
end function

!  GType gtk_toolbar_child_type_get_type (void) G_GNUC_CONST;
function gtk_toolbar_child_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_toolbar_child_type_get_type
end function

!  GType gtk_toolbar_space_style_get_type (void) G_GNUC_CONST;
function gtk_toolbar_space_style_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_toolbar_space_style_get_type
end function

!  GType gtk_tool_palette_drag_targets_get_type (void) G_GNUC_CONST;
function gtk_tool_palette_drag_targets_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tool_palette_drag_targets_get_type
end function

!  GType gtk_tree_model_flags_get_type (void) G_GNUC_CONST;
function gtk_tree_model_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_model_flags_get_type
end function

!  GType gtk_tree_view_drop_position_get_type (void) G_GNUC_CONST;
function gtk_tree_view_drop_position_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_view_drop_position_get_type
end function

!  GType gtk_tree_view_column_sizing_get_type (void) G_GNUC_CONST;
function gtk_tree_view_column_sizing_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_view_column_sizing_get_type
end function

!  GType gtk_ui_manager_item_type_get_type (void) G_GNUC_CONST;
function gtk_ui_manager_item_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_ui_manager_item_type_get_type
end function

!  GType gtk_widget_flags_get_type (void) G_GNUC_CONST;
function gtk_widget_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_widget_flags_get_type
end function

!  GType gtk_widget_help_type_get_type (void) G_GNUC_CONST;
function gtk_widget_help_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_widget_help_type_get_type
end function

!  GType gtk_tree_view_mode_get_type (void) G_GNUC_CONST;
function gtk_tree_view_mode_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_view_mode_get_type
end function

!  GType gtk_cell_type_get_type (void) G_GNUC_CONST;
function gtk_cell_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_cell_type_get_type
end function

!  GType gtk_clist_drag_pos_get_type (void) G_GNUC_CONST;
function gtk_clist_drag_pos_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_clist_drag_pos_get_type
end function

!  GType gtk_button_action_get_type (void) G_GNUC_CONST;
function gtk_button_action_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_button_action_get_type
end function

!  GType gtk_ctree_pos_get_type (void) G_GNUC_CONST;
function gtk_ctree_pos_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_ctree_pos_get_type
end function

!  GType gtk_ctree_line_style_get_type (void) G_GNUC_CONST;
function gtk_ctree_line_style_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_ctree_line_style_get_type
end function

!  GType gtk_ctree_expander_style_get_type (void) G_GNUC_CONST;
function gtk_ctree_expander_style_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_ctree_expander_style_get_type
end function

!  GType gtk_ctree_expansion_type_get_type (void) G_GNUC_CONST;
function gtk_ctree_expansion_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_ctree_expansion_type_get_type
end function

!   GType gtk_status_icon_get_type (void) G_GNUC_CONST;
function gtk_status_icon_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_status_icon_get_type
end function

!  GtkStatusIcon *gtk_status_icon_new (void);
function gtk_status_icon_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_status_icon_new
end function

! GtkStatusIcon *gtk_status_icon_new_from_pixbuf (GdkPixbuf *pixbuf);
function gtk_status_icon_new_from_pixbuf(pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_status_icon_new_from_pixbuf
  type(c_ptr), value :: pixbuf
end function

! GtkStatusIcon *gtk_status_icon_new_from_file (const gchar *filename);
function gtk_status_icon_new_from_file(filename) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_status_icon_new_from_file
  character(kind=c_char), dimension(*) :: filename
end function

! GtkStatusIcon *gtk_status_icon_new_from_stock (const gchar *stock_id);
function gtk_status_icon_new_from_stock(stock_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_status_icon_new_from_stock
  character(kind=c_char), dimension(*) :: stock_id
end function

! GtkStatusIcon *gtk_status_icon_new_from_icon_name (const gchar *icon_name);
function gtk_status_icon_new_from_icon_name(icon_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_status_icon_new_from_icon_name
  character(kind=c_char), dimension(*) :: icon_name
end function

! GtkStatusIcon *gtk_status_icon_new_from_gicon (GIcon *icon);
function gtk_status_icon_new_from_gicon(icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_status_icon_new_from_gicon
  type(c_ptr), value :: icon
end function

!  void gtk_status_icon_set_from_pixbuf (GtkStatusIcon *status_icon, GdkPixbuf *pixbuf);
subroutine gtk_status_icon_set_from_pixbuf(status_icon, pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: status_icon
  type(c_ptr), value :: pixbuf
end subroutine

! void gtk_status_icon_set_from_file (GtkStatusIcon *status_icon, const gchar *filename);
subroutine gtk_status_icon_set_from_file(status_icon, filename) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: status_icon
  character(kind=c_char), dimension(*) :: filename
end subroutine

! void gtk_status_icon_set_from_stock (GtkStatusIcon *status_icon, const gchar *stock_id);
subroutine gtk_status_icon_set_from_stock(status_icon, stock_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: status_icon
  character(kind=c_char), dimension(*) :: stock_id
end subroutine

! void gtk_status_icon_set_from_icon_name (GtkStatusIcon *status_icon, const gchar *icon_name);
subroutine gtk_status_icon_set_from_icon_name(status_icon, icon_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: status_icon
  character(kind=c_char), dimension(*) :: icon_name
end subroutine

! void gtk_status_icon_set_from_gicon (GtkStatusIcon *status_icon, GIcon *icon);
subroutine gtk_status_icon_set_from_gicon(status_icon, icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: status_icon
  type(c_ptr), value :: icon
end subroutine

!  GtkImageType gtk_status_icon_get_storage_type (GtkStatusIcon *status_icon);
function gtk_status_icon_get_storage_type(status_icon) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_status_icon_get_storage_type
  type(c_ptr), value :: status_icon
end function

!  GdkPixbuf *gtk_status_icon_get_pixbuf (GtkStatusIcon *status_icon);
function gtk_status_icon_get_pixbuf(status_icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_status_icon_get_pixbuf
  type(c_ptr), value :: status_icon
end function

! G_CONST_RETURN gchar *gtk_status_icon_get_stock (GtkStatusIcon *status_icon);
function gtk_status_icon_get_stock(status_icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_status_icon_get_stock
  type(c_ptr), value :: status_icon
end function

! G_CONST_RETURN gchar *gtk_status_icon_get_icon_name (GtkStatusIcon *status_icon);
function gtk_status_icon_get_icon_name(status_icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_status_icon_get_icon_name
  type(c_ptr), value :: status_icon
end function

! GIcon *gtk_status_icon_get_gicon (GtkStatusIcon *status_icon);
function gtk_status_icon_get_gicon(status_icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_status_icon_get_gicon
  type(c_ptr), value :: status_icon
end function

!  gint gtk_status_icon_get_size (GtkStatusIcon *status_icon);
function gtk_status_icon_get_size(status_icon) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_status_icon_get_size
  type(c_ptr), value :: status_icon
end function

!  void gtk_status_icon_set_screen (GtkStatusIcon *status_icon, GdkScreen *screen);
subroutine gtk_status_icon_set_screen(status_icon, screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: status_icon
  type(c_ptr), value :: screen
end subroutine

! GdkScreen *gtk_status_icon_get_screen (GtkStatusIcon *status_icon);
function gtk_status_icon_get_screen(status_icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_status_icon_get_screen
  type(c_ptr), value :: status_icon
end function

!  void gtk_status_icon_set_tooltip (GtkStatusIcon *status_icon, const gchar *tooltip_text);
subroutine gtk_status_icon_set_tooltip(status_icon, tooltip_text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: status_icon
  character(kind=c_char), dimension(*) :: tooltip_text
end subroutine

!  void gtk_status_icon_set_has_tooltip (GtkStatusIcon *status_icon, gboolean has_tooltip);
subroutine gtk_status_icon_set_has_tooltip(status_icon, has_tooltip) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: status_icon
  logical(c_bool), value :: has_tooltip
end subroutine

! void gtk_status_icon_set_tooltip_text (GtkStatusIcon *status_icon, const gchar *text);
subroutine gtk_status_icon_set_tooltip_text(status_icon, text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: status_icon
  character(kind=c_char), dimension(*) :: text
end subroutine

! void gtk_status_icon_set_tooltip_markup (GtkStatusIcon *status_icon, const gchar *markup);
subroutine gtk_status_icon_set_tooltip_markup(status_icon, markup) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: status_icon
  character(kind=c_char), dimension(*) :: markup
end subroutine

! void gtk_status_icon_set_title (GtkStatusIcon *status_icon, const gchar *title);
subroutine gtk_status_icon_set_title(status_icon, title) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: status_icon
  character(kind=c_char), dimension(*) :: title
end subroutine

! G_CONST_RETURN gchar *gtk_status_icon_get_title (GtkStatusIcon *status_icon);
function gtk_status_icon_get_title(status_icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_status_icon_get_title
  type(c_ptr), value :: status_icon
end function

! void gtk_status_icon_set_name (GtkStatusIcon *status_icon, const gchar *name);
subroutine gtk_status_icon_set_name(status_icon, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: status_icon
  character(kind=c_char), dimension(*) :: name
end subroutine

! void gtk_status_icon_set_visible (GtkStatusIcon *status_icon, gboolean visible);
subroutine gtk_status_icon_set_visible(status_icon, visible) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: status_icon
  logical(c_bool), value :: visible
end subroutine

! gboolean gtk_status_icon_get_visible (GtkStatusIcon *status_icon);
function gtk_status_icon_get_visible(status_icon) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_status_icon_get_visible
  type(c_ptr), value :: status_icon
end function

!  void gtk_status_icon_set_blinking (GtkStatusIcon *status_icon, gboolean blinking);
subroutine gtk_status_icon_set_blinking(status_icon, blinking) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: status_icon
  logical(c_bool), value :: blinking
end subroutine

! gboolean gtk_status_icon_get_blinking (GtkStatusIcon *status_icon);
function gtk_status_icon_get_blinking(status_icon) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_status_icon_get_blinking
  type(c_ptr), value :: status_icon
end function

!  gboolean gtk_status_icon_is_embedded (GtkStatusIcon *status_icon);
function gtk_status_icon_is_embedded(status_icon) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_status_icon_is_embedded
  type(c_ptr), value :: status_icon
end function

!  void gtk_status_icon_position_menu (GtkMenu *menu, gint *x, gint *y, gboolean *push_in, gpointer user_data);
subroutine gtk_status_icon_position_menu(menu, x, y, push_in, user_data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: menu
  type(c_ptr), value :: x
  type(c_ptr), value :: y
  type(c_ptr), value :: push_in
  type(c_ptr), value :: user_data
end subroutine

! gboolean gtk_status_icon_get_geometry (GtkStatusIcon *status_icon, GdkScreen **screen, GdkRectangle *area, GtkOrientation *orientation);
function gtk_status_icon_get_geometry(status_icon, screen, area, orientation) bi&
      &nd(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_status_icon_get_geometry
  type(c_ptr), value :: status_icon
  type(c_ptr), value :: screen
  type(c_ptr), value :: area
  integer(c_int), value :: orientation
end function

! gboolean gtk_status_icon_get_has_tooltip (GtkStatusIcon *status_icon);
function gtk_status_icon_get_has_tooltip(status_icon) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_status_icon_get_has_tooltip
  type(c_ptr), value :: status_icon
end function

! gchar *gtk_status_icon_get_tooltip_text (GtkStatusIcon *status_icon);
function gtk_status_icon_get_tooltip_text(status_icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_status_icon_get_tooltip_text
  type(c_ptr), value :: status_icon
end function

! gchar *gtk_status_icon_get_tooltip_markup (GtkStatusIcon *status_icon);
function gtk_status_icon_get_tooltip_markup(status_icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_status_icon_get_tooltip_markup
  type(c_ptr), value :: status_icon
end function

!  guint32 gtk_status_icon_get_x11_window_id (GtkStatusIcon *status_icon);
function gtk_status_icon_get_x11_window_id(status_icon) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: gtk_status_icon_get_x11_window_id
  type(c_ptr), value :: status_icon
end function

!   GType gtk_paper_size_get_type (void) G_GNUC_CONST;
function gtk_paper_size_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_paper_size_get_type
end function

!  GtkPaperSize *gtk_paper_size_new (const gchar *name);
function gtk_paper_size_new(name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_paper_size_new
  character(kind=c_char), dimension(*) :: name
end function

! GtkPaperSize *gtk_paper_size_new_from_ppd (const gchar *ppd_name, const gchar *ppd_display_name, gdouble width, gdouble height);
function gtk_paper_size_new_from_ppd(ppd_name, ppd_display_name, width, height) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_double
  type(c_ptr) :: gtk_paper_size_new_from_ppd
  character(kind=c_char), dimension(*) :: ppd_name
  character(kind=c_char), dimension(*) :: ppd_display_name
  real(c_double), value :: width
  real(c_double), value :: height
end function

! GtkPaperSize *gtk_paper_size_new_custom (const gchar *name, const gchar *display_name, gdouble width, gdouble height, GtkUnit unit);
function gtk_paper_size_new_custom(name, display_name, width, height, unit) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_char, c_double, c_int
  type(c_ptr) :: gtk_paper_size_new_custom
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: display_name
  real(c_double), value :: width
  real(c_double), value :: height
  integer(c_int), value :: unit
end function

! GtkPaperSize *gtk_paper_size_copy (GtkPaperSize *other);
function gtk_paper_size_copy(other) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_paper_size_copy
  type(c_ptr), value :: other
end function

! void gtk_paper_size_free (GtkPaperSize *size);
subroutine gtk_paper_size_free(size) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: size
end subroutine

! gboolean gtk_paper_size_is_equal (GtkPaperSize *size1, GtkPaperSize *size2);
function gtk_paper_size_is_equal(size1, size2) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_paper_size_is_equal
  type(c_ptr), value :: size1
  type(c_ptr), value :: size2
end function

!  GList *gtk_paper_size_get_paper_sizes (gboolean include_custom);
function gtk_paper_size_get_paper_sizes(include_custom) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: gtk_paper_size_get_paper_sizes
  logical(c_bool), value :: include_custom
end function

!  G_CONST_RETURN gchar *gtk_paper_size_get_name (GtkPaperSize *size);
function gtk_paper_size_get_name(size) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_paper_size_get_name
  type(c_ptr), value :: size
end function

! G_CONST_RETURN gchar *gtk_paper_size_get_display_name (GtkPaperSize *size);
function gtk_paper_size_get_display_name(size) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_paper_size_get_display_name
  type(c_ptr), value :: size
end function

! G_CONST_RETURN gchar *gtk_paper_size_get_ppd_name (GtkPaperSize *size);
function gtk_paper_size_get_ppd_name(size) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_paper_size_get_ppd_name
  type(c_ptr), value :: size
end function

!  gdouble gtk_paper_size_get_width (GtkPaperSize *size, GtkUnit unit);
function gtk_paper_size_get_width(size, unit) bind(c) 
  use iso_c_binding, only: c_double, c_ptr, c_int
  real(c_double) :: gtk_paper_size_get_width
  type(c_ptr), value :: size
  integer(c_int), value :: unit
end function

! gdouble gtk_paper_size_get_height (GtkPaperSize *size, GtkUnit unit);
function gtk_paper_size_get_height(size, unit) bind(c) 
  use iso_c_binding, only: c_double, c_ptr, c_int
  real(c_double) :: gtk_paper_size_get_height
  type(c_ptr), value :: size
  integer(c_int), value :: unit
end function

! gboolean gtk_paper_size_is_custom (GtkPaperSize *size);
function gtk_paper_size_is_custom(size) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_paper_size_is_custom
  type(c_ptr), value :: size
end function

!  void gtk_paper_size_set_size (GtkPaperSize *size, gdouble width, gdouble height, GtkUnit unit);
subroutine gtk_paper_size_set_size(size, width, height, unit) bind(c) 
  use iso_c_binding, only: c_ptr, c_double, c_int
  type(c_ptr), value :: size
  real(c_double), value :: width
  real(c_double), value :: height
  integer(c_int), value :: unit
end subroutine

!  gdouble gtk_paper_size_get_default_top_margin (GtkPaperSize *size, GtkUnit unit);
function gtk_paper_size_get_default_top_margin(size, unit) bind(c) 
  use iso_c_binding, only: c_double, c_ptr, c_int
  real(c_double) :: gtk_paper_size_get_default_top_margin
  type(c_ptr), value :: size
  integer(c_int), value :: unit
end function

! gdouble gtk_paper_size_get_default_bottom_margin (GtkPaperSize *size, GtkUnit unit);
function gtk_paper_size_get_default_bottom_margin(size, unit) bind(c) 
  use iso_c_binding, only: c_double, c_ptr, c_int
  real(c_double) :: gtk_paper_size_get_default_bottom_margin
  type(c_ptr), value :: size
  integer(c_int), value :: unit
end function

! gdouble gtk_paper_size_get_default_left_margin (GtkPaperSize *size, GtkUnit unit);
function gtk_paper_size_get_default_left_margin(size, unit) bind(c) 
  use iso_c_binding, only: c_double, c_ptr, c_int
  real(c_double) :: gtk_paper_size_get_default_left_margin
  type(c_ptr), value :: size
  integer(c_int), value :: unit
end function

! gdouble gtk_paper_size_get_default_right_margin (GtkPaperSize *size, GtkUnit unit);
function gtk_paper_size_get_default_right_margin(size, unit) bind(c) 
  use iso_c_binding, only: c_double, c_ptr, c_int
  real(c_double) :: gtk_paper_size_get_default_right_margin
  type(c_ptr), value :: size
  integer(c_int), value :: unit
end function

!  G_CONST_RETURN gchar *gtk_paper_size_get_default (void);
function gtk_paper_size_get_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_paper_size_get_default
end function

!  GtkPaperSize *gtk_paper_size_new_from_key_file (GKeyFile *key_file, const gchar *group_name, GError **error);
function gtk_paper_size_new_from_key_file(key_file, group_name, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_paper_size_new_from_key_file
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  type(c_ptr), value :: error
end function

! void gtk_paper_size_to_key_file (GtkPaperSize *size, GKeyFile *key_file, const gchar *group_name);
subroutine gtk_paper_size_to_key_file(size, key_file, group_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: size
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
end subroutine

!   GType gtk_accel_label_get_type (void) G_GNUC_CONST;
function gtk_accel_label_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_accel_label_get_type
end function

! GtkWidget* gtk_accel_label_new (const gchar *string);
function gtk_accel_label_new(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_accel_label_new
  character(kind=c_char), dimension(*) :: string
end function

! GtkWidget* gtk_accel_label_get_accel_widget (GtkAccelLabel *accel_label);
function gtk_accel_label_get_accel_widget(accel_label) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_accel_label_get_accel_widget
  type(c_ptr), value :: accel_label
end function

! guint gtk_accel_label_get_accel_width (GtkAccelLabel *accel_label);
function gtk_accel_label_get_accel_width(accel_label) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_accel_label_get_accel_width
  type(c_ptr), value :: accel_label
end function

! void gtk_accel_label_set_accel_widget (GtkAccelLabel *accel_label, GtkWidget *accel_widget);
subroutine gtk_accel_label_set_accel_widget(accel_label, accel_widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: accel_label
  type(c_ptr), value :: accel_widget
end subroutine

! void gtk_accel_label_set_accel_closure (GtkAccelLabel *accel_label, GClosure *accel_closure);
subroutine gtk_accel_label_set_accel_closure(accel_label, accel_closure) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: accel_label
  type(c_ptr), value :: accel_closure
end subroutine

! gboolean gtk_accel_label_refetch (GtkAccelLabel *accel_label);
function gtk_accel_label_refetch(accel_label) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_accel_label_refetch
  type(c_ptr), value :: accel_label
end function

!  GType gtk_text_layout_get_type (void) G_GNUC_CONST;
function gtk_text_layout_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_text_layout_get_type
end function

!  GtkTextLayout* gtk_text_layout_new (void);
function gtk_text_layout_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_layout_new
end function

! void gtk_text_layout_set_buffer (GtkTextLayout *layout, GtkTextBuffer *buffer);
subroutine gtk_text_layout_set_buffer(layout, buffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: buffer
end subroutine

! GtkTextBuffer *gtk_text_layout_get_buffer (GtkTextLayout *layout);
function gtk_text_layout_get_buffer(layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_layout_get_buffer
  type(c_ptr), value :: layout
end function

! void gtk_text_layout_set_default_style (GtkTextLayout *layout, GtkTextAttributes *values);
subroutine gtk_text_layout_set_default_style(layout, values) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: values
end subroutine

! void gtk_text_layout_set_contexts (GtkTextLayout *layout, PangoContext *ltr_context, PangoContext *rtl_context);
subroutine gtk_text_layout_set_contexts(layout, ltr_context, rtl_context) bind(c&
      &) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: ltr_context
  type(c_ptr), value :: rtl_context
end subroutine

! void gtk_text_layout_set_cursor_direction (GtkTextLayout *layout, GtkTextDirection direction);
subroutine gtk_text_layout_set_cursor_direction(layout, direction) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  integer(c_int), value :: direction
end subroutine

! void gtk_text_layout_set_overwrite_mode (GtkTextLayout *layout, gboolean overwrite);
subroutine gtk_text_layout_set_overwrite_mode(layout, overwrite) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: layout
  logical(c_bool), value :: overwrite
end subroutine

! void gtk_text_layout_set_keyboard_direction (GtkTextLayout *layout, GtkTextDirection keyboard_dir);
subroutine gtk_text_layout_set_keyboard_direction(layout, keyboard_dir) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  integer(c_int), value :: keyboard_dir
end subroutine

! void gtk_text_layout_default_style_changed (GtkTextLayout *layout);
subroutine gtk_text_layout_default_style_changed(layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
end subroutine

!  void gtk_text_layout_set_screen_width (GtkTextLayout *layout, gint width);
subroutine gtk_text_layout_set_screen_width(layout, width) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  integer(c_int), value :: width
end subroutine

! void gtk_text_layout_set_preedit_string (GtkTextLayout *layout, const gchar *preedit_string, PangoAttrList *preedit_attrs, gint cursor_pos);
subroutine gtk_text_layout_set_preedit_string(layout, preedit_string, preedit_at&
      &trs, cursor_pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: layout
  character(kind=c_char), dimension(*) :: preedit_string
  type(c_ptr), value :: preedit_attrs
  integer(c_int), value :: cursor_pos
end subroutine

!  void gtk_text_layout_set_cursor_visible (GtkTextLayout *layout, gboolean cursor_visible);
subroutine gtk_text_layout_set_cursor_visible(layout, cursor_visible) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: layout
  logical(c_bool), value :: cursor_visible
end subroutine

! gboolean gtk_text_layout_get_cursor_visible (GtkTextLayout *layout);
function gtk_text_layout_get_cursor_visible(layout) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_layout_get_cursor_visible
  type(c_ptr), value :: layout
end function

!  void gtk_text_layout_get_size (GtkTextLayout *layout, gint *width, gint *height);
subroutine gtk_text_layout_get_size(layout, width, height) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: width
  type(c_ptr), value :: height
end subroutine

! GSList* gtk_text_layout_get_lines (GtkTextLayout *layout,  gint top_y, gint bottom_y, gint *first_line_y);
function gtk_text_layout_get_lines(layout, top_y, bottom_y, first_line_y) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_text_layout_get_lines
  type(c_ptr), value :: layout
  integer(c_int), value :: top_y
  integer(c_int), value :: bottom_y
  type(c_ptr), value :: first_line_y
end function

!  void gtk_text_layout_wrap_loop_start (GtkTextLayout *layout);
subroutine gtk_text_layout_wrap_loop_start(layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
end subroutine

! void gtk_text_layout_wrap_loop_end (GtkTextLayout *layout);
subroutine gtk_text_layout_wrap_loop_end(layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
end subroutine

!  GtkTextLineDisplay* gtk_text_layout_get_line_display (GtkTextLayout *layout, GtkTextLine *line, gboolean size_only);
function gtk_text_layout_get_line_display(layout, line, size_only) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: gtk_text_layout_get_line_display
  type(c_ptr), value :: layout
  type(c_ptr), value :: line
  logical(c_bool), value :: size_only
end function

! void gtk_text_layout_free_line_display (GtkTextLayout *layout, GtkTextLineDisplay *display);
subroutine gtk_text_layout_free_line_display(layout, display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: display
end subroutine

!  void gtk_text_layout_get_line_at_y (GtkTextLayout *layout, GtkTextIter *target_iter, gint y, gint *line_top);
subroutine gtk_text_layout_get_line_at_y(layout, target_iter, y, line_top) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  type(c_ptr), value :: target_iter
  integer(c_int), value :: y
  type(c_ptr), value :: line_top
end subroutine

! void gtk_text_layout_get_iter_at_pixel (GtkTextLayout *layout, GtkTextIter *iter, gint x, gint y);
subroutine gtk_text_layout_get_iter_at_pixel(layout, iter, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  type(c_ptr), value :: iter
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void gtk_text_layout_get_iter_at_position (GtkTextLayout *layout, GtkTextIter *iter, gint *trailing, gint x, gint y);
subroutine gtk_text_layout_get_iter_at_position(layout, iter, trailing, x, y) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  type(c_ptr), value :: iter
  type(c_ptr), value :: trailing
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void gtk_text_layout_invalidate (GtkTextLayout *layout, const GtkTextIter *start, const GtkTextIter *end);
subroutine gtk_text_layout_invalidate(layout, start, end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: start
  type(c_ptr), value :: end
end subroutine

! void gtk_text_layout_invalidate_cursors(GtkTextLayout *layout, const GtkTextIter *start, const GtkTextIter *end);
subroutine gtk_text_layout_invalidate_cursors(layout, start, end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: start
  type(c_ptr), value :: end
end subroutine

! void gtk_text_layout_free_line_data (GtkTextLayout *layout, GtkTextLine *line, GtkTextLineData *line_data);
subroutine gtk_text_layout_free_line_data(layout, line, line_data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: line
  type(c_ptr), value :: line_data
end subroutine

!  gboolean gtk_text_layout_is_valid (GtkTextLayout *layout);
function gtk_text_layout_is_valid(layout) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_layout_is_valid
  type(c_ptr), value :: layout
end function

! void gtk_text_layout_validate_yrange (GtkTextLayout *layout, GtkTextIter *anchor_line, gint y0_, gint y1_);
subroutine gtk_text_layout_validate_yrange(layout, anchor_line, y0_, y1_) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  type(c_ptr), value :: anchor_line
  integer(c_int), value :: y0_
  integer(c_int), value :: y1_
end subroutine

! void gtk_text_layout_validate (GtkTextLayout *layout, gint max_pixels);
subroutine gtk_text_layout_validate(layout, max_pixels) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  integer(c_int), value :: max_pixels
end subroutine

!  GtkTextLineData* gtk_text_layout_wrap (GtkTextLayout *layout, GtkTextLine *line, GtkTextLineData *line_data);
function gtk_text_layout_wrap(layout, line, line_data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_layout_wrap
  type(c_ptr), value :: layout
  type(c_ptr), value :: line
  type(c_ptr), value :: line_data
end function

! void gtk_text_layout_changed (GtkTextLayout *layout, gint y, gint old_height, gint new_height);
subroutine gtk_text_layout_changed(layout, y, old_height, new_height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  integer(c_int), value :: y
  integer(c_int), value :: old_height
  integer(c_int), value :: new_height
end subroutine

! void gtk_text_layout_cursors_changed (GtkTextLayout *layout, gint y, gint old_height, gint new_height);
subroutine gtk_text_layout_cursors_changed(layout, y, old_height, new_height) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  integer(c_int), value :: y
  integer(c_int), value :: old_height
  integer(c_int), value :: new_height
end subroutine

! void gtk_text_layout_get_iter_location (GtkTextLayout *layout, const GtkTextIter *iter, GdkRectangle *rect);
subroutine gtk_text_layout_get_iter_location(layout, iter, rect) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: iter
  type(c_ptr), value :: rect
end subroutine

! void gtk_text_layout_get_line_yrange (GtkTextLayout *layout, const GtkTextIter *iter, gint *y, gint *height);
subroutine gtk_text_layout_get_line_yrange(layout, iter, y, height) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: iter
  type(c_ptr), value :: y
  type(c_ptr), value :: height
end subroutine

! void gtk_text_layout_get_cursor_locations (GtkTextLayout *layout, GtkTextIter *iter, GdkRectangle *strong_pos, GdkRectangle *weak_pos);
subroutine gtk_text_layout_get_cursor_locations(layout, iter, strong_pos, weak_p&
      &os) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: iter
  type(c_ptr), value :: strong_pos
  type(c_ptr), value :: weak_pos
end subroutine

! gboolean gtk_text_layout_clamp_iter_to_vrange (GtkTextLayout *layout, GtkTextIter *iter, gint top, gint bottom);
function gtk_text_layout_clamp_iter_to_vrange(layout, iter, top, bottom) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_layout_clamp_iter_to_vrange
  type(c_ptr), value :: layout
  type(c_ptr), value :: iter
  integer(c_int), value :: top
  integer(c_int), value :: bottom
end function

!  gboolean gtk_text_layout_move_iter_to_line_end (GtkTextLayout *layout, GtkTextIter *iter, gint direction);
function gtk_text_layout_move_iter_to_line_end(layout, iter, direction) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_layout_move_iter_to_line_end
  type(c_ptr), value :: layout
  type(c_ptr), value :: iter
  integer(c_int), value :: direction
end function

! gboolean gtk_text_layout_move_iter_to_previous_line (GtkTextLayout *layout, GtkTextIter *iter);
function gtk_text_layout_move_iter_to_previous_line(layout, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_layout_move_iter_to_previous_line
  type(c_ptr), value :: layout
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_layout_move_iter_to_next_line (GtkTextLayout *layout, GtkTextIter *iter);
function gtk_text_layout_move_iter_to_next_line(layout, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_layout_move_iter_to_next_line
  type(c_ptr), value :: layout
  type(c_ptr), value :: iter
end function

! void gtk_text_layout_move_iter_to_x (GtkTextLayout *layout, GtkTextIter *iter, gint x);
subroutine gtk_text_layout_move_iter_to_x(layout, iter, x) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  type(c_ptr), value :: iter
  integer(c_int), value :: x
end subroutine

! gboolean gtk_text_layout_move_iter_visually (GtkTextLayout *layout, GtkTextIter *iter, gint count);
function gtk_text_layout_move_iter_visually(layout, iter, count) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_layout_move_iter_visually
  type(c_ptr), value :: layout
  type(c_ptr), value :: iter
  integer(c_int), value :: count
end function

!  gboolean gtk_text_layout_iter_starts_line (GtkTextLayout *layout, const GtkTextIter *iter);
function gtk_text_layout_iter_starts_line(layout, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_layout_iter_starts_line
  type(c_ptr), value :: layout
  type(c_ptr), value :: iter
end function

!  void gtk_text_layout_get_iter_at_line (GtkTextLayout *layout, GtkTextIter *iter, GtkTextLine *line, gint byte_offset);
subroutine gtk_text_layout_get_iter_at_line(layout, iter, line, byte_offset) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  type(c_ptr), value :: iter
  type(c_ptr), value :: line
  integer(c_int), value :: byte_offset
end subroutine

!  void gtk_text_child_anchor_register_child (GtkTextChildAnchor *anchor, GtkWidget *child, GtkTextLayout *layout);
subroutine gtk_text_child_anchor_register_child(anchor, child, layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: anchor
  type(c_ptr), value :: child
  type(c_ptr), value :: layout
end subroutine

! void gtk_text_child_anchor_unregister_child (GtkTextChildAnchor *anchor, GtkWidget *child);
subroutine gtk_text_child_anchor_unregister_child(anchor, child) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: anchor
  type(c_ptr), value :: child
end subroutine

!  void gtk_text_child_anchor_queue_resize (GtkTextChildAnchor *anchor, GtkTextLayout *layout);
subroutine gtk_text_child_anchor_queue_resize(anchor, layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: anchor
  type(c_ptr), value :: layout
end subroutine

!  void gtk_text_anchored_child_set_layout (GtkWidget *child, GtkTextLayout *layout);
subroutine gtk_text_anchored_child_set_layout(child, layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: child
  type(c_ptr), value :: layout
end subroutine

!  void gtk_text_layout_spew (GtkTextLayout *layout);
subroutine gtk_text_layout_spew(layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
end subroutine

!   GType gtk_scrolled_window_get_type (void) G_GNUC_CONST;
function gtk_scrolled_window_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_scrolled_window_get_type
end function

! GtkWidget* gtk_scrolled_window_new (GtkAdjustment *hadjustment, GtkAdjustment *vadjustment);
function gtk_scrolled_window_new(hadjustment, vadjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_scrolled_window_new
  type(c_ptr), value :: hadjustment
  type(c_ptr), value :: vadjustment
end function

! void gtk_scrolled_window_set_hadjustment (GtkScrolledWindow *scrolled_window, GtkAdjustment *hadjustment);
subroutine gtk_scrolled_window_set_hadjustment(scrolled_window, hadjustment) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: scrolled_window
  type(c_ptr), value :: hadjustment
end subroutine

! void gtk_scrolled_window_set_vadjustment (GtkScrolledWindow *scrolled_window, GtkAdjustment *vadjustment);
subroutine gtk_scrolled_window_set_vadjustment(scrolled_window, vadjustment) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: scrolled_window
  type(c_ptr), value :: vadjustment
end subroutine

! GtkAdjustment* gtk_scrolled_window_get_hadjustment (GtkScrolledWindow *scrolled_window);
function gtk_scrolled_window_get_hadjustment(scrolled_window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_scrolled_window_get_hadjustment
  type(c_ptr), value :: scrolled_window
end function

! GtkAdjustment* gtk_scrolled_window_get_vadjustment (GtkScrolledWindow *scrolled_window);
function gtk_scrolled_window_get_vadjustment(scrolled_window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_scrolled_window_get_vadjustment
  type(c_ptr), value :: scrolled_window
end function

! GtkWidget* gtk_scrolled_window_get_hscrollbar (GtkScrolledWindow *scrolled_window);
function gtk_scrolled_window_get_hscrollbar(scrolled_window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_scrolled_window_get_hscrollbar
  type(c_ptr), value :: scrolled_window
end function

! GtkWidget* gtk_scrolled_window_get_vscrollbar (GtkScrolledWindow *scrolled_window);
function gtk_scrolled_window_get_vscrollbar(scrolled_window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_scrolled_window_get_vscrollbar
  type(c_ptr), value :: scrolled_window
end function

! void gtk_scrolled_window_set_policy (GtkScrolledWindow *scrolled_window, GtkPolicyType hscrollbar_policy, GtkPolicyType vscrollbar_policy);
subroutine gtk_scrolled_window_set_policy(scrolled_window, hscrollbar_policy, vs&
      &crollbar_policy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: scrolled_window
  integer(c_int), value :: hscrollbar_policy
  integer(c_int), value :: vscrollbar_policy
end subroutine

! void gtk_scrolled_window_get_policy (GtkScrolledWindow *scrolled_window, GtkPolicyType *hscrollbar_policy, GtkPolicyType *vscrollbar_policy);
subroutine gtk_scrolled_window_get_policy(scrolled_window, hscrollbar_policy, vs&
      &crollbar_policy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: scrolled_window
  integer(c_int), value :: hscrollbar_policy
  integer(c_int), value :: vscrollbar_policy
end subroutine

! void gtk_scrolled_window_set_placement (GtkScrolledWindow *scrolled_window, GtkCornerType window_placement);
subroutine gtk_scrolled_window_set_placement(scrolled_window, window_placement) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: scrolled_window
  integer(c_int), value :: window_placement
end subroutine

! void gtk_scrolled_window_unset_placement (GtkScrolledWindow *scrolled_window);
subroutine gtk_scrolled_window_unset_placement(scrolled_window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: scrolled_window
end subroutine

!  GtkCornerType gtk_scrolled_window_get_placement (GtkScrolledWindow *scrolled_window);
function gtk_scrolled_window_get_placement(scrolled_window) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_scrolled_window_get_placement
  type(c_ptr), value :: scrolled_window
end function

! void gtk_scrolled_window_set_shadow_type (GtkScrolledWindow *scrolled_window, GtkShadowType type);
subroutine gtk_scrolled_window_set_shadow_type(scrolled_window, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: scrolled_window
  integer(c_int), value :: type
end subroutine

! GtkShadowType gtk_scrolled_window_get_shadow_type (GtkScrolledWindow *scrolled_window);
function gtk_scrolled_window_get_shadow_type(scrolled_window) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_scrolled_window_get_shadow_type
  type(c_ptr), value :: scrolled_window
end function

! void gtk_scrolled_window_add_with_viewport (GtkScrolledWindow *scrolled_window, GtkWidget *child);
subroutine gtk_scrolled_window_add_with_viewport(scrolled_window, child) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: scrolled_window
  type(c_ptr), value :: child
end subroutine

!   GType gtk_list_item_get_type (void) G_GNUC_CONST;
function gtk_list_item_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_list_item_get_type
end function

! GtkWidget* gtk_list_item_new (void);
function gtk_list_item_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_list_item_new
end function

! GtkWidget* gtk_list_item_new_with_label (const gchar *label);
function gtk_list_item_new_with_label(label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_list_item_new_with_label
  character(kind=c_char), dimension(*) :: label
end function

! void gtk_list_item_select (GtkListItem *list_item);
subroutine gtk_list_item_select(list_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list_item
end subroutine

! void gtk_list_item_deselect (GtkListItem *list_item);
subroutine gtk_list_item_deselect(list_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list_item
end subroutine

!   GType gtk_editable_get_type (void) G_GNUC_CONST;
function gtk_editable_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_editable_get_type
end function

! void gtk_editable_select_region (GtkEditable *editable, gint start_pos, gint end_pos);
subroutine gtk_editable_select_region(editable, start_pos, end_pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: editable
  integer(c_int), value :: start_pos
  integer(c_int), value :: end_pos
end subroutine

! gboolean gtk_editable_get_selection_bounds (GtkEditable *editable, gint *start_pos, gint *end_pos);
function gtk_editable_get_selection_bounds(editable, start_pos, end_pos) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_editable_get_selection_bounds
  type(c_ptr), value :: editable
  type(c_ptr), value :: start_pos
  type(c_ptr), value :: end_pos
end function

! void gtk_editable_insert_text (GtkEditable *editable, const gchar *new_text, gint new_text_length, gint *position);
subroutine gtk_editable_insert_text(editable, new_text, new_text_length, positio&
      &n) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: editable
  character(kind=c_char), dimension(*) :: new_text
  integer(c_int), value :: new_text_length
  type(c_ptr), value :: position
end subroutine

! void gtk_editable_delete_text (GtkEditable *editable, gint start_pos, gint end_pos);
subroutine gtk_editable_delete_text(editable, start_pos, end_pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: editable
  integer(c_int), value :: start_pos
  integer(c_int), value :: end_pos
end subroutine

! gchar* gtk_editable_get_chars (GtkEditable *editable, gint start_pos, gint end_pos);
function gtk_editable_get_chars(editable, start_pos, end_pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_editable_get_chars
  type(c_ptr), value :: editable
  integer(c_int), value :: start_pos
  integer(c_int), value :: end_pos
end function

! void gtk_editable_cut_clipboard (GtkEditable *editable);
subroutine gtk_editable_cut_clipboard(editable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: editable
end subroutine

! void gtk_editable_copy_clipboard (GtkEditable *editable);
subroutine gtk_editable_copy_clipboard(editable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: editable
end subroutine

! void gtk_editable_paste_clipboard (GtkEditable *editable);
subroutine gtk_editable_paste_clipboard(editable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: editable
end subroutine

! void gtk_editable_delete_selection (GtkEditable *editable);
subroutine gtk_editable_delete_selection(editable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: editable
end subroutine

! void gtk_editable_set_position (GtkEditable *editable, gint position);
subroutine gtk_editable_set_position(editable, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: editable
  integer(c_int), value :: position
end subroutine

! gint gtk_editable_get_position (GtkEditable *editable);
function gtk_editable_get_position(editable) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_editable_get_position
  type(c_ptr), value :: editable
end function

! void gtk_editable_set_editable (GtkEditable *editable, gboolean is_editable);
subroutine gtk_editable_set_editable(editable, is_editable) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: editable
  logical(c_bool), value :: is_editable
end subroutine

! gboolean gtk_editable_get_editable (GtkEditable *editable);
function gtk_editable_get_editable(editable) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_editable_get_editable
  type(c_ptr), value :: editable
end function

!   GType gtk_icon_view_get_type (void) G_GNUC_CONST;
function gtk_icon_view_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_icon_view_get_type
end function

! GtkWidget * gtk_icon_view_new (void);
function gtk_icon_view_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_view_new
end function

! GtkWidget * gtk_icon_view_new_with_model (GtkTreeModel *model);
function gtk_icon_view_new_with_model(model) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_view_new_with_model
  type(c_ptr), value :: model
end function

!  void gtk_icon_view_set_model (GtkIconView *icon_view, GtkTreeModel *model);
subroutine gtk_icon_view_set_model(icon_view, model) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: icon_view
  type(c_ptr), value :: model
end subroutine

! GtkTreeModel * gtk_icon_view_get_model (GtkIconView *icon_view);
function gtk_icon_view_get_model(icon_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_view_get_model
  type(c_ptr), value :: icon_view
end function

! void gtk_icon_view_set_text_column (GtkIconView *icon_view, gint column);
subroutine gtk_icon_view_set_text_column(icon_view, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_view
  integer(c_int), value :: column
end subroutine

! gint gtk_icon_view_get_text_column (GtkIconView *icon_view);
function gtk_icon_view_get_text_column(icon_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_view_get_text_column
  type(c_ptr), value :: icon_view
end function

! void gtk_icon_view_set_markup_column (GtkIconView *icon_view, gint column);
subroutine gtk_icon_view_set_markup_column(icon_view, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_view
  integer(c_int), value :: column
end subroutine

! gint gtk_icon_view_get_markup_column (GtkIconView *icon_view);
function gtk_icon_view_get_markup_column(icon_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_view_get_markup_column
  type(c_ptr), value :: icon_view
end function

! void gtk_icon_view_set_pixbuf_column (GtkIconView *icon_view, gint column);
subroutine gtk_icon_view_set_pixbuf_column(icon_view, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_view
  integer(c_int), value :: column
end subroutine

! gint gtk_icon_view_get_pixbuf_column (GtkIconView *icon_view);
function gtk_icon_view_get_pixbuf_column(icon_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_view_get_pixbuf_column
  type(c_ptr), value :: icon_view
end function

!  void gtk_icon_view_set_orientation (GtkIconView *icon_view, GtkOrientation orientation);
subroutine gtk_icon_view_set_orientation(icon_view, orientation) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_view
  integer(c_int), value :: orientation
end subroutine

! GtkOrientation gtk_icon_view_get_orientation (GtkIconView *icon_view);
function gtk_icon_view_get_orientation(icon_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_view_get_orientation
  type(c_ptr), value :: icon_view
end function

! void gtk_icon_view_set_item_orientation (GtkIconView *icon_view, GtkOrientation orientation);
subroutine gtk_icon_view_set_item_orientation(icon_view, orientation) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_view
  integer(c_int), value :: orientation
end subroutine

! GtkOrientation gtk_icon_view_get_item_orientation (GtkIconView *icon_view);
function gtk_icon_view_get_item_orientation(icon_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_view_get_item_orientation
  type(c_ptr), value :: icon_view
end function

! void gtk_icon_view_set_columns (GtkIconView *icon_view, gint columns);
subroutine gtk_icon_view_set_columns(icon_view, columns) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_view
  integer(c_int), value :: columns
end subroutine

! gint gtk_icon_view_get_columns (GtkIconView *icon_view);
function gtk_icon_view_get_columns(icon_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_view_get_columns
  type(c_ptr), value :: icon_view
end function

! void gtk_icon_view_set_item_width (GtkIconView *icon_view, gint item_width);
subroutine gtk_icon_view_set_item_width(icon_view, item_width) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_view
  integer(c_int), value :: item_width
end subroutine

! gint gtk_icon_view_get_item_width (GtkIconView *icon_view);
function gtk_icon_view_get_item_width(icon_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_view_get_item_width
  type(c_ptr), value :: icon_view
end function

! void gtk_icon_view_set_spacing (GtkIconView *icon_view, gint spacing);
subroutine gtk_icon_view_set_spacing(icon_view, spacing) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_view
  integer(c_int), value :: spacing
end subroutine

! gint gtk_icon_view_get_spacing (GtkIconView *icon_view);
function gtk_icon_view_get_spacing(icon_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_view_get_spacing
  type(c_ptr), value :: icon_view
end function

! void gtk_icon_view_set_row_spacing (GtkIconView *icon_view, gint row_spacing);
subroutine gtk_icon_view_set_row_spacing(icon_view, row_spacing) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_view
  integer(c_int), value :: row_spacing
end subroutine

! gint gtk_icon_view_get_row_spacing (GtkIconView *icon_view);
function gtk_icon_view_get_row_spacing(icon_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_view_get_row_spacing
  type(c_ptr), value :: icon_view
end function

! void gtk_icon_view_set_column_spacing (GtkIconView *icon_view, gint column_spacing);
subroutine gtk_icon_view_set_column_spacing(icon_view, column_spacing) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_view
  integer(c_int), value :: column_spacing
end subroutine

! gint gtk_icon_view_get_column_spacing (GtkIconView *icon_view);
function gtk_icon_view_get_column_spacing(icon_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_view_get_column_spacing
  type(c_ptr), value :: icon_view
end function

! void gtk_icon_view_set_margin (GtkIconView *icon_view, gint margin);
subroutine gtk_icon_view_set_margin(icon_view, margin) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_view
  integer(c_int), value :: margin
end subroutine

! gint gtk_icon_view_get_margin (GtkIconView *icon_view);
function gtk_icon_view_get_margin(icon_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_view_get_margin
  type(c_ptr), value :: icon_view
end function

! void gtk_icon_view_set_item_padding (GtkIconView *icon_view, gint item_padding);
subroutine gtk_icon_view_set_item_padding(icon_view, item_padding) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_view
  integer(c_int), value :: item_padding
end subroutine

! gint gtk_icon_view_get_item_padding (GtkIconView *icon_view);
function gtk_icon_view_get_item_padding(icon_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_view_get_item_padding
  type(c_ptr), value :: icon_view
end function

!  GtkTreePath * gtk_icon_view_get_path_at_pos (GtkIconView *icon_view, gint x, gint y);
function gtk_icon_view_get_path_at_pos(icon_view, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_icon_view_get_path_at_pos
  type(c_ptr), value :: icon_view
  integer(c_int), value :: x
  integer(c_int), value :: y
end function

! gboolean gtk_icon_view_get_item_at_pos (GtkIconView *icon_view, gint x, gint y, GtkTreePath **path, GtkCellRenderer **cell);
function gtk_icon_view_get_item_at_pos(icon_view, x, y, path, cell) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_icon_view_get_item_at_pos
  type(c_ptr), value :: icon_view
  integer(c_int), value :: x
  integer(c_int), value :: y
  type(c_ptr), value :: path
  type(c_ptr), value :: cell
end function

! gboolean gtk_icon_view_get_visible_range (GtkIconView *icon_view, GtkTreePath **start_path, GtkTreePath **end_path);
function gtk_icon_view_get_visible_range(icon_view, start_path, end_path) bind(c&
      &) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_icon_view_get_visible_range
  type(c_ptr), value :: icon_view
  type(c_ptr), value :: start_path
  type(c_ptr), value :: end_path
end function

!  void gtk_icon_view_selected_foreach (GtkIconView *icon_view, GtkIconViewForeachFunc func, gpointer data);
subroutine gtk_icon_view_selected_foreach(icon_view, func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: icon_view
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end subroutine

! void gtk_icon_view_set_selection_mode (GtkIconView *icon_view, GtkSelectionMode mode);
subroutine gtk_icon_view_set_selection_mode(icon_view, mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_view
  integer(c_int), value :: mode
end subroutine

! GtkSelectionMode gtk_icon_view_get_selection_mode (GtkIconView *icon_view);
function gtk_icon_view_get_selection_mode(icon_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_view_get_selection_mode
  type(c_ptr), value :: icon_view
end function

! void gtk_icon_view_select_path (GtkIconView *icon_view, GtkTreePath *path);
subroutine gtk_icon_view_select_path(icon_view, path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: icon_view
  type(c_ptr), value :: path
end subroutine

! void gtk_icon_view_unselect_path (GtkIconView *icon_view, GtkTreePath *path);
subroutine gtk_icon_view_unselect_path(icon_view, path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: icon_view
  type(c_ptr), value :: path
end subroutine

! gboolean gtk_icon_view_path_is_selected (GtkIconView *icon_view, GtkTreePath *path);
function gtk_icon_view_path_is_selected(icon_view, path) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_icon_view_path_is_selected
  type(c_ptr), value :: icon_view
  type(c_ptr), value :: path
end function

! gint gtk_icon_view_get_item_row (GtkIconView *icon_view, GtkTreePath *path);
function gtk_icon_view_get_item_row(icon_view, path) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_view_get_item_row
  type(c_ptr), value :: icon_view
  type(c_ptr), value :: path
end function

! gint gtk_icon_view_get_item_column (GtkIconView *icon_view, GtkTreePath *path);
function gtk_icon_view_get_item_column(icon_view, path) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_view_get_item_column
  type(c_ptr), value :: icon_view
  type(c_ptr), value :: path
end function

! GList *gtk_icon_view_get_selected_items (GtkIconView *icon_view);
function gtk_icon_view_get_selected_items(icon_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_view_get_selected_items
  type(c_ptr), value :: icon_view
end function

! void gtk_icon_view_select_all (GtkIconView *icon_view);
subroutine gtk_icon_view_select_all(icon_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: icon_view
end subroutine

! void gtk_icon_view_unselect_all (GtkIconView *icon_view);
subroutine gtk_icon_view_unselect_all(icon_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: icon_view
end subroutine

! void gtk_icon_view_item_activated (GtkIconView *icon_view, GtkTreePath *path);
subroutine gtk_icon_view_item_activated(icon_view, path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: icon_view
  type(c_ptr), value :: path
end subroutine

! void gtk_icon_view_set_cursor (GtkIconView *icon_view, GtkTreePath *path, GtkCellRenderer *cell, gboolean start_editing);
subroutine gtk_icon_view_set_cursor(icon_view, path, cell, start_editing) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: icon_view
  type(c_ptr), value :: path
  type(c_ptr), value :: cell
  logical(c_bool), value :: start_editing
end subroutine

! gboolean gtk_icon_view_get_cursor (GtkIconView *icon_view, GtkTreePath **path, GtkCellRenderer **cell);
function gtk_icon_view_get_cursor(icon_view, path, cell) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_icon_view_get_cursor
  type(c_ptr), value :: icon_view
  type(c_ptr), value :: path
  type(c_ptr), value :: cell
end function

! void gtk_icon_view_scroll_to_path (GtkIconView *icon_view, GtkTreePath *path, gboolean use_align, gfloat row_align, gfloat col_align);
subroutine gtk_icon_view_scroll_to_path(icon_view, path, use_align, row_align, c&
      &ol_align) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_float
  type(c_ptr), value :: icon_view
  type(c_ptr), value :: path
  logical(c_bool), value :: use_align
  real(c_float), value :: row_align
  real(c_float), value :: col_align
end subroutine

!  void gtk_icon_view_enable_model_drag_source (GtkIconView *icon_view, GdkModifierType start_button_mask, const GtkTargetEntry *targets, gint n_targets, GdkDragAction actions);
subroutine gtk_icon_view_enable_model_drag_source(icon_view, start_button_mask, &
      &targets, n_targets, actions) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_view
  integer(c_int), value :: start_button_mask
  type(c_ptr), value :: targets
  integer(c_int), value :: n_targets
  integer(c_int), value :: actions
end subroutine

! void gtk_icon_view_enable_model_drag_dest (GtkIconView *icon_view, const GtkTargetEntry *targets, gint n_targets, GdkDragAction actions);
subroutine gtk_icon_view_enable_model_drag_dest(icon_view, targets, n_targets, a&
      &ctions) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_view
  type(c_ptr), value :: targets
  integer(c_int), value :: n_targets
  integer(c_int), value :: actions
end subroutine

! void gtk_icon_view_unset_model_drag_source (GtkIconView *icon_view);
subroutine gtk_icon_view_unset_model_drag_source(icon_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: icon_view
end subroutine

! void gtk_icon_view_unset_model_drag_dest (GtkIconView *icon_view);
subroutine gtk_icon_view_unset_model_drag_dest(icon_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: icon_view
end subroutine

! void gtk_icon_view_set_reorderable (GtkIconView *icon_view, gboolean reorderable);
subroutine gtk_icon_view_set_reorderable(icon_view, reorderable) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: icon_view
  logical(c_bool), value :: reorderable
end subroutine

! gboolean gtk_icon_view_get_reorderable (GtkIconView *icon_view);
function gtk_icon_view_get_reorderable(icon_view) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_icon_view_get_reorderable
  type(c_ptr), value :: icon_view
end function

!  void gtk_icon_view_set_drag_dest_item (GtkIconView *icon_view, GtkTreePath *path, GtkIconViewDropPosition pos);
subroutine gtk_icon_view_set_drag_dest_item(icon_view, path, pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_view
  type(c_ptr), value :: path
  integer(c_int), value :: pos
end subroutine

! void gtk_icon_view_get_drag_dest_item (GtkIconView *icon_view, GtkTreePath **path, GtkIconViewDropPosition *pos);
subroutine gtk_icon_view_get_drag_dest_item(icon_view, path, pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_view
  type(c_ptr), value :: path
  integer(c_int), value :: pos
end subroutine

! gboolean gtk_icon_view_get_dest_item_at_pos (GtkIconView *icon_view, gint drag_x, gint drag_y, GtkTreePath **path, GtkIconViewDropPosition *pos);
function gtk_icon_view_get_dest_item_at_pos(icon_view, drag_x, drag_y, path, pos&
      &) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_icon_view_get_dest_item_at_pos
  type(c_ptr), value :: icon_view
  integer(c_int), value :: drag_x
  integer(c_int), value :: drag_y
  type(c_ptr), value :: path
  integer(c_int), value :: pos
end function

! GdkPixmap *gtk_icon_view_create_drag_icon (GtkIconView *icon_view, GtkTreePath *path);
function gtk_icon_view_create_drag_icon(icon_view, path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_view_create_drag_icon
  type(c_ptr), value :: icon_view
  type(c_ptr), value :: path
end function

!  void gtk_icon_view_convert_widget_to_bin_window_coords (GtkIconView *icon_view, gint wx, gint wy, gint *bx, gint *by);
subroutine gtk_icon_view_convert_widget_to_bin_window_coords(icon_view, wx, wy, &
      &bx, by) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_view
  integer(c_int), value :: wx
  integer(c_int), value :: wy
  type(c_ptr), value :: bx
  type(c_ptr), value :: by
end subroutine

!  void gtk_icon_view_set_tooltip_item (GtkIconView *icon_view, GtkTooltip *tooltip, GtkTreePath *path);
subroutine gtk_icon_view_set_tooltip_item(icon_view, tooltip, path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: icon_view
  type(c_ptr), value :: tooltip
  type(c_ptr), value :: path
end subroutine

! void gtk_icon_view_set_tooltip_cell (GtkIconView *icon_view, GtkTooltip *tooltip, GtkTreePath *path, GtkCellRenderer *cell);
subroutine gtk_icon_view_set_tooltip_cell(icon_view, tooltip, path, cell) bind(c&
      &) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: icon_view
  type(c_ptr), value :: tooltip
  type(c_ptr), value :: path
  type(c_ptr), value :: cell
end subroutine

! gboolean gtk_icon_view_get_tooltip_context (GtkIconView *icon_view, gint *x, gint *y, gboolean keyboard_tip, GtkTreeModel **model, GtkTreePath **path, GtkTreeIter *iter);
function gtk_icon_view_get_tooltip_context(icon_view, x, y, keyboard_tip, model,&
      & path, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_icon_view_get_tooltip_context
  type(c_ptr), value :: icon_view
  type(c_ptr), value :: x
  type(c_ptr), value :: y
  logical(c_bool), value :: keyboard_tip
  type(c_ptr), value :: model
  type(c_ptr), value :: path
  type(c_ptr), value :: iter
end function

! void gtk_icon_view_set_tooltip_column (GtkIconView *icon_view, gint column);
subroutine gtk_icon_view_set_tooltip_column(icon_view, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_view
  integer(c_int), value :: column
end subroutine

! gint gtk_icon_view_get_tooltip_column (GtkIconView *icon_view);
function gtk_icon_view_get_tooltip_column(icon_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_view_get_tooltip_column
  type(c_ptr), value :: icon_view
end function

!   void gtk_marshal_BOOLEAN__VOID (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_BOOLEAN__VOID(closure, return_value, n_param_values, para&
      &m_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_BOOLEAN__POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_BOOLEAN__POINTER(closure, return_value, n_param_values, p&
      &aram_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_BOOLEAN__POINTER_POINTER_INT_INT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_BOOLEAN__POINTER_POINTER_INT_INT(closure, return_value, n&
      &_param_values, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_BOOLEAN__POINTER_INT_INT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_BOOLEAN__POINTER_INT_INT(closure, return_value, n_param_v&
      &alues, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_BOOLEAN__POINTER_INT_INT_UINT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_BOOLEAN__POINTER_INT_INT_UINT(closure, return_value, n_pa&
      &ram_values, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_BOOLEAN__POINTER_STRING_STRING_POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_BOOLEAN__POINTER_STRING_STRING_POINTER(closure, return_va&
      &lue, n_param_values, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_ENUM__ENUM (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_ENUM__ENUM(closure, return_value, n_param_values, param_v&
      &alues, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_INT__POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_INT__POINTER(closure, return_value, n_param_values, param&
      &_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_INT__POINTER_CHAR_CHAR (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_INT__POINTER_CHAR_CHAR(closure, return_value, n_param_val&
      &ues, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_VOID__ENUM_FLOAT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_VOID__ENUM_FLOAT(closure, return_value, n_param_values, p&
      &aram_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_VOID__ENUM_FLOAT_BOOLEAN (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_VOID__ENUM_FLOAT_BOOLEAN(closure, return_value, n_param_v&
      &alues, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_VOID__INT_INT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_VOID__INT_INT(closure, return_value, n_param_values, para&
      &m_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_VOID__INT_INT_POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_VOID__INT_INT_POINTER(closure, return_value, n_param_valu&
      &es, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_VOID__POINTER_INT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_VOID__POINTER_INT(closure, return_value, n_param_values, &
      &param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_VOID__POINTER_POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_VOID__POINTER_POINTER(closure, return_value, n_param_valu&
      &es, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_VOID__POINTER_POINTER_POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_VOID__POINTER_POINTER_POINTER(closure, return_value, n_pa&
      &ram_values, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_VOID__POINTER_STRING_STRING (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_VOID__POINTER_STRING_STRING(closure, return_value, n_para&
      &m_values, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_VOID__POINTER_UINT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_VOID__POINTER_UINT(closure, return_value, n_param_values,&
      & param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_VOID__POINTER_UINT_ENUM (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_VOID__POINTER_UINT_ENUM(closure, return_value, n_param_va&
      &lues, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_VOID__POINTER_POINTER_UINT_UINT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_VOID__POINTER_POINTER_UINT_UINT(closure, return_value, n_&
      &param_values, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_VOID__POINTER_INT_INT_POINTER_UINT_UINT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_VOID__POINTER_INT_INT_POINTER_UINT_UINT(closure, return_v&
      &alue, n_param_values, param_values, invocation_hint, marshal_data) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_VOID__POINTER_UINT_UINT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_VOID__POINTER_UINT_UINT(closure, return_value, n_param_va&
      &lues, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_VOID__STRING_INT_POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_VOID__STRING_INT_POINTER(closure, return_value, n_param_v&
      &alues, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_VOID__UINT_POINTER_UINT_ENUM_ENUM_POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_VOID__UINT_POINTER_UINT_ENUM_ENUM_POINTER(closure, return&
      &_value, n_param_values, param_values, invocation_hint, marshal_data) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_VOID__UINT_POINTER_UINT_UINT_ENUM (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_VOID__UINT_POINTER_UINT_UINT_ENUM(closure, return_value, &
      &n_param_values, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void gtk_marshal_VOID__UINT_STRING (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine gtk_marshal_VOID__UINT_STRING(closure, return_value, n_param_values, &
      &param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!   GType gtk_range_get_type (void) G_GNUC_CONST;
function gtk_range_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_range_get_type
end function

!  void gtk_range_set_update_policy (GtkRange *range, GtkUpdateType policy);
subroutine gtk_range_set_update_policy(range, policy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: range
  integer(c_int), value :: policy
end subroutine

! GtkUpdateType gtk_range_get_update_policy (GtkRange *range);
function gtk_range_get_update_policy(range) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_range_get_update_policy
  type(c_ptr), value :: range
end function

!  void gtk_range_set_adjustment (GtkRange *range, GtkAdjustment *adjustment);
subroutine gtk_range_set_adjustment(range, adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: range
  type(c_ptr), value :: adjustment
end subroutine

! GtkAdjustment* gtk_range_get_adjustment (GtkRange *range);
function gtk_range_get_adjustment(range) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_range_get_adjustment
  type(c_ptr), value :: range
end function

!  void gtk_range_set_inverted (GtkRange *range, gboolean setting);
subroutine gtk_range_set_inverted(range, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: range
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_range_get_inverted (GtkRange *range);
function gtk_range_get_inverted(range) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_range_get_inverted
  type(c_ptr), value :: range
end function

!  void gtk_range_set_flippable (GtkRange *range, gboolean flippable);
subroutine gtk_range_set_flippable(range, flippable) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: range
  logical(c_bool), value :: flippable
end subroutine

! gboolean gtk_range_get_flippable (GtkRange *range);
function gtk_range_get_flippable(range) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_range_get_flippable
  type(c_ptr), value :: range
end function

!  void gtk_range_set_slider_size_fixed (GtkRange *range, gboolean size_fixed);
subroutine gtk_range_set_slider_size_fixed(range, size_fixed) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: range
  logical(c_bool), value :: size_fixed
end subroutine

! gboolean gtk_range_get_slider_size_fixed (GtkRange *range);
function gtk_range_get_slider_size_fixed(range) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_range_get_slider_size_fixed
  type(c_ptr), value :: range
end function

!  void gtk_range_set_min_slider_size (GtkRange *range, gboolean min_size);
subroutine gtk_range_set_min_slider_size(range, min_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: range
  logical(c_bool), value :: min_size
end subroutine

! gint gtk_range_get_min_slider_size (GtkRange *range);
function gtk_range_get_min_slider_size(range) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_range_get_min_slider_size
  type(c_ptr), value :: range
end function

!  void gtk_range_get_range_rect (GtkRange *range, GdkRectangle *range_rect);
subroutine gtk_range_get_range_rect(range, range_rect) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: range
  type(c_ptr), value :: range_rect
end subroutine

! void gtk_range_get_slider_range (GtkRange *range, gint *slider_start, gint *slider_end);
subroutine gtk_range_get_slider_range(range, slider_start, slider_end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: range
  type(c_ptr), value :: slider_start
  type(c_ptr), value :: slider_end
end subroutine

!  void gtk_range_set_lower_stepper_sensitivity (GtkRange *range, GtkSensitivityType sensitivity);
subroutine gtk_range_set_lower_stepper_sensitivity(range, sensitivity) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: range
  integer(c_int), value :: sensitivity
end subroutine

! GtkSensitivityType gtk_range_get_lower_stepper_sensitivity (GtkRange *range);
function gtk_range_get_lower_stepper_sensitivity(range) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_range_get_lower_stepper_sensitivity
  type(c_ptr), value :: range
end function

! void gtk_range_set_upper_stepper_sensitivity (GtkRange *range, GtkSensitivityType sensitivity);
subroutine gtk_range_set_upper_stepper_sensitivity(range, sensitivity) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: range
  integer(c_int), value :: sensitivity
end subroutine

! GtkSensitivityType gtk_range_get_upper_stepper_sensitivity (GtkRange *range);
function gtk_range_get_upper_stepper_sensitivity(range) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_range_get_upper_stepper_sensitivity
  type(c_ptr), value :: range
end function

!  void gtk_range_set_increments (GtkRange *range, gdouble step, gdouble page);
subroutine gtk_range_set_increments(range, step, page) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: range
  real(c_double), value :: step
  real(c_double), value :: page
end subroutine

! void gtk_range_set_range (GtkRange *range, gdouble min, gdouble max);
subroutine gtk_range_set_range(range, min, max) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: range
  real(c_double), value :: min
  real(c_double), value :: max
end subroutine

! void gtk_range_set_value (GtkRange *range, gdouble value);
subroutine gtk_range_set_value(range, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: range
  real(c_double), value :: value
end subroutine

! gdouble gtk_range_get_value (GtkRange *range);
function gtk_range_get_value(range) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_range_get_value
  type(c_ptr), value :: range
end function

!  void gtk_range_set_show_fill_level (GtkRange *range, gboolean show_fill_level);
subroutine gtk_range_set_show_fill_level(range, show_fill_level) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: range
  logical(c_bool), value :: show_fill_level
end subroutine

! gboolean gtk_range_get_show_fill_level (GtkRange *range);
function gtk_range_get_show_fill_level(range) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_range_get_show_fill_level
  type(c_ptr), value :: range
end function

! void gtk_range_set_restrict_to_fill_level (GtkRange *range, gboolean restrict_to_fill_level);
subroutine gtk_range_set_restrict_to_fill_level(range, restrict_to_fill_level) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: range
  logical(c_bool), value :: restrict_to_fill_level
end subroutine

! gboolean gtk_range_get_restrict_to_fill_level (GtkRange *range);
function gtk_range_get_restrict_to_fill_level(range) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_range_get_restrict_to_fill_level
  type(c_ptr), value :: range
end function

! void gtk_range_set_fill_level (GtkRange *range, gdouble fill_level);
subroutine gtk_range_set_fill_level(range, fill_level) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: range
  real(c_double), value :: fill_level
end subroutine

! gdouble gtk_range_get_fill_level (GtkRange *range);
function gtk_range_get_fill_level(range) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_range_get_fill_level
  type(c_ptr), value :: range
end function

!   GType gtk_item_get_type (void) G_GNUC_CONST;
function gtk_item_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_item_get_type
end function

!  void gtk_item_select (GtkItem *item);
subroutine gtk_item_select(item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: item
end subroutine

! void gtk_item_deselect (GtkItem *item);
subroutine gtk_item_deselect(item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: item
end subroutine

! void gtk_item_toggle (GtkItem *item);
subroutine gtk_item_toggle(item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: item
end subroutine

! void gtk_test_register_all_types (void);
subroutine gtk_test_register_all_types() bind(c) 
  use iso_c_binding, only: 
end subroutine

! const GType* gtk_test_list_all_types (guint *n_types);
function gtk_test_list_all_types(n_types) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_test_list_all_types
  type(c_ptr), value :: n_types
end function

! GtkWidget* gtk_test_find_widget (GtkWidget *widget, const gchar *label_pattern, GType widget_type);
function gtk_test_find_widget(widget, label_pattern, widget_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: gtk_test_find_widget
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: label_pattern
  integer(c_size_t), value :: widget_type
end function

! GtkWidget* gtk_test_create_simple_window (const gchar *window_title, const gchar *dialog_text);
function gtk_test_create_simple_window(window_title, dialog_text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_test_create_simple_window
  character(kind=c_char), dimension(*) :: window_title
  character(kind=c_char), dimension(*) :: dialog_text
end function

! void gtk_test_slider_set_perc (GtkWidget *widget, double percentage);
subroutine gtk_test_slider_set_perc(widget, percentage) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: widget
  real(c_double), value :: percentage
end subroutine

! double gtk_test_slider_get_value (GtkWidget *widget);
function gtk_test_slider_get_value(widget) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_test_slider_get_value
  type(c_ptr), value :: widget
end function

! gboolean gtk_test_spin_button_click (GtkSpinButton *spinner, guint button, gboolean upwards);
function gtk_test_spin_button_click(spinner, button, upwards) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_test_spin_button_click
  type(c_ptr), value :: spinner
  integer(c_int), value :: button
  logical(c_bool), value :: upwards
end function

! gboolean gtk_test_widget_click (GtkWidget *widget, guint button, GdkModifierType modifiers);
function gtk_test_widget_click(widget, button, modifiers) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_test_widget_click
  type(c_ptr), value :: widget
  integer(c_int), value :: button
  integer(c_int), value :: modifiers
end function

! gboolean gtk_test_widget_send_key (GtkWidget *widget, guint keyval, GdkModifierType modifiers);
function gtk_test_widget_send_key(widget, keyval, modifiers) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_test_widget_send_key
  type(c_ptr), value :: widget
  integer(c_int), value :: keyval
  integer(c_int), value :: modifiers
end function

!  void gtk_test_text_set (GtkWidget *widget, const gchar *string);
subroutine gtk_test_text_set(widget, string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: string
end subroutine

! gchar* gtk_test_text_get (GtkWidget *widget);
function gtk_test_text_get(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_test_text_get
  type(c_ptr), value :: widget
end function

!  GtkWidget* gtk_test_find_sibling (GtkWidget *base_widget, GType widget_type);
function gtk_test_find_sibling(base_widget, widget_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: gtk_test_find_sibling
  type(c_ptr), value :: base_widget
  integer(c_size_t), value :: widget_type
end function

! GtkWidget* gtk_test_find_label (GtkWidget *widget, const gchar *label_pattern);
function gtk_test_find_label(widget, label_pattern) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_test_find_label
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: label_pattern
end function

!   GQuark gtk_builder_error_quark (void);
function gtk_builder_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: gtk_builder_error_quark
end function

!  GType gtk_builder_get_type (void) G_GNUC_CONST;
function gtk_builder_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_builder_get_type
end function

! GtkBuilder* gtk_builder_new (void);
function gtk_builder_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_builder_new
end function

!  guint gtk_builder_add_from_file (GtkBuilder *builder, const gchar *filename, GError **error);
function gtk_builder_add_from_file(builder, filename, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gtk_builder_add_from_file
  type(c_ptr), value :: builder
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: error
end function

! guint gtk_builder_add_from_string (GtkBuilder *builder, const gchar *buffer, gsize length, GError **error);
function gtk_builder_add_from_string(builder, buffer, length, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_size_t
  integer(c_int) :: gtk_builder_add_from_string
  type(c_ptr), value :: builder
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: length
  type(c_ptr), value :: error
end function

! guint gtk_builder_add_objects_from_file (GtkBuilder *builder, const gchar *filename, gchar **object_ids, GError **error);
function gtk_builder_add_objects_from_file(builder, filename, object_ids, error)&
      & bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gtk_builder_add_objects_from_file
  type(c_ptr), value :: builder
  character(kind=c_char), dimension(*) :: filename
  character(kind=c_char), dimension(*) :: object_ids
  type(c_ptr), value :: error
end function

! guint gtk_builder_add_objects_from_string (GtkBuilder *builder, const gchar *buffer, gsize length, gchar **object_ids, GError **error);
function gtk_builder_add_objects_from_string(builder, buffer, length, object_ids&
      &, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_size_t
  integer(c_int) :: gtk_builder_add_objects_from_string
  type(c_ptr), value :: builder
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: length
  character(kind=c_char), dimension(*) :: object_ids
  type(c_ptr), value :: error
end function

! GObject* gtk_builder_get_object (GtkBuilder *builder, const gchar *name);
function gtk_builder_get_object(builder, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_builder_get_object
  type(c_ptr), value :: builder
  character(kind=c_char), dimension(*) :: name
end function

! GSList* gtk_builder_get_objects (GtkBuilder *builder);
function gtk_builder_get_objects(builder) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_builder_get_objects
  type(c_ptr), value :: builder
end function

! void gtk_builder_connect_signals (GtkBuilder *builder, gpointer user_data);
subroutine gtk_builder_connect_signals(builder, user_data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: builder
  type(c_ptr), value :: user_data
end subroutine

! void gtk_builder_connect_signals_full (GtkBuilder *builder, GtkBuilderConnectFunc func, gpointer user_data);
subroutine gtk_builder_connect_signals_full(builder, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: builder
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! void gtk_builder_set_translation_domain (GtkBuilder *builder, const gchar *domain);
subroutine gtk_builder_set_translation_domain(builder, domain) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: builder
  character(kind=c_char), dimension(*) :: domain
end subroutine

! const gchar* gtk_builder_get_translation_domain (GtkBuilder *builder);
function gtk_builder_get_translation_domain(builder) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_builder_get_translation_domain
  type(c_ptr), value :: builder
end function

! GType gtk_builder_get_type_from_name (GtkBuilder *builder, const char *type_name);
function gtk_builder_get_type_from_name(builder, type_name) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char
  integer(c_size_t) :: gtk_builder_get_type_from_name
  type(c_ptr), value :: builder
  character(kind=c_char), dimension(*) :: type_name
end function

!  gboolean gtk_builder_value_from_string (GtkBuilder *builder, GParamSpec *pspec, const gchar *string, GValue *value, GError **error);
function gtk_builder_value_from_string(builder, pspec, string, value, error) bin&
      &d(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_builder_value_from_string
  type(c_ptr), value :: builder
  type(c_ptr), value :: pspec
  character(kind=c_char), dimension(*) :: string
  type(c_ptr), value :: value
  type(c_ptr), value :: error
end function

! gboolean gtk_builder_value_from_string_type (GtkBuilder *builder, GType type, const gchar *string, GValue *value, GError **error);
function gtk_builder_value_from_string_type(builder, type, string, value, error)&
      & bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_size_t, c_char
  logical(c_bool) :: gtk_builder_value_from_string_type
  type(c_ptr), value :: builder
  integer(c_size_t), value :: type
  character(kind=c_char), dimension(*) :: string
  type(c_ptr), value :: value
  type(c_ptr), value :: error
end function

!   GType gtk_toolbar_get_type (void) G_GNUC_CONST;
function gtk_toolbar_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_toolbar_get_type
end function

! GtkWidget * gtk_toolbar_new (void);
function gtk_toolbar_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_toolbar_new
end function

!  void gtk_toolbar_insert (GtkToolbar *toolbar, GtkToolItem *item, gint pos);
subroutine gtk_toolbar_insert(toolbar, item, pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: toolbar
  type(c_ptr), value :: item
  integer(c_int), value :: pos
end subroutine

!  gint gtk_toolbar_get_item_index (GtkToolbar *toolbar, GtkToolItem *item);
function gtk_toolbar_get_item_index(toolbar, item) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_toolbar_get_item_index
  type(c_ptr), value :: toolbar
  type(c_ptr), value :: item
end function

! gint gtk_toolbar_get_n_items (GtkToolbar *toolbar);
function gtk_toolbar_get_n_items(toolbar) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_toolbar_get_n_items
  type(c_ptr), value :: toolbar
end function

! GtkToolItem * gtk_toolbar_get_nth_item (GtkToolbar *toolbar, gint n);
function gtk_toolbar_get_nth_item(toolbar, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_toolbar_get_nth_item
  type(c_ptr), value :: toolbar
  integer(c_int), value :: n
end function

!  gboolean gtk_toolbar_get_show_arrow (GtkToolbar *toolbar);
function gtk_toolbar_get_show_arrow(toolbar) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_toolbar_get_show_arrow
  type(c_ptr), value :: toolbar
end function

! void gtk_toolbar_set_show_arrow (GtkToolbar *toolbar, gboolean show_arrow);
subroutine gtk_toolbar_set_show_arrow(toolbar, show_arrow) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: toolbar
  logical(c_bool), value :: show_arrow
end subroutine

!  GtkToolbarStyle gtk_toolbar_get_style (GtkToolbar *toolbar);
function gtk_toolbar_get_style(toolbar) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_toolbar_get_style
  type(c_ptr), value :: toolbar
end function

! void gtk_toolbar_set_style (GtkToolbar *toolbar, GtkToolbarStyle style);
subroutine gtk_toolbar_set_style(toolbar, style) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: toolbar
  integer(c_int), value :: style
end subroutine

! void gtk_toolbar_unset_style (GtkToolbar *toolbar);
subroutine gtk_toolbar_unset_style(toolbar) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: toolbar
end subroutine

!  GtkIconSize gtk_toolbar_get_icon_size (GtkToolbar *toolbar);
function gtk_toolbar_get_icon_size(toolbar) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_toolbar_get_icon_size
  type(c_ptr), value :: toolbar
end function

! void gtk_toolbar_set_icon_size (GtkToolbar *toolbar, GtkIconSize icon_size);
subroutine gtk_toolbar_set_icon_size(toolbar, icon_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: toolbar
  integer(c_int), value :: icon_size
end subroutine

! void gtk_toolbar_unset_icon_size (GtkToolbar *toolbar);
subroutine gtk_toolbar_unset_icon_size(toolbar) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: toolbar
end subroutine

!  GtkReliefStyle gtk_toolbar_get_relief_style (GtkToolbar *toolbar);
function gtk_toolbar_get_relief_style(toolbar) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_toolbar_get_relief_style
  type(c_ptr), value :: toolbar
end function

! gint gtk_toolbar_get_drop_index (GtkToolbar *toolbar, gint x, gint y);
function gtk_toolbar_get_drop_index(toolbar, x, y) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_toolbar_get_drop_index
  type(c_ptr), value :: toolbar
  integer(c_int), value :: x
  integer(c_int), value :: y
end function

! void gtk_toolbar_set_drop_highlight_item (GtkToolbar *toolbar, GtkToolItem *tool_item, gint index_);
subroutine gtk_toolbar_set_drop_highlight_item(toolbar, tool_item, index_) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: toolbar
  type(c_ptr), value :: tool_item
  integer(c_int), value :: index_
end subroutine

!  GtkOrientation gtk_toolbar_get_orientation (GtkToolbar *toolbar);
function gtk_toolbar_get_orientation(toolbar) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_toolbar_get_orientation
  type(c_ptr), value :: toolbar
end function

! void gtk_toolbar_set_orientation (GtkToolbar *toolbar, GtkOrientation orientation);
subroutine gtk_toolbar_set_orientation(toolbar, orientation) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: toolbar
  integer(c_int), value :: orientation
end subroutine

! gboolean gtk_toolbar_get_tooltips (GtkToolbar *toolbar);
function gtk_toolbar_get_tooltips(toolbar) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_toolbar_get_tooltips
  type(c_ptr), value :: toolbar
end function

! void gtk_toolbar_set_tooltips (GtkToolbar *toolbar, gboolean enable);
subroutine gtk_toolbar_set_tooltips(toolbar, enable) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: toolbar
  logical(c_bool), value :: enable
end subroutine

!  GtkWidget* gtk_toolbar_append_item (GtkToolbar *toolbar, const char *text, const char *tooltip_text, const char *tooltip_private_text, GtkWidget *icon, GCallback callback, gpointer user_data);
function gtk_toolbar_append_item(toolbar, text, tooltip_text, tooltip_private_te&
      &xt, icon, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr) :: gtk_toolbar_append_item
  type(c_ptr), value :: toolbar
  character(kind=c_char), dimension(*) :: text
  character(kind=c_char), dimension(*) :: tooltip_text
  character(kind=c_char), dimension(*) :: tooltip_private_text
  type(c_ptr), value :: icon
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end function

! GtkWidget* gtk_toolbar_prepend_item (GtkToolbar *toolbar, const char *text, const char *tooltip_text, const char *tooltip_private_text, GtkWidget *icon, GCallback callback, gpointer user_data);
function gtk_toolbar_prepend_item(toolbar, text, tooltip_text, tooltip_private_t&
      &ext, icon, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr) :: gtk_toolbar_prepend_item
  type(c_ptr), value :: toolbar
  character(kind=c_char), dimension(*) :: text
  character(kind=c_char), dimension(*) :: tooltip_text
  character(kind=c_char), dimension(*) :: tooltip_private_text
  type(c_ptr), value :: icon
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end function

! GtkWidget* gtk_toolbar_insert_item (GtkToolbar *toolbar, const char *text, const char *tooltip_text, const char *tooltip_private_text, GtkWidget *icon, GCallback callback, gpointer user_data, gint position);
function gtk_toolbar_insert_item(toolbar, text, tooltip_text, tooltip_private_te&
      &xt, icon, callback, user_data, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr, c_int
  type(c_ptr) :: gtk_toolbar_insert_item
  type(c_ptr), value :: toolbar
  character(kind=c_char), dimension(*) :: text
  character(kind=c_char), dimension(*) :: tooltip_text
  character(kind=c_char), dimension(*) :: tooltip_private_text
  type(c_ptr), value :: icon
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
  integer(c_int), value :: position
end function

!  GtkWidget* gtk_toolbar_insert_stock (GtkToolbar *toolbar, const gchar *stock_id, const char *tooltip_text, const char *tooltip_private_text, GCallback callback, gpointer user_data, gint position);
function gtk_toolbar_insert_stock(toolbar, stock_id, tooltip_text, tooltip_priva&
      &te_text, callback, user_data, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr, c_int
  type(c_ptr) :: gtk_toolbar_insert_stock
  type(c_ptr), value :: toolbar
  character(kind=c_char), dimension(*) :: stock_id
  character(kind=c_char), dimension(*) :: tooltip_text
  character(kind=c_char), dimension(*) :: tooltip_private_text
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
  integer(c_int), value :: position
end function

!  void gtk_toolbar_append_space (GtkToolbar *toolbar);
subroutine gtk_toolbar_append_space(toolbar) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: toolbar
end subroutine

! void gtk_toolbar_prepend_space (GtkToolbar *toolbar);
subroutine gtk_toolbar_prepend_space(toolbar) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: toolbar
end subroutine

! void gtk_toolbar_insert_space (GtkToolbar *toolbar, gint position);
subroutine gtk_toolbar_insert_space(toolbar, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: toolbar
  integer(c_int), value :: position
end subroutine

! void gtk_toolbar_remove_space (GtkToolbar *toolbar, gint position);
subroutine gtk_toolbar_remove_space(toolbar, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: toolbar
  integer(c_int), value :: position
end subroutine

!  GtkWidget* gtk_toolbar_append_element (GtkToolbar *toolbar, GtkToolbarChildType type, GtkWidget *widget, const char *text, const char *tooltip_text, const char *tooltip_private_text, GtkWidget *icon, GCallback callback, gpointer user_data);
function gtk_toolbar_append_element(toolbar, type, widget, text, tooltip_text, t&
      &ooltip_private_text, icon, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char, c_funptr
  type(c_ptr) :: gtk_toolbar_append_element
  type(c_ptr), value :: toolbar
  integer(c_int), value :: type
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: text
  character(kind=c_char), dimension(*) :: tooltip_text
  character(kind=c_char), dimension(*) :: tooltip_private_text
  type(c_ptr), value :: icon
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end function

!  GtkWidget* gtk_toolbar_prepend_element (GtkToolbar *toolbar, GtkToolbarChildType type, GtkWidget *widget, const char *text, const char *tooltip_text, const char *tooltip_private_text, GtkWidget *icon, GCallback callback, gpointer user_data);
function gtk_toolbar_prepend_element(toolbar, type, widget, text, tooltip_text, &
      &tooltip_private_text, icon, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char, c_funptr
  type(c_ptr) :: gtk_toolbar_prepend_element
  type(c_ptr), value :: toolbar
  integer(c_int), value :: type
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: text
  character(kind=c_char), dimension(*) :: tooltip_text
  character(kind=c_char), dimension(*) :: tooltip_private_text
  type(c_ptr), value :: icon
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end function

!  GtkWidget* gtk_toolbar_insert_element (GtkToolbar *toolbar, GtkToolbarChildType type, GtkWidget *widget, const char *text, const char *tooltip_text, const char *tooltip_private_text, GtkWidget *icon, GCallback callback, gpointer user_data, gint position);
function gtk_toolbar_insert_element(toolbar, type, widget, text, tooltip_text, t&
      &ooltip_private_text, icon, callback, user_data, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char, c_funptr
  type(c_ptr) :: gtk_toolbar_insert_element
  type(c_ptr), value :: toolbar
  integer(c_int), value :: type
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: text
  character(kind=c_char), dimension(*) :: tooltip_text
  character(kind=c_char), dimension(*) :: tooltip_private_text
  type(c_ptr), value :: icon
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
  integer(c_int), value :: position
end function

!  void gtk_toolbar_append_widget (GtkToolbar *toolbar, GtkWidget *widget, const char *tooltip_text, const char *tooltip_private_text);
subroutine gtk_toolbar_append_widget(toolbar, widget, tooltip_text, tooltip_priv&
      &ate_text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: toolbar
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: tooltip_text
  character(kind=c_char), dimension(*) :: tooltip_private_text
end subroutine

! void gtk_toolbar_prepend_widget (GtkToolbar *toolbar, GtkWidget *widget, const char *tooltip_text, const char *tooltip_private_text);
subroutine gtk_toolbar_prepend_widget(toolbar, widget, tooltip_text, tooltip_pri&
      &vate_text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: toolbar
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: tooltip_text
  character(kind=c_char), dimension(*) :: tooltip_private_text
end subroutine

! void gtk_toolbar_insert_widget (GtkToolbar *toolbar, GtkWidget *widget, const char *tooltip_text, const char *tooltip_private_text, gint position);
subroutine gtk_toolbar_insert_widget(toolbar, widget, tooltip_text, tooltip_priv&
      &ate_text, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: toolbar
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: tooltip_text
  character(kind=c_char), dimension(*) :: tooltip_private_text
  integer(c_int), value :: position
end subroutine

!   GType gtk_tree_model_filter_get_type (void) G_GNUC_CONST;
function gtk_tree_model_filter_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_model_filter_get_type
end function

! GtkTreeModel *gtk_tree_model_filter_new (GtkTreeModel *child_model, GtkTreePath *root);
function gtk_tree_model_filter_new(child_model, root) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_model_filter_new
  type(c_ptr), value :: child_model
  type(c_ptr), value :: root
end function

! void gtk_tree_model_filter_set_visible_func (GtkTreeModelFilter *filter, GtkTreeModelFilterVisibleFunc func, gpointer data, GDestroyNotify destroy);
subroutine gtk_tree_model_filter_set_visible_func(filter, func, data, destroy) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: filter
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

! void gtk_tree_model_filter_set_modify_func (GtkTreeModelFilter *filter, gint n_columns, GType *types, GtkTreeModelFilterModifyFunc func, gpointer data, GDestroyNotify destroy);
subroutine gtk_tree_model_filter_set_modify_func(filter, n_columns, types, func,&
      & data, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: filter
  integer(c_int), value :: n_columns
  type(c_ptr), value :: types
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

! void gtk_tree_model_filter_set_visible_column (GtkTreeModelFilter *filter, gint column);
subroutine gtk_tree_model_filter_set_visible_column(filter, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: filter
  integer(c_int), value :: column
end subroutine

!  GtkTreeModel *gtk_tree_model_filter_get_model (GtkTreeModelFilter *filter);
function gtk_tree_model_filter_get_model(filter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_model_filter_get_model
  type(c_ptr), value :: filter
end function

!  gboolean gtk_tree_model_filter_convert_child_iter_to_iter (GtkTreeModelFilter *filter, GtkTreeIter *filter_iter, GtkTreeIter *child_iter);
function gtk_tree_model_filter_convert_child_iter_to_iter(filter, filter_iter, c&
      &hild_iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_model_filter_convert_child_iter_to_iter
  type(c_ptr), value :: filter
  type(c_ptr), value :: filter_iter
  type(c_ptr), value :: child_iter
end function

! void gtk_tree_model_filter_convert_iter_to_child_iter (GtkTreeModelFilter *filter, GtkTreeIter *child_iter, GtkTreeIter *filter_iter);
subroutine gtk_tree_model_filter_convert_iter_to_child_iter(filter, child_iter, &
      &filter_iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: filter
  type(c_ptr), value :: child_iter
  type(c_ptr), value :: filter_iter
end subroutine

! GtkTreePath *gtk_tree_model_filter_convert_child_path_to_path (GtkTreeModelFilter *filter, GtkTreePath *child_path);
function gtk_tree_model_filter_convert_child_path_to_path(filter, child_path) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_model_filter_convert_child_path_to_path
  type(c_ptr), value :: filter
  type(c_ptr), value :: child_path
end function

! GtkTreePath *gtk_tree_model_filter_convert_path_to_child_path (GtkTreeModelFilter *filter, GtkTreePath *filter_path);
function gtk_tree_model_filter_convert_path_to_child_path(filter, filter_path) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_model_filter_convert_path_to_child_path
  type(c_ptr), value :: filter
  type(c_ptr), value :: filter_path
end function

!  void gtk_tree_model_filter_refilter (GtkTreeModelFilter *filter);
subroutine gtk_tree_model_filter_refilter(filter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: filter
end subroutine

! void gtk_tree_model_filter_clear_cache (GtkTreeModelFilter *filter);
subroutine gtk_tree_model_filter_clear_cache(filter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: filter
end subroutine

!   GType gtk_image_menu_item_get_type (void) G_GNUC_CONST;
function gtk_image_menu_item_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_image_menu_item_get_type
end function

! GtkWidget* gtk_image_menu_item_new (void);
function gtk_image_menu_item_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_image_menu_item_new
end function

! GtkWidget* gtk_image_menu_item_new_with_label (const gchar *label);
function gtk_image_menu_item_new_with_label(label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_image_menu_item_new_with_label
  character(kind=c_char), dimension(*) :: label
end function

! GtkWidget* gtk_image_menu_item_new_with_mnemonic (const gchar *label);
function gtk_image_menu_item_new_with_mnemonic(label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_image_menu_item_new_with_mnemonic
  character(kind=c_char), dimension(*) :: label
end function

! GtkWidget* gtk_image_menu_item_new_from_stock (const gchar *stock_id, GtkAccelGroup *accel_group);
function gtk_image_menu_item_new_from_stock(stock_id, accel_group) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_image_menu_item_new_from_stock
  character(kind=c_char), dimension(*) :: stock_id
  type(c_ptr), value :: accel_group
end function

! void gtk_image_menu_item_set_always_show_image (GtkImageMenuItem *image_menu_item, gboolean always_show);
subroutine gtk_image_menu_item_set_always_show_image(image_menu_item, always_sho&
      &w) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: image_menu_item
  logical(c_bool), value :: always_show
end subroutine

! gboolean gtk_image_menu_item_get_always_show_image (GtkImageMenuItem *image_menu_item);
function gtk_image_menu_item_get_always_show_image(image_menu_item) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_image_menu_item_get_always_show_image
  type(c_ptr), value :: image_menu_item
end function

! void gtk_image_menu_item_set_image (GtkImageMenuItem *image_menu_item, GtkWidget *image);
subroutine gtk_image_menu_item_set_image(image_menu_item, image) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: image_menu_item
  type(c_ptr), value :: image
end subroutine

! GtkWidget* gtk_image_menu_item_get_image (GtkImageMenuItem *image_menu_item);
function gtk_image_menu_item_get_image(image_menu_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_image_menu_item_get_image
  type(c_ptr), value :: image_menu_item
end function

! void gtk_image_menu_item_set_use_stock (GtkImageMenuItem *image_menu_item, gboolean use_stock);
subroutine gtk_image_menu_item_set_use_stock(image_menu_item, use_stock) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: image_menu_item
  logical(c_bool), value :: use_stock
end subroutine

! gboolean gtk_image_menu_item_get_use_stock (GtkImageMenuItem *image_menu_item);
function gtk_image_menu_item_get_use_stock(image_menu_item) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_image_menu_item_get_use_stock
  type(c_ptr), value :: image_menu_item
end function

! void gtk_image_menu_item_set_accel_group (GtkImageMenuItem *image_menu_item, GtkAccelGroup *accel_group);
subroutine gtk_image_menu_item_set_accel_group(image_menu_item, accel_group) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: image_menu_item
  type(c_ptr), value :: accel_group
end subroutine

!   GType gtk_identifier_get_type (void) G_GNUC_CONST;
function gtk_identifier_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_identifier_get_type
end function

!  void gtk_type_init (GTypeDebugFlags debug_flags);
subroutine gtk_type_init(debug_flags) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: debug_flags
end subroutine

! GtkType gtk_type_unique (GtkType parent_type, const GtkTypeInfo *gtkinfo);
function gtk_type_unique(parent_type, gtkinfo) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: gtk_type_unique
  integer(c_size_t), value :: parent_type
  type(c_ptr), value :: gtkinfo
end function

! gpointer gtk_type_class (GtkType type);
function gtk_type_class(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: gtk_type_class
  integer(c_size_t), value :: type
end function

! gpointer gtk_type_new (GtkType type);
function gtk_type_new(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: gtk_type_new
  integer(c_size_t), value :: type
end function

!  GtkEnumValue* gtk_type_enum_get_values (GtkType enum_type);
function gtk_type_enum_get_values(enum_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: gtk_type_enum_get_values
  integer(c_size_t), value :: enum_type
end function

! GtkFlagValue* gtk_type_flags_get_values (GtkType flags_type);
function gtk_type_flags_get_values(flags_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: gtk_type_flags_get_values
  integer(c_size_t), value :: flags_type
end function

! GtkEnumValue* gtk_type_enum_find_value (GtkType enum_type, const gchar *value_name);
function gtk_type_enum_find_value(enum_type, value_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr) :: gtk_type_enum_find_value
  integer(c_size_t), value :: enum_type
  character(kind=c_char), dimension(*) :: value_name
end function

! GtkFlagValue* gtk_type_flags_find_value (GtkType flags_type, const gchar *value_name);
function gtk_type_flags_find_value(flags_type, value_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr) :: gtk_type_flags_find_value
  integer(c_size_t), value :: flags_type
  character(kind=c_char), dimension(*) :: value_name
end function

!   GType gtk_cell_renderer_text_get_type (void) G_GNUC_CONST;
function gtk_cell_renderer_text_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_cell_renderer_text_get_type
end function

! GtkCellRenderer *gtk_cell_renderer_text_new (void);
function gtk_cell_renderer_text_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_cell_renderer_text_new
end function

!  void gtk_cell_renderer_text_set_fixed_height_from_font (GtkCellRendererText *renderer, gint number_of_rows);
subroutine gtk_cell_renderer_text_set_fixed_height_from_font(renderer, number_of&
      &_rows) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: renderer
  integer(c_int), value :: number_of_rows
end subroutine

!   GType gtk_radio_menu_item_get_type (void) G_GNUC_CONST;
function gtk_radio_menu_item_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_radio_menu_item_get_type
end function

!  GtkWidget* gtk_radio_menu_item_new (GSList *group);
function gtk_radio_menu_item_new(group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_radio_menu_item_new
  type(c_ptr), value :: group
end function

! GtkWidget* gtk_radio_menu_item_new_with_label (GSList *group, const gchar *label);
function gtk_radio_menu_item_new_with_label(group, label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_radio_menu_item_new_with_label
  type(c_ptr), value :: group
  character(kind=c_char), dimension(*) :: label
end function

! GtkWidget* gtk_radio_menu_item_new_with_mnemonic (GSList *group, const gchar *label);
function gtk_radio_menu_item_new_with_mnemonic(group, label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_radio_menu_item_new_with_mnemonic
  type(c_ptr), value :: group
  character(kind=c_char), dimension(*) :: label
end function

! GtkWidget* gtk_radio_menu_item_new_from_widget (GtkRadioMenuItem *group);
function gtk_radio_menu_item_new_from_widget(group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_radio_menu_item_new_from_widget
  type(c_ptr), value :: group
end function

! GtkWidget *gtk_radio_menu_item_new_with_mnemonic_from_widget (GtkRadioMenuItem *group, const gchar *label);
function gtk_radio_menu_item_new_with_mnemonic_from_widget(group, label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_radio_menu_item_new_with_mnemonic_from_widget
  type(c_ptr), value :: group
  character(kind=c_char), dimension(*) :: label
end function

! GtkWidget *gtk_radio_menu_item_new_with_label_from_widget (GtkRadioMenuItem *group, const gchar *label);
function gtk_radio_menu_item_new_with_label_from_widget(group, label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_radio_menu_item_new_with_label_from_widget
  type(c_ptr), value :: group
  character(kind=c_char), dimension(*) :: label
end function

! GSList* gtk_radio_menu_item_get_group (GtkRadioMenuItem *radio_menu_item);
function gtk_radio_menu_item_get_group(radio_menu_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_radio_menu_item_get_group
  type(c_ptr), value :: radio_menu_item
end function

! void gtk_radio_menu_item_set_group (GtkRadioMenuItem *radio_menu_item, GSList *group);
subroutine gtk_radio_menu_item_set_group(radio_menu_item, group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: radio_menu_item
  type(c_ptr), value :: group
end subroutine

!   GType gtk_aspect_frame_get_type (void) G_GNUC_CONST;
function gtk_aspect_frame_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_aspect_frame_get_type
end function

! GtkWidget* gtk_aspect_frame_new (const gchar *label, gfloat xalign, gfloat yalign, gfloat ratio, gboolean obey_child);
function gtk_aspect_frame_new(label, xalign, yalign, ratio, obey_child) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_float, c_bool
  type(c_ptr) :: gtk_aspect_frame_new
  character(kind=c_char), dimension(*) :: label
  real(c_float), value :: xalign
  real(c_float), value :: yalign
  real(c_float), value :: ratio
  logical(c_bool), value :: obey_child
end function

! void gtk_aspect_frame_set (GtkAspectFrame *aspect_frame, gfloat xalign, gfloat yalign, gfloat ratio, gboolean obey_child);
subroutine gtk_aspect_frame_set(aspect_frame, xalign, yalign, ratio, obey_child)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_float, c_bool
  type(c_ptr), value :: aspect_frame
  real(c_float), value :: xalign
  real(c_float), value :: yalign
  real(c_float), value :: ratio
  logical(c_bool), value :: obey_child
end subroutine

!   GType gtk_offscreen_window_get_type (void) G_GNUC_CONST;
function gtk_offscreen_window_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_offscreen_window_get_type
end function

!  GtkWidget *gtk_offscreen_window_new (void);
function gtk_offscreen_window_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_offscreen_window_new
end function

! GdkPixmap *gtk_offscreen_window_get_pixmap (GtkOffscreenWindow *offscreen);
function gtk_offscreen_window_get_pixmap(offscreen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_offscreen_window_get_pixmap
  type(c_ptr), value :: offscreen
end function

! GdkPixbuf *gtk_offscreen_window_get_pixbuf (GtkOffscreenWindow *offscreen);
function gtk_offscreen_window_get_pixbuf(offscreen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_offscreen_window_get_pixbuf
  type(c_ptr), value :: offscreen
end function

!   GType gtk_separator_get_type (void) G_GNUC_CONST;
function gtk_separator_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_separator_get_type
end function

!   GtkTreePath *gtk_tree_path_new (void);
function gtk_tree_path_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_path_new
end function

! GtkTreePath *gtk_tree_path_new_from_string (const gchar *path);
function gtk_tree_path_new_from_string(path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_tree_path_new_from_string
  character(kind=c_char), dimension(*) :: path
end function

! gchar *gtk_tree_path_to_string (GtkTreePath *path);
function gtk_tree_path_to_string(path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_path_to_string
  type(c_ptr), value :: path
end function

! GtkTreePath *gtk_tree_path_new_first (void);
function gtk_tree_path_new_first() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_path_new_first
end function

! void gtk_tree_path_append_index (GtkTreePath *path, gint index_);
subroutine gtk_tree_path_append_index(path, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: path
  integer(c_int), value :: index_
end subroutine

! void gtk_tree_path_prepend_index (GtkTreePath *path, gint index_);
subroutine gtk_tree_path_prepend_index(path, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: path
  integer(c_int), value :: index_
end subroutine

! gint gtk_tree_path_get_depth (GtkTreePath *path);
function gtk_tree_path_get_depth(path) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_path_get_depth
  type(c_ptr), value :: path
end function

! gint *gtk_tree_path_get_indices (GtkTreePath *path);
function gtk_tree_path_get_indices(path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_path_get_indices
  type(c_ptr), value :: path
end function

! gint *gtk_tree_path_get_indices_with_depth (GtkTreePath *path, gint *depth);
function gtk_tree_path_get_indices_with_depth(path, depth) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_path_get_indices_with_depth
  type(c_ptr), value :: path
  type(c_ptr), value :: depth
end function

! void gtk_tree_path_free (GtkTreePath *path);
subroutine gtk_tree_path_free(path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: path
end subroutine

! GtkTreePath *gtk_tree_path_copy (const GtkTreePath *path);
function gtk_tree_path_copy(path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_path_copy
  type(c_ptr), value :: path
end function

! GType gtk_tree_path_get_type (void) G_GNUC_CONST;
function gtk_tree_path_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_path_get_type
end function

! gint gtk_tree_path_compare (const GtkTreePath *a, const GtkTreePath *b);
function gtk_tree_path_compare(a, b) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_path_compare
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! void gtk_tree_path_next (GtkTreePath *path);
subroutine gtk_tree_path_next(path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: path
end subroutine

! gboolean gtk_tree_path_prev (GtkTreePath *path);
function gtk_tree_path_prev(path) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_path_prev
  type(c_ptr), value :: path
end function

! gboolean gtk_tree_path_up (GtkTreePath *path);
function gtk_tree_path_up(path) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_path_up
  type(c_ptr), value :: path
end function

! void gtk_tree_path_down (GtkTreePath *path);
subroutine gtk_tree_path_down(path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: path
end subroutine

!  gboolean gtk_tree_path_is_ancestor (GtkTreePath *path, GtkTreePath *descendant);
function gtk_tree_path_is_ancestor(path, descendant) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_path_is_ancestor
  type(c_ptr), value :: path
  type(c_ptr), value :: descendant
end function

! gboolean gtk_tree_path_is_descendant (GtkTreePath *path, GtkTreePath *ancestor);
function gtk_tree_path_is_descendant(path, ancestor) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_path_is_descendant
  type(c_ptr), value :: path
  type(c_ptr), value :: ancestor
end function

!  GType gtk_tree_row_reference_get_type (void) G_GNUC_CONST;
function gtk_tree_row_reference_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_row_reference_get_type
end function

! GtkTreeRowReference *gtk_tree_row_reference_new (GtkTreeModel *model, GtkTreePath *path);
function gtk_tree_row_reference_new(model, path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_row_reference_new
  type(c_ptr), value :: model
  type(c_ptr), value :: path
end function

! GtkTreeRowReference *gtk_tree_row_reference_new_proxy (GObject *proxy, GtkTreeModel *model, GtkTreePath *path);
function gtk_tree_row_reference_new_proxy(proxy, model, path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_row_reference_new_proxy
  type(c_ptr), value :: proxy
  type(c_ptr), value :: model
  type(c_ptr), value :: path
end function

! GtkTreePath *gtk_tree_row_reference_get_path (GtkTreeRowReference *reference);
function gtk_tree_row_reference_get_path(reference) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_row_reference_get_path
  type(c_ptr), value :: reference
end function

! GtkTreeModel *gtk_tree_row_reference_get_model (GtkTreeRowReference *reference);
function gtk_tree_row_reference_get_model(reference) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_row_reference_get_model
  type(c_ptr), value :: reference
end function

! gboolean gtk_tree_row_reference_valid (GtkTreeRowReference *reference);
function gtk_tree_row_reference_valid(reference) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_row_reference_valid
  type(c_ptr), value :: reference
end function

! GtkTreeRowReference *gtk_tree_row_reference_copy (GtkTreeRowReference *reference);
function gtk_tree_row_reference_copy(reference) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_row_reference_copy
  type(c_ptr), value :: reference
end function

! void gtk_tree_row_reference_free (GtkTreeRowReference *reference);
subroutine gtk_tree_row_reference_free(reference) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: reference
end subroutine

!  void gtk_tree_row_reference_inserted (GObject *proxy, GtkTreePath *path);
subroutine gtk_tree_row_reference_inserted(proxy, path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: proxy
  type(c_ptr), value :: path
end subroutine

! void gtk_tree_row_reference_deleted (GObject *proxy, GtkTreePath *path);
subroutine gtk_tree_row_reference_deleted(proxy, path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: proxy
  type(c_ptr), value :: path
end subroutine

! void gtk_tree_row_reference_reordered (GObject *proxy, GtkTreePath *path, GtkTreeIter *iter, gint *new_order);
subroutine gtk_tree_row_reference_reordered(proxy, path, iter, new_order) bind(c&
      &) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: proxy
  type(c_ptr), value :: path
  type(c_ptr), value :: iter
  type(c_ptr), value :: new_order
end subroutine

!  GtkTreeIter * gtk_tree_iter_copy (GtkTreeIter *iter);
function gtk_tree_iter_copy(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_iter_copy
  type(c_ptr), value :: iter
end function

! void gtk_tree_iter_free (GtkTreeIter *iter);
subroutine gtk_tree_iter_free(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
end subroutine

! GType gtk_tree_iter_get_type (void) G_GNUC_CONST;
function gtk_tree_iter_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_iter_get_type
end function

!  GType gtk_tree_model_get_type (void) G_GNUC_CONST;
function gtk_tree_model_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_model_get_type
end function

! GtkTreeModelFlags gtk_tree_model_get_flags (GtkTreeModel *tree_model);
function gtk_tree_model_get_flags(tree_model) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_model_get_flags
  type(c_ptr), value :: tree_model
end function

! gint gtk_tree_model_get_n_columns (GtkTreeModel *tree_model);
function gtk_tree_model_get_n_columns(tree_model) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_model_get_n_columns
  type(c_ptr), value :: tree_model
end function

! GType gtk_tree_model_get_column_type (GtkTreeModel *tree_model, gint index_);
function gtk_tree_model_get_column_type(tree_model, index_) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_int
  integer(c_size_t) :: gtk_tree_model_get_column_type
  type(c_ptr), value :: tree_model
  integer(c_int), value :: index_
end function

!  gboolean gtk_tree_model_get_iter (GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreePath *path);
function gtk_tree_model_get_iter(tree_model, iter, path) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_model_get_iter
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: iter
  type(c_ptr), value :: path
end function

! gboolean gtk_tree_model_get_iter_from_string (GtkTreeModel *tree_model, GtkTreeIter *iter, const gchar *path_string);
function gtk_tree_model_get_iter_from_string(tree_model, iter, path_string) bind&
      &(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_tree_model_get_iter_from_string
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: iter
  character(kind=c_char), dimension(*) :: path_string
end function

! gchar * gtk_tree_model_get_string_from_iter (GtkTreeModel *tree_model, GtkTreeIter *iter);
function gtk_tree_model_get_string_from_iter(tree_model, iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_model_get_string_from_iter
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: iter
end function

! gboolean gtk_tree_model_get_iter_first (GtkTreeModel *tree_model, GtkTreeIter *iter);
function gtk_tree_model_get_iter_first(tree_model, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_model_get_iter_first
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: iter
end function

! GtkTreePath * gtk_tree_model_get_path (GtkTreeModel *tree_model, GtkTreeIter *iter);
function gtk_tree_model_get_path(tree_model, iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_model_get_path
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: iter
end function

! void gtk_tree_model_get_value (GtkTreeModel *tree_model, GtkTreeIter *iter, gint column, GValue *value);
subroutine gtk_tree_model_get_value(tree_model, iter, column, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: iter
  integer(c_int), value :: column
  type(c_ptr), value :: value
end subroutine

! gboolean gtk_tree_model_iter_next (GtkTreeModel *tree_model, GtkTreeIter *iter);
function gtk_tree_model_iter_next(tree_model, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_model_iter_next
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: iter
end function

! gboolean gtk_tree_model_iter_children (GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *parent);
function gtk_tree_model_iter_children(tree_model, iter, parent) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_model_iter_children
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: iter
  type(c_ptr), value :: parent
end function

! gboolean gtk_tree_model_iter_has_child (GtkTreeModel *tree_model, GtkTreeIter *iter);
function gtk_tree_model_iter_has_child(tree_model, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_model_iter_has_child
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: iter
end function

! gint gtk_tree_model_iter_n_children (GtkTreeModel *tree_model, GtkTreeIter *iter);
function gtk_tree_model_iter_n_children(tree_model, iter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_model_iter_n_children
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: iter
end function

! gboolean gtk_tree_model_iter_nth_child (GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *parent, gint n);
function gtk_tree_model_iter_nth_child(tree_model, iter, parent, n) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_tree_model_iter_nth_child
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: iter
  type(c_ptr), value :: parent
  integer(c_int), value :: n
end function

! gboolean gtk_tree_model_iter_parent (GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *child);
function gtk_tree_model_iter_parent(tree_model, iter, child) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_model_iter_parent
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: iter
  type(c_ptr), value :: child
end function

! void gtk_tree_model_ref_node (GtkTreeModel *tree_model, GtkTreeIter *iter);
subroutine gtk_tree_model_ref_node(tree_model, iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: iter
end subroutine

! void gtk_tree_model_unref_node (GtkTreeModel *tree_model, GtkTreeIter *iter);
subroutine gtk_tree_model_unref_node(tree_model, iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: iter
end subroutine

! void gtk_tree_model_get_valist (GtkTreeModel *tree_model, GtkTreeIter *iter, va_list var_args);
subroutine gtk_tree_model_get_valist(tree_model, iter, var_args) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: iter
  type(c_ptr), value :: var_args
end subroutine

!  void gtk_tree_model_foreach (GtkTreeModel *model, GtkTreeModelForeachFunc func, gpointer user_data);
subroutine gtk_tree_model_foreach(model, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: model
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!  void gtk_tree_model_row_changed (GtkTreeModel *tree_model, GtkTreePath *path, GtkTreeIter *iter);
subroutine gtk_tree_model_row_changed(tree_model, path, iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: path
  type(c_ptr), value :: iter
end subroutine

! void gtk_tree_model_row_inserted (GtkTreeModel *tree_model, GtkTreePath *path, GtkTreeIter *iter);
subroutine gtk_tree_model_row_inserted(tree_model, path, iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: path
  type(c_ptr), value :: iter
end subroutine

! void gtk_tree_model_row_has_child_toggled (GtkTreeModel *tree_model, GtkTreePath *path, GtkTreeIter *iter);
subroutine gtk_tree_model_row_has_child_toggled(tree_model, path, iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: path
  type(c_ptr), value :: iter
end subroutine

! void gtk_tree_model_row_deleted (GtkTreeModel *tree_model, GtkTreePath *path);
subroutine gtk_tree_model_row_deleted(tree_model, path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: path
end subroutine

! void gtk_tree_model_rows_reordered (GtkTreeModel *tree_model, GtkTreePath *path, GtkTreeIter *iter, gint *new_order);
subroutine gtk_tree_model_rows_reordered(tree_model, path, iter, new_order) bind&
      &(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: path
  type(c_ptr), value :: iter
  type(c_ptr), value :: new_order
end subroutine

!   GdkGC* gtk_gc_get (gint depth, GdkColormap *colormap, GdkGCValues *values, GdkGCValuesMask values_mask);
function gtk_gc_get(depth, colormap, values, values_mask) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_gc_get
  integer(c_int), value :: depth
  type(c_ptr), value :: colormap
  type(c_ptr), value :: values
  integer(c_int), value :: values_mask
end function

! void gtk_gc_release (GdkGC *gc);
subroutine gtk_gc_release(gc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: gc
end subroutine

!   GType gtk_box_get_type (void) G_GNUC_CONST;
function gtk_box_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_box_get_type
end function

!  void gtk_box_pack_start (GtkBox *box, GtkWidget *child, gboolean expand, gboolean fill, guint padding);
subroutine gtk_box_pack_start(box, child, expand, fill, padding) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_int
  type(c_ptr), value :: box
  type(c_ptr), value :: child
  logical(c_bool), value :: expand
  logical(c_bool), value :: fill
  integer(c_int), value :: padding
end subroutine

! void gtk_box_pack_end (GtkBox *box, GtkWidget *child, gboolean expand, gboolean fill, guint padding);
subroutine gtk_box_pack_end(box, child, expand, fill, padding) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_int
  type(c_ptr), value :: box
  type(c_ptr), value :: child
  logical(c_bool), value :: expand
  logical(c_bool), value :: fill
  integer(c_int), value :: padding
end subroutine

!  void gtk_box_pack_start_defaults (GtkBox *box, GtkWidget *widget);
subroutine gtk_box_pack_start_defaults(box, widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: box
  type(c_ptr), value :: widget
end subroutine

! void gtk_box_pack_end_defaults (GtkBox *box, GtkWidget *widget);
subroutine gtk_box_pack_end_defaults(box, widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: box
  type(c_ptr), value :: widget
end subroutine

!  void gtk_box_set_homogeneous (GtkBox *box, gboolean homogeneous);
subroutine gtk_box_set_homogeneous(box, homogeneous) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: box
  logical(c_bool), value :: homogeneous
end subroutine

! gboolean gtk_box_get_homogeneous (GtkBox *box);
function gtk_box_get_homogeneous(box) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_box_get_homogeneous
  type(c_ptr), value :: box
end function

! void gtk_box_set_spacing (GtkBox *box, gint spacing);
subroutine gtk_box_set_spacing(box, spacing) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: box
  integer(c_int), value :: spacing
end subroutine

! gint gtk_box_get_spacing (GtkBox *box);
function gtk_box_get_spacing(box) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_box_get_spacing
  type(c_ptr), value :: box
end function

!  void gtk_box_reorder_child (GtkBox *box, GtkWidget *child, gint position);
subroutine gtk_box_reorder_child(box, child, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: box
  type(c_ptr), value :: child
  integer(c_int), value :: position
end subroutine

!  void gtk_box_query_child_packing (GtkBox *box, GtkWidget *child, gboolean *expand, gboolean *fill, guint *padding, GtkPackType *pack_type);
subroutine gtk_box_query_child_packing(box, child, expand, fill, padding, pack_t&
      &ype) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: box
  type(c_ptr), value :: child
  type(c_ptr), value :: expand
  type(c_ptr), value :: fill
  type(c_ptr), value :: padding
  integer(c_int), value :: pack_type
end subroutine

! void gtk_box_set_child_packing (GtkBox *box, GtkWidget *child, gboolean expand, gboolean fill, guint padding, GtkPackType pack_type);
subroutine gtk_box_set_child_packing(box, child, expand, fill, padding, pack_typ&
      &e) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_int
  type(c_ptr), value :: box
  type(c_ptr), value :: child
  logical(c_bool), value :: expand
  logical(c_bool), value :: fill
  integer(c_int), value :: padding
  integer(c_int), value :: pack_type
end subroutine

!   GQuark gtk_recent_manager_error_quark (void);
function gtk_recent_manager_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: gtk_recent_manager_error_quark
end function

!  GType gtk_recent_manager_get_type (void) G_GNUC_CONST;
function gtk_recent_manager_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_recent_manager_get_type
end function

!  GtkRecentManager *gtk_recent_manager_new (void);
function gtk_recent_manager_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_manager_new
end function

! GtkRecentManager *gtk_recent_manager_get_default (void);
function gtk_recent_manager_get_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_manager_get_default
end function

!  GtkRecentManager *gtk_recent_manager_get_for_screen (GdkScreen *screen);
function gtk_recent_manager_get_for_screen(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_manager_get_for_screen
  type(c_ptr), value :: screen
end function

! void gtk_recent_manager_set_screen (GtkRecentManager *manager, GdkScreen *screen);
subroutine gtk_recent_manager_set_screen(manager, screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: manager
  type(c_ptr), value :: screen
end subroutine

!  gboolean gtk_recent_manager_add_item (GtkRecentManager *manager, const gchar *uri);
function gtk_recent_manager_add_item(manager, uri) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_recent_manager_add_item
  type(c_ptr), value :: manager
  character(kind=c_char), dimension(*) :: uri
end function

! gboolean gtk_recent_manager_add_full (GtkRecentManager *manager, const gchar *uri, const GtkRecentData *recent_data);
function gtk_recent_manager_add_full(manager, uri, recent_data) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_recent_manager_add_full
  type(c_ptr), value :: manager
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: recent_data
end function

! gboolean gtk_recent_manager_remove_item (GtkRecentManager *manager, const gchar *uri, GError **error);
function gtk_recent_manager_remove_item(manager, uri, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_recent_manager_remove_item
  type(c_ptr), value :: manager
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! GtkRecentInfo * gtk_recent_manager_lookup_item (GtkRecentManager *manager, const gchar *uri, GError **error);
function gtk_recent_manager_lookup_item(manager, uri, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_recent_manager_lookup_item
  type(c_ptr), value :: manager
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! gboolean gtk_recent_manager_has_item (GtkRecentManager *manager, const gchar *uri);
function gtk_recent_manager_has_item(manager, uri) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_recent_manager_has_item
  type(c_ptr), value :: manager
  character(kind=c_char), dimension(*) :: uri
end function

! gboolean gtk_recent_manager_move_item (GtkRecentManager *manager, const gchar *uri, const gchar *new_uri, GError **error);
function gtk_recent_manager_move_item(manager, uri, new_uri, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_recent_manager_move_item
  type(c_ptr), value :: manager
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: new_uri
  type(c_ptr), value :: error
end function

! void gtk_recent_manager_set_limit (GtkRecentManager *manager, gint limit);
subroutine gtk_recent_manager_set_limit(manager, limit) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: manager
  integer(c_int), value :: limit
end subroutine

! gint gtk_recent_manager_get_limit (GtkRecentManager *manager);
function gtk_recent_manager_get_limit(manager) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_recent_manager_get_limit
  type(c_ptr), value :: manager
end function

! GList * gtk_recent_manager_get_items (GtkRecentManager *manager);
function gtk_recent_manager_get_items(manager) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_manager_get_items
  type(c_ptr), value :: manager
end function

! gint gtk_recent_manager_purge_items (GtkRecentManager *manager, GError **error);
function gtk_recent_manager_purge_items(manager, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_recent_manager_purge_items
  type(c_ptr), value :: manager
  type(c_ptr), value :: error
end function

!  GType gtk_recent_info_get_type (void) G_GNUC_CONST;
function gtk_recent_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_recent_info_get_type
end function

!  GtkRecentInfo * gtk_recent_info_ref (GtkRecentInfo *info);
function gtk_recent_info_ref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_info_ref
  type(c_ptr), value :: info
end function

! void gtk_recent_info_unref (GtkRecentInfo *info);
subroutine gtk_recent_info_unref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
end subroutine

!  G_CONST_RETURN gchar *gtk_recent_info_get_uri (GtkRecentInfo *info);
function gtk_recent_info_get_uri(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_info_get_uri
  type(c_ptr), value :: info
end function

! G_CONST_RETURN gchar *gtk_recent_info_get_display_name (GtkRecentInfo *info);
function gtk_recent_info_get_display_name(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_info_get_display_name
  type(c_ptr), value :: info
end function

! G_CONST_RETURN gchar *gtk_recent_info_get_description (GtkRecentInfo *info);
function gtk_recent_info_get_description(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_info_get_description
  type(c_ptr), value :: info
end function

! G_CONST_RETURN gchar *gtk_recent_info_get_mime_type (GtkRecentInfo *info);
function gtk_recent_info_get_mime_type(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_info_get_mime_type
  type(c_ptr), value :: info
end function

! time_t gtk_recent_info_get_added (GtkRecentInfo *info);
function gtk_recent_info_get_added(info) bind(c) 
  use iso_c_binding, only: c_long, c_ptr
  integer(c_long) :: gtk_recent_info_get_added
  type(c_ptr), value :: info
end function

! time_t gtk_recent_info_get_modified (GtkRecentInfo *info);
function gtk_recent_info_get_modified(info) bind(c) 
  use iso_c_binding, only: c_long, c_ptr
  integer(c_long) :: gtk_recent_info_get_modified
  type(c_ptr), value :: info
end function

! time_t gtk_recent_info_get_visited (GtkRecentInfo *info);
function gtk_recent_info_get_visited(info) bind(c) 
  use iso_c_binding, only: c_long, c_ptr
  integer(c_long) :: gtk_recent_info_get_visited
  type(c_ptr), value :: info
end function

! gboolean gtk_recent_info_get_private_hint (GtkRecentInfo *info);
function gtk_recent_info_get_private_hint(info) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_recent_info_get_private_hint
  type(c_ptr), value :: info
end function

! gboolean gtk_recent_info_get_application_info (GtkRecentInfo *info, const gchar *app_name, const gchar **app_exec, guint *count, time_t *time_);
function gtk_recent_info_get_application_info(info, app_name, app_exec, count, t&
      &ime_) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_recent_info_get_application_info
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: app_name
  character(kind=c_char), dimension(*) :: app_exec
  type(c_ptr), value :: count
  type(c_ptr), value :: time_
end function

! gchar ** gtk_recent_info_get_applications (GtkRecentInfo *info, gsize *length) G_GNUC_MALLOC;
function gtk_recent_info_get_applications(info, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_info_get_applications
  type(c_ptr), value :: info
  type(c_ptr), value :: length
end function

! gchar * gtk_recent_info_last_application (GtkRecentInfo *info) G_GNUC_MALLOC;
function gtk_recent_info_last_application(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_info_last_application
  type(c_ptr), value :: info
end function

! gboolean gtk_recent_info_has_application (GtkRecentInfo *info, const gchar *app_name);
function gtk_recent_info_has_application(info, app_name) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_recent_info_has_application
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: app_name
end function

! gchar ** gtk_recent_info_get_groups (GtkRecentInfo *info, gsize *length) G_GNUC_MALLOC;
function gtk_recent_info_get_groups(info, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_info_get_groups
  type(c_ptr), value :: info
  type(c_ptr), value :: length
end function

! gboolean gtk_recent_info_has_group (GtkRecentInfo *info, const gchar *group_name);
function gtk_recent_info_has_group(info, group_name) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_recent_info_has_group
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: group_name
end function

! GdkPixbuf * gtk_recent_info_get_icon (GtkRecentInfo *info, gint size);
function gtk_recent_info_get_icon(info, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_recent_info_get_icon
  type(c_ptr), value :: info
  integer(c_int), value :: size
end function

! gchar * gtk_recent_info_get_short_name (GtkRecentInfo *info) G_GNUC_MALLOC;
function gtk_recent_info_get_short_name(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_info_get_short_name
  type(c_ptr), value :: info
end function

! gchar * gtk_recent_info_get_uri_display (GtkRecentInfo *info) G_GNUC_MALLOC;
function gtk_recent_info_get_uri_display(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_info_get_uri_display
  type(c_ptr), value :: info
end function

! gint gtk_recent_info_get_age (GtkRecentInfo *info);
function gtk_recent_info_get_age(info) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_recent_info_get_age
  type(c_ptr), value :: info
end function

! gboolean gtk_recent_info_is_local (GtkRecentInfo *info);
function gtk_recent_info_is_local(info) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_recent_info_is_local
  type(c_ptr), value :: info
end function

! gboolean gtk_recent_info_exists (GtkRecentInfo *info);
function gtk_recent_info_exists(info) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_recent_info_exists
  type(c_ptr), value :: info
end function

! gboolean gtk_recent_info_match (GtkRecentInfo *info_a, GtkRecentInfo *info_b);
function gtk_recent_info_match(info_a, info_b) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_recent_info_match
  type(c_ptr), value :: info_a
  type(c_ptr), value :: info_b
end function

!   GType gtk_vscrollbar_get_type (void) G_GNUC_CONST;
function gtk_vscrollbar_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_vscrollbar_get_type
end function

! GtkWidget* gtk_vscrollbar_new (GtkAdjustment *adjustment);
function gtk_vscrollbar_new(adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_vscrollbar_new
  type(c_ptr), value :: adjustment
end function

!  GtkBindingSet* gtk_binding_set_new (const gchar *set_name);
function gtk_binding_set_new(set_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_binding_set_new
  character(kind=c_char), dimension(*) :: set_name
end function

! GtkBindingSet* gtk_binding_set_by_class(gpointer object_class);
function gtk_binding_set_by_class(object_class) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_binding_set_by_class
  type(c_ptr), value :: object_class
end function

! GtkBindingSet* gtk_binding_set_find (const gchar *set_name);
function gtk_binding_set_find(set_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_binding_set_find
  character(kind=c_char), dimension(*) :: set_name
end function

! gboolean gtk_bindings_activate (GtkObject *object, guint keyval, GdkModifierType modifiers);
function gtk_bindings_activate(object, keyval, modifiers) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_bindings_activate
  type(c_ptr), value :: object
  integer(c_int), value :: keyval
  integer(c_int), value :: modifiers
end function

! gboolean gtk_bindings_activate_event (GtkObject *object, GdkEventKey *event);
function gtk_bindings_activate_event(object, event) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_bindings_activate_event
  type(c_ptr), value :: object
  type(c_ptr), value :: event
end function

! gboolean gtk_binding_set_activate (GtkBindingSet *binding_set, guint keyval, GdkModifierType modifiers, GtkObject *object);
function gtk_binding_set_activate(binding_set, keyval, modifiers, object) bind(c&
      &) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_binding_set_activate
  type(c_ptr), value :: binding_set
  integer(c_int), value :: keyval
  integer(c_int), value :: modifiers
  type(c_ptr), value :: object
end function

!  void gtk_binding_entry_clear (GtkBindingSet *binding_set, guint keyval, GdkModifierType modifiers);
subroutine gtk_binding_entry_clear(binding_set, keyval, modifiers) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: binding_set
  integer(c_int), value :: keyval
  integer(c_int), value :: modifiers
end subroutine

! guint gtk_binding_parse_binding (GScanner *scanner);
function gtk_binding_parse_binding(scanner) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_binding_parse_binding
  type(c_ptr), value :: scanner
end function

!  void gtk_binding_entry_skip (GtkBindingSet *binding_set, guint keyval, GdkModifierType modifiers);
subroutine gtk_binding_entry_skip(binding_set, keyval, modifiers) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: binding_set
  integer(c_int), value :: keyval
  integer(c_int), value :: modifiers
end subroutine

! void gtk_binding_entry_add_signall (GtkBindingSet *binding_set, guint keyval, GdkModifierType modifiers, const gchar *signal_name, GSList *binding_args);
subroutine gtk_binding_entry_add_signall(binding_set, keyval, modifiers, signal_&
      &name, binding_args) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: binding_set
  integer(c_int), value :: keyval
  integer(c_int), value :: modifiers
  character(kind=c_char), dimension(*) :: signal_name
  type(c_ptr), value :: binding_args
end subroutine

! void gtk_binding_entry_remove (GtkBindingSet *binding_set, guint keyval, GdkModifierType modifiers);
subroutine gtk_binding_entry_remove(binding_set, keyval, modifiers) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: binding_set
  integer(c_int), value :: keyval
  integer(c_int), value :: modifiers
end subroutine

!  void gtk_binding_set_add_path (GtkBindingSet *binding_set, GtkPathType path_type, const gchar *path_pattern, GtkPathPriorityType priority);
subroutine gtk_binding_set_add_path(binding_set, path_type, path_pattern, priori&
      &ty) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: binding_set
  integer(c_int), value :: path_type
  character(kind=c_char), dimension(*) :: path_pattern
  integer(c_int), value :: priority
end subroutine

!   GType gtk_ruler_get_type (void) G_GNUC_CONST;
function gtk_ruler_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_ruler_get_type
end function

! void gtk_ruler_set_metric (GtkRuler *ruler, GtkMetricType metric);
subroutine gtk_ruler_set_metric(ruler, metric) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: ruler
  integer(c_int), value :: metric
end subroutine

! GtkMetricType gtk_ruler_get_metric (GtkRuler *ruler);
function gtk_ruler_get_metric(ruler) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_ruler_get_metric
  type(c_ptr), value :: ruler
end function

! void gtk_ruler_set_range (GtkRuler *ruler, gdouble lower, gdouble upper, gdouble position, gdouble max_size);
subroutine gtk_ruler_set_range(ruler, lower, upper, position, max_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: ruler
  real(c_double), value :: lower
  real(c_double), value :: upper
  real(c_double), value :: position
  real(c_double), value :: max_size
end subroutine

! void gtk_ruler_get_range (GtkRuler *ruler, gdouble *lower, gdouble *upper, gdouble *position, gdouble *max_size);
subroutine gtk_ruler_get_range(ruler, lower, upper, position, max_size) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ruler
  type(c_ptr), value :: lower
  type(c_ptr), value :: upper
  type(c_ptr), value :: position
  type(c_ptr), value :: max_size
end subroutine

!  void gtk_ruler_draw_ticks (GtkRuler *ruler);
subroutine gtk_ruler_draw_ticks(ruler) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ruler
end subroutine

! void gtk_ruler_draw_pos (GtkRuler *ruler);
subroutine gtk_ruler_draw_pos(ruler) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ruler
end subroutine

!   GType gtk_link_button_get_type (void) G_GNUC_CONST;
function gtk_link_button_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_link_button_get_type
end function

!  GtkWidget * gtk_link_button_new (const gchar *uri);
function gtk_link_button_new(uri) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_link_button_new
  character(kind=c_char), dimension(*) :: uri
end function

! GtkWidget * gtk_link_button_new_with_label (const gchar *uri, const gchar *label);
function gtk_link_button_new_with_label(uri, label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_link_button_new_with_label
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: label
end function

!  G_CONST_RETURN gchar *gtk_link_button_get_uri (GtkLinkButton *link_button);
function gtk_link_button_get_uri(link_button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_link_button_get_uri
  type(c_ptr), value :: link_button
end function

! void gtk_link_button_set_uri (GtkLinkButton *link_button, const gchar *uri);
subroutine gtk_link_button_set_uri(link_button, uri) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: link_button
  character(kind=c_char), dimension(*) :: uri
end subroutine

!  GtkLinkButtonUriFunc gtk_link_button_set_uri_hook (GtkLinkButtonUriFunc func, gpointer data, GDestroyNotify destroy);
function gtk_link_button_set_uri_hook(func, data, destroy) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr) :: gtk_link_button_set_uri_hook
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end function

!  gboolean gtk_link_button_get_visited (GtkLinkButton *link_button);
function gtk_link_button_get_visited(link_button) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_link_button_get_visited
  type(c_ptr), value :: link_button
end function

! void gtk_link_button_set_visited (GtkLinkButton *link_button, gboolean visited);
subroutine gtk_link_button_set_visited(link_button, visited) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: link_button
  logical(c_bool), value :: visited
end subroutine

!   GType gtk_combo_box_get_type (void) G_GNUC_CONST;
function gtk_combo_box_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_combo_box_get_type
end function

! GtkWidget *gtk_combo_box_new (void);
function gtk_combo_box_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_combo_box_new
end function

! GtkWidget *gtk_combo_box_new_with_model (GtkTreeModel *model);
function gtk_combo_box_new_with_model(model) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_combo_box_new_with_model
  type(c_ptr), value :: model
end function

!  gint gtk_combo_box_get_wrap_width (GtkComboBox *combo_box);
function gtk_combo_box_get_wrap_width(combo_box) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_combo_box_get_wrap_width
  type(c_ptr), value :: combo_box
end function

! void gtk_combo_box_set_wrap_width (GtkComboBox *combo_box, gint width);
subroutine gtk_combo_box_set_wrap_width(combo_box, width) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: combo_box
  integer(c_int), value :: width
end subroutine

! gint gtk_combo_box_get_row_span_column (GtkComboBox *combo_box);
function gtk_combo_box_get_row_span_column(combo_box) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_combo_box_get_row_span_column
  type(c_ptr), value :: combo_box
end function

! void gtk_combo_box_set_row_span_column (GtkComboBox *combo_box, gint row_span);
subroutine gtk_combo_box_set_row_span_column(combo_box, row_span) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: combo_box
  integer(c_int), value :: row_span
end subroutine

! gint gtk_combo_box_get_column_span_column (GtkComboBox *combo_box);
function gtk_combo_box_get_column_span_column(combo_box) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_combo_box_get_column_span_column
  type(c_ptr), value :: combo_box
end function

! void gtk_combo_box_set_column_span_column (GtkComboBox *combo_box, gint column_span);
subroutine gtk_combo_box_set_column_span_column(combo_box, column_span) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: combo_box
  integer(c_int), value :: column_span
end subroutine

!  gboolean gtk_combo_box_get_add_tearoffs (GtkComboBox *combo_box);
function gtk_combo_box_get_add_tearoffs(combo_box) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_combo_box_get_add_tearoffs
  type(c_ptr), value :: combo_box
end function

! void gtk_combo_box_set_add_tearoffs (GtkComboBox *combo_box, gboolean add_tearoffs);
subroutine gtk_combo_box_set_add_tearoffs(combo_box, add_tearoffs) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: combo_box
  logical(c_bool), value :: add_tearoffs
end subroutine

!  G_CONST_RETURN gchar *gtk_combo_box_get_title (GtkComboBox *combo_box);
function gtk_combo_box_get_title(combo_box) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_combo_box_get_title
  type(c_ptr), value :: combo_box
end function

! void gtk_combo_box_set_title (GtkComboBox *combo_box, const gchar *title);
subroutine gtk_combo_box_set_title(combo_box, title) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: combo_box
  character(kind=c_char), dimension(*) :: title
end subroutine

!  gboolean gtk_combo_box_get_focus_on_click (GtkComboBox *combo);
function gtk_combo_box_get_focus_on_click(combo) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_combo_box_get_focus_on_click
  type(c_ptr), value :: combo
end function

! void gtk_combo_box_set_focus_on_click (GtkComboBox *combo, gboolean focus_on_click);
subroutine gtk_combo_box_set_focus_on_click(combo, focus_on_click) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: combo
  logical(c_bool), value :: focus_on_click
end subroutine

!  gint gtk_combo_box_get_active (GtkComboBox *combo_box);
function gtk_combo_box_get_active(combo_box) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_combo_box_get_active
  type(c_ptr), value :: combo_box
end function

! void gtk_combo_box_set_active (GtkComboBox *combo_box, gint index_);
subroutine gtk_combo_box_set_active(combo_box, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: combo_box
  integer(c_int), value :: index_
end subroutine

! gboolean gtk_combo_box_get_active_iter (GtkComboBox *combo_box, GtkTreeIter *iter);
function gtk_combo_box_get_active_iter(combo_box, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_combo_box_get_active_iter
  type(c_ptr), value :: combo_box
  type(c_ptr), value :: iter
end function

! void gtk_combo_box_set_active_iter (GtkComboBox *combo_box, GtkTreeIter *iter);
subroutine gtk_combo_box_set_active_iter(combo_box, iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: combo_box
  type(c_ptr), value :: iter
end subroutine

!  void gtk_combo_box_set_model (GtkComboBox *combo_box, GtkTreeModel *model);
subroutine gtk_combo_box_set_model(combo_box, model) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: combo_box
  type(c_ptr), value :: model
end subroutine

! GtkTreeModel *gtk_combo_box_get_model (GtkComboBox *combo_box);
function gtk_combo_box_get_model(combo_box) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_combo_box_get_model
  type(c_ptr), value :: combo_box
end function

!  GtkTreeViewRowSeparatorFunc gtk_combo_box_get_row_separator_func (GtkComboBox *combo_box);
function gtk_combo_box_get_row_separator_func(combo_box) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr) :: gtk_combo_box_get_row_separator_func
  type(c_ptr), value :: combo_box
end function

! void gtk_combo_box_set_row_separator_func (GtkComboBox *combo_box, GtkTreeViewRowSeparatorFunc func, gpointer data, GDestroyNotify destroy);
subroutine gtk_combo_box_set_row_separator_func(combo_box, func, data, destroy) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: combo_box
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

!  void gtk_combo_box_set_button_sensitivity (GtkComboBox *combo_box, GtkSensitivityType sensitivity);
subroutine gtk_combo_box_set_button_sensitivity(combo_box, sensitivity) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: combo_box
  integer(c_int), value :: sensitivity
end subroutine

! GtkSensitivityType gtk_combo_box_get_button_sensitivity (GtkComboBox *combo_box);
function gtk_combo_box_get_button_sensitivity(combo_box) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_combo_box_get_button_sensitivity
  type(c_ptr), value :: combo_box
end function

!  GtkWidget *gtk_combo_box_new_text (void);
function gtk_combo_box_new_text() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_combo_box_new_text
end function

! void gtk_combo_box_append_text (GtkComboBox *combo_box, const gchar *text);
subroutine gtk_combo_box_append_text(combo_box, text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: combo_box
  character(kind=c_char), dimension(*) :: text
end subroutine

! void gtk_combo_box_insert_text (GtkComboBox *combo_box, gint position, const gchar *text);
subroutine gtk_combo_box_insert_text(combo_box, position, text) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: combo_box
  integer(c_int), value :: position
  character(kind=c_char), dimension(*) :: text
end subroutine

! void gtk_combo_box_prepend_text (GtkComboBox *combo_box, const gchar *text);
subroutine gtk_combo_box_prepend_text(combo_box, text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: combo_box
  character(kind=c_char), dimension(*) :: text
end subroutine

! void gtk_combo_box_remove_text (GtkComboBox *combo_box, gint position);
subroutine gtk_combo_box_remove_text(combo_box, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: combo_box
  integer(c_int), value :: position
end subroutine

! gchar *gtk_combo_box_get_active_text (GtkComboBox *combo_box);
function gtk_combo_box_get_active_text(combo_box) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_combo_box_get_active_text
  type(c_ptr), value :: combo_box
end function

!  void gtk_combo_box_popup (GtkComboBox *combo_box);
subroutine gtk_combo_box_popup(combo_box) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: combo_box
end subroutine

! void gtk_combo_box_popdown (GtkComboBox *combo_box);
subroutine gtk_combo_box_popdown(combo_box) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: combo_box
end subroutine

! AtkObject* gtk_combo_box_get_popup_accessible (GtkComboBox *combo_box);
function gtk_combo_box_get_popup_accessible(combo_box) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_combo_box_get_popup_accessible
  type(c_ptr), value :: combo_box
end function

!   void gtk_text_layout_draw (GtkTextLayout *layout, GtkWidget *widget, GdkDrawable *drawable, GdkGC *cursor_gc, gint x_offset, gint y_offset, gint x, gint y, gint width, gint height, GList **widgets);
subroutine gtk_text_layout_draw(layout, widget, drawable, cursor_gc, x_offset, y&
      &_offset, x, y, width, height, widgets) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  type(c_ptr), value :: widget
  type(c_ptr), value :: drawable
  type(c_ptr), value :: cursor_gc
  integer(c_int), value :: x_offset
  integer(c_int), value :: y_offset
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  type(c_ptr), value :: widgets
end subroutine

!   GType gtk_hbutton_box_get_type (void) G_GNUC_CONST;
function gtk_hbutton_box_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_hbutton_box_get_type
end function

! GtkWidget* gtk_hbutton_box_new (void);
function gtk_hbutton_box_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_hbutton_box_new
end function

!  gint gtk_hbutton_box_get_spacing_default (void);
function gtk_hbutton_box_get_spacing_default() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gtk_hbutton_box_get_spacing_default
end function

! GtkButtonBoxStyle gtk_hbutton_box_get_layout_default (void);
function gtk_hbutton_box_get_layout_default() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gtk_hbutton_box_get_layout_default
end function

!  void gtk_hbutton_box_set_spacing_default (gint spacing);
subroutine gtk_hbutton_box_set_spacing_default(spacing) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: spacing
end subroutine

! void gtk_hbutton_box_set_layout_default (GtkButtonBoxStyle layout);
subroutine gtk_hbutton_box_set_layout_default(layout) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: layout
end subroutine

!   GType gtk_cell_renderer_accel_get_type (void) G_GNUC_CONST;
function gtk_cell_renderer_accel_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_cell_renderer_accel_get_type
end function

! GtkCellRenderer *gtk_cell_renderer_accel_new (void);
function gtk_cell_renderer_accel_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_cell_renderer_accel_new
end function

!   void gtk_stock_add (const GtkStockItem *items, guint n_items);
subroutine gtk_stock_add(items, n_items) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: items
  integer(c_int), value :: n_items
end subroutine

! void gtk_stock_add_static (const GtkStockItem *items, guint n_items);
subroutine gtk_stock_add_static(items, n_items) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: items
  integer(c_int), value :: n_items
end subroutine

! gboolean gtk_stock_lookup (const gchar *stock_id, GtkStockItem *item);
function gtk_stock_lookup(stock_id, item) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_ptr
  logical(c_bool) :: gtk_stock_lookup
  character(kind=c_char), dimension(*) :: stock_id
  type(c_ptr), value :: item
end function

!  GSList* gtk_stock_list_ids (void);
function gtk_stock_list_ids() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_stock_list_ids
end function

!  GtkStockItem *gtk_stock_item_copy (const GtkStockItem *item);
function gtk_stock_item_copy(item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_stock_item_copy
  type(c_ptr), value :: item
end function

! void gtk_stock_item_free (GtkStockItem *item);
subroutine gtk_stock_item_free(item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: item
end subroutine

!  void gtk_stock_set_translate_func (const gchar *domain, GtkTranslateFunc func, gpointer data, GDestroyNotify notify);
subroutine gtk_stock_set_translate_func(domain, func, data, notify) bind(c) 
  use iso_c_binding, only: c_char, c_funptr, c_ptr
  character(kind=c_char), dimension(*) :: domain
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end subroutine

!   GType gtk_input_dialog_get_type (void) G_GNUC_CONST;
function gtk_input_dialog_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_input_dialog_get_type
end function

! GtkWidget* gtk_input_dialog_new (void);
function gtk_input_dialog_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_input_dialog_new
end function

!   GType gtk_page_setup_get_type (void) G_GNUC_CONST;
function gtk_page_setup_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_page_setup_get_type
end function

! GtkPageSetup * gtk_page_setup_new (void);
function gtk_page_setup_new() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gtk_page_setup_new
end function

! GtkPageSetup * gtk_page_setup_copy (GtkPageSetup *other);
function gtk_page_setup_copy(other) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gtk_page_setup_copy
  integer(c_int), value :: other
end function

! GtkPageOrientation gtk_page_setup_get_orientation (GtkPageSetup *setup);
function gtk_page_setup_get_orientation(setup) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gtk_page_setup_get_orientation
  integer(c_int), value :: setup
end function

! void gtk_page_setup_set_orientation (GtkPageSetup *setup, GtkPageOrientation orientation);
subroutine gtk_page_setup_set_orientation(setup, orientation) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: setup
  integer(c_int), value :: orientation
end subroutine

! GtkPaperSize * gtk_page_setup_get_paper_size (GtkPageSetup *setup);
function gtk_page_setup_get_paper_size(setup) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_page_setup_get_paper_size
  integer(c_int), value :: setup
end function

! void gtk_page_setup_set_paper_size (GtkPageSetup *setup, GtkPaperSize *size);
subroutine gtk_page_setup_set_paper_size(setup, size) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int), value :: setup
  type(c_ptr), value :: size
end subroutine

! gdouble gtk_page_setup_get_top_margin (GtkPageSetup *setup, GtkUnit unit);
function gtk_page_setup_get_top_margin(setup, unit) bind(c) 
  use iso_c_binding, only: c_double, c_int
  real(c_double) :: gtk_page_setup_get_top_margin
  integer(c_int), value :: setup
  integer(c_int), value :: unit
end function

! void gtk_page_setup_set_top_margin (GtkPageSetup *setup, gdouble margin, GtkUnit unit);
subroutine gtk_page_setup_set_top_margin(setup, margin, unit) bind(c) 
  use iso_c_binding, only: c_int, c_double
  integer(c_int), value :: setup
  real(c_double), value :: margin
  integer(c_int), value :: unit
end subroutine

! gdouble gtk_page_setup_get_bottom_margin (GtkPageSetup *setup, GtkUnit unit);
function gtk_page_setup_get_bottom_margin(setup, unit) bind(c) 
  use iso_c_binding, only: c_double, c_int
  real(c_double) :: gtk_page_setup_get_bottom_margin
  integer(c_int), value :: setup
  integer(c_int), value :: unit
end function

! void gtk_page_setup_set_bottom_margin (GtkPageSetup *setup, gdouble margin, GtkUnit unit);
subroutine gtk_page_setup_set_bottom_margin(setup, margin, unit) bind(c) 
  use iso_c_binding, only: c_int, c_double
  integer(c_int), value :: setup
  real(c_double), value :: margin
  integer(c_int), value :: unit
end subroutine

! gdouble gtk_page_setup_get_left_margin (GtkPageSetup *setup, GtkUnit unit);
function gtk_page_setup_get_left_margin(setup, unit) bind(c) 
  use iso_c_binding, only: c_double, c_int
  real(c_double) :: gtk_page_setup_get_left_margin
  integer(c_int), value :: setup
  integer(c_int), value :: unit
end function

! void gtk_page_setup_set_left_margin (GtkPageSetup *setup, gdouble margin, GtkUnit unit);
subroutine gtk_page_setup_set_left_margin(setup, margin, unit) bind(c) 
  use iso_c_binding, only: c_int, c_double
  integer(c_int), value :: setup
  real(c_double), value :: margin
  integer(c_int), value :: unit
end subroutine

! gdouble gtk_page_setup_get_right_margin (GtkPageSetup *setup, GtkUnit unit);
function gtk_page_setup_get_right_margin(setup, unit) bind(c) 
  use iso_c_binding, only: c_double, c_int
  real(c_double) :: gtk_page_setup_get_right_margin
  integer(c_int), value :: setup
  integer(c_int), value :: unit
end function

! void gtk_page_setup_set_right_margin (GtkPageSetup *setup, gdouble margin, GtkUnit unit);
subroutine gtk_page_setup_set_right_margin(setup, margin, unit) bind(c) 
  use iso_c_binding, only: c_int, c_double
  integer(c_int), value :: setup
  real(c_double), value :: margin
  integer(c_int), value :: unit
end subroutine

!  void gtk_page_setup_set_paper_size_and_default_margins (GtkPageSetup *setup, GtkPaperSize *size);
subroutine gtk_page_setup_set_paper_size_and_default_margins(setup, size) bind(c&
      &) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int), value :: setup
  type(c_ptr), value :: size
end subroutine

!  gdouble gtk_page_setup_get_paper_width (GtkPageSetup *setup, GtkUnit unit);
function gtk_page_setup_get_paper_width(setup, unit) bind(c) 
  use iso_c_binding, only: c_double, c_int
  real(c_double) :: gtk_page_setup_get_paper_width
  integer(c_int), value :: setup
  integer(c_int), value :: unit
end function

! gdouble gtk_page_setup_get_paper_height (GtkPageSetup *setup, GtkUnit unit);
function gtk_page_setup_get_paper_height(setup, unit) bind(c) 
  use iso_c_binding, only: c_double, c_int
  real(c_double) :: gtk_page_setup_get_paper_height
  integer(c_int), value :: setup
  integer(c_int), value :: unit
end function

!  gdouble gtk_page_setup_get_page_width (GtkPageSetup *setup, GtkUnit unit);
function gtk_page_setup_get_page_width(setup, unit) bind(c) 
  use iso_c_binding, only: c_double, c_int
  real(c_double) :: gtk_page_setup_get_page_width
  integer(c_int), value :: setup
  integer(c_int), value :: unit
end function

! gdouble gtk_page_setup_get_page_height (GtkPageSetup *setup, GtkUnit unit);
function gtk_page_setup_get_page_height(setup, unit) bind(c) 
  use iso_c_binding, only: c_double, c_int
  real(c_double) :: gtk_page_setup_get_page_height
  integer(c_int), value :: setup
  integer(c_int), value :: unit
end function

!  GtkPageSetup *gtk_page_setup_new_from_file (const gchar *file_name, GError **error);
function gtk_page_setup_new_from_file(file_name, error) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_ptr
  integer(c_int) :: gtk_page_setup_new_from_file
  character(kind=c_char), dimension(*) :: file_name
  type(c_ptr), value :: error
end function

! gboolean gtk_page_setup_load_file (GtkPageSetup *setup, const char *file_name, GError **error);
function gtk_page_setup_load_file(setup, file_name, error) bind(c) 
  use iso_c_binding, only: c_bool, c_int, c_char, c_ptr
  logical(c_bool) :: gtk_page_setup_load_file
  integer(c_int), value :: setup
  character(kind=c_char), dimension(*) :: file_name
  type(c_ptr), value :: error
end function

! gboolean gtk_page_setup_to_file (GtkPageSetup *setup, const char *file_name, GError **error);
function gtk_page_setup_to_file(setup, file_name, error) bind(c) 
  use iso_c_binding, only: c_bool, c_int, c_char, c_ptr
  logical(c_bool) :: gtk_page_setup_to_file
  integer(c_int), value :: setup
  character(kind=c_char), dimension(*) :: file_name
  type(c_ptr), value :: error
end function

! GtkPageSetup *gtk_page_setup_new_from_key_file (GKeyFile *key_file, const gchar *group_name, GError **error);
function gtk_page_setup_new_from_key_file(key_file, group_name, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gtk_page_setup_new_from_key_file
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  type(c_ptr), value :: error
end function

! gboolean gtk_page_setup_load_key_file (GtkPageSetup *setup, GKeyFile *key_file, const gchar *group_name, GError **error);
function gtk_page_setup_load_key_file(setup, key_file, group_name, error) bind(c&
      &) 
  use iso_c_binding, only: c_bool, c_int, c_ptr, c_char
  logical(c_bool) :: gtk_page_setup_load_key_file
  integer(c_int), value :: setup
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  type(c_ptr), value :: error
end function

! void gtk_page_setup_to_key_file (GtkPageSetup *setup, GKeyFile *key_file, const gchar *group_name);
subroutine gtk_page_setup_to_key_file(setup, key_file, group_name) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int), value :: setup
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
end subroutine

!   GType gtk_scale_button_get_type (void) G_GNUC_CONST;
function gtk_scale_button_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_scale_button_get_type
end function

! GtkWidget * gtk_scale_button_new (GtkIconSize size, gdouble min, gdouble max, gdouble step, const gchar **icons);
function gtk_scale_button_new(size, min, max, step, icons) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_double, c_char
  type(c_ptr) :: gtk_scale_button_new
  integer(c_int), value :: size
  real(c_double), value :: min
  real(c_double), value :: max
  real(c_double), value :: step
  character(kind=c_char), dimension(*) :: icons
end function

! void gtk_scale_button_set_icons (GtkScaleButton *button, const gchar **icons);
subroutine gtk_scale_button_set_icons(button, icons) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: button
  character(kind=c_char), dimension(*) :: icons
end subroutine

! gdouble gtk_scale_button_get_value (GtkScaleButton *button);
function gtk_scale_button_get_value(button) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_scale_button_get_value
  type(c_ptr), value :: button
end function

! void gtk_scale_button_set_value (GtkScaleButton *button, gdouble value);
subroutine gtk_scale_button_set_value(button, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: button
  real(c_double), value :: value
end subroutine

! GtkAdjustment * gtk_scale_button_get_adjustment (GtkScaleButton *button);
function gtk_scale_button_get_adjustment(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_scale_button_get_adjustment
  type(c_ptr), value :: button
end function

! void gtk_scale_button_set_adjustment (GtkScaleButton *button, GtkAdjustment *adjustment);
subroutine gtk_scale_button_set_adjustment(button, adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: button
  type(c_ptr), value :: adjustment
end subroutine

! GtkWidget * gtk_scale_button_get_plus_button (GtkScaleButton *button);
function gtk_scale_button_get_plus_button(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_scale_button_get_plus_button
  type(c_ptr), value :: button
end function

! GtkWidget * gtk_scale_button_get_minus_button (GtkScaleButton *button);
function gtk_scale_button_get_minus_button(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_scale_button_get_minus_button
  type(c_ptr), value :: button
end function

! GtkWidget * gtk_scale_button_get_popup (GtkScaleButton *button);
function gtk_scale_button_get_popup(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_scale_button_get_popup
  type(c_ptr), value :: button
end function

!  GtkOrientation gtk_scale_button_get_orientation (GtkScaleButton *button);
function gtk_scale_button_get_orientation(button) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_scale_button_get_orientation
  type(c_ptr), value :: button
end function

! void gtk_scale_button_set_orientation (GtkScaleButton *button, GtkOrientation orientation);
subroutine gtk_scale_button_set_orientation(button, orientation) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: button
  integer(c_int), value :: orientation
end subroutine

!   GType gtk_pixmap_get_type (void) G_GNUC_CONST;
function gtk_pixmap_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_pixmap_get_type
end function

! GtkWidget* gtk_pixmap_new (GdkPixmap *pixmap, GdkBitmap *mask);
function gtk_pixmap_new(pixmap, mask) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_pixmap_new
  type(c_ptr), value :: pixmap
  type(c_ptr), value :: mask
end function

! void gtk_pixmap_set (GtkPixmap *pixmap, GdkPixmap *val, GdkBitmap *mask);
subroutine gtk_pixmap_set(pixmap, val, mask) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pixmap
  type(c_ptr), value :: val
  type(c_ptr), value :: mask
end subroutine

! void gtk_pixmap_get (GtkPixmap *pixmap, GdkPixmap **val, GdkBitmap **mask);
subroutine gtk_pixmap_get(pixmap, val, mask) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pixmap
  type(c_ptr), value :: val
  type(c_ptr), value :: mask
end subroutine

!  void gtk_pixmap_set_build_insensitive (GtkPixmap *pixmap, gboolean build);
subroutine gtk_pixmap_set_build_insensitive(pixmap, build) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: pixmap
  logical(c_bool), value :: build
end subroutine

!   GType gtk_font_button_get_type (void) G_GNUC_CONST;
function gtk_font_button_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_font_button_get_type
end function

! GtkWidget *gtk_font_button_new (void);
function gtk_font_button_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_button_new
end function

! GtkWidget *gtk_font_button_new_with_font (const gchar *fontname);
function gtk_font_button_new_with_font(fontname) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_font_button_new_with_font
  character(kind=c_char), dimension(*) :: fontname
end function

!  G_CONST_RETURN gchar *gtk_font_button_get_title (GtkFontButton *font_button);
function gtk_font_button_get_title(font_button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_button_get_title
  type(c_ptr), value :: font_button
end function

! void gtk_font_button_set_title (GtkFontButton *font_button, const gchar *title);
subroutine gtk_font_button_set_title(font_button, title) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: font_button
  character(kind=c_char), dimension(*) :: title
end subroutine

! gboolean gtk_font_button_get_use_font (GtkFontButton *font_button);
function gtk_font_button_get_use_font(font_button) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_font_button_get_use_font
  type(c_ptr), value :: font_button
end function

! void gtk_font_button_set_use_font (GtkFontButton *font_button, gboolean use_font);
subroutine gtk_font_button_set_use_font(font_button, use_font) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: font_button
  logical(c_bool), value :: use_font
end subroutine

! gboolean gtk_font_button_get_use_size (GtkFontButton *font_button);
function gtk_font_button_get_use_size(font_button) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_font_button_get_use_size
  type(c_ptr), value :: font_button
end function

! void gtk_font_button_set_use_size (GtkFontButton *font_button, gboolean use_size);
subroutine gtk_font_button_set_use_size(font_button, use_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: font_button
  logical(c_bool), value :: use_size
end subroutine

! G_CONST_RETURN gchar* gtk_font_button_get_font_name (GtkFontButton *font_button);
function gtk_font_button_get_font_name(font_button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_button_get_font_name
  type(c_ptr), value :: font_button
end function

! gboolean gtk_font_button_set_font_name (GtkFontButton *font_button, const gchar *fontname);
function gtk_font_button_set_font_name(font_button, fontname) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_font_button_set_font_name
  type(c_ptr), value :: font_button
  character(kind=c_char), dimension(*) :: fontname
end function

! gboolean gtk_font_button_get_show_style (GtkFontButton *font_button);
function gtk_font_button_get_show_style(font_button) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_font_button_get_show_style
  type(c_ptr), value :: font_button
end function

! void gtk_font_button_set_show_style (GtkFontButton *font_button, gboolean show_style);
subroutine gtk_font_button_set_show_style(font_button, show_style) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: font_button
  logical(c_bool), value :: show_style
end subroutine

! gboolean gtk_font_button_get_show_size (GtkFontButton *font_button);
function gtk_font_button_get_show_size(font_button) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_font_button_get_show_size
  type(c_ptr), value :: font_button
end function

! void gtk_font_button_set_show_size (GtkFontButton *font_button, gboolean show_size);
subroutine gtk_font_button_set_show_size(font_button, show_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: font_button
  logical(c_bool), value :: show_size
end subroutine

!   GType gtk_im_multicontext_get_type (void) G_GNUC_CONST;
function gtk_im_multicontext_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_im_multicontext_get_type
end function

! GtkIMContext *gtk_im_multicontext_new (void);
function gtk_im_multicontext_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_im_multicontext_new
end function

!  void gtk_im_multicontext_append_menuitems (GtkIMMulticontext *context, GtkMenuShell *menushell);
subroutine gtk_im_multicontext_append_menuitems(context, menushell) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: menushell
end subroutine

! const char * gtk_im_multicontext_get_context_id (GtkIMMulticontext *context);
function gtk_im_multicontext_get_context_id(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_im_multicontext_get_context_id
  type(c_ptr), value :: context
end function

!  void gtk_im_multicontext_set_context_id (GtkIMMulticontext *context, const char *context_id);
subroutine gtk_im_multicontext_set_context_id(context, context_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: context_id
end subroutine

!   GType gtk_menu_shell_get_type (void) G_GNUC_CONST;
function gtk_menu_shell_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_menu_shell_get_type
end function

! void gtk_menu_shell_append (GtkMenuShell *menu_shell, GtkWidget *child);
subroutine gtk_menu_shell_append(menu_shell, child) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: menu_shell
  type(c_ptr), value :: child
end subroutine

! void gtk_menu_shell_prepend (GtkMenuShell *menu_shell, GtkWidget *child);
subroutine gtk_menu_shell_prepend(menu_shell, child) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: menu_shell
  type(c_ptr), value :: child
end subroutine

! void gtk_menu_shell_insert (GtkMenuShell *menu_shell, GtkWidget *child, gint position);
subroutine gtk_menu_shell_insert(menu_shell, child, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: menu_shell
  type(c_ptr), value :: child
  integer(c_int), value :: position
end subroutine

! void gtk_menu_shell_deactivate (GtkMenuShell *menu_shell);
subroutine gtk_menu_shell_deactivate(menu_shell) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: menu_shell
end subroutine

! void gtk_menu_shell_select_item (GtkMenuShell *menu_shell, GtkWidget *menu_item);
subroutine gtk_menu_shell_select_item(menu_shell, menu_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: menu_shell
  type(c_ptr), value :: menu_item
end subroutine

! void gtk_menu_shell_deselect (GtkMenuShell *menu_shell);
subroutine gtk_menu_shell_deselect(menu_shell) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: menu_shell
end subroutine

! void gtk_menu_shell_activate_item (GtkMenuShell *menu_shell, GtkWidget *menu_item, gboolean force_deactivate);
subroutine gtk_menu_shell_activate_item(menu_shell, menu_item, force_deactivate)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: menu_shell
  type(c_ptr), value :: menu_item
  logical(c_bool), value :: force_deactivate
end subroutine

! void gtk_menu_shell_select_first (GtkMenuShell *menu_shell, gboolean search_sensitive);
subroutine gtk_menu_shell_select_first(menu_shell, search_sensitive) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: menu_shell
  logical(c_bool), value :: search_sensitive
end subroutine

! void gtk_menu_shell_cancel (GtkMenuShell *menu_shell);
subroutine gtk_menu_shell_cancel(menu_shell) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: menu_shell
end subroutine

!  gboolean gtk_menu_shell_get_take_focus (GtkMenuShell *menu_shell);
function gtk_menu_shell_get_take_focus(menu_shell) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_menu_shell_get_take_focus
  type(c_ptr), value :: menu_shell
end function

! void gtk_menu_shell_set_take_focus (GtkMenuShell *menu_shell, gboolean take_focus);
subroutine gtk_menu_shell_set_take_focus(menu_shell, take_focus) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: menu_shell
  logical(c_bool), value :: take_focus
end subroutine

!   GType gtk_tree_model_sort_get_type (void) G_GNUC_CONST;
function gtk_tree_model_sort_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_model_sort_get_type
end function

! GtkTreeModel *gtk_tree_model_sort_new_with_model (GtkTreeModel *child_model);
function gtk_tree_model_sort_new_with_model(child_model) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_model_sort_new_with_model
  type(c_ptr), value :: child_model
end function

!  GtkTreeModel *gtk_tree_model_sort_get_model (GtkTreeModelSort *tree_model);
function gtk_tree_model_sort_get_model(tree_model) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_model_sort_get_model
  type(c_ptr), value :: tree_model
end function

! GtkTreePath *gtk_tree_model_sort_convert_child_path_to_path (GtkTreeModelSort *tree_model_sort, GtkTreePath *child_path);
function gtk_tree_model_sort_convert_child_path_to_path(tree_model_sort, child_p&
      &ath) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_model_sort_convert_child_path_to_path
  type(c_ptr), value :: tree_model_sort
  type(c_ptr), value :: child_path
end function

! gboolean gtk_tree_model_sort_convert_child_iter_to_iter (GtkTreeModelSort *tree_model_sort, GtkTreeIter *sort_iter, GtkTreeIter *child_iter);
function gtk_tree_model_sort_convert_child_iter_to_iter(tree_model_sort, sort_it&
      &er, child_iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_model_sort_convert_child_iter_to_iter
  type(c_ptr), value :: tree_model_sort
  type(c_ptr), value :: sort_iter
  type(c_ptr), value :: child_iter
end function

! GtkTreePath *gtk_tree_model_sort_convert_path_to_child_path (GtkTreeModelSort *tree_model_sort, GtkTreePath *sorted_path);
function gtk_tree_model_sort_convert_path_to_child_path(tree_model_sort, sorted_&
      &path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_model_sort_convert_path_to_child_path
  type(c_ptr), value :: tree_model_sort
  type(c_ptr), value :: sorted_path
end function

! void gtk_tree_model_sort_convert_iter_to_child_iter (GtkTreeModelSort *tree_model_sort, GtkTreeIter *child_iter, GtkTreeIter *sorted_iter);
subroutine gtk_tree_model_sort_convert_iter_to_child_iter(tree_model_sort, child&
      &_iter, sorted_iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_model_sort
  type(c_ptr), value :: child_iter
  type(c_ptr), value :: sorted_iter
end subroutine

! void gtk_tree_model_sort_reset_default_sort_func (GtkTreeModelSort *tree_model_sort);
subroutine gtk_tree_model_sort_reset_default_sort_func(tree_model_sort) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_model_sort
end subroutine

! void gtk_tree_model_sort_clear_cache (GtkTreeModelSort *tree_model_sort);
subroutine gtk_tree_model_sort_clear_cache(tree_model_sort) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_model_sort
end subroutine

! gboolean gtk_tree_model_sort_iter_is_valid (GtkTreeModelSort *tree_model_sort, GtkTreeIter *iter);
function gtk_tree_model_sort_iter_is_valid(tree_model_sort, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_model_sort_iter_is_valid
  type(c_ptr), value :: tree_model_sort
  type(c_ptr), value :: iter
end function

!   GType gtk_dialog_get_type (void) G_GNUC_CONST;
function gtk_dialog_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_dialog_get_type
end function

! GtkWidget* gtk_dialog_new (void);
function gtk_dialog_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_dialog_new
end function

!  void gtk_dialog_add_action_widget (GtkDialog *dialog, GtkWidget *child, gint response_id);
subroutine gtk_dialog_add_action_widget(dialog, child, response_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: dialog
  type(c_ptr), value :: child
  integer(c_int), value :: response_id
end subroutine

! GtkWidget* gtk_dialog_add_button (GtkDialog *dialog, const gchar *button_text, gint response_id);
function gtk_dialog_add_button(dialog, button_text, response_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: gtk_dialog_add_button
  type(c_ptr), value :: dialog
  character(kind=c_char), dimension(*) :: button_text
  integer(c_int), value :: response_id
end function

!  void gtk_dialog_set_response_sensitive (GtkDialog *dialog, gint response_id, gboolean setting);
subroutine gtk_dialog_set_response_sensitive(dialog, response_id, setting) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr), value :: dialog
  integer(c_int), value :: response_id
  logical(c_bool), value :: setting
end subroutine

! void gtk_dialog_set_default_response (GtkDialog *dialog, gint response_id);
subroutine gtk_dialog_set_default_response(dialog, response_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: dialog
  integer(c_int), value :: response_id
end subroutine

! GtkWidget* gtk_dialog_get_widget_for_response (GtkDialog *dialog, gint response_id);
function gtk_dialog_get_widget_for_response(dialog, response_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_dialog_get_widget_for_response
  type(c_ptr), value :: dialog
  integer(c_int), value :: response_id
end function

! gint gtk_dialog_get_response_for_widget (GtkDialog *dialog, GtkWidget *widget);
function gtk_dialog_get_response_for_widget(dialog, widget) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_dialog_get_response_for_widget
  type(c_ptr), value :: dialog
  type(c_ptr), value :: widget
end function

!  void gtk_dialog_set_has_separator (GtkDialog *dialog, gboolean setting);
subroutine gtk_dialog_set_has_separator(dialog, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: dialog
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_dialog_get_has_separator (GtkDialog *dialog);
function gtk_dialog_get_has_separator(dialog) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_dialog_get_has_separator
  type(c_ptr), value :: dialog
end function

!  gboolean gtk_alternative_dialog_button_order (GdkScreen *screen);
function gtk_alternative_dialog_button_order(screen) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_alternative_dialog_button_order
  type(c_ptr), value :: screen
end function

! void gtk_dialog_set_alternative_button_order_from_array (GtkDialog *dialog, gint n_params, gint *new_order);
subroutine gtk_dialog_set_alternative_button_order_from_array(dialog, n_params, &
      &new_order) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: dialog
  integer(c_int), value :: n_params
  type(c_ptr), value :: new_order
end subroutine

!  void gtk_dialog_response (GtkDialog *dialog, gint response_id);
subroutine gtk_dialog_response(dialog, response_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: dialog
  integer(c_int), value :: response_id
end subroutine

!  gint gtk_dialog_run (GtkDialog *dialog);
function gtk_dialog_run(dialog) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_dialog_run
  type(c_ptr), value :: dialog
end function

!  GtkWidget * gtk_dialog_get_action_area (GtkDialog *dialog);
function gtk_dialog_get_action_area(dialog) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_dialog_get_action_area
  type(c_ptr), value :: dialog
end function

! GtkWidget * gtk_dialog_get_content_area (GtkDialog *dialog);
function gtk_dialog_get_content_area(dialog) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_dialog_get_content_area
  type(c_ptr), value :: dialog
end function

!   GType gtk_scrollbar_get_type (void) G_GNUC_CONST;
function gtk_scrollbar_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_scrollbar_get_type
end function

!   GType gtk_socket_get_type (void) G_GNUC_CONST;
function gtk_socket_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_socket_get_type
end function

! GtkWidget* gtk_socket_new (void);
function gtk_socket_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_socket_new
end function

!  void gtk_socket_add_id (GtkSocket *socket_, GdkNativeWindow window_id);
subroutine gtk_socket_add_id(socket_, window_id) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: socket_
  type(c_ptr), value :: window_id
end subroutine

! GdkNativeWindow gtk_socket_get_id (GtkSocket *socket_);
function gtk_socket_get_id(socket_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_socket_get_id
  type(c_ptr), value :: socket_
end function

! GdkWindow* gtk_socket_get_plug_window (GtkSocket *socket_);
function gtk_socket_get_plug_window(socket_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_socket_get_plug_window
  type(c_ptr), value :: socket_
end function

!  void gtk_socket_steal (GtkSocket *socket_, GdkNativeWindow wid);
subroutine gtk_socket_steal(socket_, wid) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: socket_
  type(c_ptr), value :: wid
end subroutine

!   GType gtk_hpaned_get_type (void) G_GNUC_CONST;
function gtk_hpaned_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_hpaned_get_type
end function

! GtkWidget * gtk_hpaned_new (void);
function gtk_hpaned_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_hpaned_new
end function

!   GType gtk_scale_get_type (void) G_GNUC_CONST;
function gtk_scale_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_scale_get_type
end function

! void gtk_scale_set_digits (GtkScale *scale, gint digits);
subroutine gtk_scale_set_digits(scale, digits) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: scale
  integer(c_int), value :: digits
end subroutine

! gint gtk_scale_get_digits (GtkScale *scale);
function gtk_scale_get_digits(scale) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_scale_get_digits
  type(c_ptr), value :: scale
end function

! void gtk_scale_set_draw_value (GtkScale *scale, gboolean draw_value);
subroutine gtk_scale_set_draw_value(scale, draw_value) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: scale
  logical(c_bool), value :: draw_value
end subroutine

! gboolean gtk_scale_get_draw_value (GtkScale *scale);
function gtk_scale_get_draw_value(scale) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_scale_get_draw_value
  type(c_ptr), value :: scale
end function

! void gtk_scale_set_value_pos (GtkScale *scale, GtkPositionType pos);
subroutine gtk_scale_set_value_pos(scale, pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: scale
  integer(c_int), value :: pos
end subroutine

! GtkPositionType gtk_scale_get_value_pos (GtkScale *scale);
function gtk_scale_get_value_pos(scale) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_scale_get_value_pos
  type(c_ptr), value :: scale
end function

!  PangoLayout * gtk_scale_get_layout (GtkScale *scale);
function gtk_scale_get_layout(scale) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_scale_get_layout
  type(c_ptr), value :: scale
end function

! void gtk_scale_get_layout_offsets (GtkScale *scale, gint *x, gint *y);
subroutine gtk_scale_get_layout_offsets(scale, x, y) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: scale
  type(c_ptr), value :: x
  type(c_ptr), value :: y
end subroutine

!  void gtk_scale_add_mark (GtkScale *scale, gdouble value, GtkPositionType position, const gchar *markup);
subroutine gtk_scale_add_mark(scale, value, position, markup) bind(c) 
  use iso_c_binding, only: c_ptr, c_double, c_int, c_char
  type(c_ptr), value :: scale
  real(c_double), value :: value
  integer(c_int), value :: position
  character(kind=c_char), dimension(*) :: markup
end subroutine

! void gtk_scale_clear_marks (GtkScale *scale);
subroutine gtk_scale_clear_marks(scale) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: scale
end subroutine

!   guint gtk_signal_newv (const gchar *name, GtkSignalRunType signal_flags, GType object_type, guint function_offset, GSignalCMarshaller marshaller, GType return_val, guint n_args, GType *args);
function gtk_signal_newv(name, signal_flags, object_type, function_offset, marsh&
      &aller, return_val, n_args, args) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_size_t, c_ptr
  integer(c_int) :: gtk_signal_newv
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: signal_flags
  integer(c_size_t), value :: object_type
  integer(c_int), value :: function_offset
  type(c_ptr), value :: marshaller
  integer(c_size_t), value :: return_val
  integer(c_int), value :: n_args
  type(c_ptr), value :: args
end function

! void gtk_signal_emit_stop_by_name (GtkObject *object, const gchar *name);
subroutine gtk_signal_emit_stop_by_name(object, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: name
end subroutine

! void gtk_signal_connect_object_while_alive (GtkObject *object, const gchar *name, GCallback func, GtkObject *alive_object);
subroutine gtk_signal_connect_object_while_alive(object, name, func, alive_objec&
      &t) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: name
  type(c_funptr), value :: func
  type(c_ptr), value :: alive_object
end subroutine

! void gtk_signal_connect_while_alive (GtkObject *object, const gchar *name, GCallback func, gpointer func_data, GtkObject *alive_object);
subroutine gtk_signal_connect_while_alive(object, name, func, func_data, alive_o&
      &bject) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: name
  type(c_funptr), value :: func
  type(c_ptr), value :: func_data
  type(c_ptr), value :: alive_object
end subroutine

! gulong gtk_signal_connect_full (GtkObject *object, const gchar *name, GCallback func, GtkCallbackMarshal unsupported, gpointer data, GDestroyNotify destroy_func, gint object_signal, gint after);
function gtk_signal_connect_full(object, name, func, unsupported, data, destroy_&
      &func, object_signal, after) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_char, c_funptr, c_int
  integer(c_long) :: gtk_signal_connect_full
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: name
  type(c_funptr), value :: func
  type(c_funptr), value :: unsupported
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy_func
  integer(c_int), value :: object_signal
  integer(c_int), value :: after
end function

! void gtk_signal_emitv (GtkObject *object, guint signal_id, GtkArg *args);
subroutine gtk_signal_emitv(object, signal_id, args) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: object
  integer(c_int), value :: signal_id
  type(c_ptr), value :: args
end subroutine

! void gtk_signal_emitv_by_name (GtkObject *object, const gchar *name, GtkArg *args);
subroutine gtk_signal_emitv_by_name(object, name, args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: args
end subroutine

! void gtk_signal_compat_matched (GtkObject *object, GCallback func, gpointer data, GSignalMatchType match, guint action);
subroutine gtk_signal_compat_matched(object, func, data, match, action) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr, c_int
  type(c_ptr), value :: object
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  integer(c_int), value :: match
  integer(c_int), value :: action
end subroutine

!   GType gtk_cell_layout_get_type (void) G_GNUC_CONST;
function gtk_cell_layout_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_cell_layout_get_type
end function

! void gtk_cell_layout_pack_start (GtkCellLayout *cell_layout, GtkCellRenderer *cell, gboolean expand);
subroutine gtk_cell_layout_pack_start(cell_layout, cell, expand) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: cell_layout
  type(c_ptr), value :: cell
  logical(c_bool), value :: expand
end subroutine

! void gtk_cell_layout_pack_end (GtkCellLayout *cell_layout, GtkCellRenderer *cell, gboolean expand);
subroutine gtk_cell_layout_pack_end(cell_layout, cell, expand) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: cell_layout
  type(c_ptr), value :: cell
  logical(c_bool), value :: expand
end subroutine

! GList *gtk_cell_layout_get_cells (GtkCellLayout *cell_layout);
function gtk_cell_layout_get_cells(cell_layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_cell_layout_get_cells
  type(c_ptr), value :: cell_layout
end function

! void gtk_cell_layout_clear (GtkCellLayout *cell_layout);
subroutine gtk_cell_layout_clear(cell_layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cell_layout
end subroutine

! void gtk_cell_layout_add_attribute (GtkCellLayout *cell_layout, GtkCellRenderer *cell, const gchar *attribute, gint column);
subroutine gtk_cell_layout_add_attribute(cell_layout, cell, attribute, column) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: cell_layout
  type(c_ptr), value :: cell
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int), value :: column
end subroutine

! void gtk_cell_layout_set_cell_data_func (GtkCellLayout *cell_layout, GtkCellRenderer *cell, GtkCellLayoutDataFunc func, gpointer func_data, GDestroyNotify destroy);
subroutine gtk_cell_layout_set_cell_data_func(cell_layout, cell, func, func_data&
      &, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: cell_layout
  type(c_ptr), value :: cell
  type(c_funptr), value :: func
  type(c_ptr), value :: func_data
  type(c_funptr), value :: destroy
end subroutine

! void gtk_cell_layout_clear_attributes (GtkCellLayout *cell_layout, GtkCellRenderer *cell);
subroutine gtk_cell_layout_clear_attributes(cell_layout, cell) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cell_layout
  type(c_ptr), value :: cell
end subroutine

! void gtk_cell_layout_reorder (GtkCellLayout *cell_layout, GtkCellRenderer *cell, gint position);
subroutine gtk_cell_layout_reorder(cell_layout, cell, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: cell_layout
  type(c_ptr), value :: cell
  integer(c_int), value :: position
end subroutine

!   GType gtk_im_context_simple_get_type (void) G_GNUC_CONST;
function gtk_im_context_simple_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_im_context_simple_get_type
end function

! GtkIMContext *gtk_im_context_simple_new (void);
function gtk_im_context_simple_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_im_context_simple_new
end function

!  void gtk_im_context_simple_add_table (GtkIMContextSimple *context_simple, guint16 *data, gint max_seq_len, gint n_seqs);
subroutine gtk_im_context_simple_add_table(context_simple, data, max_seq_len, n_&
      &seqs) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: context_simple
  type(c_ptr), value :: data
  integer(c_int), value :: max_seq_len
  integer(c_int), value :: n_seqs
end subroutine

!   GType gtk_menu_bar_get_type (void) G_GNUC_CONST;
function gtk_menu_bar_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_menu_bar_get_type
end function

! GtkWidget* gtk_menu_bar_new (void);
function gtk_menu_bar_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_menu_bar_new
end function

!  GtkPackDirection gtk_menu_bar_get_pack_direction (GtkMenuBar *menubar);
function gtk_menu_bar_get_pack_direction(menubar) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_menu_bar_get_pack_direction
  type(c_ptr), value :: menubar
end function

! void gtk_menu_bar_set_pack_direction (GtkMenuBar *menubar, GtkPackDirection pack_dir);
subroutine gtk_menu_bar_set_pack_direction(menubar, pack_dir) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: menubar
  integer(c_int), value :: pack_dir
end subroutine

! GtkPackDirection gtk_menu_bar_get_child_pack_direction (GtkMenuBar *menubar);
function gtk_menu_bar_get_child_pack_direction(menubar) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_menu_bar_get_child_pack_direction
  type(c_ptr), value :: menubar
end function

! void gtk_menu_bar_set_child_pack_direction (GtkMenuBar *menubar, GtkPackDirection child_pack_dir);
subroutine gtk_menu_bar_set_child_pack_direction(menubar, child_pack_dir) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: menubar
  integer(c_int), value :: child_pack_dir
end subroutine

!       GType gtk_button_box_get_type (void) G_GNUC_CONST;
function gtk_button_box_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_button_box_get_type
end function

!  GtkButtonBoxStyle gtk_button_box_get_layout (GtkButtonBox *widget);
function gtk_button_box_get_layout(widget) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_button_box_get_layout
  type(c_ptr), value :: widget
end function

! void gtk_button_box_set_layout (GtkButtonBox *widget, GtkButtonBoxStyle layout_style);
subroutine gtk_button_box_set_layout(widget, layout_style) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  integer(c_int), value :: layout_style
end subroutine

! gboolean gtk_button_box_get_child_secondary (GtkButtonBox *widget, GtkWidget *child);
function gtk_button_box_get_child_secondary(widget, child) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_button_box_get_child_secondary
  type(c_ptr), value :: widget
  type(c_ptr), value :: child
end function

! void gtk_button_box_set_child_secondary (GtkButtonBox *widget, GtkWidget *child, gboolean is_secondary);
subroutine gtk_button_box_set_child_secondary(widget, child, is_secondary) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: widget
  type(c_ptr), value :: child
  logical(c_bool), value :: is_secondary
end subroutine

!  void gtk_button_box_set_child_size (GtkButtonBox *widget, gint min_width, gint min_height);
subroutine gtk_button_box_set_child_size(widget, min_width, min_height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  integer(c_int), value :: min_width
  integer(c_int), value :: min_height
end subroutine

! void gtk_button_box_set_child_ipadding (GtkButtonBox *widget, gint ipad_x, gint ipad_y);
subroutine gtk_button_box_set_child_ipadding(widget, ipad_x, ipad_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  integer(c_int), value :: ipad_x
  integer(c_int), value :: ipad_y
end subroutine

! void gtk_button_box_get_child_size (GtkButtonBox *widget, gint *min_width, gint *min_height);
subroutine gtk_button_box_get_child_size(widget, min_width, min_height) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: min_width
  type(c_ptr), value :: min_height
end subroutine

! void gtk_button_box_get_child_ipadding (GtkButtonBox *widget, gint *ipad_x, gint *ipad_y);
subroutine gtk_button_box_get_child_ipadding(widget, ipad_x, ipad_y) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: ipad_x
  type(c_ptr), value :: ipad_y
end subroutine

!   GType gtk_volume_button_get_type (void) G_GNUC_CONST;
function gtk_volume_button_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_volume_button_get_type
end function

! GtkWidget* gtk_volume_button_new (void);
function gtk_volume_button_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_volume_button_new
end function

!   GType gtk_tool_palette_get_type (void) G_GNUC_CONST;
function gtk_tool_palette_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tool_palette_get_type
end function

! GtkWidget* gtk_tool_palette_new (void);
function gtk_tool_palette_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tool_palette_new
end function

!  void gtk_tool_palette_set_group_position (GtkToolPalette *palette, GtkToolItemGroup *group, gint position);
subroutine gtk_tool_palette_set_group_position(palette, group, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: palette
  type(c_ptr), value :: group
  integer(c_int), value :: position
end subroutine

! void gtk_tool_palette_set_exclusive (GtkToolPalette *palette, GtkToolItemGroup *group, gboolean exclusive);
subroutine gtk_tool_palette_set_exclusive(palette, group, exclusive) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: palette
  type(c_ptr), value :: group
  logical(c_bool), value :: exclusive
end subroutine

! void gtk_tool_palette_set_expand (GtkToolPalette *palette, GtkToolItemGroup *group, gboolean expand);
subroutine gtk_tool_palette_set_expand(palette, group, expand) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: palette
  type(c_ptr), value :: group
  logical(c_bool), value :: expand
end subroutine

!  gint gtk_tool_palette_get_group_position (GtkToolPalette *palette, GtkToolItemGroup *group);
function gtk_tool_palette_get_group_position(palette, group) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tool_palette_get_group_position
  type(c_ptr), value :: palette
  type(c_ptr), value :: group
end function

! gboolean gtk_tool_palette_get_exclusive (GtkToolPalette *palette, GtkToolItemGroup *group);
function gtk_tool_palette_get_exclusive(palette, group) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tool_palette_get_exclusive
  type(c_ptr), value :: palette
  type(c_ptr), value :: group
end function

! gboolean gtk_tool_palette_get_expand (GtkToolPalette *palette, GtkToolItemGroup *group);
function gtk_tool_palette_get_expand(palette, group) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tool_palette_get_expand
  type(c_ptr), value :: palette
  type(c_ptr), value :: group
end function

!  void gtk_tool_palette_set_icon_size (GtkToolPalette *palette, GtkIconSize icon_size);
subroutine gtk_tool_palette_set_icon_size(palette, icon_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: palette
  integer(c_int), value :: icon_size
end subroutine

! void gtk_tool_palette_unset_icon_size (GtkToolPalette *palette);
subroutine gtk_tool_palette_unset_icon_size(palette) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: palette
end subroutine

! void gtk_tool_palette_set_style (GtkToolPalette *palette, GtkToolbarStyle style);
subroutine gtk_tool_palette_set_style(palette, style) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: palette
  integer(c_int), value :: style
end subroutine

! void gtk_tool_palette_unset_style (GtkToolPalette *palette);
subroutine gtk_tool_palette_unset_style(palette) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: palette
end subroutine

!  GtkIconSize gtk_tool_palette_get_icon_size (GtkToolPalette *palette);
function gtk_tool_palette_get_icon_size(palette) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tool_palette_get_icon_size
  type(c_ptr), value :: palette
end function

! GtkToolbarStyle gtk_tool_palette_get_style (GtkToolPalette *palette);
function gtk_tool_palette_get_style(palette) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tool_palette_get_style
  type(c_ptr), value :: palette
end function

!  GtkToolItem* gtk_tool_palette_get_drop_item (GtkToolPalette *palette, gint x, gint y);
function gtk_tool_palette_get_drop_item(palette, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_tool_palette_get_drop_item
  type(c_ptr), value :: palette
  integer(c_int), value :: x
  integer(c_int), value :: y
end function

! GtkToolItemGroup* gtk_tool_palette_get_drop_group (GtkToolPalette *palette, gint x, gint y);
function gtk_tool_palette_get_drop_group(palette, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_tool_palette_get_drop_group
  type(c_ptr), value :: palette
  integer(c_int), value :: x
  integer(c_int), value :: y
end function

! GtkWidget* gtk_tool_palette_get_drag_item (GtkToolPalette *palette, const GtkSelectionData *selection);
function gtk_tool_palette_get_drag_item(palette, selection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tool_palette_get_drag_item
  type(c_ptr), value :: palette
  type(c_ptr), value :: selection
end function

!  void gtk_tool_palette_set_drag_source (GtkToolPalette *palette, GtkToolPaletteDragTargets targets);
subroutine gtk_tool_palette_set_drag_source(palette, targets) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: palette
  integer(c_int), value :: targets
end subroutine

! void gtk_tool_palette_add_drag_dest (GtkToolPalette *palette, GtkWidget *widget, GtkDestDefaults flags, GtkToolPaletteDragTargets targets, GdkDragAction actions);
subroutine gtk_tool_palette_add_drag_dest(palette, widget, flags, targets, actio&
      &ns) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: palette
  type(c_ptr), value :: widget
  integer(c_int), value :: flags
  integer(c_int), value :: targets
  integer(c_int), value :: actions
end subroutine

!  GtkAdjustment* gtk_tool_palette_get_hadjustment (GtkToolPalette *palette);
function gtk_tool_palette_get_hadjustment(palette) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tool_palette_get_hadjustment
  type(c_ptr), value :: palette
end function

! GtkAdjustment* gtk_tool_palette_get_vadjustment (GtkToolPalette *palette);
function gtk_tool_palette_get_vadjustment(palette) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tool_palette_get_vadjustment
  type(c_ptr), value :: palette
end function

!  G_CONST_RETURN GtkTargetEntry* gtk_tool_palette_get_drag_target_item (void) G_GNUC_CONST;
function gtk_tool_palette_get_drag_target_item() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tool_palette_get_drag_target_item
end function

! G_CONST_RETURN GtkTargetEntry* gtk_tool_palette_get_drag_target_group (void) G_GNUC_CONST;
function gtk_tool_palette_get_drag_target_group() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tool_palette_get_drag_target_group
end function

!   GType gtk_font_selection_get_type (void) G_GNUC_CONST;
function gtk_font_selection_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_font_selection_get_type
end function

! GtkWidget * gtk_font_selection_new (void);
function gtk_font_selection_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_selection_new
end function

! GtkWidget * gtk_font_selection_get_family_list (GtkFontSelection *fontsel);
function gtk_font_selection_get_family_list(fontsel) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_selection_get_family_list
  type(c_ptr), value :: fontsel
end function

! GtkWidget * gtk_font_selection_get_face_list (GtkFontSelection *fontsel);
function gtk_font_selection_get_face_list(fontsel) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_selection_get_face_list
  type(c_ptr), value :: fontsel
end function

! GtkWidget * gtk_font_selection_get_size_entry (GtkFontSelection *fontsel);
function gtk_font_selection_get_size_entry(fontsel) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_selection_get_size_entry
  type(c_ptr), value :: fontsel
end function

! GtkWidget * gtk_font_selection_get_size_list (GtkFontSelection *fontsel);
function gtk_font_selection_get_size_list(fontsel) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_selection_get_size_list
  type(c_ptr), value :: fontsel
end function

! GtkWidget * gtk_font_selection_get_preview_entry (GtkFontSelection *fontsel);
function gtk_font_selection_get_preview_entry(fontsel) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_selection_get_preview_entry
  type(c_ptr), value :: fontsel
end function

! PangoFontFamily * gtk_font_selection_get_family (GtkFontSelection *fontsel);
function gtk_font_selection_get_family(fontsel) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_selection_get_family
  type(c_ptr), value :: fontsel
end function

! PangoFontFace * gtk_font_selection_get_face (GtkFontSelection *fontsel);
function gtk_font_selection_get_face(fontsel) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_selection_get_face
  type(c_ptr), value :: fontsel
end function

! gint gtk_font_selection_get_size (GtkFontSelection *fontsel);
function gtk_font_selection_get_size(fontsel) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_font_selection_get_size
  type(c_ptr), value :: fontsel
end function

! gchar* gtk_font_selection_get_font_name (GtkFontSelection *fontsel);
function gtk_font_selection_get_font_name(fontsel) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_selection_get_font_name
  type(c_ptr), value :: fontsel
end function

!  GdkFont* gtk_font_selection_get_font (GtkFontSelection *fontsel);
function gtk_font_selection_get_font(fontsel) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_selection_get_font
  type(c_ptr), value :: fontsel
end function

!  gboolean gtk_font_selection_set_font_name (GtkFontSelection *fontsel, const gchar *fontname);
function gtk_font_selection_set_font_name(fontsel, fontname) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_font_selection_set_font_name
  type(c_ptr), value :: fontsel
  character(kind=c_char), dimension(*) :: fontname
end function

! const gchar* gtk_font_selection_get_preview_text (GtkFontSelection *fontsel);
function gtk_font_selection_get_preview_text(fontsel) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_selection_get_preview_text
  type(c_ptr), value :: fontsel
end function

! void gtk_font_selection_set_preview_text (GtkFontSelection *fontsel, const gchar *text);
subroutine gtk_font_selection_set_preview_text(fontsel, text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: fontsel
  character(kind=c_char), dimension(*) :: text
end subroutine

!  GType gtk_font_selection_dialog_get_type (void) G_GNUC_CONST;
function gtk_font_selection_dialog_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_font_selection_dialog_get_type
end function

! GtkWidget *gtk_font_selection_dialog_new (const gchar *title);
function gtk_font_selection_dialog_new(title) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_font_selection_dialog_new
  character(kind=c_char), dimension(*) :: title
end function

!  GtkWidget *gtk_font_selection_dialog_get_ok_button (GtkFontSelectionDialog *fsd);
function gtk_font_selection_dialog_get_ok_button(fsd) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_selection_dialog_get_ok_button
  type(c_ptr), value :: fsd
end function

!  GtkWidget *gtk_font_selection_dialog_get_apply_button (GtkFontSelectionDialog *fsd);
function gtk_font_selection_dialog_get_apply_button(fsd) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_selection_dialog_get_apply_button
  type(c_ptr), value :: fsd
end function

!  GtkWidget *gtk_font_selection_dialog_get_cancel_button (GtkFontSelectionDialog *fsd);
function gtk_font_selection_dialog_get_cancel_button(fsd) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_selection_dialog_get_cancel_button
  type(c_ptr), value :: fsd
end function

! GtkWidget *gtk_font_selection_dialog_get_font_selection (GtkFontSelectionDialog *fsd);
function gtk_font_selection_dialog_get_font_selection(fsd) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_selection_dialog_get_font_selection
  type(c_ptr), value :: fsd
end function

!  gchar* gtk_font_selection_dialog_get_font_name (GtkFontSelectionDialog *fsd);
function gtk_font_selection_dialog_get_font_name(fsd) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_selection_dialog_get_font_name
  type(c_ptr), value :: fsd
end function

!  GdkFont* gtk_font_selection_dialog_get_font (GtkFontSelectionDialog *fsd);
function gtk_font_selection_dialog_get_font(fsd) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_selection_dialog_get_font
  type(c_ptr), value :: fsd
end function

!  gboolean gtk_font_selection_dialog_set_font_name (GtkFontSelectionDialog *fsd, const gchar *fontname);
function gtk_font_selection_dialog_set_font_name(fsd, fontname) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_font_selection_dialog_set_font_name
  type(c_ptr), value :: fsd
  character(kind=c_char), dimension(*) :: fontname
end function

!  G_CONST_RETURN gchar* gtk_font_selection_dialog_get_preview_text (GtkFontSelectionDialog *fsd);
function gtk_font_selection_dialog_get_preview_text(fsd) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_font_selection_dialog_get_preview_text
  type(c_ptr), value :: fsd
end function

!  void gtk_font_selection_dialog_set_preview_text (GtkFontSelectionDialog *fsd, const gchar *text);
subroutine gtk_font_selection_dialog_set_preview_text(fsd, text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: fsd
  character(kind=c_char), dimension(*) :: text
end subroutine

!   GType gtk_progress_bar_get_type (void) G_GNUC_CONST;
function gtk_progress_bar_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_progress_bar_get_type
end function

! GtkWidget* gtk_progress_bar_new (void);
function gtk_progress_bar_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_progress_bar_new
end function

!  void gtk_progress_bar_pulse (GtkProgressBar *pbar);
subroutine gtk_progress_bar_pulse(pbar) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pbar
end subroutine

! void gtk_progress_bar_set_text (GtkProgressBar *pbar, const gchar *text);
subroutine gtk_progress_bar_set_text(pbar, text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: pbar
  character(kind=c_char), dimension(*) :: text
end subroutine

! void gtk_progress_bar_set_fraction (GtkProgressBar *pbar, gdouble fraction);
subroutine gtk_progress_bar_set_fraction(pbar, fraction) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: pbar
  real(c_double), value :: fraction
end subroutine

!  void gtk_progress_bar_set_pulse_step (GtkProgressBar *pbar, gdouble fraction);
subroutine gtk_progress_bar_set_pulse_step(pbar, fraction) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: pbar
  real(c_double), value :: fraction
end subroutine

! void gtk_progress_bar_set_orientation (GtkProgressBar *pbar, GtkProgressBarOrientation orientation);
subroutine gtk_progress_bar_set_orientation(pbar, orientation) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: pbar
  integer(c_int), value :: orientation
end subroutine

!  G_CONST_RETURN gchar* gtk_progress_bar_get_text (GtkProgressBar *pbar);
function gtk_progress_bar_get_text(pbar) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_progress_bar_get_text
  type(c_ptr), value :: pbar
end function

! gdouble gtk_progress_bar_get_fraction (GtkProgressBar *pbar);
function gtk_progress_bar_get_fraction(pbar) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_progress_bar_get_fraction
  type(c_ptr), value :: pbar
end function

! gdouble gtk_progress_bar_get_pulse_step (GtkProgressBar *pbar);
function gtk_progress_bar_get_pulse_step(pbar) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_progress_bar_get_pulse_step
  type(c_ptr), value :: pbar
end function

!  GtkProgressBarOrientation gtk_progress_bar_get_orientation (GtkProgressBar *pbar);
function gtk_progress_bar_get_orientation(pbar) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_progress_bar_get_orientation
  type(c_ptr), value :: pbar
end function

! void gtk_progress_bar_set_ellipsize (GtkProgressBar *pbar, PangoEllipsizeMode mode);
subroutine gtk_progress_bar_set_ellipsize(pbar, mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: pbar
  integer(c_int), value :: mode
end subroutine

! PangoEllipsizeMode gtk_progress_bar_get_ellipsize (GtkProgressBar *pbar);
function gtk_progress_bar_get_ellipsize(pbar) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_progress_bar_get_ellipsize
  type(c_ptr), value :: pbar
end function

!  GtkWidget* gtk_progress_bar_new_with_adjustment (GtkAdjustment *adjustment);
function gtk_progress_bar_new_with_adjustment(adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_progress_bar_new_with_adjustment
  type(c_ptr), value :: adjustment
end function

! void gtk_progress_bar_set_bar_style (GtkProgressBar *pbar, GtkProgressBarStyle style);
subroutine gtk_progress_bar_set_bar_style(pbar, style) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: pbar
  integer(c_int), value :: style
end subroutine

! void gtk_progress_bar_set_discrete_blocks (GtkProgressBar *pbar, guint blocks);
subroutine gtk_progress_bar_set_discrete_blocks(pbar, blocks) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: pbar
  integer(c_int), value :: blocks
end subroutine

!  void gtk_progress_bar_set_activity_step (GtkProgressBar *pbar, guint step);
subroutine gtk_progress_bar_set_activity_step(pbar, step) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: pbar
  integer(c_int), value :: step
end subroutine

! void gtk_progress_bar_set_activity_blocks (GtkProgressBar *pbar, guint blocks);
subroutine gtk_progress_bar_set_activity_blocks(pbar, blocks) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: pbar
  integer(c_int), value :: blocks
end subroutine

! void gtk_progress_bar_update (GtkProgressBar *pbar, gdouble percentage);
subroutine gtk_progress_bar_update(pbar, percentage) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: pbar
  real(c_double), value :: percentage
end subroutine

! const gchar* gtk_check_version (guint required_major, guint required_minor, guint required_micro);
function gtk_check_version(required_major, required_minor, required_micro) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_check_version
  integer(c_int), value :: required_major
  integer(c_int), value :: required_minor
  integer(c_int), value :: required_micro
end function

!  gboolean gtk_parse_args (int *argc, char ***argv);
function gtk_parse_args(argc, argv) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_parse_args
  type(c_ptr), value :: argc
  character(kind=c_char), dimension(*) :: argv
end function

!  gboolean gtk_init_check (int *argc, char ***argv);
function gtk_init_check(argc, argv) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_init_check
  type(c_ptr), value :: argc
  character(kind=c_char), dimension(*) :: argv
end function

!  gboolean gtk_init_with_args (int *argc, char ***argv, const char *parameter_string, GOptionEntry *entries, const char *translation_domain, GError **error);
function gtk_init_with_args(argc, argv, parameter_string, entries, translation_d&
      &omain, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_init_with_args
  type(c_ptr), value :: argc
  character(kind=c_char), dimension(*) :: argv
  character(kind=c_char), dimension(*) :: parameter_string
  type(c_ptr), value :: entries
  character(kind=c_char), dimension(*) :: translation_domain
  type(c_ptr), value :: error
end function

!  GOptionGroup *gtk_get_option_group (gboolean open_default_display);
function gtk_get_option_group(open_default_display) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: gtk_get_option_group
  logical(c_bool), value :: open_default_display
end function

!   void gtk_init_abi_check (int *argc, char ***argv, int num_checks, size_t sizeof_GtkWindow, size_t sizeof_GtkBox);
subroutine gtk_init_abi_check(argc, argv, num_checks, sizeof_GtkWindow, sizeof_G&
      &tkBox) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_size_t
  type(c_ptr), value :: argc
  character(kind=c_char), dimension(*) :: argv
  integer(c_int), value :: num_checks
  integer(c_size_t), value :: sizeof_GtkWindow
  integer(c_size_t), value :: sizeof_GtkBox
end subroutine

! gboolean gtk_init_check_abi_check (int *argc, char ***argv, int num_checks, size_t sizeof_GtkWindow, size_t sizeof_GtkBox);
function gtk_init_check_abi_check(argc, argv, num_checks, sizeof_GtkWindow, size&
      &of_GtkBox) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int, c_size_t
  logical(c_bool) :: gtk_init_check_abi_check
  type(c_ptr), value :: argc
  character(kind=c_char), dimension(*) :: argv
  integer(c_int), value :: num_checks
  integer(c_size_t), value :: sizeof_GtkWindow
  integer(c_size_t), value :: sizeof_GtkBox
end function

!  void gtk_exit (gint error_code);
subroutine gtk_exit(error_code) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: error_code
end subroutine

!  void gtk_disable_setlocale (void);
subroutine gtk_disable_setlocale() bind(c) 
  use iso_c_binding, only: 
end subroutine

! gchar * gtk_set_locale (void);
function gtk_set_locale() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_set_locale
end function

! PangoLanguage *gtk_get_default_language (void);
function gtk_get_default_language() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_get_default_language
end function

! gboolean gtk_events_pending (void);
function gtk_events_pending() bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool) :: gtk_events_pending
end function

!  void gtk_main_do_event (GdkEvent *event);
subroutine gtk_main_do_event(event) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: event
end subroutine

!  void gtk_main (void);
subroutine gtk_main() bind(c) 
  use iso_c_binding, only: 
end subroutine

! guint gtk_main_level (void);
function gtk_main_level() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gtk_main_level
end function

! void gtk_main_quit (void);
subroutine gtk_main_quit() bind(c) 
  use iso_c_binding, only: 
end subroutine

! gboolean gtk_main_iteration (void);
function gtk_main_iteration() bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool) :: gtk_main_iteration
end function

!  gboolean gtk_main_iteration_do (gboolean blocking);
function gtk_main_iteration_do(blocking) bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool) :: gtk_main_iteration_do
  logical(c_bool), value :: blocking
end function

!  gboolean gtk_true (void) G_GNUC_CONST;
function gtk_true() bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool) :: gtk_true
end function

! gboolean gtk_false (void) G_GNUC_CONST;
function gtk_false() bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool) :: gtk_false
end function

!  void gtk_grab_add (GtkWidget *widget);
subroutine gtk_grab_add(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! GtkWidget* gtk_grab_get_current (void);
function gtk_grab_get_current() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_grab_get_current
end function

! void gtk_grab_remove (GtkWidget *widget);
subroutine gtk_grab_remove(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

!  void gtk_init_add (GtkFunction function, gpointer data);
subroutine gtk_init_add(function, data) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end subroutine

! void gtk_quit_add_destroy (guint main_level, GtkObject *object);
subroutine gtk_quit_add_destroy(main_level, object) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int), value :: main_level
  type(c_ptr), value :: object
end subroutine

! guint gtk_quit_add (guint main_level, GtkFunction function, gpointer data);
function gtk_quit_add(main_level, function, data) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: gtk_quit_add
  integer(c_int), value :: main_level
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

! guint gtk_quit_add_full (guint main_level, GtkFunction function, GtkCallbackMarshal marshal, gpointer data, GDestroyNotify destroy);
function gtk_quit_add_full(main_level, function, marshal, data, destroy) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: gtk_quit_add_full
  integer(c_int), value :: main_level
  type(c_funptr), value :: function
  type(c_funptr), value :: marshal
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end function

! void gtk_quit_remove (guint quit_handler_id);
subroutine gtk_quit_remove(quit_handler_id) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: quit_handler_id
end subroutine

! void gtk_quit_remove_by_data (gpointer data);
subroutine gtk_quit_remove_by_data(data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: data
end subroutine

!  guint gtk_timeout_add (guint32 interval, GtkFunction function, gpointer data);
function gtk_timeout_add(interval, function, data) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t, c_funptr, c_ptr
  integer(c_int) :: gtk_timeout_add
  integer(c_int32_t), value :: interval
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

! guint gtk_timeout_add_full (guint32 interval, GtkFunction function, GtkCallbackMarshal marshal, gpointer data, GDestroyNotify destroy);
function gtk_timeout_add_full(interval, function, marshal, data, destroy) bind(c&
      &) 
  use iso_c_binding, only: c_int, c_int32_t, c_funptr, c_ptr
  integer(c_int) :: gtk_timeout_add_full
  integer(c_int32_t), value :: interval
  type(c_funptr), value :: function
  type(c_funptr), value :: marshal
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end function

! void gtk_timeout_remove (guint timeout_handler_id);
subroutine gtk_timeout_remove(timeout_handler_id) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: timeout_handler_id
end subroutine

!  guint gtk_idle_add (GtkFunction function, gpointer data);
function gtk_idle_add(function, data) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: gtk_idle_add
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

! guint gtk_idle_add_priority (gint priority, GtkFunction function, gpointer data);
function gtk_idle_add_priority(priority, function, data) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: gtk_idle_add_priority
  integer(c_int), value :: priority
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

! guint gtk_idle_add_full (gint priority, GtkFunction function, GtkCallbackMarshal marshal, gpointer data, GDestroyNotify destroy);
function gtk_idle_add_full(priority, function, marshal, data, destroy) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: gtk_idle_add_full
  integer(c_int), value :: priority
  type(c_funptr), value :: function
  type(c_funptr), value :: marshal
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end function

! void gtk_idle_remove (guint idle_handler_id);
subroutine gtk_idle_remove(idle_handler_id) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: idle_handler_id
end subroutine

! void gtk_idle_remove_by_data (gpointer data);
subroutine gtk_idle_remove_by_data(data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: data
end subroutine

! guint gtk_input_add_full (gint source, GdkInputCondition condition, GdkInputFunction function, GtkCallbackMarshal marshal, gpointer data, GDestroyNotify destroy);
function gtk_input_add_full(source, condition, function, marshal, data, destroy)&
      & bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: gtk_input_add_full
  integer(c_int), value :: source
  integer(c_int), value :: condition
  type(c_funptr), value :: function
  type(c_funptr), value :: marshal
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end function

! void gtk_input_remove (guint input_handler_id);
subroutine gtk_input_remove(input_handler_id) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: input_handler_id
end subroutine

!  guint gtk_key_snooper_install (GtkKeySnoopFunc snooper, gpointer func_data);
function gtk_key_snooper_install(snooper, func_data) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: gtk_key_snooper_install
  type(c_funptr), value :: snooper
  type(c_ptr), value :: func_data
end function

! void gtk_key_snooper_remove (guint snooper_handler_id);
subroutine gtk_key_snooper_remove(snooper_handler_id) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: snooper_handler_id
end subroutine

!  GdkEvent* gtk_get_current_event (void);
function gtk_get_current_event() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_get_current_event
end function

! guint32 gtk_get_current_event_time (void);
function gtk_get_current_event_time() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: gtk_get_current_event_time
end function

! gboolean gtk_get_current_event_state (GdkModifierType *state);
function gtk_get_current_event_state(state) bind(c) 
  use iso_c_binding, only: c_bool, c_int
  logical(c_bool) :: gtk_get_current_event_state
  integer(c_int), value :: state
end function

!  GtkWidget* gtk_get_event_widget (GdkEvent *event);
function gtk_get_event_widget(event) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_get_event_widget
  type(c_ptr), value :: event
end function

!  void gtk_propagate_event (GtkWidget *widget, GdkEvent *event);
subroutine gtk_propagate_event(widget, event) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: event
end subroutine

!   GType gtk_combo_get_type (void) G_GNUC_CONST;
function gtk_combo_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_combo_get_type
end function

!  GtkWidget* gtk_combo_new (void);
function gtk_combo_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_combo_new
end function

!  void gtk_combo_set_value_in_list (GtkCombo* combo, gboolean val, gboolean ok_if_empty);
subroutine gtk_combo_set_value_in_list(combo, val, ok_if_empty) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: combo
  logical(c_bool), value :: val
  logical(c_bool), value :: ok_if_empty
end subroutine

!  void gtk_combo_set_use_arrows (GtkCombo* combo, gboolean val);
subroutine gtk_combo_set_use_arrows(combo, val) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: combo
  logical(c_bool), value :: val
end subroutine

!  void gtk_combo_set_use_arrows_always (GtkCombo* combo, gboolean val);
subroutine gtk_combo_set_use_arrows_always(combo, val) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: combo
  logical(c_bool), value :: val
end subroutine

!  void gtk_combo_set_case_sensitive (GtkCombo* combo, gboolean val);
subroutine gtk_combo_set_case_sensitive(combo, val) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: combo
  logical(c_bool), value :: val
end subroutine

!  void gtk_combo_set_item_string (GtkCombo* combo, GtkItem* item, const gchar* item_value);
subroutine gtk_combo_set_item_string(combo, item, item_value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: combo
  type(c_ptr), value :: item
  character(kind=c_char), dimension(*) :: item_value
end subroutine

!  void gtk_combo_set_popdown_strings (GtkCombo* combo, GList *strings);
subroutine gtk_combo_set_popdown_strings(combo, strings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: combo
  type(c_ptr), value :: strings
end subroutine

!  void gtk_combo_disable_activate (GtkCombo* combo);
subroutine gtk_combo_disable_activate(combo) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: combo
end subroutine

!   GType gtk_tree_sortable_get_type (void) G_GNUC_CONST;
function gtk_tree_sortable_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_sortable_get_type
end function

!  void gtk_tree_sortable_sort_column_changed (GtkTreeSortable *sortable);
subroutine gtk_tree_sortable_sort_column_changed(sortable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: sortable
end subroutine

! gboolean gtk_tree_sortable_get_sort_column_id (GtkTreeSortable *sortable, gint *sort_column_id, GtkSortType *order);
function gtk_tree_sortable_get_sort_column_id(sortable, sort_column_id, order) b&
      &ind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_tree_sortable_get_sort_column_id
  type(c_ptr), value :: sortable
  type(c_ptr), value :: sort_column_id
  integer(c_int), value :: order
end function

! void gtk_tree_sortable_set_sort_column_id (GtkTreeSortable *sortable, gint sort_column_id, GtkSortType order);
subroutine gtk_tree_sortable_set_sort_column_id(sortable, sort_column_id, order)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: sortable
  integer(c_int), value :: sort_column_id
  integer(c_int), value :: order
end subroutine

! void gtk_tree_sortable_set_sort_func (GtkTreeSortable *sortable, gint sort_column_id, GtkTreeIterCompareFunc sort_func, gpointer user_data, GDestroyNotify destroy);
subroutine gtk_tree_sortable_set_sort_func(sortable, sort_column_id, sort_func, &
      &user_data, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: sortable
  integer(c_int), value :: sort_column_id
  type(c_funptr), value :: sort_func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy
end subroutine

! void gtk_tree_sortable_set_default_sort_func (GtkTreeSortable *sortable, GtkTreeIterCompareFunc sort_func, gpointer user_data, GDestroyNotify destroy);
subroutine gtk_tree_sortable_set_default_sort_func(sortable, sort_func, user_dat&
      &a, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: sortable
  type(c_funptr), value :: sort_func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy
end subroutine

! gboolean gtk_tree_sortable_has_default_sort_func (GtkTreeSortable *sortable);
function gtk_tree_sortable_has_default_sort_func(sortable) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_sortable_has_default_sort_func
  type(c_ptr), value :: sortable
end function

!   GType gtk_fixed_get_type (void) G_GNUC_CONST;
function gtk_fixed_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_fixed_get_type
end function

! GtkWidget* gtk_fixed_new (void);
function gtk_fixed_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_fixed_new
end function

! void gtk_fixed_put (GtkFixed *fixed, GtkWidget *widget, gint x, gint y);
subroutine gtk_fixed_put(fixed, widget, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: fixed
  type(c_ptr), value :: widget
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void gtk_fixed_move (GtkFixed *fixed, GtkWidget *widget, gint x, gint y);
subroutine gtk_fixed_move(fixed, widget, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: fixed
  type(c_ptr), value :: widget
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

!  void gtk_fixed_set_has_window (GtkFixed *fixed, gboolean has_window);
subroutine gtk_fixed_set_has_window(fixed, has_window) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: fixed
  logical(c_bool), value :: has_window
end subroutine

! gboolean gtk_fixed_get_has_window (GtkFixed *fixed);
function gtk_fixed_get_has_window(fixed) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_fixed_get_has_window
  type(c_ptr), value :: fixed
end function

!   GType gtk_cell_renderer_progress_get_type (void) G_GNUC_CONST;
function gtk_cell_renderer_progress_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_cell_renderer_progress_get_type
end function

! GtkCellRenderer* gtk_cell_renderer_progress_new (void);
function gtk_cell_renderer_progress_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_cell_renderer_progress_new
end function

!   GType gtk_accel_group_get_type (void) G_GNUC_CONST;
function gtk_accel_group_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_accel_group_get_type
end function

! GtkAccelGroup* gtk_accel_group_new (void);
function gtk_accel_group_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_accel_group_new
end function

! gboolean gtk_accel_group_get_is_locked (GtkAccelGroup *accel_group);
function gtk_accel_group_get_is_locked(accel_group) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_accel_group_get_is_locked
  type(c_ptr), value :: accel_group
end function

! GdkModifierType gtk_accel_group_get_modifier_mask (GtkAccelGroup *accel_group);
function gtk_accel_group_get_modifier_mask(accel_group) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_accel_group_get_modifier_mask
  type(c_ptr), value :: accel_group
end function

! void gtk_accel_group_lock (GtkAccelGroup *accel_group);
subroutine gtk_accel_group_lock(accel_group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: accel_group
end subroutine

! void gtk_accel_group_unlock (GtkAccelGroup *accel_group);
subroutine gtk_accel_group_unlock(accel_group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: accel_group
end subroutine

! void gtk_accel_group_connect (GtkAccelGroup *accel_group, guint accel_key, GdkModifierType accel_mods, GtkAccelFlags accel_flags, GClosure *closure);
subroutine gtk_accel_group_connect(accel_group, accel_key, accel_mods, accel_fla&
      &gs, closure) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: accel_group
  integer(c_int), value :: accel_key
  integer(c_int), value :: accel_mods
  integer(c_int), value :: accel_flags
  type(c_ptr), value :: closure
end subroutine

! void gtk_accel_group_connect_by_path (GtkAccelGroup *accel_group, const gchar *accel_path, GClosure *closure);
subroutine gtk_accel_group_connect_by_path(accel_group, accel_path, closure) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: accel_group
  character(kind=c_char), dimension(*) :: accel_path
  type(c_ptr), value :: closure
end subroutine

! gboolean gtk_accel_group_disconnect (GtkAccelGroup *accel_group, GClosure *closure);
function gtk_accel_group_disconnect(accel_group, closure) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_accel_group_disconnect
  type(c_ptr), value :: accel_group
  type(c_ptr), value :: closure
end function

! gboolean gtk_accel_group_disconnect_key (GtkAccelGroup *accel_group, guint accel_key, GdkModifierType accel_mods);
function gtk_accel_group_disconnect_key(accel_group, accel_key, accel_mods) bind&
      &(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_accel_group_disconnect_key
  type(c_ptr), value :: accel_group
  integer(c_int), value :: accel_key
  integer(c_int), value :: accel_mods
end function

! gboolean gtk_accel_group_activate (GtkAccelGroup *accel_group, GQuark accel_quark, GObject *acceleratable, guint accel_key, GdkModifierType accel_mods);
function gtk_accel_group_activate(accel_group, accel_quark, acceleratable, accel&
      &_key, accel_mods) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int32_t, c_int
  logical(c_bool) :: gtk_accel_group_activate
  type(c_ptr), value :: accel_group
  integer(c_int32_t), value :: accel_quark
  type(c_ptr), value :: acceleratable
  integer(c_int), value :: accel_key
  integer(c_int), value :: accel_mods
end function

! gboolean gtk_accel_groups_activate (GObject *object, guint accel_key, GdkModifierType accel_mods);
function gtk_accel_groups_activate(object, accel_key, accel_mods) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_accel_groups_activate
  type(c_ptr), value :: object
  integer(c_int), value :: accel_key
  integer(c_int), value :: accel_mods
end function

! GSList* gtk_accel_groups_from_object (GObject *object);
function gtk_accel_groups_from_object(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_accel_groups_from_object
  type(c_ptr), value :: object
end function

! GtkAccelKey* gtk_accel_group_find (GtkAccelGroup *accel_group, GtkAccelGroupFindFunc find_func, gpointer data);
function gtk_accel_group_find(accel_group, find_func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: gtk_accel_group_find
  type(c_ptr), value :: accel_group
  type(c_funptr), value :: find_func
  type(c_ptr), value :: data
end function

! GtkAccelGroup* gtk_accel_group_from_accel_closure (GClosure *closure);
function gtk_accel_group_from_accel_closure(closure) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_accel_group_from_accel_closure
  type(c_ptr), value :: closure
end function

!  gboolean gtk_accelerator_valid (guint keyval, GdkModifierType modifiers) G_GNUC_CONST;
function gtk_accelerator_valid(keyval, modifiers) bind(c) 
  use iso_c_binding, only: c_bool, c_int
  logical(c_bool) :: gtk_accelerator_valid
  integer(c_int), value :: keyval
  integer(c_int), value :: modifiers
end function

! void gtk_accelerator_parse (const gchar *accelerator, guint *accelerator_key, GdkModifierType *accelerator_mods);
subroutine gtk_accelerator_parse(accelerator, accelerator_key, accelerator_mods)&
      & bind(c) 
  use iso_c_binding, only: c_char, c_ptr, c_int
  character(kind=c_char), dimension(*) :: accelerator
  type(c_ptr), value :: accelerator_key
  integer(c_int), value :: accelerator_mods
end subroutine

! gchar* gtk_accelerator_name (guint accelerator_key, GdkModifierType accelerator_mods);
function gtk_accelerator_name(accelerator_key, accelerator_mods) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_accelerator_name
  integer(c_int), value :: accelerator_key
  integer(c_int), value :: accelerator_mods
end function

! gchar* gtk_accelerator_get_label (guint accelerator_key, GdkModifierType accelerator_mods);
function gtk_accelerator_get_label(accelerator_key, accelerator_mods) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_accelerator_get_label
  integer(c_int), value :: accelerator_key
  integer(c_int), value :: accelerator_mods
end function

! void gtk_accelerator_set_default_mod_mask (GdkModifierType default_mod_mask);
subroutine gtk_accelerator_set_default_mod_mask(default_mod_mask) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: default_mod_mask
end subroutine

! guint gtk_accelerator_get_default_mod_mask (void);
function gtk_accelerator_get_default_mod_mask() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gtk_accelerator_get_default_mod_mask
end function

!  GtkAccelGroupEntry* gtk_accel_group_query (GtkAccelGroup *accel_group, guint accel_key, GdkModifierType accel_mods, guint *n_entries);
function gtk_accel_group_query(accel_group, accel_key, accel_mods, n_entries) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_accel_group_query
  type(c_ptr), value :: accel_group
  integer(c_int), value :: accel_key
  integer(c_int), value :: accel_mods
  type(c_ptr), value :: n_entries
end function

!   GType gtk_radio_tool_button_get_type (void) G_GNUC_CONST;
function gtk_radio_tool_button_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_radio_tool_button_get_type
end function

!  GtkToolItem *gtk_radio_tool_button_new (GSList *group);
function gtk_radio_tool_button_new(group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_radio_tool_button_new
  type(c_ptr), value :: group
end function

! GtkToolItem *gtk_radio_tool_button_new_from_stock (GSList *group, const gchar *stock_id);
function gtk_radio_tool_button_new_from_stock(group, stock_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_radio_tool_button_new_from_stock
  type(c_ptr), value :: group
  character(kind=c_char), dimension(*) :: stock_id
end function

! GtkToolItem *gtk_radio_tool_button_new_from_widget (GtkRadioToolButton *group);
function gtk_radio_tool_button_new_from_widget(group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_radio_tool_button_new_from_widget
  type(c_ptr), value :: group
end function

! GtkToolItem *gtk_radio_tool_button_new_with_stock_from_widget (GtkRadioToolButton *group, const gchar *stock_id);
function gtk_radio_tool_button_new_with_stock_from_widget(group, stock_id) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_radio_tool_button_new_with_stock_from_widget
  type(c_ptr), value :: group
  character(kind=c_char), dimension(*) :: stock_id
end function

! GSList * gtk_radio_tool_button_get_group (GtkRadioToolButton *button);
function gtk_radio_tool_button_get_group(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_radio_tool_button_get_group
  type(c_ptr), value :: button
end function

! void gtk_radio_tool_button_set_group (GtkRadioToolButton *button, GSList *group);
subroutine gtk_radio_tool_button_set_group(button, group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: button
  type(c_ptr), value :: group
end subroutine

!   GType gtk_size_group_get_type (void) G_GNUC_CONST;
function gtk_size_group_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_size_group_get_type
end function

!  GtkSizeGroup * gtk_size_group_new (GtkSizeGroupMode mode);
function gtk_size_group_new(mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_size_group_new
  integer(c_int), value :: mode
end function

! void gtk_size_group_set_mode (GtkSizeGroup *size_group, GtkSizeGroupMode mode);
subroutine gtk_size_group_set_mode(size_group, mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: size_group
  integer(c_int), value :: mode
end subroutine

! GtkSizeGroupMode gtk_size_group_get_mode (GtkSizeGroup *size_group);
function gtk_size_group_get_mode(size_group) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_size_group_get_mode
  type(c_ptr), value :: size_group
end function

! void gtk_size_group_set_ignore_hidden (GtkSizeGroup *size_group, gboolean ignore_hidden);
subroutine gtk_size_group_set_ignore_hidden(size_group, ignore_hidden) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: size_group
  logical(c_bool), value :: ignore_hidden
end subroutine

! gboolean gtk_size_group_get_ignore_hidden (GtkSizeGroup *size_group);
function gtk_size_group_get_ignore_hidden(size_group) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_size_group_get_ignore_hidden
  type(c_ptr), value :: size_group
end function

! void gtk_size_group_add_widget (GtkSizeGroup *size_group, GtkWidget *widget);
subroutine gtk_size_group_add_widget(size_group, widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: size_group
  type(c_ptr), value :: widget
end subroutine

! void gtk_size_group_remove_widget (GtkSizeGroup *size_group, GtkWidget *widget);
subroutine gtk_size_group_remove_widget(size_group, widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: size_group
  type(c_ptr), value :: widget
end subroutine

! GSList * gtk_size_group_get_widgets (GtkSizeGroup *size_group);
function gtk_size_group_get_widgets(size_group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_size_group_get_widgets
  type(c_ptr), value :: size_group
end function

!   GType gtk_file_selection_get_type (void) G_GNUC_CONST;
function gtk_file_selection_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_file_selection_get_type
end function

! GtkWidget* gtk_file_selection_new (const gchar *title);
function gtk_file_selection_new(title) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_file_selection_new
  character(kind=c_char), dimension(*) :: title
end function

! void gtk_file_selection_set_filename (GtkFileSelection *filesel, const gchar *filename);
subroutine gtk_file_selection_set_filename(filesel, filename) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: filesel
  character(kind=c_char), dimension(*) :: filename
end subroutine

! G_CONST_RETURN gchar* gtk_file_selection_get_filename (GtkFileSelection *filesel);
function gtk_file_selection_get_filename(filesel) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_selection_get_filename
  type(c_ptr), value :: filesel
end function

!  void gtk_file_selection_complete (GtkFileSelection *filesel, const gchar *pattern);
subroutine gtk_file_selection_complete(filesel, pattern) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: filesel
  character(kind=c_char), dimension(*) :: pattern
end subroutine

! void gtk_file_selection_show_fileop_buttons (GtkFileSelection *filesel);
subroutine gtk_file_selection_show_fileop_buttons(filesel) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: filesel
end subroutine

! void gtk_file_selection_hide_fileop_buttons (GtkFileSelection *filesel);
subroutine gtk_file_selection_hide_fileop_buttons(filesel) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: filesel
end subroutine

!  gchar** gtk_file_selection_get_selections (GtkFileSelection *filesel);
function gtk_file_selection_get_selections(filesel) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_selection_get_selections
  type(c_ptr), value :: filesel
end function

!  void gtk_file_selection_set_select_multiple (GtkFileSelection *filesel, gboolean select_multiple);
subroutine gtk_file_selection_set_select_multiple(filesel, select_multiple) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: filesel
  logical(c_bool), value :: select_multiple
end subroutine

! gboolean gtk_file_selection_get_select_multiple (GtkFileSelection *filesel);
function gtk_file_selection_get_select_multiple(filesel) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_file_selection_get_select_multiple
  type(c_ptr), value :: filesel
end function

!   GType gtk_menu_get_type (void) G_GNUC_CONST;
function gtk_menu_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_menu_get_type
end function

! GtkWidget* gtk_menu_new (void);
function gtk_menu_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_menu_new
end function

!  void gtk_menu_popup (GtkMenu *menu, GtkWidget *parent_menu_shell, GtkWidget *parent_menu_item, GtkMenuPositionFunc func, gpointer data, guint button, guint32 activate_time);
subroutine gtk_menu_popup(menu, parent_menu_shell, parent_menu_item, func, data,&
      & button, activate_time) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr, c_int, c_int32_t
  type(c_ptr), value :: menu
  type(c_ptr), value :: parent_menu_shell
  type(c_ptr), value :: parent_menu_item
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  integer(c_int), value :: button
  integer(c_int32_t), value :: activate_time
end subroutine

!  void gtk_menu_reposition (GtkMenu *menu);
subroutine gtk_menu_reposition(menu) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: menu
end subroutine

!  void gtk_menu_popdown (GtkMenu *menu);
subroutine gtk_menu_popdown(menu) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: menu
end subroutine

!  GtkWidget* gtk_menu_get_active (GtkMenu *menu);
function gtk_menu_get_active(menu) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_menu_get_active
  type(c_ptr), value :: menu
end function

! void gtk_menu_set_active (GtkMenu *menu, guint index_);
subroutine gtk_menu_set_active(menu, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: menu
  integer(c_int), value :: index_
end subroutine

!  void gtk_menu_set_accel_group (GtkMenu *menu, GtkAccelGroup *accel_group);
subroutine gtk_menu_set_accel_group(menu, accel_group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: menu
  type(c_ptr), value :: accel_group
end subroutine

! GtkAccelGroup* gtk_menu_get_accel_group (GtkMenu *menu);
function gtk_menu_get_accel_group(menu) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_menu_get_accel_group
  type(c_ptr), value :: menu
end function

! void gtk_menu_set_accel_path (GtkMenu *menu, const gchar *accel_path);
subroutine gtk_menu_set_accel_path(menu, accel_path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: menu
  character(kind=c_char), dimension(*) :: accel_path
end subroutine

! const gchar* gtk_menu_get_accel_path (GtkMenu *menu);
function gtk_menu_get_accel_path(menu) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_menu_get_accel_path
  type(c_ptr), value :: menu
end function

!  void gtk_menu_attach_to_widget (GtkMenu *menu, GtkWidget *attach_widget, GtkMenuDetachFunc detacher);
subroutine gtk_menu_attach_to_widget(menu, attach_widget, detacher) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: menu
  type(c_ptr), value :: attach_widget
  type(c_funptr), value :: detacher
end subroutine

! void gtk_menu_detach (GtkMenu *menu);
subroutine gtk_menu_detach(menu) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: menu
end subroutine

!  GtkWidget* gtk_menu_get_attach_widget (GtkMenu *menu);
function gtk_menu_get_attach_widget(menu) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_menu_get_attach_widget
  type(c_ptr), value :: menu
end function

!  void gtk_menu_set_tearoff_state (GtkMenu *menu, gboolean torn_off);
subroutine gtk_menu_set_tearoff_state(menu, torn_off) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: menu
  logical(c_bool), value :: torn_off
end subroutine

! gboolean gtk_menu_get_tearoff_state (GtkMenu *menu);
function gtk_menu_get_tearoff_state(menu) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_menu_get_tearoff_state
  type(c_ptr), value :: menu
end function

!  void gtk_menu_set_title (GtkMenu *menu, const gchar *title);
subroutine gtk_menu_set_title(menu, title) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: menu
  character(kind=c_char), dimension(*) :: title
end subroutine

! G_CONST_RETURN gchar *gtk_menu_get_title (GtkMenu *menu);
function gtk_menu_get_title(menu) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_menu_get_title
  type(c_ptr), value :: menu
end function

!  void gtk_menu_reorder_child (GtkMenu *menu, GtkWidget *child, gint position);
subroutine gtk_menu_reorder_child(menu, child, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: menu
  type(c_ptr), value :: child
  integer(c_int), value :: position
end subroutine

!  void gtk_menu_set_screen (GtkMenu *menu, GdkScreen *screen);
subroutine gtk_menu_set_screen(menu, screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: menu
  type(c_ptr), value :: screen
end subroutine

!  void gtk_menu_attach (GtkMenu *menu, GtkWidget *child, guint left_attach, guint right_attach, guint top_attach, guint bottom_attach);
subroutine gtk_menu_attach(menu, child, left_attach, right_attach, top_attach, b&
      &ottom_attach) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: menu
  type(c_ptr), value :: child
  integer(c_int), value :: left_attach
  integer(c_int), value :: right_attach
  integer(c_int), value :: top_attach
  integer(c_int), value :: bottom_attach
end subroutine

!  void gtk_menu_set_monitor (GtkMenu *menu, gint monitor_num);
subroutine gtk_menu_set_monitor(menu, monitor_num) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: menu
  integer(c_int), value :: monitor_num
end subroutine

! gint gtk_menu_get_monitor (GtkMenu *menu);
function gtk_menu_get_monitor(menu) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_menu_get_monitor
  type(c_ptr), value :: menu
end function

! GList* gtk_menu_get_for_attach_widget (GtkWidget *widget);
function gtk_menu_get_for_attach_widget(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_menu_get_for_attach_widget
  type(c_ptr), value :: widget
end function

!  void gtk_menu_set_reserve_toggle_size (GtkMenu *menu, gboolean reserve_toggle_size);
subroutine gtk_menu_set_reserve_toggle_size(menu, reserve_toggle_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: menu
  logical(c_bool), value :: reserve_toggle_size
end subroutine

! gboolean gtk_menu_get_reserve_toggle_size (GtkMenu *menu);
function gtk_menu_get_reserve_toggle_size(menu) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_menu_get_reserve_toggle_size
  type(c_ptr), value :: menu
end function

!   GType gtk_mount_operation_get_type (void);
function gtk_mount_operation_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_mount_operation_get_type
end function

! GMountOperation *gtk_mount_operation_new (GtkWindow *parent);
function gtk_mount_operation_new(parent) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_mount_operation_new
  type(c_ptr), value :: parent
end function

! gboolean gtk_mount_operation_is_showing (GtkMountOperation *op);
function gtk_mount_operation_is_showing(op) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_mount_operation_is_showing
  type(c_ptr), value :: op
end function

! void gtk_mount_operation_set_parent (GtkMountOperation *op, GtkWindow *parent);
subroutine gtk_mount_operation_set_parent(op, parent) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: op
  type(c_ptr), value :: parent
end subroutine

! GtkWindow * gtk_mount_operation_get_parent (GtkMountOperation *op);
function gtk_mount_operation_get_parent(op) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_mount_operation_get_parent
  type(c_ptr), value :: op
end function

! void gtk_mount_operation_set_screen (GtkMountOperation *op, GdkScreen *screen);
subroutine gtk_mount_operation_set_screen(op, screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: op
  type(c_ptr), value :: screen
end subroutine

! GdkScreen *gtk_mount_operation_get_screen (GtkMountOperation *op);
function gtk_mount_operation_get_screen(op) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_mount_operation_get_screen
  type(c_ptr), value :: op
end function

!  GType gtk_text_get_type (void) G_GNUC_CONST;
function gtk_text_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_text_get_type
end function

! GtkWidget* gtk_text_new (GtkAdjustment *hadj, GtkAdjustment *vadj);
function gtk_text_new(hadj, vadj) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_new
  type(c_ptr), value :: hadj
  type(c_ptr), value :: vadj
end function

! void gtk_text_set_editable (GtkText *text, gboolean editable);
subroutine gtk_text_set_editable(text, editable) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: text
  logical(c_bool), value :: editable
end subroutine

! void gtk_text_set_word_wrap (GtkText *text, gboolean word_wrap);
subroutine gtk_text_set_word_wrap(text, word_wrap) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: text
  logical(c_bool), value :: word_wrap
end subroutine

! void gtk_text_set_line_wrap (GtkText *text, gboolean line_wrap);
subroutine gtk_text_set_line_wrap(text, line_wrap) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: text
  logical(c_bool), value :: line_wrap
end subroutine

! void gtk_text_set_adjustments (GtkText *text, GtkAdjustment *hadj, GtkAdjustment *vadj);
subroutine gtk_text_set_adjustments(text, hadj, vadj) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: text
  type(c_ptr), value :: hadj
  type(c_ptr), value :: vadj
end subroutine

! void gtk_text_set_point (GtkText *text, guint index);
subroutine gtk_text_set_point(text, index) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text
  integer(c_int), value :: index
end subroutine

! guint gtk_text_get_point (GtkText *text);
function gtk_text_get_point(text) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_get_point
  type(c_ptr), value :: text
end function

! guint gtk_text_get_length (GtkText *text);
function gtk_text_get_length(text) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_get_length
  type(c_ptr), value :: text
end function

! void gtk_text_freeze (GtkText *text);
subroutine gtk_text_freeze(text) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: text
end subroutine

! void gtk_text_thaw (GtkText *text);
subroutine gtk_text_thaw(text) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: text
end subroutine

! void gtk_text_insert (GtkText *text, GdkFont *font, const GdkColor *fore, const GdkColor *back, const char *chars, gint length);
subroutine gtk_text_insert(text, font, fore, back, chars, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: text
  type(c_ptr), value :: font
  type(c_ptr), value :: fore
  type(c_ptr), value :: back
  character(kind=c_char), dimension(*) :: chars
  integer(c_int), value :: length
end subroutine

! gboolean gtk_text_backward_delete (GtkText *text, guint nchars);
function gtk_text_backward_delete(text, nchars) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_backward_delete
  type(c_ptr), value :: text
  integer(c_int), value :: nchars
end function

! gboolean gtk_text_forward_delete (GtkText *text, guint nchars);
function gtk_text_forward_delete(text, nchars) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_forward_delete
  type(c_ptr), value :: text
  integer(c_int), value :: nchars
end function

!   GType gtk_file_chooser_get_type (void) G_GNUC_CONST;
function gtk_file_chooser_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_file_chooser_get_type
end function

!  GQuark gtk_file_chooser_error_quark (void);
function gtk_file_chooser_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: gtk_file_chooser_error_quark
end function

!  void gtk_file_chooser_set_action (GtkFileChooser *chooser, GtkFileChooserAction action);
subroutine gtk_file_chooser_set_action(chooser, action) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: chooser
  integer(c_int), value :: action
end subroutine

! GtkFileChooserAction gtk_file_chooser_get_action (GtkFileChooser *chooser);
function gtk_file_chooser_get_action(chooser) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_file_chooser_get_action
  type(c_ptr), value :: chooser
end function

! void gtk_file_chooser_set_local_only (GtkFileChooser *chooser, gboolean local_only);
subroutine gtk_file_chooser_set_local_only(chooser, local_only) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: chooser
  logical(c_bool), value :: local_only
end subroutine

! gboolean gtk_file_chooser_get_local_only (GtkFileChooser *chooser);
function gtk_file_chooser_get_local_only(chooser) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_file_chooser_get_local_only
  type(c_ptr), value :: chooser
end function

! void gtk_file_chooser_set_select_multiple (GtkFileChooser *chooser, gboolean select_multiple);
subroutine gtk_file_chooser_set_select_multiple(chooser, select_multiple) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: chooser
  logical(c_bool), value :: select_multiple
end subroutine

! gboolean gtk_file_chooser_get_select_multiple (GtkFileChooser *chooser);
function gtk_file_chooser_get_select_multiple(chooser) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_file_chooser_get_select_multiple
  type(c_ptr), value :: chooser
end function

! void gtk_file_chooser_set_show_hidden (GtkFileChooser *chooser, gboolean show_hidden);
subroutine gtk_file_chooser_set_show_hidden(chooser, show_hidden) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: chooser
  logical(c_bool), value :: show_hidden
end subroutine

! gboolean gtk_file_chooser_get_show_hidden (GtkFileChooser *chooser);
function gtk_file_chooser_get_show_hidden(chooser) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_file_chooser_get_show_hidden
  type(c_ptr), value :: chooser
end function

!  void gtk_file_chooser_set_do_overwrite_confirmation (GtkFileChooser *chooser, gboolean do_overwrite_confirmation);
subroutine gtk_file_chooser_set_do_overwrite_confirmation(chooser, do_overwrite_&
      &confirmation) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: chooser
  logical(c_bool), value :: do_overwrite_confirmation
end subroutine

! gboolean gtk_file_chooser_get_do_overwrite_confirmation (GtkFileChooser *chooser);
function gtk_file_chooser_get_do_overwrite_confirmation(chooser) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_file_chooser_get_do_overwrite_confirmation
  type(c_ptr), value :: chooser
end function

!  void gtk_file_chooser_set_create_folders (GtkFileChooser *chooser, gboolean create_folders);
subroutine gtk_file_chooser_set_create_folders(chooser, create_folders) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: chooser
  logical(c_bool), value :: create_folders
end subroutine

! gboolean gtk_file_chooser_get_create_folders (GtkFileChooser *chooser);
function gtk_file_chooser_get_create_folders(chooser) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_file_chooser_get_create_folders
  type(c_ptr), value :: chooser
end function

!  void gtk_file_chooser_set_current_name (GtkFileChooser *chooser, const gchar *name);
subroutine gtk_file_chooser_set_current_name(chooser, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: chooser
  character(kind=c_char), dimension(*) :: name
end subroutine

!  gchar * gtk_file_chooser_get_filename (GtkFileChooser *chooser);
function gtk_file_chooser_get_filename(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_get_filename
  type(c_ptr), value :: chooser
end function

! gboolean gtk_file_chooser_set_filename (GtkFileChooser *chooser, const char *filename);
function gtk_file_chooser_set_filename(chooser, filename) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_file_chooser_set_filename
  type(c_ptr), value :: chooser
  character(kind=c_char), dimension(*) :: filename
end function

! gboolean gtk_file_chooser_select_filename (GtkFileChooser *chooser, const char *filename);
function gtk_file_chooser_select_filename(chooser, filename) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_file_chooser_select_filename
  type(c_ptr), value :: chooser
  character(kind=c_char), dimension(*) :: filename
end function

! void gtk_file_chooser_unselect_filename (GtkFileChooser *chooser, const char *filename);
subroutine gtk_file_chooser_unselect_filename(chooser, filename) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: chooser
  character(kind=c_char), dimension(*) :: filename
end subroutine

! void gtk_file_chooser_select_all (GtkFileChooser *chooser);
subroutine gtk_file_chooser_select_all(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: chooser
end subroutine

! void gtk_file_chooser_unselect_all (GtkFileChooser *chooser);
subroutine gtk_file_chooser_unselect_all(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: chooser
end subroutine

! GSList * gtk_file_chooser_get_filenames (GtkFileChooser *chooser);
function gtk_file_chooser_get_filenames(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_get_filenames
  type(c_ptr), value :: chooser
end function

! gboolean gtk_file_chooser_set_current_folder (GtkFileChooser *chooser, const gchar *filename);
function gtk_file_chooser_set_current_folder(chooser, filename) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_file_chooser_set_current_folder
  type(c_ptr), value :: chooser
  character(kind=c_char), dimension(*) :: filename
end function

! gchar * gtk_file_chooser_get_current_folder (GtkFileChooser *chooser);
function gtk_file_chooser_get_current_folder(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_get_current_folder
  type(c_ptr), value :: chooser
end function

!  gchar * gtk_file_chooser_get_uri (GtkFileChooser *chooser);
function gtk_file_chooser_get_uri(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_get_uri
  type(c_ptr), value :: chooser
end function

! gboolean gtk_file_chooser_set_uri (GtkFileChooser *chooser, const char *uri);
function gtk_file_chooser_set_uri(chooser, uri) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_file_chooser_set_uri
  type(c_ptr), value :: chooser
  character(kind=c_char), dimension(*) :: uri
end function

! gboolean gtk_file_chooser_select_uri (GtkFileChooser *chooser, const char *uri);
function gtk_file_chooser_select_uri(chooser, uri) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_file_chooser_select_uri
  type(c_ptr), value :: chooser
  character(kind=c_char), dimension(*) :: uri
end function

! void gtk_file_chooser_unselect_uri (GtkFileChooser *chooser, const char *uri);
subroutine gtk_file_chooser_unselect_uri(chooser, uri) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: chooser
  character(kind=c_char), dimension(*) :: uri
end subroutine

! GSList * gtk_file_chooser_get_uris (GtkFileChooser *chooser);
function gtk_file_chooser_get_uris(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_get_uris
  type(c_ptr), value :: chooser
end function

! gboolean gtk_file_chooser_set_current_folder_uri (GtkFileChooser *chooser, const gchar *uri);
function gtk_file_chooser_set_current_folder_uri(chooser, uri) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_file_chooser_set_current_folder_uri
  type(c_ptr), value :: chooser
  character(kind=c_char), dimension(*) :: uri
end function

! gchar * gtk_file_chooser_get_current_folder_uri (GtkFileChooser *chooser);
function gtk_file_chooser_get_current_folder_uri(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_get_current_folder_uri
  type(c_ptr), value :: chooser
end function

!  GFile * gtk_file_chooser_get_file (GtkFileChooser *chooser);
function gtk_file_chooser_get_file(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_get_file
  type(c_ptr), value :: chooser
end function

! gboolean gtk_file_chooser_set_file (GtkFileChooser *chooser, GFile *file, GError **error);
function gtk_file_chooser_set_file(chooser, file, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_file_chooser_set_file
  type(c_ptr), value :: chooser
  type(c_ptr), value :: file
  type(c_ptr), value :: error
end function

! gboolean gtk_file_chooser_select_file (GtkFileChooser *chooser, GFile *file, GError **error);
function gtk_file_chooser_select_file(chooser, file, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_file_chooser_select_file
  type(c_ptr), value :: chooser
  type(c_ptr), value :: file
  type(c_ptr), value :: error
end function

! void gtk_file_chooser_unselect_file (GtkFileChooser *chooser, GFile *file);
subroutine gtk_file_chooser_unselect_file(chooser, file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: chooser
  type(c_ptr), value :: file
end subroutine

! GSList * gtk_file_chooser_get_files (GtkFileChooser *chooser);
function gtk_file_chooser_get_files(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_get_files
  type(c_ptr), value :: chooser
end function

! gboolean gtk_file_chooser_set_current_folder_file (GtkFileChooser *chooser, GFile *file, GError **error);
function gtk_file_chooser_set_current_folder_file(chooser, file, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_file_chooser_set_current_folder_file
  type(c_ptr), value :: chooser
  type(c_ptr), value :: file
  type(c_ptr), value :: error
end function

! GFile * gtk_file_chooser_get_current_folder_file (GtkFileChooser *chooser);
function gtk_file_chooser_get_current_folder_file(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_get_current_folder_file
  type(c_ptr), value :: chooser
end function

!  void gtk_file_chooser_set_preview_widget (GtkFileChooser *chooser, GtkWidget *preview_widget);
subroutine gtk_file_chooser_set_preview_widget(chooser, preview_widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: chooser
  type(c_ptr), value :: preview_widget
end subroutine

! GtkWidget *gtk_file_chooser_get_preview_widget (GtkFileChooser *chooser);
function gtk_file_chooser_get_preview_widget(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_get_preview_widget
  type(c_ptr), value :: chooser
end function

! void gtk_file_chooser_set_preview_widget_active (GtkFileChooser *chooser, gboolean active);
subroutine gtk_file_chooser_set_preview_widget_active(chooser, active) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: chooser
  logical(c_bool), value :: active
end subroutine

! gboolean gtk_file_chooser_get_preview_widget_active (GtkFileChooser *chooser);
function gtk_file_chooser_get_preview_widget_active(chooser) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_file_chooser_get_preview_widget_active
  type(c_ptr), value :: chooser
end function

! void gtk_file_chooser_set_use_preview_label (GtkFileChooser *chooser, gboolean use_label);
subroutine gtk_file_chooser_set_use_preview_label(chooser, use_label) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: chooser
  logical(c_bool), value :: use_label
end subroutine

! gboolean gtk_file_chooser_get_use_preview_label (GtkFileChooser *chooser);
function gtk_file_chooser_get_use_preview_label(chooser) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_file_chooser_get_use_preview_label
  type(c_ptr), value :: chooser
end function

!  char *gtk_file_chooser_get_preview_filename (GtkFileChooser *chooser);
function gtk_file_chooser_get_preview_filename(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_get_preview_filename
  type(c_ptr), value :: chooser
end function

! char *gtk_file_chooser_get_preview_uri (GtkFileChooser *chooser);
function gtk_file_chooser_get_preview_uri(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_get_preview_uri
  type(c_ptr), value :: chooser
end function

! GFile *gtk_file_chooser_get_preview_file (GtkFileChooser *chooser);
function gtk_file_chooser_get_preview_file(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_get_preview_file
  type(c_ptr), value :: chooser
end function

!  void gtk_file_chooser_set_extra_widget (GtkFileChooser *chooser, GtkWidget *extra_widget);
subroutine gtk_file_chooser_set_extra_widget(chooser, extra_widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: chooser
  type(c_ptr), value :: extra_widget
end subroutine

! GtkWidget *gtk_file_chooser_get_extra_widget (GtkFileChooser *chooser);
function gtk_file_chooser_get_extra_widget(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_get_extra_widget
  type(c_ptr), value :: chooser
end function

!  void gtk_file_chooser_add_filter (GtkFileChooser *chooser, GtkFileFilter *filter);
subroutine gtk_file_chooser_add_filter(chooser, filter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: chooser
  type(c_ptr), value :: filter
end subroutine

! void gtk_file_chooser_remove_filter (GtkFileChooser *chooser, GtkFileFilter *filter);
subroutine gtk_file_chooser_remove_filter(chooser, filter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: chooser
  type(c_ptr), value :: filter
end subroutine

! GSList *gtk_file_chooser_list_filters (GtkFileChooser *chooser);
function gtk_file_chooser_list_filters(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_list_filters
  type(c_ptr), value :: chooser
end function

!  void gtk_file_chooser_set_filter (GtkFileChooser *chooser, GtkFileFilter *filter);
subroutine gtk_file_chooser_set_filter(chooser, filter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: chooser
  type(c_ptr), value :: filter
end subroutine

! GtkFileFilter *gtk_file_chooser_get_filter (GtkFileChooser *chooser);
function gtk_file_chooser_get_filter(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_get_filter
  type(c_ptr), value :: chooser
end function

!  gboolean gtk_file_chooser_add_shortcut_folder (GtkFileChooser *chooser, const char *folder, GError **error);
function gtk_file_chooser_add_shortcut_folder(chooser, folder, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_file_chooser_add_shortcut_folder
  type(c_ptr), value :: chooser
  character(kind=c_char), dimension(*) :: folder
  type(c_ptr), value :: error
end function

! gboolean gtk_file_chooser_remove_shortcut_folder (GtkFileChooser *chooser, const char *folder, GError **error);
function gtk_file_chooser_remove_shortcut_folder(chooser, folder, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_file_chooser_remove_shortcut_folder
  type(c_ptr), value :: chooser
  character(kind=c_char), dimension(*) :: folder
  type(c_ptr), value :: error
end function

! GSList *gtk_file_chooser_list_shortcut_folders (GtkFileChooser *chooser);
function gtk_file_chooser_list_shortcut_folders(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_list_shortcut_folders
  type(c_ptr), value :: chooser
end function

!  gboolean gtk_file_chooser_add_shortcut_folder_uri (GtkFileChooser *chooser, const char *uri, GError **error);
function gtk_file_chooser_add_shortcut_folder_uri(chooser, uri, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_file_chooser_add_shortcut_folder_uri
  type(c_ptr), value :: chooser
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! gboolean gtk_file_chooser_remove_shortcut_folder_uri (GtkFileChooser *chooser, const char *uri, GError **error);
function gtk_file_chooser_remove_shortcut_folder_uri(chooser, uri, error) bind(c&
      &) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_file_chooser_remove_shortcut_folder_uri
  type(c_ptr), value :: chooser
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! GSList *gtk_file_chooser_list_shortcut_folder_uris (GtkFileChooser *chooser);
function gtk_file_chooser_list_shortcut_folder_uris(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_chooser_list_shortcut_folder_uris
  type(c_ptr), value :: chooser
end function

!   GType gtk_text_tag_get_type (void) G_GNUC_CONST;
function gtk_text_tag_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_text_tag_get_type
end function

! GtkTextTag *gtk_text_tag_new (const gchar *name);
function gtk_text_tag_new(name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_text_tag_new
  character(kind=c_char), dimension(*) :: name
end function

! gint gtk_text_tag_get_priority (GtkTextTag *tag);
function gtk_text_tag_get_priority(tag) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_tag_get_priority
  type(c_ptr), value :: tag
end function

! void gtk_text_tag_set_priority (GtkTextTag *tag, gint priority);
subroutine gtk_text_tag_set_priority(tag, priority) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tag
  integer(c_int), value :: priority
end subroutine

! gboolean gtk_text_tag_event (GtkTextTag *tag, GObject *event_object, GdkEvent *event, const GtkTextIter *iter);
function gtk_text_tag_event(tag, event_object, event, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_tag_event
  type(c_ptr), value :: tag
  type(c_ptr), value :: event_object
  type(c_ptr), value :: event
  type(c_ptr), value :: iter
end function

!  GtkTextAttributes* gtk_text_attributes_new (void);
function gtk_text_attributes_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_attributes_new
end function

! GtkTextAttributes* gtk_text_attributes_copy (GtkTextAttributes *src);
function gtk_text_attributes_copy(src) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_attributes_copy
  type(c_ptr), value :: src
end function

! void gtk_text_attributes_copy_values (GtkTextAttributes *src, GtkTextAttributes *dest);
subroutine gtk_text_attributes_copy_values(src, dest) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: src
  type(c_ptr), value :: dest
end subroutine

! void gtk_text_attributes_unref (GtkTextAttributes *values);
subroutine gtk_text_attributes_unref(values) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: values
end subroutine

! GtkTextAttributes *gtk_text_attributes_ref (GtkTextAttributes *values);
function gtk_text_attributes_ref(values) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_attributes_ref
  type(c_ptr), value :: values
end function

!  GType gtk_text_attributes_get_type (void) G_GNUC_CONST;
function gtk_text_attributes_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_text_attributes_get_type
end function

!   GType gtk_curve_get_type (void) G_GNUC_CONST;
function gtk_curve_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_curve_get_type
end function

! GtkWidget* gtk_curve_new (void);
function gtk_curve_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_curve_new
end function

! void gtk_curve_reset (GtkCurve *curve);
subroutine gtk_curve_reset(curve) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: curve
end subroutine

! void gtk_curve_set_gamma (GtkCurve *curve, gfloat gamma_);
subroutine gtk_curve_set_gamma(curve, gamma_) bind(c) 
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: curve
  real(c_float), value :: gamma_
end subroutine

! void gtk_curve_set_range (GtkCurve *curve, gfloat min_x, gfloat max_x, gfloat min_y, gfloat max_y);
subroutine gtk_curve_set_range(curve, min_x, max_x, min_y, max_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: curve
  real(c_float), value :: min_x
  real(c_float), value :: max_x
  real(c_float), value :: min_y
  real(c_float), value :: max_y
end subroutine

! void gtk_curve_get_vector (GtkCurve *curve, int veclen, gfloat vector[]);
subroutine gtk_curve_get_vector(curve, veclen, vector) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_float
  type(c_ptr), value :: curve
  integer(c_int), value :: veclen
  real(c_float), dimension(*) :: vector
end subroutine

! void gtk_curve_set_vector (GtkCurve *curve, int veclen, gfloat vector[]);
subroutine gtk_curve_set_vector(curve, veclen, vector) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_float
  type(c_ptr), value :: curve
  integer(c_int), value :: veclen
  real(c_float), dimension(*) :: vector
end subroutine

! void gtk_curve_set_curve_type (GtkCurve *curve, GtkCurveType type);
subroutine gtk_curve_set_curve_type(curve, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: curve
  integer(c_int), value :: type
end subroutine

!   GType gtk_alignment_get_type (void) G_GNUC_CONST;
function gtk_alignment_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_alignment_get_type
end function

! GtkWidget* gtk_alignment_new (gfloat xalign, gfloat yalign, gfloat xscale, gfloat yscale);
function gtk_alignment_new(xalign, yalign, xscale, yscale) bind(c) 
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: gtk_alignment_new
  real(c_float), value :: xalign
  real(c_float), value :: yalign
  real(c_float), value :: xscale
  real(c_float), value :: yscale
end function

! void gtk_alignment_set (GtkAlignment *alignment, gfloat xalign, gfloat yalign, gfloat xscale, gfloat yscale);
subroutine gtk_alignment_set(alignment, xalign, yalign, xscale, yscale) bind(c) 
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: alignment
  real(c_float), value :: xalign
  real(c_float), value :: yalign
  real(c_float), value :: xscale
  real(c_float), value :: yscale
end subroutine

!  void gtk_alignment_set_padding (GtkAlignment *alignment, guint padding_top, guint padding_bottom, guint padding_left, guint padding_right);
subroutine gtk_alignment_set_padding(alignment, padding_top, padding_bottom, pad&
      &ding_left, padding_right) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: alignment
  integer(c_int), value :: padding_top
  integer(c_int), value :: padding_bottom
  integer(c_int), value :: padding_left
  integer(c_int), value :: padding_right
end subroutine

!  void gtk_alignment_get_padding (GtkAlignment *alignment, guint *padding_top, guint *padding_bottom, guint *padding_left, guint *padding_right);
subroutine gtk_alignment_get_padding(alignment, padding_top, padding_bottom, pad&
      &ding_left, padding_right) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: alignment
  type(c_ptr), value :: padding_top
  type(c_ptr), value :: padding_bottom
  type(c_ptr), value :: padding_left
  type(c_ptr), value :: padding_right
end subroutine

!   GType gtk_cell_view_get_type (void) G_GNUC_CONST;
function gtk_cell_view_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_cell_view_get_type
end function

! GtkWidget *gtk_cell_view_new (void);
function gtk_cell_view_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_cell_view_new
end function

! GtkWidget *gtk_cell_view_new_with_text (const gchar *text);
function gtk_cell_view_new_with_text(text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_cell_view_new_with_text
  character(kind=c_char), dimension(*) :: text
end function

! GtkWidget *gtk_cell_view_new_with_markup (const gchar *markup);
function gtk_cell_view_new_with_markup(markup) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_cell_view_new_with_markup
  character(kind=c_char), dimension(*) :: markup
end function

! GtkWidget *gtk_cell_view_new_with_pixbuf (GdkPixbuf *pixbuf);
function gtk_cell_view_new_with_pixbuf(pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_cell_view_new_with_pixbuf
  type(c_ptr), value :: pixbuf
end function

!  void gtk_cell_view_set_model (GtkCellView *cell_view, GtkTreeModel *model);
subroutine gtk_cell_view_set_model(cell_view, model) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cell_view
  type(c_ptr), value :: model
end subroutine

! GtkTreeModel *gtk_cell_view_get_model (GtkCellView *cell_view);
function gtk_cell_view_get_model(cell_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_cell_view_get_model
  type(c_ptr), value :: cell_view
end function

! void gtk_cell_view_set_displayed_row (GtkCellView *cell_view, GtkTreePath *path);
subroutine gtk_cell_view_set_displayed_row(cell_view, path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cell_view
  type(c_ptr), value :: path
end subroutine

! GtkTreePath *gtk_cell_view_get_displayed_row (GtkCellView *cell_view);
function gtk_cell_view_get_displayed_row(cell_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_cell_view_get_displayed_row
  type(c_ptr), value :: cell_view
end function

! gboolean gtk_cell_view_get_size_of_row (GtkCellView *cell_view, GtkTreePath *path, GtkRequisition *requisition);
function gtk_cell_view_get_size_of_row(cell_view, path, requisition) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_cell_view_get_size_of_row
  type(c_ptr), value :: cell_view
  type(c_ptr), value :: path
  type(c_ptr), value :: requisition
end function

!  void gtk_cell_view_set_background_color (GtkCellView *cell_view, const GdkColor *color);
subroutine gtk_cell_view_set_background_color(cell_view, color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cell_view
  type(c_ptr), value :: color
end subroutine

!  GList *gtk_cell_view_get_cell_renderers (GtkCellView *cell_view);
function gtk_cell_view_get_cell_renderers(cell_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_cell_view_get_cell_renderers
  type(c_ptr), value :: cell_view
end function

!   GType gtk_vscale_get_type (void) G_GNUC_CONST;
function gtk_vscale_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_vscale_get_type
end function

! GtkWidget* gtk_vscale_new (GtkAdjustment *adjustment);
function gtk_vscale_new(adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_vscale_new
  type(c_ptr), value :: adjustment
end function

! GtkWidget* gtk_vscale_new_with_range (gdouble min, gdouble max, gdouble step);
function gtk_vscale_new_with_range(min, max, step) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr) :: gtk_vscale_new_with_range
  real(c_double), value :: min
  real(c_double), value :: max
  real(c_double), value :: step
end function

!   GType gtk_text_view_get_type (void) G_GNUC_CONST;
function gtk_text_view_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_text_view_get_type
end function

! GtkWidget * gtk_text_view_new (void);
function gtk_text_view_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_view_new
end function

! GtkWidget * gtk_text_view_new_with_buffer (GtkTextBuffer *buffer);
function gtk_text_view_new_with_buffer(buffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_view_new_with_buffer
  type(c_ptr), value :: buffer
end function

! void gtk_text_view_set_buffer (GtkTextView *text_view, GtkTextBuffer *buffer);
subroutine gtk_text_view_set_buffer(text_view, buffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: text_view
  type(c_ptr), value :: buffer
end subroutine

! GtkTextBuffer *gtk_text_view_get_buffer (GtkTextView *text_view);
function gtk_text_view_get_buffer(text_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_view_get_buffer
  type(c_ptr), value :: text_view
end function

! gboolean gtk_text_view_scroll_to_iter (GtkTextView *text_view, GtkTextIter *iter, gdouble within_margin, gboolean use_align, gdouble xalign, gdouble yalign);
function gtk_text_view_scroll_to_iter(text_view, iter, within_margin, use_align,&
      & xalign, yalign) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_double
  logical(c_bool) :: gtk_text_view_scroll_to_iter
  type(c_ptr), value :: text_view
  type(c_ptr), value :: iter
  real(c_double), value :: within_margin
  logical(c_bool), value :: use_align
  real(c_double), value :: xalign
  real(c_double), value :: yalign
end function

! void gtk_text_view_scroll_to_mark (GtkTextView *text_view, GtkTextMark *mark, gdouble within_margin, gboolean use_align, gdouble xalign, gdouble yalign);
subroutine gtk_text_view_scroll_to_mark(text_view, mark, within_margin, use_alig&
      &n, xalign, yalign) bind(c) 
  use iso_c_binding, only: c_ptr, c_double, c_bool
  type(c_ptr), value :: text_view
  type(c_ptr), value :: mark
  real(c_double), value :: within_margin
  logical(c_bool), value :: use_align
  real(c_double), value :: xalign
  real(c_double), value :: yalign
end subroutine

! void gtk_text_view_scroll_mark_onscreen (GtkTextView *text_view, GtkTextMark *mark);
subroutine gtk_text_view_scroll_mark_onscreen(text_view, mark) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: text_view
  type(c_ptr), value :: mark
end subroutine

! gboolean gtk_text_view_move_mark_onscreen (GtkTextView *text_view, GtkTextMark *mark);
function gtk_text_view_move_mark_onscreen(text_view, mark) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_view_move_mark_onscreen
  type(c_ptr), value :: text_view
  type(c_ptr), value :: mark
end function

! gboolean gtk_text_view_place_cursor_onscreen (GtkTextView *text_view);
function gtk_text_view_place_cursor_onscreen(text_view) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_view_place_cursor_onscreen
  type(c_ptr), value :: text_view
end function

!  void gtk_text_view_get_visible_rect (GtkTextView *text_view, GdkRectangle *visible_rect);
subroutine gtk_text_view_get_visible_rect(text_view, visible_rect) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: text_view
  type(c_ptr), value :: visible_rect
end subroutine

! void gtk_text_view_set_cursor_visible (GtkTextView *text_view, gboolean setting);
subroutine gtk_text_view_set_cursor_visible(text_view, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: text_view
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_text_view_get_cursor_visible (GtkTextView *text_view);
function gtk_text_view_get_cursor_visible(text_view) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_view_get_cursor_visible
  type(c_ptr), value :: text_view
end function

!  void gtk_text_view_get_iter_location (GtkTextView *text_view, const GtkTextIter *iter, GdkRectangle *location);
subroutine gtk_text_view_get_iter_location(text_view, iter, location) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: text_view
  type(c_ptr), value :: iter
  type(c_ptr), value :: location
end subroutine

! void gtk_text_view_get_iter_at_location (GtkTextView *text_view, GtkTextIter *iter, gint x, gint y);
subroutine gtk_text_view_get_iter_at_location(text_view, iter, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text_view
  type(c_ptr), value :: iter
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void gtk_text_view_get_iter_at_position (GtkTextView *text_view, GtkTextIter *iter, gint *trailing, gint x, gint y);
subroutine gtk_text_view_get_iter_at_position(text_view, iter, trailing, x, y) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text_view
  type(c_ptr), value :: iter
  type(c_ptr), value :: trailing
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void gtk_text_view_get_line_yrange (GtkTextView *text_view, const GtkTextIter *iter, gint *y, gint *height);
subroutine gtk_text_view_get_line_yrange(text_view, iter, y, height) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: text_view
  type(c_ptr), value :: iter
  type(c_ptr), value :: y
  type(c_ptr), value :: height
end subroutine

!  void gtk_text_view_get_line_at_y (GtkTextView *text_view, GtkTextIter *target_iter, gint y, gint *line_top);
subroutine gtk_text_view_get_line_at_y(text_view, target_iter, y, line_top) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text_view
  type(c_ptr), value :: target_iter
  integer(c_int), value :: y
  type(c_ptr), value :: line_top
end subroutine

!  void gtk_text_view_buffer_to_window_coords (GtkTextView *text_view, GtkTextWindowType win, gint buffer_x, gint buffer_y, gint *window_x, gint *window_y);
subroutine gtk_text_view_buffer_to_window_coords(text_view, win, buffer_x, buffe&
      &r_y, window_x, window_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text_view
  integer(c_int), value :: win
  integer(c_int), value :: buffer_x
  integer(c_int), value :: buffer_y
  type(c_ptr), value :: window_x
  type(c_ptr), value :: window_y
end subroutine

! void gtk_text_view_window_to_buffer_coords (GtkTextView *text_view, GtkTextWindowType win, gint window_x, gint window_y, gint *buffer_x, gint *buffer_y);
subroutine gtk_text_view_window_to_buffer_coords(text_view, win, window_x, windo&
      &w_y, buffer_x, buffer_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text_view
  integer(c_int), value :: win
  integer(c_int), value :: window_x
  integer(c_int), value :: window_y
  type(c_ptr), value :: buffer_x
  type(c_ptr), value :: buffer_y
end subroutine

!  GtkAdjustment* gtk_text_view_get_hadjustment (GtkTextView *text_view);
function gtk_text_view_get_hadjustment(text_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_view_get_hadjustment
  type(c_ptr), value :: text_view
end function

! GtkAdjustment* gtk_text_view_get_vadjustment (GtkTextView *text_view);
function gtk_text_view_get_vadjustment(text_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_view_get_vadjustment
  type(c_ptr), value :: text_view
end function

!  GdkWindow* gtk_text_view_get_window (GtkTextView *text_view, GtkTextWindowType win);
function gtk_text_view_get_window(text_view, win) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_text_view_get_window
  type(c_ptr), value :: text_view
  integer(c_int), value :: win
end function

! GtkTextWindowType gtk_text_view_get_window_type (GtkTextView *text_view, GdkWindow *window);
function gtk_text_view_get_window_type(text_view, window) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_view_get_window_type
  type(c_ptr), value :: text_view
  type(c_ptr), value :: window
end function

!  void gtk_text_view_set_border_window_size (GtkTextView *text_view, GtkTextWindowType type, gint size);
subroutine gtk_text_view_set_border_window_size(text_view, type, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text_view
  integer(c_int), value :: type
  integer(c_int), value :: size
end subroutine

! gint gtk_text_view_get_border_window_size (GtkTextView *text_view, GtkTextWindowType type);
function gtk_text_view_get_border_window_size(text_view, type) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_view_get_border_window_size
  type(c_ptr), value :: text_view
  integer(c_int), value :: type
end function

!  gboolean gtk_text_view_forward_display_line (GtkTextView *text_view, GtkTextIter *iter);
function gtk_text_view_forward_display_line(text_view, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_view_forward_display_line
  type(c_ptr), value :: text_view
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_view_backward_display_line (GtkTextView *text_view, GtkTextIter *iter);
function gtk_text_view_backward_display_line(text_view, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_view_backward_display_line
  type(c_ptr), value :: text_view
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_view_forward_display_line_end (GtkTextView *text_view, GtkTextIter *iter);
function gtk_text_view_forward_display_line_end(text_view, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_view_forward_display_line_end
  type(c_ptr), value :: text_view
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_view_backward_display_line_start (GtkTextView *text_view, GtkTextIter *iter);
function gtk_text_view_backward_display_line_start(text_view, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_view_backward_display_line_start
  type(c_ptr), value :: text_view
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_view_starts_display_line (GtkTextView *text_view, const GtkTextIter *iter);
function gtk_text_view_starts_display_line(text_view, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_view_starts_display_line
  type(c_ptr), value :: text_view
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_view_move_visually (GtkTextView *text_view, GtkTextIter *iter, gint count);
function gtk_text_view_move_visually(text_view, iter, count) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_view_move_visually
  type(c_ptr), value :: text_view
  type(c_ptr), value :: iter
  integer(c_int), value :: count
end function

!  gboolean gtk_text_view_im_context_filter_keypress (GtkTextView *text_view, GdkEventKey *event);
function gtk_text_view_im_context_filter_keypress(text_view, event) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_view_im_context_filter_keypress
  type(c_ptr), value :: text_view
  type(c_ptr), value :: event
end function

! void gtk_text_view_reset_im_context (GtkTextView *text_view);
subroutine gtk_text_view_reset_im_context(text_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: text_view
end subroutine

!  void gtk_text_view_add_child_at_anchor (GtkTextView *text_view, GtkWidget *child, GtkTextChildAnchor *anchor);
subroutine gtk_text_view_add_child_at_anchor(text_view, child, anchor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: text_view
  type(c_ptr), value :: child
  type(c_ptr), value :: anchor
end subroutine

!  void gtk_text_view_add_child_in_window (GtkTextView *text_view, GtkWidget *child, GtkTextWindowType which_window,  gint xpos, gint ypos);
subroutine gtk_text_view_add_child_in_window(text_view, child, which_window, xpo&
      &s, ypos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text_view
  type(c_ptr), value :: child
  integer(c_int), value :: which_window
  integer(c_int), value :: xpos
  integer(c_int), value :: ypos
end subroutine

!  void gtk_text_view_move_child (GtkTextView *text_view, GtkWidget *child,  gint xpos, gint ypos);
subroutine gtk_text_view_move_child(text_view, child, xpos, ypos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text_view
  type(c_ptr), value :: child
  integer(c_int), value :: xpos
  integer(c_int), value :: ypos
end subroutine

!  void gtk_text_view_set_wrap_mode (GtkTextView *text_view, GtkWrapMode wrap_mode);
subroutine gtk_text_view_set_wrap_mode(text_view, wrap_mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text_view
  integer(c_int), value :: wrap_mode
end subroutine

! GtkWrapMode gtk_text_view_get_wrap_mode (GtkTextView *text_view);
function gtk_text_view_get_wrap_mode(text_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_view_get_wrap_mode
  type(c_ptr), value :: text_view
end function

! void gtk_text_view_set_editable (GtkTextView *text_view, gboolean setting);
subroutine gtk_text_view_set_editable(text_view, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: text_view
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_text_view_get_editable (GtkTextView *text_view);
function gtk_text_view_get_editable(text_view) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_view_get_editable
  type(c_ptr), value :: text_view
end function

! void gtk_text_view_set_overwrite (GtkTextView *text_view, gboolean overwrite);
subroutine gtk_text_view_set_overwrite(text_view, overwrite) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: text_view
  logical(c_bool), value :: overwrite
end subroutine

! gboolean gtk_text_view_get_overwrite (GtkTextView *text_view);
function gtk_text_view_get_overwrite(text_view) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_view_get_overwrite
  type(c_ptr), value :: text_view
end function

! void gtk_text_view_set_accepts_tab (GtkTextView *text_view, gboolean accepts_tab);
subroutine gtk_text_view_set_accepts_tab(text_view, accepts_tab) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: text_view
  logical(c_bool), value :: accepts_tab
end subroutine

! gboolean gtk_text_view_get_accepts_tab (GtkTextView *text_view);
function gtk_text_view_get_accepts_tab(text_view) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_view_get_accepts_tab
  type(c_ptr), value :: text_view
end function

! void gtk_text_view_set_pixels_above_lines (GtkTextView *text_view, gint pixels_above_lines);
subroutine gtk_text_view_set_pixels_above_lines(text_view, pixels_above_lines) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text_view
  integer(c_int), value :: pixels_above_lines
end subroutine

! gint gtk_text_view_get_pixels_above_lines (GtkTextView *text_view);
function gtk_text_view_get_pixels_above_lines(text_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_view_get_pixels_above_lines
  type(c_ptr), value :: text_view
end function

! void gtk_text_view_set_pixels_below_lines (GtkTextView *text_view, gint pixels_below_lines);
subroutine gtk_text_view_set_pixels_below_lines(text_view, pixels_below_lines) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text_view
  integer(c_int), value :: pixels_below_lines
end subroutine

! gint gtk_text_view_get_pixels_below_lines (GtkTextView *text_view);
function gtk_text_view_get_pixels_below_lines(text_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_view_get_pixels_below_lines
  type(c_ptr), value :: text_view
end function

! void gtk_text_view_set_pixels_inside_wrap (GtkTextView *text_view, gint pixels_inside_wrap);
subroutine gtk_text_view_set_pixels_inside_wrap(text_view, pixels_inside_wrap) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text_view
  integer(c_int), value :: pixels_inside_wrap
end subroutine

! gint gtk_text_view_get_pixels_inside_wrap (GtkTextView *text_view);
function gtk_text_view_get_pixels_inside_wrap(text_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_view_get_pixels_inside_wrap
  type(c_ptr), value :: text_view
end function

! void gtk_text_view_set_justification (GtkTextView *text_view, GtkJustification justification);
subroutine gtk_text_view_set_justification(text_view, justification) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text_view
  integer(c_int), value :: justification
end subroutine

! GtkJustification gtk_text_view_get_justification (GtkTextView *text_view);
function gtk_text_view_get_justification(text_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_view_get_justification
  type(c_ptr), value :: text_view
end function

! void gtk_text_view_set_left_margin (GtkTextView *text_view, gint left_margin);
subroutine gtk_text_view_set_left_margin(text_view, left_margin) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text_view
  integer(c_int), value :: left_margin
end subroutine

! gint gtk_text_view_get_left_margin (GtkTextView *text_view);
function gtk_text_view_get_left_margin(text_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_view_get_left_margin
  type(c_ptr), value :: text_view
end function

! void gtk_text_view_set_right_margin (GtkTextView *text_view, gint right_margin);
subroutine gtk_text_view_set_right_margin(text_view, right_margin) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text_view
  integer(c_int), value :: right_margin
end subroutine

! gint gtk_text_view_get_right_margin (GtkTextView *text_view);
function gtk_text_view_get_right_margin(text_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_view_get_right_margin
  type(c_ptr), value :: text_view
end function

! void gtk_text_view_set_indent (GtkTextView *text_view, gint indent);
subroutine gtk_text_view_set_indent(text_view, indent) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: text_view
  integer(c_int), value :: indent
end subroutine

! gint gtk_text_view_get_indent (GtkTextView *text_view);
function gtk_text_view_get_indent(text_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_view_get_indent
  type(c_ptr), value :: text_view
end function

! void gtk_text_view_set_tabs (GtkTextView *text_view, PangoTabArray *tabs);
subroutine gtk_text_view_set_tabs(text_view, tabs) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: text_view
  type(c_ptr), value :: tabs
end subroutine

! PangoTabArray* gtk_text_view_get_tabs (GtkTextView *text_view);
function gtk_text_view_get_tabs(text_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_view_get_tabs
  type(c_ptr), value :: text_view
end function

!  GtkTextAttributes* gtk_text_view_get_default_attributes (GtkTextView *text_view);
function gtk_text_view_get_default_attributes(text_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_view_get_default_attributes
  type(c_ptr), value :: text_view
end function

!   GType gtk_entry_completion_get_type (void) G_GNUC_CONST;
function gtk_entry_completion_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_entry_completion_get_type
end function

! GtkEntryCompletion *gtk_entry_completion_new (void);
function gtk_entry_completion_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_entry_completion_new
end function

!  GtkWidget *gtk_entry_completion_get_entry (GtkEntryCompletion *completion);
function gtk_entry_completion_get_entry(completion) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_entry_completion_get_entry
  type(c_ptr), value :: completion
end function

!  void gtk_entry_completion_set_model (GtkEntryCompletion *completion, GtkTreeModel *model);
subroutine gtk_entry_completion_set_model(completion, model) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: completion
  type(c_ptr), value :: model
end subroutine

! GtkTreeModel *gtk_entry_completion_get_model (GtkEntryCompletion *completion);
function gtk_entry_completion_get_model(completion) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_entry_completion_get_model
  type(c_ptr), value :: completion
end function

!  void gtk_entry_completion_set_match_func (GtkEntryCompletion *completion, GtkEntryCompletionMatchFunc func, gpointer func_data, GDestroyNotify func_notify);
subroutine gtk_entry_completion_set_match_func(completion, func, func_data, func&
      &_notify) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: completion
  type(c_funptr), value :: func
  type(c_ptr), value :: func_data
  type(c_funptr), value :: func_notify
end subroutine

! void gtk_entry_completion_set_minimum_key_length (GtkEntryCompletion *completion, gint length);
subroutine gtk_entry_completion_set_minimum_key_length(completion, length) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: completion
  integer(c_int), value :: length
end subroutine

! gint gtk_entry_completion_get_minimum_key_length (GtkEntryCompletion *completion);
function gtk_entry_completion_get_minimum_key_length(completion) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_entry_completion_get_minimum_key_length
  type(c_ptr), value :: completion
end function

! void gtk_entry_completion_complete (GtkEntryCompletion *completion);
subroutine gtk_entry_completion_complete(completion) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: completion
end subroutine

! void gtk_entry_completion_insert_prefix (GtkEntryCompletion *completion);
subroutine gtk_entry_completion_insert_prefix(completion) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: completion
end subroutine

!  void gtk_entry_completion_insert_action_text (GtkEntryCompletion *completion, gint index_, const gchar *text);
subroutine gtk_entry_completion_insert_action_text(completion, index_, text) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: completion
  integer(c_int), value :: index_
  character(kind=c_char), dimension(*) :: text
end subroutine

! void gtk_entry_completion_insert_action_markup (GtkEntryCompletion *completion, gint index_, const gchar *markup);
subroutine gtk_entry_completion_insert_action_markup(completion, index_, markup)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: completion
  integer(c_int), value :: index_
  character(kind=c_char), dimension(*) :: markup
end subroutine

! void gtk_entry_completion_delete_action (GtkEntryCompletion *completion, gint index_);
subroutine gtk_entry_completion_delete_action(completion, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: completion
  integer(c_int), value :: index_
end subroutine

!  void gtk_entry_completion_set_inline_completion (GtkEntryCompletion *completion, gboolean inline_completion);
subroutine gtk_entry_completion_set_inline_completion(completion, inline_complet&
      &ion) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: completion
  logical(c_bool), value :: inline_completion
end subroutine

! gboolean gtk_entry_completion_get_inline_completion (GtkEntryCompletion *completion);
function gtk_entry_completion_get_inline_completion(completion) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_entry_completion_get_inline_completion
  type(c_ptr), value :: completion
end function

! void gtk_entry_completion_set_inline_selection (GtkEntryCompletion *completion, gboolean inline_selection);
subroutine gtk_entry_completion_set_inline_selection(completion, inline_selectio&
      &n) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: completion
  logical(c_bool), value :: inline_selection
end subroutine

! gboolean gtk_entry_completion_get_inline_selection (GtkEntryCompletion *completion);
function gtk_entry_completion_get_inline_selection(completion) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_entry_completion_get_inline_selection
  type(c_ptr), value :: completion
end function

! void gtk_entry_completion_set_popup_completion (GtkEntryCompletion *completion, gboolean popup_completion);
subroutine gtk_entry_completion_set_popup_completion(completion, popup_completio&
      &n) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: completion
  logical(c_bool), value :: popup_completion
end subroutine

! gboolean gtk_entry_completion_get_popup_completion (GtkEntryCompletion *completion);
function gtk_entry_completion_get_popup_completion(completion) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_entry_completion_get_popup_completion
  type(c_ptr), value :: completion
end function

! void gtk_entry_completion_set_popup_set_width (GtkEntryCompletion *completion, gboolean popup_set_width);
subroutine gtk_entry_completion_set_popup_set_width(completion, popup_set_width)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: completion
  logical(c_bool), value :: popup_set_width
end subroutine

! gboolean gtk_entry_completion_get_popup_set_width (GtkEntryCompletion *completion);
function gtk_entry_completion_get_popup_set_width(completion) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_entry_completion_get_popup_set_width
  type(c_ptr), value :: completion
end function

! void gtk_entry_completion_set_popup_single_match (GtkEntryCompletion *completion, gboolean popup_single_match);
subroutine gtk_entry_completion_set_popup_single_match(completion, popup_single_&
      &match) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: completion
  logical(c_bool), value :: popup_single_match
end subroutine

! gboolean gtk_entry_completion_get_popup_single_match (GtkEntryCompletion *completion);
function gtk_entry_completion_get_popup_single_match(completion) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_entry_completion_get_popup_single_match
  type(c_ptr), value :: completion
end function

!  const gchar *gtk_entry_completion_get_completion_prefix (GtkEntryCompletion *completion);
function gtk_entry_completion_get_completion_prefix(completion) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_entry_completion_get_completion_prefix
  type(c_ptr), value :: completion
end function

!  void gtk_entry_completion_set_text_column (GtkEntryCompletion *completion, gint column);
subroutine gtk_entry_completion_set_text_column(completion, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: completion
  integer(c_int), value :: column
end subroutine

! gint gtk_entry_completion_get_text_column (GtkEntryCompletion *completion);
function gtk_entry_completion_get_text_column(completion) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_entry_completion_get_text_column
  type(c_ptr), value :: completion
end function

!   GtkTextBuffer *gtk_text_iter_get_buffer (const GtkTextIter *iter);
function gtk_text_iter_get_buffer(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_iter_get_buffer
  type(c_ptr), value :: iter
end function

!  GtkTextIter *gtk_text_iter_copy (const GtkTextIter *iter);
function gtk_text_iter_copy(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_iter_copy
  type(c_ptr), value :: iter
end function

! void gtk_text_iter_free (GtkTextIter *iter);
subroutine gtk_text_iter_free(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
end subroutine

!  GType gtk_text_iter_get_type (void) G_GNUC_CONST;
function gtk_text_iter_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_text_iter_get_type
end function

!  gint gtk_text_iter_get_offset (const GtkTextIter *iter);
function gtk_text_iter_get_offset(iter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_iter_get_offset
  type(c_ptr), value :: iter
end function

! gint gtk_text_iter_get_line (const GtkTextIter *iter);
function gtk_text_iter_get_line(iter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_iter_get_line
  type(c_ptr), value :: iter
end function

! gint gtk_text_iter_get_line_offset (const GtkTextIter *iter);
function gtk_text_iter_get_line_offset(iter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_iter_get_line_offset
  type(c_ptr), value :: iter
end function

! gint gtk_text_iter_get_line_index (const GtkTextIter *iter);
function gtk_text_iter_get_line_index(iter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_iter_get_line_index
  type(c_ptr), value :: iter
end function

!  gint gtk_text_iter_get_visible_line_offset (const GtkTextIter *iter);
function gtk_text_iter_get_visible_line_offset(iter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_iter_get_visible_line_offset
  type(c_ptr), value :: iter
end function

! gint gtk_text_iter_get_visible_line_index (const GtkTextIter *iter);
function gtk_text_iter_get_visible_line_index(iter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_iter_get_visible_line_index
  type(c_ptr), value :: iter
end function

!  gunichar gtk_text_iter_get_char (const GtkTextIter *iter);
function gtk_text_iter_get_char(iter) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: gtk_text_iter_get_char
  type(c_ptr), value :: iter
end function

!  gchar *gtk_text_iter_get_slice (const GtkTextIter *start, const GtkTextIter *end);
function gtk_text_iter_get_slice(start, end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_iter_get_slice
  type(c_ptr), value :: start
  type(c_ptr), value :: end
end function

!  gchar *gtk_text_iter_get_text (const GtkTextIter *start, const GtkTextIter *end);
function gtk_text_iter_get_text(start, end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_iter_get_text
  type(c_ptr), value :: start
  type(c_ptr), value :: end
end function

!  gchar *gtk_text_iter_get_visible_slice (const GtkTextIter *start, const GtkTextIter *end);
function gtk_text_iter_get_visible_slice(start, end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_iter_get_visible_slice
  type(c_ptr), value :: start
  type(c_ptr), value :: end
end function

! gchar *gtk_text_iter_get_visible_text (const GtkTextIter *start, const GtkTextIter *end);
function gtk_text_iter_get_visible_text(start, end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_iter_get_visible_text
  type(c_ptr), value :: start
  type(c_ptr), value :: end
end function

!  GdkPixbuf* gtk_text_iter_get_pixbuf (const GtkTextIter *iter);
function gtk_text_iter_get_pixbuf(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_iter_get_pixbuf
  type(c_ptr), value :: iter
end function

! GSList * gtk_text_iter_get_marks (const GtkTextIter *iter);
function gtk_text_iter_get_marks(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_iter_get_marks
  type(c_ptr), value :: iter
end function

!  GtkTextChildAnchor* gtk_text_iter_get_child_anchor (const GtkTextIter *iter);
function gtk_text_iter_get_child_anchor(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_iter_get_child_anchor
  type(c_ptr), value :: iter
end function

!  GSList *gtk_text_iter_get_toggled_tags (const GtkTextIter *iter, gboolean toggled_on);
function gtk_text_iter_get_toggled_tags(iter, toggled_on) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: gtk_text_iter_get_toggled_tags
  type(c_ptr), value :: iter
  logical(c_bool), value :: toggled_on
end function

!  gboolean gtk_text_iter_begins_tag (const GtkTextIter *iter, GtkTextTag *tag);
function gtk_text_iter_begins_tag(iter, tag) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_begins_tag
  type(c_ptr), value :: iter
  type(c_ptr), value :: tag
end function

!  gboolean gtk_text_iter_ends_tag (const GtkTextIter *iter, GtkTextTag *tag);
function gtk_text_iter_ends_tag(iter, tag) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_ends_tag
  type(c_ptr), value :: iter
  type(c_ptr), value :: tag
end function

!  gboolean gtk_text_iter_toggles_tag (const GtkTextIter *iter, GtkTextTag *tag);
function gtk_text_iter_toggles_tag(iter, tag) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_toggles_tag
  type(c_ptr), value :: iter
  type(c_ptr), value :: tag
end function

!  gboolean gtk_text_iter_has_tag (const GtkTextIter *iter, GtkTextTag *tag);
function gtk_text_iter_has_tag(iter, tag) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_has_tag
  type(c_ptr), value :: iter
  type(c_ptr), value :: tag
end function

! GSList *gtk_text_iter_get_tags (const GtkTextIter *iter);
function gtk_text_iter_get_tags(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_iter_get_tags
  type(c_ptr), value :: iter
end function

!  gboolean gtk_text_iter_editable (const GtkTextIter *iter, gboolean default_setting);
function gtk_text_iter_editable(iter, default_setting) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_editable
  type(c_ptr), value :: iter
  logical(c_bool), value :: default_setting
end function

! gboolean gtk_text_iter_can_insert (const GtkTextIter *iter, gboolean default_editability);
function gtk_text_iter_can_insert(iter, default_editability) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_can_insert
  type(c_ptr), value :: iter
  logical(c_bool), value :: default_editability
end function

!  gboolean gtk_text_iter_starts_word (const GtkTextIter *iter);
function gtk_text_iter_starts_word(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_starts_word
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_ends_word (const GtkTextIter *iter);
function gtk_text_iter_ends_word(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_ends_word
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_inside_word (const GtkTextIter *iter);
function gtk_text_iter_inside_word(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_inside_word
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_starts_sentence (const GtkTextIter *iter);
function gtk_text_iter_starts_sentence(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_starts_sentence
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_ends_sentence (const GtkTextIter *iter);
function gtk_text_iter_ends_sentence(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_ends_sentence
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_inside_sentence (const GtkTextIter *iter);
function gtk_text_iter_inside_sentence(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_inside_sentence
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_starts_line (const GtkTextIter *iter);
function gtk_text_iter_starts_line(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_starts_line
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_ends_line (const GtkTextIter *iter);
function gtk_text_iter_ends_line(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_ends_line
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_is_cursor_position (const GtkTextIter *iter);
function gtk_text_iter_is_cursor_position(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_is_cursor_position
  type(c_ptr), value :: iter
end function

!  gint gtk_text_iter_get_chars_in_line (const GtkTextIter *iter);
function gtk_text_iter_get_chars_in_line(iter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_iter_get_chars_in_line
  type(c_ptr), value :: iter
end function

! gint gtk_text_iter_get_bytes_in_line (const GtkTextIter *iter);
function gtk_text_iter_get_bytes_in_line(iter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_iter_get_bytes_in_line
  type(c_ptr), value :: iter
end function

!  gboolean gtk_text_iter_get_attributes (const GtkTextIter *iter, GtkTextAttributes *values);
function gtk_text_iter_get_attributes(iter, values) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_get_attributes
  type(c_ptr), value :: iter
  type(c_ptr), value :: values
end function

! PangoLanguage* gtk_text_iter_get_language (const GtkTextIter *iter);
function gtk_text_iter_get_language(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_iter_get_language
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_is_end (const GtkTextIter *iter);
function gtk_text_iter_is_end(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_is_end
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_is_start (const GtkTextIter *iter);
function gtk_text_iter_is_start(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_is_start
  type(c_ptr), value :: iter
end function

!  gboolean gtk_text_iter_forward_char (GtkTextIter *iter);
function gtk_text_iter_forward_char(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_forward_char
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_backward_char (GtkTextIter *iter);
function gtk_text_iter_backward_char(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_backward_char
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_forward_chars (GtkTextIter *iter, gint count);
function gtk_text_iter_forward_chars(iter, count) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_iter_forward_chars
  type(c_ptr), value :: iter
  integer(c_int), value :: count
end function

! gboolean gtk_text_iter_backward_chars (GtkTextIter *iter, gint count);
function gtk_text_iter_backward_chars(iter, count) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_iter_backward_chars
  type(c_ptr), value :: iter
  integer(c_int), value :: count
end function

! gboolean gtk_text_iter_forward_line (GtkTextIter *iter);
function gtk_text_iter_forward_line(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_forward_line
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_backward_line (GtkTextIter *iter);
function gtk_text_iter_backward_line(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_backward_line
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_forward_lines (GtkTextIter *iter, gint count);
function gtk_text_iter_forward_lines(iter, count) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_iter_forward_lines
  type(c_ptr), value :: iter
  integer(c_int), value :: count
end function

! gboolean gtk_text_iter_backward_lines (GtkTextIter *iter, gint count);
function gtk_text_iter_backward_lines(iter, count) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_iter_backward_lines
  type(c_ptr), value :: iter
  integer(c_int), value :: count
end function

! gboolean gtk_text_iter_forward_word_end (GtkTextIter *iter);
function gtk_text_iter_forward_word_end(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_forward_word_end
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_backward_word_start (GtkTextIter *iter);
function gtk_text_iter_backward_word_start(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_backward_word_start
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_forward_word_ends (GtkTextIter *iter, gint count);
function gtk_text_iter_forward_word_ends(iter, count) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_iter_forward_word_ends
  type(c_ptr), value :: iter
  integer(c_int), value :: count
end function

! gboolean gtk_text_iter_backward_word_starts (GtkTextIter *iter, gint count);
function gtk_text_iter_backward_word_starts(iter, count) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_iter_backward_word_starts
  type(c_ptr), value :: iter
  integer(c_int), value :: count
end function

!  gboolean gtk_text_iter_forward_visible_line (GtkTextIter *iter);
function gtk_text_iter_forward_visible_line(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_forward_visible_line
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_backward_visible_line (GtkTextIter *iter);
function gtk_text_iter_backward_visible_line(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_backward_visible_line
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_forward_visible_lines (GtkTextIter *iter, gint count);
function gtk_text_iter_forward_visible_lines(iter, count) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_iter_forward_visible_lines
  type(c_ptr), value :: iter
  integer(c_int), value :: count
end function

! gboolean gtk_text_iter_backward_visible_lines (GtkTextIter *iter, gint count);
function gtk_text_iter_backward_visible_lines(iter, count) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_iter_backward_visible_lines
  type(c_ptr), value :: iter
  integer(c_int), value :: count
end function

!  gboolean gtk_text_iter_forward_visible_word_end (GtkTextIter *iter);
function gtk_text_iter_forward_visible_word_end(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_forward_visible_word_end
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_backward_visible_word_start (GtkTextIter *iter);
function gtk_text_iter_backward_visible_word_start(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_backward_visible_word_start
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_forward_visible_word_ends (GtkTextIter *iter, gint count);
function gtk_text_iter_forward_visible_word_ends(iter, count) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_iter_forward_visible_word_ends
  type(c_ptr), value :: iter
  integer(c_int), value :: count
end function

! gboolean gtk_text_iter_backward_visible_word_starts (GtkTextIter *iter, gint count);
function gtk_text_iter_backward_visible_word_starts(iter, count) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_iter_backward_visible_word_starts
  type(c_ptr), value :: iter
  integer(c_int), value :: count
end function

!  gboolean gtk_text_iter_forward_sentence_end (GtkTextIter *iter);
function gtk_text_iter_forward_sentence_end(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_forward_sentence_end
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_backward_sentence_start (GtkTextIter *iter);
function gtk_text_iter_backward_sentence_start(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_backward_sentence_start
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_forward_sentence_ends (GtkTextIter *iter, gint count);
function gtk_text_iter_forward_sentence_ends(iter, count) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_iter_forward_sentence_ends
  type(c_ptr), value :: iter
  integer(c_int), value :: count
end function

! gboolean gtk_text_iter_backward_sentence_starts (GtkTextIter *iter, gint count);
function gtk_text_iter_backward_sentence_starts(iter, count) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_iter_backward_sentence_starts
  type(c_ptr), value :: iter
  integer(c_int), value :: count
end function

!  gboolean gtk_text_iter_forward_cursor_position (GtkTextIter *iter);
function gtk_text_iter_forward_cursor_position(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_forward_cursor_position
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_backward_cursor_position (GtkTextIter *iter);
function gtk_text_iter_backward_cursor_position(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_backward_cursor_position
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_forward_cursor_positions (GtkTextIter *iter, gint count);
function gtk_text_iter_forward_cursor_positions(iter, count) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_iter_forward_cursor_positions
  type(c_ptr), value :: iter
  integer(c_int), value :: count
end function

! gboolean gtk_text_iter_backward_cursor_positions (GtkTextIter *iter, gint count);
function gtk_text_iter_backward_cursor_positions(iter, count) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_iter_backward_cursor_positions
  type(c_ptr), value :: iter
  integer(c_int), value :: count
end function

!  gboolean gtk_text_iter_forward_visible_cursor_position (GtkTextIter *iter);
function gtk_text_iter_forward_visible_cursor_position(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_forward_visible_cursor_position
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_backward_visible_cursor_position (GtkTextIter *iter);
function gtk_text_iter_backward_visible_cursor_position(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_backward_visible_cursor_position
  type(c_ptr), value :: iter
end function

! gboolean gtk_text_iter_forward_visible_cursor_positions (GtkTextIter *iter, gint count);
function gtk_text_iter_forward_visible_cursor_positions(iter, count) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_iter_forward_visible_cursor_positions
  type(c_ptr), value :: iter
  integer(c_int), value :: count
end function

! gboolean gtk_text_iter_backward_visible_cursor_positions (GtkTextIter *iter, gint count);
function gtk_text_iter_backward_visible_cursor_positions(iter, count) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_text_iter_backward_visible_cursor_positions
  type(c_ptr), value :: iter
  integer(c_int), value :: count
end function

!  void gtk_text_iter_set_offset (GtkTextIter *iter, gint char_offset);
subroutine gtk_text_iter_set_offset(iter, char_offset) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: iter
  integer(c_int), value :: char_offset
end subroutine

! void gtk_text_iter_set_line (GtkTextIter *iter, gint line_number);
subroutine gtk_text_iter_set_line(iter, line_number) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: iter
  integer(c_int), value :: line_number
end subroutine

! void gtk_text_iter_set_line_offset (GtkTextIter *iter, gint char_on_line);
subroutine gtk_text_iter_set_line_offset(iter, char_on_line) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: iter
  integer(c_int), value :: char_on_line
end subroutine

! void gtk_text_iter_set_line_index (GtkTextIter *iter, gint byte_on_line);
subroutine gtk_text_iter_set_line_index(iter, byte_on_line) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: iter
  integer(c_int), value :: byte_on_line
end subroutine

! void gtk_text_iter_forward_to_end (GtkTextIter *iter);
subroutine gtk_text_iter_forward_to_end(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
end subroutine

! gboolean gtk_text_iter_forward_to_line_end (GtkTextIter *iter);
function gtk_text_iter_forward_to_line_end(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_forward_to_line_end
  type(c_ptr), value :: iter
end function

!  void gtk_text_iter_set_visible_line_offset (GtkTextIter *iter, gint char_on_line);
subroutine gtk_text_iter_set_visible_line_offset(iter, char_on_line) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: iter
  integer(c_int), value :: char_on_line
end subroutine

! void gtk_text_iter_set_visible_line_index (GtkTextIter *iter, gint byte_on_line);
subroutine gtk_text_iter_set_visible_line_index(iter, byte_on_line) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: iter
  integer(c_int), value :: byte_on_line
end subroutine

!  gboolean gtk_text_iter_forward_to_tag_toggle (GtkTextIter *iter, GtkTextTag *tag);
function gtk_text_iter_forward_to_tag_toggle(iter, tag) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_forward_to_tag_toggle
  type(c_ptr), value :: iter
  type(c_ptr), value :: tag
end function

!  gboolean gtk_text_iter_backward_to_tag_toggle (GtkTextIter *iter, GtkTextTag *tag);
function gtk_text_iter_backward_to_tag_toggle(iter, tag) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_backward_to_tag_toggle
  type(c_ptr), value :: iter
  type(c_ptr), value :: tag
end function

!  gboolean gtk_text_iter_forward_find_char (GtkTextIter *iter, GtkTextCharPredicate pred, gpointer user_data, const GtkTextIter *limit);
function gtk_text_iter_forward_find_char(iter, pred, user_data, limit) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_funptr
  logical(c_bool) :: gtk_text_iter_forward_find_char
  type(c_ptr), value :: iter
  type(c_funptr), value :: pred
  type(c_ptr), value :: user_data
  type(c_ptr), value :: limit
end function

! gboolean gtk_text_iter_backward_find_char (GtkTextIter *iter, GtkTextCharPredicate pred, gpointer user_data, const GtkTextIter *limit);
function gtk_text_iter_backward_find_char(iter, pred, user_data, limit) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_funptr
  logical(c_bool) :: gtk_text_iter_backward_find_char
  type(c_ptr), value :: iter
  type(c_funptr), value :: pred
  type(c_ptr), value :: user_data
  type(c_ptr), value :: limit
end function

!  gboolean gtk_text_iter_forward_search (const GtkTextIter *iter, const gchar *str, GtkTextSearchFlags flags, GtkTextIter *match_start, GtkTextIter *match_end, const GtkTextIter *limit);
function gtk_text_iter_forward_search(iter, str, flags, match_start, match_end, &
      &limit) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: gtk_text_iter_forward_search
  type(c_ptr), value :: iter
  character(kind=c_char), dimension(*) :: str
  integer(c_int), value :: flags
  type(c_ptr), value :: match_start
  type(c_ptr), value :: match_end
  type(c_ptr), value :: limit
end function

!  gboolean gtk_text_iter_backward_search (const GtkTextIter *iter, const gchar *str, GtkTextSearchFlags flags, GtkTextIter *match_start, GtkTextIter *match_end, const GtkTextIter *limit);
function gtk_text_iter_backward_search(iter, str, flags, match_start, match_end,&
      & limit) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: gtk_text_iter_backward_search
  type(c_ptr), value :: iter
  character(kind=c_char), dimension(*) :: str
  integer(c_int), value :: flags
  type(c_ptr), value :: match_start
  type(c_ptr), value :: match_end
  type(c_ptr), value :: limit
end function

!  gboolean gtk_text_iter_equal (const GtkTextIter *lhs, const GtkTextIter *rhs);
function gtk_text_iter_equal(lhs, rhs) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_equal
  type(c_ptr), value :: lhs
  type(c_ptr), value :: rhs
end function

! gint gtk_text_iter_compare (const GtkTextIter *lhs, const GtkTextIter *rhs);
function gtk_text_iter_compare(lhs, rhs) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_iter_compare
  type(c_ptr), value :: lhs
  type(c_ptr), value :: rhs
end function

! gboolean gtk_text_iter_in_range (const GtkTextIter *iter, const GtkTextIter *start, const GtkTextIter *end);
function gtk_text_iter_in_range(iter, start, end) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_iter_in_range
  type(c_ptr), value :: iter
  type(c_ptr), value :: start
  type(c_ptr), value :: end
end function

!  void gtk_text_iter_order (GtkTextIter *first, GtkTextIter *second);
subroutine gtk_text_iter_order(first, second) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: first
  type(c_ptr), value :: second
end subroutine

!   GType gtk_tree_drag_source_get_type (void) G_GNUC_CONST;
function gtk_tree_drag_source_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_drag_source_get_type
end function

!  gboolean gtk_tree_drag_source_row_draggable (GtkTreeDragSource *drag_source, GtkTreePath *path);
function gtk_tree_drag_source_row_draggable(drag_source, path) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_drag_source_row_draggable
  type(c_ptr), value :: drag_source
  type(c_ptr), value :: path
end function

!  gboolean gtk_tree_drag_source_drag_data_delete (GtkTreeDragSource *drag_source, GtkTreePath *path);
function gtk_tree_drag_source_drag_data_delete(drag_source, path) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_drag_source_drag_data_delete
  type(c_ptr), value :: drag_source
  type(c_ptr), value :: path
end function

!  gboolean gtk_tree_drag_source_drag_data_get (GtkTreeDragSource *drag_source, GtkTreePath *path, GtkSelectionData *selection_data);
function gtk_tree_drag_source_drag_data_get(drag_source, path, selection_data) b&
      &ind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_drag_source_drag_data_get
  type(c_ptr), value :: drag_source
  type(c_ptr), value :: path
  type(c_ptr), value :: selection_data
end function

!  GType gtk_tree_drag_dest_get_type (void) G_GNUC_CONST;
function gtk_tree_drag_dest_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_drag_dest_get_type
end function

!  gboolean gtk_tree_drag_dest_drag_data_received (GtkTreeDragDest *drag_dest, GtkTreePath *dest, GtkSelectionData *selection_data);
function gtk_tree_drag_dest_drag_data_received(drag_dest, dest, selection_data) &
      &bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_drag_dest_drag_data_received
  type(c_ptr), value :: drag_dest
  type(c_ptr), value :: dest
  type(c_ptr), value :: selection_data
end function

!  gboolean gtk_tree_drag_dest_row_drop_possible (GtkTreeDragDest *drag_dest, GtkTreePath *dest_path, GtkSelectionData *selection_data);
function gtk_tree_drag_dest_row_drop_possible(drag_dest, dest_path, selection_da&
      &ta) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_drag_dest_row_drop_possible
  type(c_ptr), value :: drag_dest
  type(c_ptr), value :: dest_path
  type(c_ptr), value :: selection_data
end function

!  gboolean gtk_tree_set_row_drag_data (GtkSelectionData *selection_data, GtkTreeModel *tree_model, GtkTreePath *path);
function gtk_tree_set_row_drag_data(selection_data, tree_model, path) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_set_row_drag_data
  type(c_ptr), value :: selection_data
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: path
end function

! gboolean gtk_tree_get_row_drag_data (GtkSelectionData *selection_data, GtkTreeModel **tree_model, GtkTreePath **path);
function gtk_tree_get_row_drag_data(selection_data, tree_model, path) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_get_row_drag_data
  type(c_ptr), value :: selection_data
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: path
end function

!   GType ubuntu_menu_proxy_get_type (void) G_GNUC_CONST;
function ubuntu_menu_proxy_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: ubuntu_menu_proxy_get_type
end function

! UbuntuMenuProxy* ubuntu_menu_proxy_get (void);
function ubuntu_menu_proxy_get() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: ubuntu_menu_proxy_get
end function

! void ubuntu_menu_proxy_insert (UbuntuMenuProxy *proxy, GtkWidget *parent, GtkWidget *child, guint position);
subroutine ubuntu_menu_proxy_insert(proxy, parent, child, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: proxy
  type(c_ptr), value :: parent
  type(c_ptr), value :: child
  integer(c_int), value :: position
end subroutine

! gboolean ubuntu_menu_proxy_show_local (UbuntuMenuProxy *proxy);
function ubuntu_menu_proxy_show_local(proxy) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: ubuntu_menu_proxy_show_local
  type(c_ptr), value :: proxy
end function

! void ubuntu_menu_proxy_activate_menu (UbuntuMenuProxy *proxy, GtkWidget *widget);
subroutine ubuntu_menu_proxy_activate_menu(proxy, widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: proxy
  type(c_ptr), value :: widget
end subroutine

!   GType gtk_tree_selection_get_type (void) G_GNUC_CONST;
function gtk_tree_selection_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_selection_get_type
end function

!  void gtk_tree_selection_set_mode (GtkTreeSelection *selection, GtkSelectionMode type);
subroutine gtk_tree_selection_set_mode(selection, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: selection
  integer(c_int), value :: type
end subroutine

! GtkSelectionMode gtk_tree_selection_get_mode (GtkTreeSelection *selection);
function gtk_tree_selection_get_mode(selection) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_selection_get_mode
  type(c_ptr), value :: selection
end function

! void gtk_tree_selection_set_select_function (GtkTreeSelection *selection, GtkTreeSelectionFunc func, gpointer data, GDestroyNotify destroy);
subroutine gtk_tree_selection_set_select_function(selection, func, data, destroy&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: selection
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

! gpointer gtk_tree_selection_get_user_data (GtkTreeSelection *selection);
function gtk_tree_selection_get_user_data(selection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_selection_get_user_data
  type(c_ptr), value :: selection
end function

! GtkTreeView* gtk_tree_selection_get_tree_view (GtkTreeSelection *selection);
function gtk_tree_selection_get_tree_view(selection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_selection_get_tree_view
  type(c_ptr), value :: selection
end function

!  GtkTreeSelectionFunc gtk_tree_selection_get_select_function (GtkTreeSelection *selection);
function gtk_tree_selection_get_select_function(selection) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr) :: gtk_tree_selection_get_select_function
  type(c_ptr), value :: selection
end function

!  gboolean gtk_tree_selection_get_selected (GtkTreeSelection *selection, GtkTreeModel **model, GtkTreeIter *iter);
function gtk_tree_selection_get_selected(selection, model, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_selection_get_selected
  type(c_ptr), value :: selection
  type(c_ptr), value :: model
  type(c_ptr), value :: iter
end function

! GList * gtk_tree_selection_get_selected_rows (GtkTreeSelection *selection, GtkTreeModel **model);
function gtk_tree_selection_get_selected_rows(selection, model) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_selection_get_selected_rows
  type(c_ptr), value :: selection
  type(c_ptr), value :: model
end function

! gint gtk_tree_selection_count_selected_rows (GtkTreeSelection *selection);
function gtk_tree_selection_count_selected_rows(selection) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_selection_count_selected_rows
  type(c_ptr), value :: selection
end function

! void gtk_tree_selection_selected_foreach (GtkTreeSelection *selection, GtkTreeSelectionForeachFunc func, gpointer data);
subroutine gtk_tree_selection_selected_foreach(selection, func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: selection
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end subroutine

! void gtk_tree_selection_select_path (GtkTreeSelection *selection, GtkTreePath *path);
subroutine gtk_tree_selection_select_path(selection, path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: selection
  type(c_ptr), value :: path
end subroutine

! void gtk_tree_selection_unselect_path (GtkTreeSelection *selection, GtkTreePath *path);
subroutine gtk_tree_selection_unselect_path(selection, path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: selection
  type(c_ptr), value :: path
end subroutine

! void gtk_tree_selection_select_iter (GtkTreeSelection *selection, GtkTreeIter *iter);
subroutine gtk_tree_selection_select_iter(selection, iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: selection
  type(c_ptr), value :: iter
end subroutine

! void gtk_tree_selection_unselect_iter (GtkTreeSelection *selection, GtkTreeIter *iter);
subroutine gtk_tree_selection_unselect_iter(selection, iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: selection
  type(c_ptr), value :: iter
end subroutine

! gboolean gtk_tree_selection_path_is_selected (GtkTreeSelection *selection, GtkTreePath *path);
function gtk_tree_selection_path_is_selected(selection, path) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_selection_path_is_selected
  type(c_ptr), value :: selection
  type(c_ptr), value :: path
end function

! gboolean gtk_tree_selection_iter_is_selected (GtkTreeSelection *selection, GtkTreeIter *iter);
function gtk_tree_selection_iter_is_selected(selection, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_selection_iter_is_selected
  type(c_ptr), value :: selection
  type(c_ptr), value :: iter
end function

! void gtk_tree_selection_select_all (GtkTreeSelection *selection);
subroutine gtk_tree_selection_select_all(selection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: selection
end subroutine

! void gtk_tree_selection_unselect_all (GtkTreeSelection *selection);
subroutine gtk_tree_selection_unselect_all(selection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: selection
end subroutine

! void gtk_tree_selection_select_range (GtkTreeSelection *selection, GtkTreePath *start_path, GtkTreePath *end_path);
subroutine gtk_tree_selection_select_range(selection, start_path, end_path) bind&
      &(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: selection
  type(c_ptr), value :: start_path
  type(c_ptr), value :: end_path
end subroutine

! void gtk_tree_selection_unselect_range (GtkTreeSelection *selection, GtkTreePath *start_path, GtkTreePath *end_path);
subroutine gtk_tree_selection_unselect_range(selection, start_path, end_path) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: selection
  type(c_ptr), value :: start_path
  type(c_ptr), value :: end_path
end subroutine

!   GQuark gtk_icon_theme_error_quark (void);
function gtk_icon_theme_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: gtk_icon_theme_error_quark
end function

!  GType gtk_icon_theme_get_type (void) G_GNUC_CONST;
function gtk_icon_theme_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_icon_theme_get_type
end function

!  GtkIconTheme *gtk_icon_theme_new (void);
function gtk_icon_theme_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_theme_new
end function

! GtkIconTheme *gtk_icon_theme_get_default (void);
function gtk_icon_theme_get_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_theme_get_default
end function

! GtkIconTheme *gtk_icon_theme_get_for_screen (GdkScreen *screen);
function gtk_icon_theme_get_for_screen(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_theme_get_for_screen
  type(c_ptr), value :: screen
end function

! void gtk_icon_theme_set_screen (GtkIconTheme *icon_theme, GdkScreen *screen);
subroutine gtk_icon_theme_set_screen(icon_theme, screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: icon_theme
  type(c_ptr), value :: screen
end subroutine

!  void gtk_icon_theme_set_search_path (GtkIconTheme *icon_theme, const gchar *path[], gint n_elements);
subroutine gtk_icon_theme_set_search_path(icon_theme, path, n_elements) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: icon_theme
  character(kind=c_char), dimension(*) :: path
  integer(c_int), value :: n_elements
end subroutine

! void gtk_icon_theme_get_search_path (GtkIconTheme *icon_theme, gchar **path[], gint *n_elements);
subroutine gtk_icon_theme_get_search_path(icon_theme, path, n_elements) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: icon_theme
  character(kind=c_char), dimension(*) :: path
  type(c_ptr), value :: n_elements
end subroutine

! void gtk_icon_theme_append_search_path (GtkIconTheme *icon_theme, const gchar *path);
subroutine gtk_icon_theme_append_search_path(icon_theme, path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: icon_theme
  character(kind=c_char), dimension(*) :: path
end subroutine

! void gtk_icon_theme_prepend_search_path (GtkIconTheme *icon_theme, const gchar *path);
subroutine gtk_icon_theme_prepend_search_path(icon_theme, path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: icon_theme
  character(kind=c_char), dimension(*) :: path
end subroutine

!  void gtk_icon_theme_set_custom_theme (GtkIconTheme *icon_theme, const gchar *theme_name);
subroutine gtk_icon_theme_set_custom_theme(icon_theme, theme_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: icon_theme
  character(kind=c_char), dimension(*) :: theme_name
end subroutine

!  gboolean gtk_icon_theme_has_icon (GtkIconTheme *icon_theme, const gchar *icon_name);
function gtk_icon_theme_has_icon(icon_theme, icon_name) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_icon_theme_has_icon
  type(c_ptr), value :: icon_theme
  character(kind=c_char), dimension(*) :: icon_name
end function

! gint *gtk_icon_theme_get_icon_sizes (GtkIconTheme *icon_theme, const gchar *icon_name);
function gtk_icon_theme_get_icon_sizes(icon_theme, icon_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_icon_theme_get_icon_sizes
  type(c_ptr), value :: icon_theme
  character(kind=c_char), dimension(*) :: icon_name
end function

! GtkIconInfo * gtk_icon_theme_lookup_icon (GtkIconTheme *icon_theme, const gchar *icon_name, gint size, GtkIconLookupFlags flags);
function gtk_icon_theme_lookup_icon(icon_theme, icon_name, size, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: gtk_icon_theme_lookup_icon
  type(c_ptr), value :: icon_theme
  character(kind=c_char), dimension(*) :: icon_name
  integer(c_int), value :: size
  integer(c_int), value :: flags
end function

! GtkIconInfo * gtk_icon_theme_choose_icon (GtkIconTheme *icon_theme, const gchar *icon_names[], gint size, GtkIconLookupFlags flags);
function gtk_icon_theme_choose_icon(icon_theme, icon_names, size, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: gtk_icon_theme_choose_icon
  type(c_ptr), value :: icon_theme
  character(kind=c_char), dimension(*) :: icon_names
  integer(c_int), value :: size
  integer(c_int), value :: flags
end function

! GdkPixbuf * gtk_icon_theme_load_icon (GtkIconTheme *icon_theme, const gchar *icon_name, gint size, GtkIconLookupFlags flags, GError **error);
function gtk_icon_theme_load_icon(icon_theme, icon_name, size, flags, error) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: gtk_icon_theme_load_icon
  type(c_ptr), value :: icon_theme
  character(kind=c_char), dimension(*) :: icon_name
  integer(c_int), value :: size
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

!  GtkIconInfo * gtk_icon_theme_lookup_by_gicon (GtkIconTheme *icon_theme, GIcon *icon, gint size, GtkIconLookupFlags flags);
function gtk_icon_theme_lookup_by_gicon(icon_theme, icon, size, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_icon_theme_lookup_by_gicon
  type(c_ptr), value :: icon_theme
  type(c_ptr), value :: icon
  integer(c_int), value :: size
  integer(c_int), value :: flags
end function

!  GList * gtk_icon_theme_list_icons (GtkIconTheme *icon_theme, const gchar *context);
function gtk_icon_theme_list_icons(icon_theme, context) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_icon_theme_list_icons
  type(c_ptr), value :: icon_theme
  character(kind=c_char), dimension(*) :: context
end function

! GList * gtk_icon_theme_list_contexts (GtkIconTheme *icon_theme);
function gtk_icon_theme_list_contexts(icon_theme) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_theme_list_contexts
  type(c_ptr), value :: icon_theme
end function

! char * gtk_icon_theme_get_example_icon_name (GtkIconTheme *icon_theme);
function gtk_icon_theme_get_example_icon_name(icon_theme) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_theme_get_example_icon_name
  type(c_ptr), value :: icon_theme
end function

!  gboolean gtk_icon_theme_rescan_if_needed (GtkIconTheme *icon_theme);
function gtk_icon_theme_rescan_if_needed(icon_theme) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_icon_theme_rescan_if_needed
  type(c_ptr), value :: icon_theme
end function

!  void gtk_icon_theme_add_builtin_icon (const gchar *icon_name, gint size, GdkPixbuf *pixbuf);
subroutine gtk_icon_theme_add_builtin_icon(icon_name, size, pixbuf) bind(c) 
  use iso_c_binding, only: c_char, c_int, c_ptr
  character(kind=c_char), dimension(*) :: icon_name
  integer(c_int), value :: size
  type(c_ptr), value :: pixbuf
end subroutine

!  GType gtk_icon_info_get_type (void) G_GNUC_CONST;
function gtk_icon_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_icon_info_get_type
end function

! GtkIconInfo * gtk_icon_info_copy (GtkIconInfo *icon_info);
function gtk_icon_info_copy(icon_info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_info_copy
  type(c_ptr), value :: icon_info
end function

! void gtk_icon_info_free (GtkIconInfo *icon_info);
subroutine gtk_icon_info_free(icon_info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: icon_info
end subroutine

!  GtkIconInfo * gtk_icon_info_new_for_pixbuf (GtkIconTheme *icon_theme, GdkPixbuf *pixbuf);
function gtk_icon_info_new_for_pixbuf(icon_theme, pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_info_new_for_pixbuf
  type(c_ptr), value :: icon_theme
  type(c_ptr), value :: pixbuf
end function

!  gint gtk_icon_info_get_base_size (GtkIconInfo *icon_info);
function gtk_icon_info_get_base_size(icon_info) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_info_get_base_size
  type(c_ptr), value :: icon_info
end function

! G_CONST_RETURN gchar *gtk_icon_info_get_filename (GtkIconInfo *icon_info);
function gtk_icon_info_get_filename(icon_info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_info_get_filename
  type(c_ptr), value :: icon_info
end function

! GdkPixbuf * gtk_icon_info_get_builtin_pixbuf (GtkIconInfo *icon_info);
function gtk_icon_info_get_builtin_pixbuf(icon_info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_info_get_builtin_pixbuf
  type(c_ptr), value :: icon_info
end function

! GdkPixbuf * gtk_icon_info_load_icon (GtkIconInfo *icon_info, GError **error);
function gtk_icon_info_load_icon(icon_info, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_info_load_icon
  type(c_ptr), value :: icon_info
  type(c_ptr), value :: error
end function

! void gtk_icon_info_set_raw_coordinates (GtkIconInfo *icon_info, gboolean raw_coordinates);
subroutine gtk_icon_info_set_raw_coordinates(icon_info, raw_coordinates) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: icon_info
  logical(c_bool), value :: raw_coordinates
end subroutine

!  gboolean gtk_icon_info_get_embedded_rect (GtkIconInfo *icon_info, GdkRectangle *rectangle);
function gtk_icon_info_get_embedded_rect(icon_info, rectangle) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_icon_info_get_embedded_rect
  type(c_ptr), value :: icon_info
  type(c_ptr), value :: rectangle
end function

! gboolean gtk_icon_info_get_attach_points (GtkIconInfo *icon_info, GdkPoint **points, gint *n_points);
function gtk_icon_info_get_attach_points(icon_info, points, n_points) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_icon_info_get_attach_points
  type(c_ptr), value :: icon_info
  type(c_ptr), value :: points
  type(c_ptr), value :: n_points
end function

! G_CONST_RETURN gchar *gtk_icon_info_get_display_name (GtkIconInfo *icon_info);
function gtk_icon_info_get_display_name(icon_info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_info_get_display_name
  type(c_ptr), value :: icon_info
end function

!   GType gtk_cell_renderer_pixbuf_get_type (void) G_GNUC_CONST;
function gtk_cell_renderer_pixbuf_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_cell_renderer_pixbuf_get_type
end function

! GtkCellRenderer *gtk_cell_renderer_pixbuf_new (void);
function gtk_cell_renderer_pixbuf_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_cell_renderer_pixbuf_new
end function

!   GtkTargetList *gtk_target_list_new (const GtkTargetEntry *targets, guint ntargets);
function gtk_target_list_new(targets, ntargets) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_target_list_new
  type(c_ptr), value :: targets
  integer(c_int), value :: ntargets
end function

! GtkTargetList *gtk_target_list_ref (GtkTargetList *list);
function gtk_target_list_ref(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_target_list_ref
  type(c_ptr), value :: list
end function

! void gtk_target_list_unref (GtkTargetList *list);
subroutine gtk_target_list_unref(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

! void gtk_target_list_add (GtkTargetList *list, GdkAtom target, guint flags, guint info);
subroutine gtk_target_list_add(list, target, flags, info) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: list
  type(c_ptr), value :: target
  integer(c_int), value :: flags
  integer(c_int), value :: info
end subroutine

! void gtk_target_list_add_text_targets (GtkTargetList *list, guint info);
subroutine gtk_target_list_add_text_targets(list, info) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: list
  integer(c_int), value :: info
end subroutine

! void gtk_target_list_add_rich_text_targets (GtkTargetList *list, guint info, gboolean deserializable, GtkTextBuffer *buffer);
subroutine gtk_target_list_add_rich_text_targets(list, info, deserializable, buf&
      &fer) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr), value :: list
  integer(c_int), value :: info
  logical(c_bool), value :: deserializable
  type(c_ptr), value :: buffer
end subroutine

! void gtk_target_list_add_image_targets (GtkTargetList *list, guint info, gboolean writable);
subroutine gtk_target_list_add_image_targets(list, info, writable) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr), value :: list
  integer(c_int), value :: info
  logical(c_bool), value :: writable
end subroutine

! void gtk_target_list_add_uri_targets (GtkTargetList *list, guint info);
subroutine gtk_target_list_add_uri_targets(list, info) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: list
  integer(c_int), value :: info
end subroutine

! void gtk_target_list_add_table (GtkTargetList *list, const GtkTargetEntry *targets, guint ntargets);
subroutine gtk_target_list_add_table(list, targets, ntargets) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: list
  type(c_ptr), value :: targets
  integer(c_int), value :: ntargets
end subroutine

! void gtk_target_list_remove (GtkTargetList *list, GdkAtom target);
subroutine gtk_target_list_remove(list, target) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
  type(c_ptr), value :: target
end subroutine

! gboolean gtk_target_list_find (GtkTargetList *list, GdkAtom target, guint *info);
function gtk_target_list_find(list, target, info) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_target_list_find
  type(c_ptr), value :: list
  type(c_ptr), value :: target
  type(c_ptr), value :: info
end function

!  GtkTargetEntry * gtk_target_table_new_from_list (GtkTargetList *list, gint *n_targets);
function gtk_target_table_new_from_list(list, n_targets) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_target_table_new_from_list
  type(c_ptr), value :: list
  type(c_ptr), value :: n_targets
end function

! void gtk_target_table_free (GtkTargetEntry *targets, gint n_targets);
subroutine gtk_target_table_free(targets, n_targets) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: targets
  integer(c_int), value :: n_targets
end subroutine

!  gboolean gtk_selection_owner_set (GtkWidget *widget, GdkAtom selection, guint32 time_);
function gtk_selection_owner_set(widget, selection, time_) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int32_t
  logical(c_bool) :: gtk_selection_owner_set
  type(c_ptr), value :: widget
  type(c_ptr), value :: selection
  integer(c_int32_t), value :: time_
end function

! gboolean gtk_selection_owner_set_for_display (GdkDisplay *display, GtkWidget *widget, GdkAtom selection, guint32 time_);
function gtk_selection_owner_set_for_display(display, widget, selection, time_) &
      &bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int32_t
  logical(c_bool) :: gtk_selection_owner_set_for_display
  type(c_ptr), value :: display
  type(c_ptr), value :: widget
  type(c_ptr), value :: selection
  integer(c_int32_t), value :: time_
end function

!  void gtk_selection_add_target (GtkWidget *widget, GdkAtom selection, GdkAtom target, guint info);
subroutine gtk_selection_add_target(widget, selection, target, info) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  type(c_ptr), value :: selection
  type(c_ptr), value :: target
  integer(c_int), value :: info
end subroutine

! void gtk_selection_add_targets (GtkWidget *widget, GdkAtom selection, const GtkTargetEntry *targets, guint ntargets);
subroutine gtk_selection_add_targets(widget, selection, targets, ntargets) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  type(c_ptr), value :: selection
  type(c_ptr), value :: targets
  integer(c_int), value :: ntargets
end subroutine

! void gtk_selection_clear_targets (GtkWidget *widget, GdkAtom selection);
subroutine gtk_selection_clear_targets(widget, selection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: selection
end subroutine

! gboolean gtk_selection_convert (GtkWidget *widget, GdkAtom selection, GdkAtom target, guint32 time_);
function gtk_selection_convert(widget, selection, target, time_) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int32_t
  logical(c_bool) :: gtk_selection_convert
  type(c_ptr), value :: widget
  type(c_ptr), value :: selection
  type(c_ptr), value :: target
  integer(c_int32_t), value :: time_
end function

!  GdkAtom gtk_selection_data_get_selection (GtkSelectionData *selection_data);
function gtk_selection_data_get_selection(selection_data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_selection_data_get_selection
  type(c_ptr), value :: selection_data
end function

! GdkAtom gtk_selection_data_get_target (GtkSelectionData *selection_data);
function gtk_selection_data_get_target(selection_data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_selection_data_get_target
  type(c_ptr), value :: selection_data
end function

! GdkAtom gtk_selection_data_get_data_type (GtkSelectionData *selection_data);
function gtk_selection_data_get_data_type(selection_data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_selection_data_get_data_type
  type(c_ptr), value :: selection_data
end function

! gint gtk_selection_data_get_format (GtkSelectionData *selection_data);
function gtk_selection_data_get_format(selection_data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_selection_data_get_format
  type(c_ptr), value :: selection_data
end function

! const guchar *gtk_selection_data_get_data (GtkSelectionData *selection_data);
function gtk_selection_data_get_data(selection_data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_selection_data_get_data
  type(c_ptr), value :: selection_data
end function

! gint gtk_selection_data_get_length (GtkSelectionData *selection_data);
function gtk_selection_data_get_length(selection_data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_selection_data_get_length
  type(c_ptr), value :: selection_data
end function

! GdkDisplay *gtk_selection_data_get_display (GtkSelectionData *selection_data);
function gtk_selection_data_get_display(selection_data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_selection_data_get_display
  type(c_ptr), value :: selection_data
end function

!  void gtk_selection_data_set (GtkSelectionData *selection_data, GdkAtom type, gint format, const guchar *data, gint length);
subroutine gtk_selection_data_set(selection_data, type, format, data, length) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: selection_data
  type(c_ptr), value :: type
  integer(c_int), value :: format
  character(kind=c_char), dimension(*) :: data
  integer(c_int), value :: length
end subroutine

! gboolean gtk_selection_data_set_text (GtkSelectionData *selection_data, const gchar *str, gint len);
function gtk_selection_data_set_text(selection_data, str, len) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: gtk_selection_data_set_text
  type(c_ptr), value :: selection_data
  character(kind=c_char), dimension(*) :: str
  integer(c_int), value :: len
end function

! guchar * gtk_selection_data_get_text (GtkSelectionData *selection_data);
function gtk_selection_data_get_text(selection_data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_selection_data_get_text
  type(c_ptr), value :: selection_data
end function

! gboolean gtk_selection_data_set_pixbuf (GtkSelectionData *selection_data, GdkPixbuf *pixbuf);
function gtk_selection_data_set_pixbuf(selection_data, pixbuf) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_selection_data_set_pixbuf
  type(c_ptr), value :: selection_data
  type(c_ptr), value :: pixbuf
end function

! GdkPixbuf *gtk_selection_data_get_pixbuf (GtkSelectionData *selection_data);
function gtk_selection_data_get_pixbuf(selection_data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_selection_data_get_pixbuf
  type(c_ptr), value :: selection_data
end function

! gboolean gtk_selection_data_set_uris (GtkSelectionData *selection_data, gchar **uris);
function gtk_selection_data_set_uris(selection_data, uris) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_selection_data_set_uris
  type(c_ptr), value :: selection_data
  character(kind=c_char), dimension(*) :: uris
end function

! gchar **gtk_selection_data_get_uris (GtkSelectionData *selection_data);
function gtk_selection_data_get_uris(selection_data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_selection_data_get_uris
  type(c_ptr), value :: selection_data
end function

!  gboolean gtk_selection_data_get_targets (GtkSelectionData *selection_data, GdkAtom **targets, gint *n_atoms);
function gtk_selection_data_get_targets(selection_data, targets, n_atoms) bind(c&
      &) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_selection_data_get_targets
  type(c_ptr), value :: selection_data
  type(c_ptr), value :: targets
  type(c_ptr), value :: n_atoms
end function

! gboolean gtk_selection_data_targets_include_text (GtkSelectionData *selection_data);
function gtk_selection_data_targets_include_text(selection_data) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_selection_data_targets_include_text
  type(c_ptr), value :: selection_data
end function

! gboolean gtk_selection_data_targets_include_rich_text (GtkSelectionData *selection_data, GtkTextBuffer *buffer);
function gtk_selection_data_targets_include_rich_text(selection_data, buffer) bi&
      &nd(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_selection_data_targets_include_rich_text
  type(c_ptr), value :: selection_data
  type(c_ptr), value :: buffer
end function

! gboolean gtk_selection_data_targets_include_image (GtkSelectionData *selection_data, gboolean writable);
function gtk_selection_data_targets_include_image(selection_data, writable) bind&
      &(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_selection_data_targets_include_image
  type(c_ptr), value :: selection_data
  logical(c_bool), value :: writable
end function

! gboolean gtk_selection_data_targets_include_uri (GtkSelectionData *selection_data);
function gtk_selection_data_targets_include_uri(selection_data) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_selection_data_targets_include_uri
  type(c_ptr), value :: selection_data
end function

! gboolean gtk_targets_include_text (GdkAtom *targets, gint n_targets);
function gtk_targets_include_text(targets, n_targets) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_targets_include_text
  type(c_ptr), value :: targets
  integer(c_int), value :: n_targets
end function

! gboolean gtk_targets_include_rich_text (GdkAtom *targets, gint n_targets, GtkTextBuffer *buffer);
function gtk_targets_include_rich_text(targets, n_targets, buffer) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_targets_include_rich_text
  type(c_ptr), value :: targets
  integer(c_int), value :: n_targets
  type(c_ptr), value :: buffer
end function

! gboolean gtk_targets_include_image (GdkAtom *targets, gint n_targets, gboolean writable);
function gtk_targets_include_image(targets, n_targets, writable) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_targets_include_image
  type(c_ptr), value :: targets
  integer(c_int), value :: n_targets
  logical(c_bool), value :: writable
end function

! gboolean gtk_targets_include_uri (GdkAtom *targets, gint n_targets);
function gtk_targets_include_uri(targets, n_targets) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_targets_include_uri
  type(c_ptr), value :: targets
  integer(c_int), value :: n_targets
end function

!  void gtk_selection_remove_all (GtkWidget *widget);
subroutine gtk_selection_remove_all(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

!  gboolean gtk_selection_clear (GtkWidget *widget, GdkEventSelection *event);
function gtk_selection_clear(widget, event) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_selection_clear
  type(c_ptr), value :: widget
  type(c_ptr), value :: event
end function

!  GType gtk_selection_data_get_type (void) G_GNUC_CONST;
function gtk_selection_data_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_selection_data_get_type
end function

! GtkSelectionData *gtk_selection_data_copy (GtkSelectionData *data);
function gtk_selection_data_copy(data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_selection_data_copy
  type(c_ptr), value :: data
end function

! void gtk_selection_data_free (GtkSelectionData *data);
subroutine gtk_selection_data_free(data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: data
end subroutine

!  GType gtk_target_list_get_type (void) G_GNUC_CONST;
function gtk_target_list_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_target_list_get_type
end function

!   GType gtk_vseparator_get_type (void) G_GNUC_CONST;
function gtk_vseparator_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_vseparator_get_type
end function

! GtkWidget* gtk_vseparator_new (void);
function gtk_vseparator_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_vseparator_new
end function

!   GType gtk_tooltips_get_type (void) G_GNUC_CONST;
function gtk_tooltips_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tooltips_get_type
end function

! GtkTooltips* gtk_tooltips_new (void);
function gtk_tooltips_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tooltips_new
end function

!  void gtk_tooltips_enable (GtkTooltips *tooltips);
subroutine gtk_tooltips_enable(tooltips) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tooltips
end subroutine

! void gtk_tooltips_disable (GtkTooltips *tooltips);
subroutine gtk_tooltips_disable(tooltips) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tooltips
end subroutine

! void gtk_tooltips_set_delay (GtkTooltips *tooltips, guint delay);
subroutine gtk_tooltips_set_delay(tooltips, delay) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tooltips
  integer(c_int), value :: delay
end subroutine

! void gtk_tooltips_set_tip (GtkTooltips *tooltips, GtkWidget *widget, const gchar *tip_text, const gchar *tip_private);
subroutine gtk_tooltips_set_tip(tooltips, widget, tip_text, tip_private) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: tooltips
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: tip_text
  character(kind=c_char), dimension(*) :: tip_private
end subroutine

! GtkTooltipsData* gtk_tooltips_data_get (GtkWidget *widget);
function gtk_tooltips_data_get(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tooltips_data_get
  type(c_ptr), value :: widget
end function

! void gtk_tooltips_force_window (GtkTooltips *tooltips);
subroutine gtk_tooltips_force_window(tooltips) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tooltips
end subroutine

!  gboolean gtk_tooltips_get_info_from_tip_window (GtkWindow *tip_window, GtkTooltips **tooltips, GtkWidget **current_widget);
function gtk_tooltips_get_info_from_tip_window(tip_window, tooltips, current_wid&
      &get) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tooltips_get_info_from_tip_window
  type(c_ptr), value :: tip_window
  type(c_ptr), value :: tooltips
  type(c_ptr), value :: current_widget
end function

!   GType gtk_check_menu_item_get_type (void) G_GNUC_CONST;
function gtk_check_menu_item_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_check_menu_item_get_type
end function

!  GtkWidget* gtk_check_menu_item_new (void);
function gtk_check_menu_item_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_check_menu_item_new
end function

! GtkWidget* gtk_check_menu_item_new_with_label (const gchar *label);
function gtk_check_menu_item_new_with_label(label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_check_menu_item_new_with_label
  character(kind=c_char), dimension(*) :: label
end function

! GtkWidget* gtk_check_menu_item_new_with_mnemonic (const gchar *label);
function gtk_check_menu_item_new_with_mnemonic(label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_check_menu_item_new_with_mnemonic
  character(kind=c_char), dimension(*) :: label
end function

! void gtk_check_menu_item_set_active (GtkCheckMenuItem *check_menu_item, gboolean is_active);
subroutine gtk_check_menu_item_set_active(check_menu_item, is_active) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: check_menu_item
  logical(c_bool), value :: is_active
end subroutine

! gboolean gtk_check_menu_item_get_active (GtkCheckMenuItem *check_menu_item);
function gtk_check_menu_item_get_active(check_menu_item) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_check_menu_item_get_active
  type(c_ptr), value :: check_menu_item
end function

! void gtk_check_menu_item_toggled (GtkCheckMenuItem *check_menu_item);
subroutine gtk_check_menu_item_toggled(check_menu_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: check_menu_item
end subroutine

! void gtk_check_menu_item_set_inconsistent (GtkCheckMenuItem *check_menu_item, gboolean setting);
subroutine gtk_check_menu_item_set_inconsistent(check_menu_item, setting) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: check_menu_item
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_check_menu_item_get_inconsistent (GtkCheckMenuItem *check_menu_item);
function gtk_check_menu_item_get_inconsistent(check_menu_item) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_check_menu_item_get_inconsistent
  type(c_ptr), value :: check_menu_item
end function

! void gtk_check_menu_item_set_draw_as_radio (GtkCheckMenuItem *check_menu_item, gboolean draw_as_radio);
subroutine gtk_check_menu_item_set_draw_as_radio(check_menu_item, draw_as_radio)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: check_menu_item
  logical(c_bool), value :: draw_as_radio
end subroutine

! gboolean gtk_check_menu_item_get_draw_as_radio (GtkCheckMenuItem *check_menu_item);
function gtk_check_menu_item_get_draw_as_radio(check_menu_item) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_check_menu_item_get_draw_as_radio
  type(c_ptr), value :: check_menu_item
end function

!  void gtk_check_menu_item_set_show_toggle (GtkCheckMenuItem *menu_item, gboolean always);
subroutine gtk_check_menu_item_set_show_toggle(menu_item, always) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: menu_item
  logical(c_bool), value :: always
end subroutine

!   GType gtk_about_dialog_get_type (void) G_GNUC_CONST;
function gtk_about_dialog_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_about_dialog_get_type
end function

! GtkWidget *gtk_about_dialog_new (void);
function gtk_about_dialog_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_about_dialog_new
end function

!  G_CONST_RETURN gchar *gtk_about_dialog_get_name (GtkAboutDialog *about);
function gtk_about_dialog_get_name(about) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_about_dialog_get_name
  type(c_ptr), value :: about
end function

! void gtk_about_dialog_set_name (GtkAboutDialog *about, const gchar *name);
subroutine gtk_about_dialog_set_name(about, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: about
  character(kind=c_char), dimension(*) :: name
end subroutine

!  G_CONST_RETURN gchar *gtk_about_dialog_get_program_name (GtkAboutDialog *about);
function gtk_about_dialog_get_program_name(about) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_about_dialog_get_program_name
  type(c_ptr), value :: about
end function

! void gtk_about_dialog_set_program_name (GtkAboutDialog *about, const gchar *name);
subroutine gtk_about_dialog_set_program_name(about, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: about
  character(kind=c_char), dimension(*) :: name
end subroutine

! G_CONST_RETURN gchar *gtk_about_dialog_get_version (GtkAboutDialog *about);
function gtk_about_dialog_get_version(about) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_about_dialog_get_version
  type(c_ptr), value :: about
end function

! void gtk_about_dialog_set_version (GtkAboutDialog *about, const gchar *version);
subroutine gtk_about_dialog_set_version(about, version) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: about
  character(kind=c_char), dimension(*) :: version
end subroutine

! G_CONST_RETURN gchar *gtk_about_dialog_get_copyright (GtkAboutDialog *about);
function gtk_about_dialog_get_copyright(about) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_about_dialog_get_copyright
  type(c_ptr), value :: about
end function

! void gtk_about_dialog_set_copyright (GtkAboutDialog *about, const gchar *copyright);
subroutine gtk_about_dialog_set_copyright(about, copyright) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: about
  character(kind=c_char), dimension(*) :: copyright
end subroutine

! G_CONST_RETURN gchar *gtk_about_dialog_get_comments (GtkAboutDialog *about);
function gtk_about_dialog_get_comments(about) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_about_dialog_get_comments
  type(c_ptr), value :: about
end function

! void gtk_about_dialog_set_comments (GtkAboutDialog *about, const gchar *comments);
subroutine gtk_about_dialog_set_comments(about, comments) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: about
  character(kind=c_char), dimension(*) :: comments
end subroutine

! G_CONST_RETURN gchar *gtk_about_dialog_get_license (GtkAboutDialog *about);
function gtk_about_dialog_get_license(about) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_about_dialog_get_license
  type(c_ptr), value :: about
end function

! void gtk_about_dialog_set_license (GtkAboutDialog *about, const gchar *license);
subroutine gtk_about_dialog_set_license(about, license) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: about
  character(kind=c_char), dimension(*) :: license
end subroutine

!  gboolean gtk_about_dialog_get_wrap_license (GtkAboutDialog *about);
function gtk_about_dialog_get_wrap_license(about) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_about_dialog_get_wrap_license
  type(c_ptr), value :: about
end function

! void gtk_about_dialog_set_wrap_license (GtkAboutDialog *about, gboolean wrap_license);
subroutine gtk_about_dialog_set_wrap_license(about, wrap_license) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: about
  logical(c_bool), value :: wrap_license
end subroutine

!  G_CONST_RETURN gchar *gtk_about_dialog_get_website (GtkAboutDialog *about);
function gtk_about_dialog_get_website(about) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_about_dialog_get_website
  type(c_ptr), value :: about
end function

! void gtk_about_dialog_set_website (GtkAboutDialog *about, const gchar *website);
subroutine gtk_about_dialog_set_website(about, website) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: about
  character(kind=c_char), dimension(*) :: website
end subroutine

! G_CONST_RETURN gchar *gtk_about_dialog_get_website_label (GtkAboutDialog *about);
function gtk_about_dialog_get_website_label(about) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_about_dialog_get_website_label
  type(c_ptr), value :: about
end function

! void gtk_about_dialog_set_website_label (GtkAboutDialog *about, const gchar *website_label);
subroutine gtk_about_dialog_set_website_label(about, website_label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: about
  character(kind=c_char), dimension(*) :: website_label
end subroutine

! G_CONST_RETURN gchar* G_CONST_RETURN * gtk_about_dialog_get_authors (GtkAboutDialog *about);
function gtk_about_dialog_get_authors(about) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_about_dialog_get_authors
  type(c_ptr), value :: about
end function

! void gtk_about_dialog_set_authors (GtkAboutDialog *about, const gchar **authors);
subroutine gtk_about_dialog_set_authors(about, authors) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: about
  character(kind=c_char), dimension(*) :: authors
end subroutine

! G_CONST_RETURN gchar* G_CONST_RETURN * gtk_about_dialog_get_documenters (GtkAboutDialog *about);
function gtk_about_dialog_get_documenters(about) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_about_dialog_get_documenters
  type(c_ptr), value :: about
end function

! void gtk_about_dialog_set_documenters (GtkAboutDialog *about, const gchar **documenters);
subroutine gtk_about_dialog_set_documenters(about, documenters) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: about
  character(kind=c_char), dimension(*) :: documenters
end subroutine

! G_CONST_RETURN gchar* G_CONST_RETURN * gtk_about_dialog_get_artists (GtkAboutDialog *about);
function gtk_about_dialog_get_artists(about) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_about_dialog_get_artists
  type(c_ptr), value :: about
end function

! void gtk_about_dialog_set_artists (GtkAboutDialog *about, const gchar **artists);
subroutine gtk_about_dialog_set_artists(about, artists) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: about
  character(kind=c_char), dimension(*) :: artists
end subroutine

! G_CONST_RETURN gchar *gtk_about_dialog_get_translator_credits (GtkAboutDialog *about);
function gtk_about_dialog_get_translator_credits(about) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_about_dialog_get_translator_credits
  type(c_ptr), value :: about
end function

! void gtk_about_dialog_set_translator_credits (GtkAboutDialog *about, const gchar *translator_credits);
subroutine gtk_about_dialog_set_translator_credits(about, translator_credits) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: about
  character(kind=c_char), dimension(*) :: translator_credits
end subroutine

! GdkPixbuf *gtk_about_dialog_get_logo (GtkAboutDialog *about);
function gtk_about_dialog_get_logo(about) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_about_dialog_get_logo
  type(c_ptr), value :: about
end function

! void gtk_about_dialog_set_logo (GtkAboutDialog *about, GdkPixbuf *logo);
subroutine gtk_about_dialog_set_logo(about, logo) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: about
  type(c_ptr), value :: logo
end subroutine

! G_CONST_RETURN gchar *gtk_about_dialog_get_logo_icon_name (GtkAboutDialog *about);
function gtk_about_dialog_get_logo_icon_name(about) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_about_dialog_get_logo_icon_name
  type(c_ptr), value :: about
end function

! void gtk_about_dialog_set_logo_icon_name (GtkAboutDialog *about, const gchar *icon_name);
subroutine gtk_about_dialog_set_logo_icon_name(about, icon_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: about
  character(kind=c_char), dimension(*) :: icon_name
end subroutine

!  GtkAboutDialogActivateLinkFunc gtk_about_dialog_set_email_hook (GtkAboutDialogActivateLinkFunc func, gpointer data, GDestroyNotify destroy);
function gtk_about_dialog_set_email_hook(func, data, destroy) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr) :: gtk_about_dialog_set_email_hook
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end function

! GtkAboutDialogActivateLinkFunc gtk_about_dialog_set_url_hook (GtkAboutDialogActivateLinkFunc func, gpointer data, GDestroyNotify destroy);
function gtk_about_dialog_set_url_hook(func, data, destroy) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr) :: gtk_about_dialog_set_url_hook
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end function

!   GType gtk_ui_manager_get_type (void) G_GNUC_CONST;
function gtk_ui_manager_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_ui_manager_get_type
end function

! GtkUIManager *gtk_ui_manager_new (void);
function gtk_ui_manager_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_ui_manager_new
end function

! void gtk_ui_manager_set_add_tearoffs (GtkUIManager *self, gboolean add_tearoffs);
subroutine gtk_ui_manager_set_add_tearoffs(self, add_tearoffs) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: self
  logical(c_bool), value :: add_tearoffs
end subroutine

! gboolean gtk_ui_manager_get_add_tearoffs (GtkUIManager *self);
function gtk_ui_manager_get_add_tearoffs(self) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_ui_manager_get_add_tearoffs
  type(c_ptr), value :: self
end function

! void gtk_ui_manager_insert_action_group (GtkUIManager *self, GtkActionGroup *action_group, gint pos);
subroutine gtk_ui_manager_insert_action_group(self, action_group, pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: self
  type(c_ptr), value :: action_group
  integer(c_int), value :: pos
end subroutine

! void gtk_ui_manager_remove_action_group (GtkUIManager *self, GtkActionGroup *action_group);
subroutine gtk_ui_manager_remove_action_group(self, action_group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: self
  type(c_ptr), value :: action_group
end subroutine

! GList *gtk_ui_manager_get_action_groups (GtkUIManager *self);
function gtk_ui_manager_get_action_groups(self) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_ui_manager_get_action_groups
  type(c_ptr), value :: self
end function

! GtkAccelGroup *gtk_ui_manager_get_accel_group (GtkUIManager *self);
function gtk_ui_manager_get_accel_group(self) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_ui_manager_get_accel_group
  type(c_ptr), value :: self
end function

! GtkWidget *gtk_ui_manager_get_widget (GtkUIManager *self, const gchar *path);
function gtk_ui_manager_get_widget(self, path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_ui_manager_get_widget
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: path
end function

! GSList *gtk_ui_manager_get_toplevels (GtkUIManager *self, GtkUIManagerItemType types);
function gtk_ui_manager_get_toplevels(self, types) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_ui_manager_get_toplevels
  type(c_ptr), value :: self
  integer(c_int), value :: types
end function

! GtkAction *gtk_ui_manager_get_action (GtkUIManager *self, const gchar *path);
function gtk_ui_manager_get_action(self, path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_ui_manager_get_action
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: path
end function

! guint gtk_ui_manager_add_ui_from_string (GtkUIManager *self, const gchar *buffer, gssize length, GError **error);
function gtk_ui_manager_add_ui_from_string(self, buffer, length, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_size_t
  integer(c_int) :: gtk_ui_manager_add_ui_from_string
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: length
  type(c_ptr), value :: error
end function

! guint gtk_ui_manager_add_ui_from_file (GtkUIManager *self, const gchar *filename, GError **error);
function gtk_ui_manager_add_ui_from_file(self, filename, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gtk_ui_manager_add_ui_from_file
  type(c_ptr), value :: self
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: error
end function

! void gtk_ui_manager_add_ui (GtkUIManager *self, guint merge_id, const gchar *path, const gchar *name, const gchar *action, GtkUIManagerItemType type, gboolean top);
subroutine gtk_ui_manager_add_ui(self, merge_id, path, name, action, type, top) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char, c_bool
  type(c_ptr), value :: self
  integer(c_int), value :: merge_id
  character(kind=c_char), dimension(*) :: path
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: action
  integer(c_int), value :: type
  logical(c_bool), value :: top
end subroutine

! void gtk_ui_manager_remove_ui (GtkUIManager *self, guint merge_id);
subroutine gtk_ui_manager_remove_ui(self, merge_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: self
  integer(c_int), value :: merge_id
end subroutine

! gchar *gtk_ui_manager_get_ui (GtkUIManager *self);
function gtk_ui_manager_get_ui(self) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_ui_manager_get_ui
  type(c_ptr), value :: self
end function

! void gtk_ui_manager_ensure_update (GtkUIManager *self);
subroutine gtk_ui_manager_ensure_update(self) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: self
end subroutine

! guint gtk_ui_manager_new_merge_id (GtkUIManager *self);
function gtk_ui_manager_new_merge_id(self) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_ui_manager_new_merge_id
  type(c_ptr), value :: self
end function

!   GType gtk_action_group_get_type (void) G_GNUC_CONST;
function gtk_action_group_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_action_group_get_type
end function

! GtkActionGroup *gtk_action_group_new (const gchar *name);
function gtk_action_group_new(name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_action_group_new
  character(kind=c_char), dimension(*) :: name
end function

! G_CONST_RETURN gchar *gtk_action_group_get_name (GtkActionGroup *action_group);
function gtk_action_group_get_name(action_group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_action_group_get_name
  type(c_ptr), value :: action_group
end function

! gboolean gtk_action_group_get_sensitive (GtkActionGroup *action_group);
function gtk_action_group_get_sensitive(action_group) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_action_group_get_sensitive
  type(c_ptr), value :: action_group
end function

! void gtk_action_group_set_sensitive (GtkActionGroup *action_group, gboolean sensitive);
subroutine gtk_action_group_set_sensitive(action_group, sensitive) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: action_group
  logical(c_bool), value :: sensitive
end subroutine

! gboolean gtk_action_group_get_visible (GtkActionGroup *action_group);
function gtk_action_group_get_visible(action_group) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_action_group_get_visible
  type(c_ptr), value :: action_group
end function

! void gtk_action_group_set_visible (GtkActionGroup *action_group, gboolean visible);
subroutine gtk_action_group_set_visible(action_group, visible) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: action_group
  logical(c_bool), value :: visible
end subroutine

! GtkAction *gtk_action_group_get_action (GtkActionGroup *action_group, const gchar *action_name);
function gtk_action_group_get_action(action_group, action_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_action_group_get_action
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
end function

! GList *gtk_action_group_list_actions (GtkActionGroup *action_group);
function gtk_action_group_list_actions(action_group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_action_group_list_actions
  type(c_ptr), value :: action_group
end function

! void gtk_action_group_add_action (GtkActionGroup *action_group, GtkAction *action);
subroutine gtk_action_group_add_action(action_group, action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: action_group
  type(c_ptr), value :: action
end subroutine

! void gtk_action_group_add_action_with_accel (GtkActionGroup *action_group, GtkAction *action, const gchar *accelerator);
subroutine gtk_action_group_add_action_with_accel(action_group, action, accelera&
      &tor) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: action_group
  type(c_ptr), value :: action
  character(kind=c_char), dimension(*) :: accelerator
end subroutine

! void gtk_action_group_remove_action (GtkActionGroup *action_group, GtkAction *action);
subroutine gtk_action_group_remove_action(action_group, action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: action_group
  type(c_ptr), value :: action
end subroutine

! void gtk_action_group_add_actions (GtkActionGroup *action_group, const GtkActionEntry *entries, guint n_entries, gpointer user_data);
subroutine gtk_action_group_add_actions(action_group, entries, n_entries, user_d&
      &ata) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: action_group
  type(c_ptr), value :: entries
  integer(c_int), value :: n_entries
  type(c_ptr), value :: user_data
end subroutine

! void gtk_action_group_add_toggle_actions (GtkActionGroup *action_group, const GtkToggleActionEntry *entries, guint n_entries, gpointer user_data);
subroutine gtk_action_group_add_toggle_actions(action_group, entries, n_entries,&
      & user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: action_group
  type(c_ptr), value :: entries
  integer(c_int), value :: n_entries
  type(c_ptr), value :: user_data
end subroutine

! void gtk_action_group_add_radio_actions (GtkActionGroup *action_group, const GtkRadioActionEntry *entries, guint n_entries, gint value, GCallback on_change, gpointer user_data);
subroutine gtk_action_group_add_radio_actions(action_group, entries, n_entries, &
      &value, on_change, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: action_group
  type(c_ptr), value :: entries
  integer(c_int), value :: n_entries
  integer(c_int), value :: value
  type(c_funptr), value :: on_change
  type(c_ptr), value :: user_data
end subroutine

! void gtk_action_group_add_actions_full (GtkActionGroup *action_group, const GtkActionEntry *entries, guint n_entries, gpointer user_data, GDestroyNotify destroy);
subroutine gtk_action_group_add_actions_full(action_group, entries, n_entries, u&
      &ser_data, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: action_group
  type(c_ptr), value :: entries
  integer(c_int), value :: n_entries
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy
end subroutine

! void gtk_action_group_add_toggle_actions_full (GtkActionGroup *action_group, const GtkToggleActionEntry *entries, guint n_entries, gpointer user_data, GDestroyNotify destroy);
subroutine gtk_action_group_add_toggle_actions_full(action_group, entries, n_ent&
      &ries, user_data, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: action_group
  type(c_ptr), value :: entries
  integer(c_int), value :: n_entries
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy
end subroutine

! void gtk_action_group_add_radio_actions_full (GtkActionGroup *action_group, const GtkRadioActionEntry *entries, guint n_entries, gint value, GCallback on_change, gpointer user_data, GDestroyNotify destroy);
subroutine gtk_action_group_add_radio_actions_full(action_group, entries, n_entr&
      &ies, value, on_change, user_data, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: action_group
  type(c_ptr), value :: entries
  integer(c_int), value :: n_entries
  integer(c_int), value :: value
  type(c_funptr), value :: on_change
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy
end subroutine

! void gtk_action_group_set_translate_func (GtkActionGroup *action_group, GtkTranslateFunc func, gpointer data, GDestroyNotify notify);
subroutine gtk_action_group_set_translate_func(action_group, func, data, notify)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: action_group
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end subroutine

! void gtk_action_group_set_translation_domain (GtkActionGroup *action_group, const gchar *domain);
subroutine gtk_action_group_set_translation_domain(action_group, domain) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: domain
end subroutine

! G_CONST_RETURN gchar *gtk_action_group_translate_string (GtkActionGroup *action_group, const gchar *string);
function gtk_action_group_translate_string(action_group, string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_action_group_translate_string
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: string
end function

!   GType gtk_adjustment_get_type (void) G_GNUC_CONST;
function gtk_adjustment_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_adjustment_get_type
end function

! GtkObject* gtk_adjustment_new (gdouble value, gdouble lower, gdouble upper, gdouble step_increment, gdouble page_increment, gdouble page_size);
function gtk_adjustment_new(value, lower, upper, step_increment, page_increment,&
      & page_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr) :: gtk_adjustment_new
  real(c_double), value :: value
  real(c_double), value :: lower
  real(c_double), value :: upper
  real(c_double), value :: step_increment
  real(c_double), value :: page_increment
  real(c_double), value :: page_size
end function

!  void gtk_adjustment_changed (GtkAdjustment *adjustment);
subroutine gtk_adjustment_changed(adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: adjustment
end subroutine

! void gtk_adjustment_value_changed (GtkAdjustment *adjustment);
subroutine gtk_adjustment_value_changed(adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: adjustment
end subroutine

! void gtk_adjustment_clamp_page (GtkAdjustment *adjustment, gdouble lower, gdouble upper);
subroutine gtk_adjustment_clamp_page(adjustment, lower, upper) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: adjustment
  real(c_double), value :: lower
  real(c_double), value :: upper
end subroutine

!  gdouble gtk_adjustment_get_value (GtkAdjustment *adjustment);
function gtk_adjustment_get_value(adjustment) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_adjustment_get_value
  type(c_ptr), value :: adjustment
end function

! void gtk_adjustment_set_value (GtkAdjustment *adjustment, gdouble value);
subroutine gtk_adjustment_set_value(adjustment, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: adjustment
  real(c_double), value :: value
end subroutine

! gdouble gtk_adjustment_get_lower (GtkAdjustment *adjustment);
function gtk_adjustment_get_lower(adjustment) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_adjustment_get_lower
  type(c_ptr), value :: adjustment
end function

! void gtk_adjustment_set_lower (GtkAdjustment *adjustment, gdouble lower);
subroutine gtk_adjustment_set_lower(adjustment, lower) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: adjustment
  real(c_double), value :: lower
end subroutine

! gdouble gtk_adjustment_get_upper (GtkAdjustment *adjustment);
function gtk_adjustment_get_upper(adjustment) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_adjustment_get_upper
  type(c_ptr), value :: adjustment
end function

! void gtk_adjustment_set_upper (GtkAdjustment *adjustment, gdouble upper);
subroutine gtk_adjustment_set_upper(adjustment, upper) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: adjustment
  real(c_double), value :: upper
end subroutine

! gdouble gtk_adjustment_get_step_increment (GtkAdjustment *adjustment);
function gtk_adjustment_get_step_increment(adjustment) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_adjustment_get_step_increment
  type(c_ptr), value :: adjustment
end function

! void gtk_adjustment_set_step_increment (GtkAdjustment *adjustment, gdouble step_increment);
subroutine gtk_adjustment_set_step_increment(adjustment, step_increment) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: adjustment
  real(c_double), value :: step_increment
end subroutine

! gdouble gtk_adjustment_get_page_increment (GtkAdjustment *adjustment);
function gtk_adjustment_get_page_increment(adjustment) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_adjustment_get_page_increment
  type(c_ptr), value :: adjustment
end function

! void gtk_adjustment_set_page_increment (GtkAdjustment *adjustment, gdouble page_increment);
subroutine gtk_adjustment_set_page_increment(adjustment, page_increment) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: adjustment
  real(c_double), value :: page_increment
end subroutine

! gdouble gtk_adjustment_get_page_size (GtkAdjustment *adjustment);
function gtk_adjustment_get_page_size(adjustment) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_adjustment_get_page_size
  type(c_ptr), value :: adjustment
end function

! void gtk_adjustment_set_page_size (GtkAdjustment *adjustment, gdouble page_size);
subroutine gtk_adjustment_set_page_size(adjustment, page_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: adjustment
  real(c_double), value :: page_size
end subroutine

!  void gtk_adjustment_configure (GtkAdjustment *adjustment, gdouble value, gdouble lower, gdouble upper, gdouble step_increment, gdouble page_increment, gdouble page_size);
subroutine gtk_adjustment_configure(adjustment, value, lower, upper, step_increm&
      &ent, page_increment, page_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: adjustment
  real(c_double), value :: value
  real(c_double), value :: lower
  real(c_double), value :: upper
  real(c_double), value :: step_increment
  real(c_double), value :: page_increment
  real(c_double), value :: page_size
end subroutine

!   GType gtk_radio_action_get_type (void) G_GNUC_CONST;
function gtk_radio_action_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_radio_action_get_type
end function

! GtkRadioAction *gtk_radio_action_new (const gchar *name, const gchar *label, const gchar *tooltip, const gchar *stock_id, gint value);
function gtk_radio_action_new(name, label, tooltip, stock_id, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: gtk_radio_action_new
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: label
  character(kind=c_char), dimension(*) :: tooltip
  character(kind=c_char), dimension(*) :: stock_id
  integer(c_int), value :: value
end function

! GSList *gtk_radio_action_get_group (GtkRadioAction *action);
function gtk_radio_action_get_group(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_radio_action_get_group
  type(c_ptr), value :: action
end function

! void gtk_radio_action_set_group (GtkRadioAction *action, GSList *group);
subroutine gtk_radio_action_set_group(action, group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: action
  type(c_ptr), value :: group
end subroutine

! gint gtk_radio_action_get_current_value (GtkRadioAction *action);
function gtk_radio_action_get_current_value(action) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_radio_action_get_current_value
  type(c_ptr), value :: action
end function

! void gtk_radio_action_set_current_value (GtkRadioAction *action, gint current_value);
subroutine gtk_radio_action_set_current_value(action, current_value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: action
  integer(c_int), value :: current_value
end subroutine

!   GType gtk_cell_renderer_spinner_get_type (void) G_GNUC_CONST;
function gtk_cell_renderer_spinner_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_cell_renderer_spinner_get_type
end function

! GtkCellRenderer *gtk_cell_renderer_spinner_new (void);
function gtk_cell_renderer_spinner_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_cell_renderer_spinner_new
end function

!   GType gtk_recent_chooser_widget_get_type (void) G_GNUC_CONST;
function gtk_recent_chooser_widget_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_recent_chooser_widget_get_type
end function

! GtkWidget *gtk_recent_chooser_widget_new (void);
function gtk_recent_chooser_widget_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_chooser_widget_new
end function

! GtkWidget *gtk_recent_chooser_widget_new_for_manager (GtkRecentManager *manager);
function gtk_recent_chooser_widget_new_for_manager(manager) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_chooser_widget_new_for_manager
  type(c_ptr), value :: manager
end function

!   GType gtk_check_button_get_type (void) G_GNUC_CONST;
function gtk_check_button_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_check_button_get_type
end function

! GtkWidget* gtk_check_button_new (void);
function gtk_check_button_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_check_button_new
end function

! GtkWidget* gtk_check_button_new_with_label (const gchar *label);
function gtk_check_button_new_with_label(label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_check_button_new_with_label
  character(kind=c_char), dimension(*) :: label
end function

! GtkWidget* gtk_check_button_new_with_mnemonic (const gchar *label);
function gtk_check_button_new_with_mnemonic(label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_check_button_new_with_mnemonic
  character(kind=c_char), dimension(*) :: label
end function

!   GType gtk_hseparator_get_type (void) G_GNUC_CONST;
function gtk_hseparator_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_hseparator_get_type
end function

! GtkWidget* gtk_hseparator_new (void);
function gtk_hseparator_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_hseparator_new
end function

!   GType gtk_image_get_type (void) G_GNUC_CONST;
function gtk_image_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_image_get_type
end function

!  GtkWidget* gtk_image_new (void);
function gtk_image_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_image_new
end function

! GtkWidget* gtk_image_new_from_pixmap (GdkPixmap *pixmap, GdkBitmap *mask);
function gtk_image_new_from_pixmap(pixmap, mask) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_image_new_from_pixmap
  type(c_ptr), value :: pixmap
  type(c_ptr), value :: mask
end function

! GtkWidget* gtk_image_new_from_image (GdkImage *image, GdkBitmap *mask);
function gtk_image_new_from_image(image, mask) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_image_new_from_image
  type(c_ptr), value :: image
  type(c_ptr), value :: mask
end function

! GtkWidget* gtk_image_new_from_file (const gchar *filename);
function gtk_image_new_from_file(filename) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_image_new_from_file
  character(kind=c_char), dimension(*) :: filename
end function

! GtkWidget* gtk_image_new_from_pixbuf (GdkPixbuf *pixbuf);
function gtk_image_new_from_pixbuf(pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_image_new_from_pixbuf
  type(c_ptr), value :: pixbuf
end function

! GtkWidget* gtk_image_new_from_stock (const gchar *stock_id, GtkIconSize size);
function gtk_image_new_from_stock(stock_id, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: gtk_image_new_from_stock
  character(kind=c_char), dimension(*) :: stock_id
  integer(c_int), value :: size
end function

! GtkWidget* gtk_image_new_from_icon_set (GtkIconSet *icon_set, GtkIconSize size);
function gtk_image_new_from_icon_set(icon_set, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_image_new_from_icon_set
  type(c_ptr), value :: icon_set
  integer(c_int), value :: size
end function

! GtkWidget* gtk_image_new_from_animation (GdkPixbufAnimation *animation);
function gtk_image_new_from_animation(animation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_image_new_from_animation
  type(c_ptr), value :: animation
end function

! GtkWidget* gtk_image_new_from_icon_name (const gchar *icon_name, GtkIconSize size);
function gtk_image_new_from_icon_name(icon_name, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: gtk_image_new_from_icon_name
  character(kind=c_char), dimension(*) :: icon_name
  integer(c_int), value :: size
end function

! GtkWidget* gtk_image_new_from_gicon (GIcon *icon, GtkIconSize size);
function gtk_image_new_from_gicon(icon, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_image_new_from_gicon
  type(c_ptr), value :: icon
  integer(c_int), value :: size
end function

!  void gtk_image_clear (GtkImage *image);
subroutine gtk_image_clear(image) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: image
end subroutine

! void gtk_image_set_from_pixmap (GtkImage *image, GdkPixmap *pixmap, GdkBitmap *mask);
subroutine gtk_image_set_from_pixmap(image, pixmap, mask) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: image
  type(c_ptr), value :: pixmap
  type(c_ptr), value :: mask
end subroutine

! void gtk_image_set_from_image (GtkImage *image, GdkImage *gdk_image, GdkBitmap *mask);
subroutine gtk_image_set_from_image(image, gdk_image, mask) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: image
  type(c_ptr), value :: gdk_image
  type(c_ptr), value :: mask
end subroutine

! void gtk_image_set_from_file (GtkImage *image, const gchar *filename);
subroutine gtk_image_set_from_file(image, filename) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: image
  character(kind=c_char), dimension(*) :: filename
end subroutine

! void gtk_image_set_from_pixbuf (GtkImage *image, GdkPixbuf *pixbuf);
subroutine gtk_image_set_from_pixbuf(image, pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: image
  type(c_ptr), value :: pixbuf
end subroutine

! void gtk_image_set_from_stock (GtkImage *image, const gchar *stock_id, GtkIconSize size);
subroutine gtk_image_set_from_stock(image, stock_id, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: image
  character(kind=c_char), dimension(*) :: stock_id
  integer(c_int), value :: size
end subroutine

! void gtk_image_set_from_icon_set (GtkImage *image, GtkIconSet *icon_set, GtkIconSize size);
subroutine gtk_image_set_from_icon_set(image, icon_set, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: image
  type(c_ptr), value :: icon_set
  integer(c_int), value :: size
end subroutine

! void gtk_image_set_from_animation (GtkImage *image, GdkPixbufAnimation *animation);
subroutine gtk_image_set_from_animation(image, animation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: image
  type(c_ptr), value :: animation
end subroutine

! void gtk_image_set_from_icon_name (GtkImage *image, const gchar *icon_name, GtkIconSize size);
subroutine gtk_image_set_from_icon_name(image, icon_name, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: image
  character(kind=c_char), dimension(*) :: icon_name
  integer(c_int), value :: size
end subroutine

! void gtk_image_set_from_gicon (GtkImage *image, GIcon *icon, GtkIconSize size);
subroutine gtk_image_set_from_gicon(image, icon, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: image
  type(c_ptr), value :: icon
  integer(c_int), value :: size
end subroutine

! void gtk_image_set_pixel_size (GtkImage *image, gint pixel_size);
subroutine gtk_image_set_pixel_size(image, pixel_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: image
  integer(c_int), value :: pixel_size
end subroutine

!  GtkImageType gtk_image_get_storage_type (GtkImage *image);
function gtk_image_get_storage_type(image) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_image_get_storage_type
  type(c_ptr), value :: image
end function

!  void gtk_image_get_pixmap (GtkImage *image, GdkPixmap **pixmap, GdkBitmap **mask);
subroutine gtk_image_get_pixmap(image, pixmap, mask) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: image
  type(c_ptr), value :: pixmap
  type(c_ptr), value :: mask
end subroutine

! void gtk_image_get_image (GtkImage *image, GdkImage **gdk_image, GdkBitmap **mask);
subroutine gtk_image_get_image(image, gdk_image, mask) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: image
  type(c_ptr), value :: gdk_image
  type(c_ptr), value :: mask
end subroutine

! GdkPixbuf* gtk_image_get_pixbuf (GtkImage *image);
function gtk_image_get_pixbuf(image) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_image_get_pixbuf
  type(c_ptr), value :: image
end function

! void gtk_image_get_stock (GtkImage *image, gchar **stock_id, GtkIconSize *size);
subroutine gtk_image_get_stock(image, stock_id, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: image
  character(kind=c_char), dimension(*) :: stock_id
  integer(c_int), value :: size
end subroutine

! void gtk_image_get_icon_set (GtkImage *image, GtkIconSet **icon_set, GtkIconSize *size);
subroutine gtk_image_get_icon_set(image, icon_set, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: image
  type(c_ptr), value :: icon_set
  integer(c_int), value :: size
end subroutine

! GdkPixbufAnimation* gtk_image_get_animation (GtkImage *image);
function gtk_image_get_animation(image) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_image_get_animation
  type(c_ptr), value :: image
end function

! void gtk_image_get_icon_name (GtkImage *image, G_CONST_RETURN gchar **icon_name, GtkIconSize *size);
subroutine gtk_image_get_icon_name(image, icon_name, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: image
  character(kind=c_char), dimension(*) :: icon_name
  integer(c_int), value :: size
end subroutine

! void gtk_image_get_gicon (GtkImage *image, GIcon **gicon, GtkIconSize *size);
subroutine gtk_image_get_gicon(image, gicon, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: image
  type(c_ptr), value :: gicon
  integer(c_int), value :: size
end subroutine

! gint gtk_image_get_pixel_size (GtkImage *image);
function gtk_image_get_pixel_size(image) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_image_get_pixel_size
  type(c_ptr), value :: image
end function

!  void gtk_image_set (GtkImage *image, GdkImage *val, GdkBitmap *mask);
subroutine gtk_image_set(image, val, mask) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: image
  type(c_ptr), value :: val
  type(c_ptr), value :: mask
end subroutine

! void gtk_image_get (GtkImage *image, GdkImage **val, GdkBitmap **mask);
subroutine gtk_image_get(image, val, mask) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: image
  type(c_ptr), value :: val
  type(c_ptr), value :: mask
end subroutine

!   GType gtk_preview_get_type (void) G_GNUC_CONST;
function gtk_preview_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_preview_get_type
end function

! void gtk_preview_uninit (void);
subroutine gtk_preview_uninit() bind(c) 
  use iso_c_binding, only: 
end subroutine

! GtkWidget* gtk_preview_new (GtkPreviewType type);
function gtk_preview_new(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_preview_new
  integer(c_int), value :: type
end function

! void gtk_preview_size (GtkPreview *preview, gint width, gint height);
subroutine gtk_preview_size(preview, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: preview
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_preview_put (GtkPreview *preview, GdkWindow *window, GdkGC *gc, gint srcx, gint srcy, gint destx, gint desty, gint width, gint height);
subroutine gtk_preview_put(preview, window, gc, srcx, srcy, destx, desty, width,&
      & height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: preview
  type(c_ptr), value :: window
  type(c_ptr), value :: gc
  integer(c_int), value :: srcx
  integer(c_int), value :: srcy
  integer(c_int), value :: destx
  integer(c_int), value :: desty
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_preview_draw_row (GtkPreview *preview, guchar *data, gint x, gint y, gint w);
subroutine gtk_preview_draw_row(preview, data, x, y, w) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: preview
  character(kind=c_char), dimension(*) :: data
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: w
end subroutine

! void gtk_preview_set_expand (GtkPreview *preview, gboolean expand);
subroutine gtk_preview_set_expand(preview, expand) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: preview
  logical(c_bool), value :: expand
end subroutine

!  void gtk_preview_set_gamma (double gamma_);
subroutine gtk_preview_set_gamma(gamma_) bind(c) 
  use iso_c_binding, only: c_double
  real(c_double), value :: gamma_
end subroutine

! void gtk_preview_set_color_cube (guint nred_shades, guint ngreen_shades, guint nblue_shades, guint ngray_shades);
subroutine gtk_preview_set_color_cube(nred_shades, ngreen_shades, nblue_shades, &
      &ngray_shades) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: nred_shades
  integer(c_int), value :: ngreen_shades
  integer(c_int), value :: nblue_shades
  integer(c_int), value :: ngray_shades
end subroutine

! void gtk_preview_set_install_cmap (gint install_cmap);
subroutine gtk_preview_set_install_cmap(install_cmap) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: install_cmap
end subroutine

! void gtk_preview_set_reserved (gint nreserved);
subroutine gtk_preview_set_reserved(nreserved) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: nreserved
end subroutine

! void gtk_preview_set_dither (GtkPreview *preview, GdkRgbDither dither);
subroutine gtk_preview_set_dither(preview, dither) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: preview
  integer(c_int), value :: dither
end subroutine

! GdkVisual* gtk_preview_get_visual (void);
function gtk_preview_get_visual() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_preview_get_visual
end function

! GdkColormap* gtk_preview_get_cmap (void);
function gtk_preview_get_cmap() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_preview_get_cmap
end function

! GtkPreviewInfo* gtk_preview_get_info (void);
function gtk_preview_get_info() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_preview_get_info
end function

!  void gtk_preview_reset (void);
subroutine gtk_preview_reset() bind(c) 
  use iso_c_binding, only: 
end subroutine

!   GType gtk_invisible_get_type (void) G_GNUC_CONST;
function gtk_invisible_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_invisible_get_type
end function

!  GtkWidget* gtk_invisible_new (void);
function gtk_invisible_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_invisible_new
end function

! GtkWidget* gtk_invisible_new_for_screen (GdkScreen *screen);
function gtk_invisible_new_for_screen(screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_invisible_new_for_screen
  type(c_ptr), value :: screen
end function

! void gtk_invisible_set_screen (GtkInvisible *invisible, GdkScreen *screen);
subroutine gtk_invisible_set_screen(invisible, screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: invisible
  type(c_ptr), value :: screen
end subroutine

! GdkScreen* gtk_invisible_get_screen (GtkInvisible *invisible);
function gtk_invisible_get_screen(invisible) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_invisible_get_screen
  type(c_ptr), value :: invisible
end function

!  void gtk_rc_add_default_file (const gchar *filename);
subroutine gtk_rc_add_default_file(filename) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: filename
end subroutine

! void gtk_rc_set_default_files (gchar **filenames);
subroutine gtk_rc_set_default_files(filenames) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: filenames
end subroutine

! gchar** gtk_rc_get_default_files (void);
function gtk_rc_get_default_files() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_rc_get_default_files
end function

! GtkStyle* gtk_rc_get_style (GtkWidget *widget);
function gtk_rc_get_style(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_rc_get_style
  type(c_ptr), value :: widget
end function

! GtkStyle* gtk_rc_get_style_by_paths (GtkSettings *settings, const char *widget_path, const char *class_path, GType type);
function gtk_rc_get_style_by_paths(settings, widget_path, class_path, type) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: gtk_rc_get_style_by_paths
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: widget_path
  character(kind=c_char), dimension(*) :: class_path
  integer(c_size_t), value :: type
end function

!  gboolean gtk_rc_reparse_all_for_settings (GtkSettings *settings, gboolean force_load);
function gtk_rc_reparse_all_for_settings(settings, force_load) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_rc_reparse_all_for_settings
  type(c_ptr), value :: settings
  logical(c_bool), value :: force_load
end function

! void gtk_rc_reset_styles (GtkSettings *settings);
subroutine gtk_rc_reset_styles(settings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: settings
end subroutine

!  gchar* gtk_rc_find_pixmap_in_path (GtkSettings *settings, GScanner *scanner, const gchar *pixmap_file);
function gtk_rc_find_pixmap_in_path(settings, scanner, pixmap_file) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_rc_find_pixmap_in_path
  type(c_ptr), value :: settings
  type(c_ptr), value :: scanner
  character(kind=c_char), dimension(*) :: pixmap_file
end function

!  void gtk_rc_parse (const gchar *filename);
subroutine gtk_rc_parse(filename) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: filename
end subroutine

! void gtk_rc_parse_string (const gchar *rc_string);
subroutine gtk_rc_parse_string(rc_string) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: rc_string
end subroutine

! gboolean gtk_rc_reparse_all (void);
function gtk_rc_reparse_all() bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool) :: gtk_rc_reparse_all
end function

!  void gtk_rc_add_widget_name_style (GtkRcStyle *rc_style, const gchar *pattern);
subroutine gtk_rc_add_widget_name_style(rc_style, pattern) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: rc_style
  character(kind=c_char), dimension(*) :: pattern
end subroutine

! void gtk_rc_add_widget_class_style (GtkRcStyle *rc_style, const gchar *pattern);
subroutine gtk_rc_add_widget_class_style(rc_style, pattern) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: rc_style
  character(kind=c_char), dimension(*) :: pattern
end subroutine

! void gtk_rc_add_class_style (GtkRcStyle *rc_style, const gchar *pattern);
subroutine gtk_rc_add_class_style(rc_style, pattern) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: rc_style
  character(kind=c_char), dimension(*) :: pattern
end subroutine

!  GType gtk_rc_style_get_type (void) G_GNUC_CONST;
function gtk_rc_style_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_rc_style_get_type
end function

! GtkRcStyle* gtk_rc_style_new (void);
function gtk_rc_style_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_rc_style_new
end function

! GtkRcStyle* gtk_rc_style_copy (GtkRcStyle *orig);
function gtk_rc_style_copy(orig) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_rc_style_copy
  type(c_ptr), value :: orig
end function

!  void gtk_rc_style_ref (GtkRcStyle *rc_style);
subroutine gtk_rc_style_ref(rc_style) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: rc_style
end subroutine

! void gtk_rc_style_unref (GtkRcStyle *rc_style);
subroutine gtk_rc_style_unref(rc_style) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: rc_style
end subroutine

!  gchar* gtk_rc_find_module_in_path (const gchar *module_file);
function gtk_rc_find_module_in_path(module_file) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_rc_find_module_in_path
  character(kind=c_char), dimension(*) :: module_file
end function

! gchar* gtk_rc_get_theme_dir (void);
function gtk_rc_get_theme_dir() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_rc_get_theme_dir
end function

! gchar* gtk_rc_get_module_dir (void);
function gtk_rc_get_module_dir() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_rc_get_module_dir
end function

! gchar* gtk_rc_get_im_module_path (void);
function gtk_rc_get_im_module_path() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_rc_get_im_module_path
end function

! gchar* gtk_rc_get_im_module_file (void);
function gtk_rc_get_im_module_file() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_rc_get_im_module_file
end function

!  GScanner* gtk_rc_scanner_new (void);
function gtk_rc_scanner_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_rc_scanner_new
end function

! guint gtk_rc_parse_color (GScanner *scanner, GdkColor *color);
function gtk_rc_parse_color(scanner, color) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_rc_parse_color
  type(c_ptr), value :: scanner
  type(c_ptr), value :: color
end function

! guint gtk_rc_parse_color_full (GScanner *scanner, GtkRcStyle *style, GdkColor *color);
function gtk_rc_parse_color_full(scanner, style, color) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_rc_parse_color_full
  type(c_ptr), value :: scanner
  type(c_ptr), value :: style
  type(c_ptr), value :: color
end function

! guint gtk_rc_parse_state (GScanner *scanner, GtkStateType *state);
function gtk_rc_parse_state(scanner, state) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_rc_parse_state
  type(c_ptr), value :: scanner
  integer(c_int), value :: state
end function

! guint gtk_rc_parse_priority (GScanner *scanner, GtkPathPriorityType *priority);
function gtk_rc_parse_priority(scanner, priority) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_rc_parse_priority
  type(c_ptr), value :: scanner
  integer(c_int), value :: priority
end function

!   GType gtk_color_button_get_type (void) G_GNUC_CONST;
function gtk_color_button_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_color_button_get_type
end function

! GtkWidget *gtk_color_button_new (void);
function gtk_color_button_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_color_button_new
end function

! GtkWidget *gtk_color_button_new_with_color (const GdkColor *color);
function gtk_color_button_new_with_color(color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_color_button_new_with_color
  type(c_ptr), value :: color
end function

! void gtk_color_button_set_color (GtkColorButton *color_button, const GdkColor *color);
subroutine gtk_color_button_set_color(color_button, color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: color_button
  type(c_ptr), value :: color
end subroutine

! void gtk_color_button_set_alpha (GtkColorButton *color_button, guint16 alpha);
subroutine gtk_color_button_set_alpha(color_button, alpha) bind(c) 
  use iso_c_binding, only: c_ptr, c_int16_t
  type(c_ptr), value :: color_button
  integer(c_int16_t), value :: alpha
end subroutine

! void gtk_color_button_get_color (GtkColorButton *color_button, GdkColor *color);
subroutine gtk_color_button_get_color(color_button, color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: color_button
  type(c_ptr), value :: color
end subroutine

! guint16 gtk_color_button_get_alpha (GtkColorButton *color_button);
function gtk_color_button_get_alpha(color_button) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: gtk_color_button_get_alpha
  type(c_ptr), value :: color_button
end function

! void gtk_color_button_set_use_alpha (GtkColorButton *color_button, gboolean use_alpha);
subroutine gtk_color_button_set_use_alpha(color_button, use_alpha) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: color_button
  logical(c_bool), value :: use_alpha
end subroutine

! gboolean gtk_color_button_get_use_alpha (GtkColorButton *color_button);
function gtk_color_button_get_use_alpha(color_button) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_color_button_get_use_alpha
  type(c_ptr), value :: color_button
end function

! void gtk_color_button_set_title (GtkColorButton *color_button, const gchar *title);
subroutine gtk_color_button_set_title(color_button, title) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: color_button
  character(kind=c_char), dimension(*) :: title
end subroutine

! G_CONST_RETURN gchar *gtk_color_button_get_title (GtkColorButton *color_button);
function gtk_color_button_get_title(color_button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_color_button_get_title
  type(c_ptr), value :: color_button
end function

!   GType gtk_entry_get_type (void) G_GNUC_CONST;
function gtk_entry_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_entry_get_type
end function

! GtkWidget* gtk_entry_new (void);
function gtk_entry_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_entry_new
end function

! GtkWidget* gtk_entry_new_with_buffer (GtkEntryBuffer *buffer);
function gtk_entry_new_with_buffer(buffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_entry_new_with_buffer
  type(c_ptr), value :: buffer
end function

!  GtkEntryBuffer* gtk_entry_get_buffer (GtkEntry *entry);
function gtk_entry_get_buffer(entry) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_entry_get_buffer
  type(c_ptr), value :: entry
end function

! void gtk_entry_set_buffer (GtkEntry *entry, GtkEntryBuffer *buffer);
subroutine gtk_entry_set_buffer(entry, buffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: entry
  type(c_ptr), value :: buffer
end subroutine

!  GdkWindow *gtk_entry_get_text_window (GtkEntry *entry);
function gtk_entry_get_text_window(entry) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_entry_get_text_window
  type(c_ptr), value :: entry
end function

!  void gtk_entry_set_visibility (GtkEntry *entry, gboolean visible);
subroutine gtk_entry_set_visibility(entry, visible) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: entry
  logical(c_bool), value :: visible
end subroutine

! gboolean gtk_entry_get_visibility (GtkEntry *entry);
function gtk_entry_get_visibility(entry) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_entry_get_visibility
  type(c_ptr), value :: entry
end function

!  void gtk_entry_set_invisible_char (GtkEntry *entry, gunichar ch);
subroutine gtk_entry_set_invisible_char(entry, ch) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: entry
  integer(c_int32_t), value :: ch
end subroutine

! gunichar gtk_entry_get_invisible_char (GtkEntry *entry);
function gtk_entry_get_invisible_char(entry) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: gtk_entry_get_invisible_char
  type(c_ptr), value :: entry
end function

! void gtk_entry_unset_invisible_char (GtkEntry *entry);
subroutine gtk_entry_unset_invisible_char(entry) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: entry
end subroutine

!  void gtk_entry_set_has_frame (GtkEntry *entry, gboolean setting);
subroutine gtk_entry_set_has_frame(entry, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: entry
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_entry_get_has_frame (GtkEntry *entry);
function gtk_entry_get_has_frame(entry) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_entry_get_has_frame
  type(c_ptr), value :: entry
end function

!  void gtk_entry_set_inner_border (GtkEntry *entry, const GtkBorder *border);
subroutine gtk_entry_set_inner_border(entry, border) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: entry
  type(c_ptr), value :: border
end subroutine

! G_CONST_RETURN GtkBorder* gtk_entry_get_inner_border (GtkEntry *entry);
function gtk_entry_get_inner_border(entry) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_entry_get_inner_border
  type(c_ptr), value :: entry
end function

!  void gtk_entry_set_overwrite_mode (GtkEntry *entry, gboolean overwrite);
subroutine gtk_entry_set_overwrite_mode(entry, overwrite) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: entry
  logical(c_bool), value :: overwrite
end subroutine

! gboolean gtk_entry_get_overwrite_mode (GtkEntry *entry);
function gtk_entry_get_overwrite_mode(entry) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_entry_get_overwrite_mode
  type(c_ptr), value :: entry
end function

!  void gtk_entry_set_max_length (GtkEntry *entry, gint max);
subroutine gtk_entry_set_max_length(entry, max) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: entry
  integer(c_int), value :: max
end subroutine

! gint gtk_entry_get_max_length (GtkEntry *entry);
function gtk_entry_get_max_length(entry) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_entry_get_max_length
  type(c_ptr), value :: entry
end function

! guint16 gtk_entry_get_text_length (GtkEntry *entry);
function gtk_entry_get_text_length(entry) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: gtk_entry_get_text_length
  type(c_ptr), value :: entry
end function

!  void gtk_entry_set_activates_default (GtkEntry *entry, gboolean setting);
subroutine gtk_entry_set_activates_default(entry, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: entry
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_entry_get_activates_default (GtkEntry *entry);
function gtk_entry_get_activates_default(entry) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_entry_get_activates_default
  type(c_ptr), value :: entry
end function

!  void gtk_entry_set_width_chars (GtkEntry *entry, gint n_chars);
subroutine gtk_entry_set_width_chars(entry, n_chars) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: entry
  integer(c_int), value :: n_chars
end subroutine

! gint gtk_entry_get_width_chars (GtkEntry *entry);
function gtk_entry_get_width_chars(entry) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_entry_get_width_chars
  type(c_ptr), value :: entry
end function

!  void gtk_entry_set_text (GtkEntry *entry, const gchar *text);
subroutine gtk_entry_set_text(entry, text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: entry
  character(kind=c_char), dimension(*) :: text
end subroutine

!  G_CONST_RETURN gchar* gtk_entry_get_text (GtkEntry *entry);
function gtk_entry_get_text(entry) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_entry_get_text
  type(c_ptr), value :: entry
end function

!  PangoLayout* gtk_entry_get_layout (GtkEntry *entry);
function gtk_entry_get_layout(entry) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_entry_get_layout
  type(c_ptr), value :: entry
end function

! void gtk_entry_get_layout_offsets (GtkEntry *entry, gint *x, gint *y);
subroutine gtk_entry_get_layout_offsets(entry, x, y) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: entry
  type(c_ptr), value :: x
  type(c_ptr), value :: y
end subroutine

! void gtk_entry_set_alignment (GtkEntry *entry, gfloat xalign);
subroutine gtk_entry_set_alignment(entry, xalign) bind(c) 
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: entry
  real(c_float), value :: xalign
end subroutine

! gfloat gtk_entry_get_alignment (GtkEntry *entry);
function gtk_entry_get_alignment(entry) bind(c) 
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: gtk_entry_get_alignment
  type(c_ptr), value :: entry
end function

!  void gtk_entry_set_completion (GtkEntry *entry, GtkEntryCompletion *completion);
subroutine gtk_entry_set_completion(entry, completion) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: entry
  type(c_ptr), value :: completion
end subroutine

! GtkEntryCompletion *gtk_entry_get_completion (GtkEntry *entry);
function gtk_entry_get_completion(entry) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_entry_get_completion
  type(c_ptr), value :: entry
end function

!  gint gtk_entry_layout_index_to_text_index (GtkEntry *entry, gint layout_index);
function gtk_entry_layout_index_to_text_index(entry, layout_index) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_entry_layout_index_to_text_index
  type(c_ptr), value :: entry
  integer(c_int), value :: layout_index
end function

! gint gtk_entry_text_index_to_layout_index (GtkEntry *entry, gint text_index);
function gtk_entry_text_index_to_layout_index(entry, text_index) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_entry_text_index_to_layout_index
  type(c_ptr), value :: entry
  integer(c_int), value :: text_index
end function

!  void gtk_entry_set_cursor_hadjustment (GtkEntry *entry, GtkAdjustment *adjustment);
subroutine gtk_entry_set_cursor_hadjustment(entry, adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: entry
  type(c_ptr), value :: adjustment
end subroutine

! GtkAdjustment* gtk_entry_get_cursor_hadjustment (GtkEntry *entry);
function gtk_entry_get_cursor_hadjustment(entry) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_entry_get_cursor_hadjustment
  type(c_ptr), value :: entry
end function

!  void gtk_entry_set_progress_fraction (GtkEntry *entry, gdouble fraction);
subroutine gtk_entry_set_progress_fraction(entry, fraction) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: entry
  real(c_double), value :: fraction
end subroutine

! gdouble gtk_entry_get_progress_fraction (GtkEntry *entry);
function gtk_entry_get_progress_fraction(entry) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_entry_get_progress_fraction
  type(c_ptr), value :: entry
end function

!  void gtk_entry_set_progress_pulse_step (GtkEntry *entry, gdouble fraction);
subroutine gtk_entry_set_progress_pulse_step(entry, fraction) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: entry
  real(c_double), value :: fraction
end subroutine

! gdouble gtk_entry_get_progress_pulse_step (GtkEntry *entry);
function gtk_entry_get_progress_pulse_step(entry) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_entry_get_progress_pulse_step
  type(c_ptr), value :: entry
end function

!  void gtk_entry_progress_pulse (GtkEntry *entry);
subroutine gtk_entry_progress_pulse(entry) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: entry
end subroutine

!  void gtk_entry_set_icon_from_pixbuf (GtkEntry *entry, GtkEntryIconPosition icon_pos, GdkPixbuf *pixbuf);
subroutine gtk_entry_set_icon_from_pixbuf(entry, icon_pos, pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: entry
  integer(c_int), value :: icon_pos
  type(c_ptr), value :: pixbuf
end subroutine

! void gtk_entry_set_icon_from_stock (GtkEntry *entry, GtkEntryIconPosition icon_pos, const gchar *stock_id);
subroutine gtk_entry_set_icon_from_stock(entry, icon_pos, stock_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: entry
  integer(c_int), value :: icon_pos
  character(kind=c_char), dimension(*) :: stock_id
end subroutine

! void gtk_entry_set_icon_from_icon_name (GtkEntry *entry, GtkEntryIconPosition icon_pos, const gchar *icon_name);
subroutine gtk_entry_set_icon_from_icon_name(entry, icon_pos, icon_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: entry
  integer(c_int), value :: icon_pos
  character(kind=c_char), dimension(*) :: icon_name
end subroutine

! void gtk_entry_set_icon_from_gicon (GtkEntry *entry, GtkEntryIconPosition icon_pos, GIcon *icon);
subroutine gtk_entry_set_icon_from_gicon(entry, icon_pos, icon) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: entry
  integer(c_int), value :: icon_pos
  type(c_ptr), value :: icon
end subroutine

! GtkImageType gtk_entry_get_icon_storage_type (GtkEntry *entry, GtkEntryIconPosition icon_pos);
function gtk_entry_get_icon_storage_type(entry, icon_pos) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_entry_get_icon_storage_type
  type(c_ptr), value :: entry
  integer(c_int), value :: icon_pos
end function

! GdkPixbuf* gtk_entry_get_icon_pixbuf (GtkEntry *entry, GtkEntryIconPosition icon_pos);
function gtk_entry_get_icon_pixbuf(entry, icon_pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_entry_get_icon_pixbuf
  type(c_ptr), value :: entry
  integer(c_int), value :: icon_pos
end function

! const gchar* gtk_entry_get_icon_stock (GtkEntry *entry, GtkEntryIconPosition icon_pos);
function gtk_entry_get_icon_stock(entry, icon_pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_entry_get_icon_stock
  type(c_ptr), value :: entry
  integer(c_int), value :: icon_pos
end function

! const gchar* gtk_entry_get_icon_name (GtkEntry *entry, GtkEntryIconPosition icon_pos);
function gtk_entry_get_icon_name(entry, icon_pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_entry_get_icon_name
  type(c_ptr), value :: entry
  integer(c_int), value :: icon_pos
end function

! GIcon* gtk_entry_get_icon_gicon (GtkEntry *entry, GtkEntryIconPosition icon_pos);
function gtk_entry_get_icon_gicon(entry, icon_pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_entry_get_icon_gicon
  type(c_ptr), value :: entry
  integer(c_int), value :: icon_pos
end function

! void gtk_entry_set_icon_activatable (GtkEntry *entry, GtkEntryIconPosition icon_pos, gboolean activatable);
subroutine gtk_entry_set_icon_activatable(entry, icon_pos, activatable) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr), value :: entry
  integer(c_int), value :: icon_pos
  logical(c_bool), value :: activatable
end subroutine

! gboolean gtk_entry_get_icon_activatable (GtkEntry *entry, GtkEntryIconPosition icon_pos);
function gtk_entry_get_icon_activatable(entry, icon_pos) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_entry_get_icon_activatable
  type(c_ptr), value :: entry
  integer(c_int), value :: icon_pos
end function

! void gtk_entry_set_icon_sensitive (GtkEntry *entry, GtkEntryIconPosition icon_pos, gboolean sensitive);
subroutine gtk_entry_set_icon_sensitive(entry, icon_pos, sensitive) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr), value :: entry
  integer(c_int), value :: icon_pos
  logical(c_bool), value :: sensitive
end subroutine

! gboolean gtk_entry_get_icon_sensitive (GtkEntry *entry, GtkEntryIconPosition icon_pos);
function gtk_entry_get_icon_sensitive(entry, icon_pos) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_entry_get_icon_sensitive
  type(c_ptr), value :: entry
  integer(c_int), value :: icon_pos
end function

! gint gtk_entry_get_icon_at_pos (GtkEntry *entry, gint x, gint y);
function gtk_entry_get_icon_at_pos(entry, x, y) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_entry_get_icon_at_pos
  type(c_ptr), value :: entry
  integer(c_int), value :: x
  integer(c_int), value :: y
end function

! void gtk_entry_set_icon_tooltip_text (GtkEntry *entry, GtkEntryIconPosition icon_pos, const gchar *tooltip);
subroutine gtk_entry_set_icon_tooltip_text(entry, icon_pos, tooltip) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: entry
  integer(c_int), value :: icon_pos
  character(kind=c_char), dimension(*) :: tooltip
end subroutine

! gchar * gtk_entry_get_icon_tooltip_text (GtkEntry *entry, GtkEntryIconPosition icon_pos);
function gtk_entry_get_icon_tooltip_text(entry, icon_pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_entry_get_icon_tooltip_text
  type(c_ptr), value :: entry
  integer(c_int), value :: icon_pos
end function

! void gtk_entry_set_icon_tooltip_markup (GtkEntry *entry, GtkEntryIconPosition icon_pos, const gchar *tooltip);
subroutine gtk_entry_set_icon_tooltip_markup(entry, icon_pos, tooltip) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: entry
  integer(c_int), value :: icon_pos
  character(kind=c_char), dimension(*) :: tooltip
end subroutine

! gchar * gtk_entry_get_icon_tooltip_markup (GtkEntry *entry, GtkEntryIconPosition icon_pos);
function gtk_entry_get_icon_tooltip_markup(entry, icon_pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_entry_get_icon_tooltip_markup
  type(c_ptr), value :: entry
  integer(c_int), value :: icon_pos
end function

! void gtk_entry_set_icon_drag_source (GtkEntry *entry, GtkEntryIconPosition icon_pos, GtkTargetList *target_list, GdkDragAction actions);
subroutine gtk_entry_set_icon_drag_source(entry, icon_pos, target_list, actions)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: entry
  integer(c_int), value :: icon_pos
  type(c_ptr), value :: target_list
  integer(c_int), value :: actions
end subroutine

! gint gtk_entry_get_current_icon_drag_source (GtkEntry *entry);
function gtk_entry_get_current_icon_drag_source(entry) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_entry_get_current_icon_drag_source
  type(c_ptr), value :: entry
end function

!  GdkWindow * gtk_entry_get_icon_window (GtkEntry *entry, GtkEntryIconPosition icon_pos);
function gtk_entry_get_icon_window(entry, icon_pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_entry_get_icon_window
  type(c_ptr), value :: entry
  integer(c_int), value :: icon_pos
end function

!  gboolean gtk_entry_im_context_filter_keypress (GtkEntry *entry, GdkEventKey *event);
function gtk_entry_im_context_filter_keypress(entry, event) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_entry_im_context_filter_keypress
  type(c_ptr), value :: entry
  type(c_ptr), value :: event
end function

! void gtk_entry_reset_im_context (GtkEntry *entry);
subroutine gtk_entry_reset_im_context(entry) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: entry
end subroutine

!  GtkWidget* gtk_entry_new_with_max_length (gint max);
function gtk_entry_new_with_max_length(max) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_entry_new_with_max_length
  integer(c_int), value :: max
end function

! void gtk_entry_append_text (GtkEntry *entry, const gchar *text);
subroutine gtk_entry_append_text(entry, text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: entry
  character(kind=c_char), dimension(*) :: text
end subroutine

! void gtk_entry_prepend_text (GtkEntry *entry, const gchar *text);
subroutine gtk_entry_prepend_text(entry, text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: entry
  character(kind=c_char), dimension(*) :: text
end subroutine

! void gtk_entry_set_position (GtkEntry *entry, gint position);
subroutine gtk_entry_set_position(entry, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: entry
  integer(c_int), value :: position
end subroutine

! void gtk_entry_select_region (GtkEntry *entry, gint start, gint end);
subroutine gtk_entry_select_region(entry, start, end) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: entry
  integer(c_int), value :: start
  integer(c_int), value :: end
end subroutine

! void gtk_entry_set_editable (GtkEntry *entry, gboolean editable);
subroutine gtk_entry_set_editable(entry, editable) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: entry
  logical(c_bool), value :: editable
end subroutine

!   GType gtk_separator_menu_item_get_type (void) G_GNUC_CONST;
function gtk_separator_menu_item_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_separator_menu_item_get_type
end function

! GtkWidget* gtk_separator_menu_item_new (void);
function gtk_separator_menu_item_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_separator_menu_item_new
end function

!   GType gtk_spinner_get_type (void) G_GNUC_CONST;
function gtk_spinner_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_spinner_get_type
end function

! GtkWidget *gtk_spinner_new (void);
function gtk_spinner_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_spinner_new
end function

! void gtk_spinner_start (GtkSpinner *spinner);
subroutine gtk_spinner_start(spinner) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: spinner
end subroutine

! void gtk_spinner_stop (GtkSpinner *spinner);
subroutine gtk_spinner_stop(spinner) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: spinner
end subroutine

!   GType gtk_text_tag_table_get_type (void) G_GNUC_CONST;
function gtk_text_tag_table_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_text_tag_table_get_type
end function

!  GtkTextTagTable *gtk_text_tag_table_new (void);
function gtk_text_tag_table_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_tag_table_new
end function

! void gtk_text_tag_table_add (GtkTextTagTable *table, GtkTextTag *tag);
subroutine gtk_text_tag_table_add(table, tag) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: table
  type(c_ptr), value :: tag
end subroutine

! void gtk_text_tag_table_remove (GtkTextTagTable *table, GtkTextTag *tag);
subroutine gtk_text_tag_table_remove(table, tag) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: table
  type(c_ptr), value :: tag
end subroutine

! GtkTextTag *gtk_text_tag_table_lookup (GtkTextTagTable *table, const gchar *name);
function gtk_text_tag_table_lookup(table, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_text_tag_table_lookup
  type(c_ptr), value :: table
  character(kind=c_char), dimension(*) :: name
end function

! void gtk_text_tag_table_foreach (GtkTextTagTable *table, GtkTextTagTableForeach func, gpointer data);
subroutine gtk_text_tag_table_foreach(table, func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: table
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end subroutine

! gint gtk_text_tag_table_get_size (GtkTextTagTable *table);
function gtk_text_tag_table_get_size(table) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_tag_table_get_size
  type(c_ptr), value :: table
end function

!   GType gtk_color_selection_dialog_get_type (void) G_GNUC_CONST;
function gtk_color_selection_dialog_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_color_selection_dialog_get_type
end function

! GtkWidget* gtk_color_selection_dialog_new (const gchar *title);
function gtk_color_selection_dialog_new(title) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_color_selection_dialog_new
  character(kind=c_char), dimension(*) :: title
end function

! GtkWidget* gtk_color_selection_dialog_get_color_selection (GtkColorSelectionDialog *colorsel);
function gtk_color_selection_dialog_get_color_selection(colorsel) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_color_selection_dialog_get_color_selection
  type(c_ptr), value :: colorsel
end function

!   GType gtk_layout_get_type (void) G_GNUC_CONST;
function gtk_layout_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_layout_get_type
end function

! GtkWidget* gtk_layout_new (GtkAdjustment *hadjustment, GtkAdjustment *vadjustment);
function gtk_layout_new(hadjustment, vadjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_layout_new
  type(c_ptr), value :: hadjustment
  type(c_ptr), value :: vadjustment
end function

! GdkWindow* gtk_layout_get_bin_window (GtkLayout *layout);
function gtk_layout_get_bin_window(layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_layout_get_bin_window
  type(c_ptr), value :: layout
end function

! void gtk_layout_put (GtkLayout *layout, GtkWidget *child_widget, gint x, gint y);
subroutine gtk_layout_put(layout, child_widget, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  type(c_ptr), value :: child_widget
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

!  void gtk_layout_move (GtkLayout *layout, GtkWidget *child_widget, gint x, gint y);
subroutine gtk_layout_move(layout, child_widget, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  type(c_ptr), value :: child_widget
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

!  void gtk_layout_set_size (GtkLayout *layout, guint width, guint height);
subroutine gtk_layout_set_size(layout, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_layout_get_size (GtkLayout *layout, guint *width, guint *height);
subroutine gtk_layout_get_size(layout, width, height) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: width
  type(c_ptr), value :: height
end subroutine

!  GtkAdjustment* gtk_layout_get_hadjustment (GtkLayout *layout);
function gtk_layout_get_hadjustment(layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_layout_get_hadjustment
  type(c_ptr), value :: layout
end function

! GtkAdjustment* gtk_layout_get_vadjustment (GtkLayout *layout);
function gtk_layout_get_vadjustment(layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_layout_get_vadjustment
  type(c_ptr), value :: layout
end function

! void gtk_layout_set_hadjustment (GtkLayout *layout, GtkAdjustment *adjustment);
subroutine gtk_layout_set_hadjustment(layout, adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: adjustment
end subroutine

! void gtk_layout_set_vadjustment (GtkLayout *layout, GtkAdjustment *adjustment);
subroutine gtk_layout_set_vadjustment(layout, adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: adjustment
end subroutine

!  void gtk_layout_freeze (GtkLayout *layout);
subroutine gtk_layout_freeze(layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
end subroutine

! void gtk_layout_thaw (GtkLayout *layout);
subroutine gtk_layout_thaw(layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
end subroutine

!   GType gtk_tree_view_get_type (void) G_GNUC_CONST;
function gtk_tree_view_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_view_get_type
end function

! GtkWidget *gtk_tree_view_new (void);
function gtk_tree_view_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_view_new
end function

! GtkWidget *gtk_tree_view_new_with_model (GtkTreeModel *model);
function gtk_tree_view_new_with_model(model) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_view_new_with_model
  type(c_ptr), value :: model
end function

!  GtkTreeModel *gtk_tree_view_get_model (GtkTreeView *tree_view);
function gtk_tree_view_get_model(tree_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_view_get_model
  type(c_ptr), value :: tree_view
end function

! void gtk_tree_view_set_model (GtkTreeView *tree_view, GtkTreeModel *model);
subroutine gtk_tree_view_set_model(tree_view, model) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: model
end subroutine

! GtkTreeSelection *gtk_tree_view_get_selection (GtkTreeView *tree_view);
function gtk_tree_view_get_selection(tree_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_view_get_selection
  type(c_ptr), value :: tree_view
end function

! GtkAdjustment *gtk_tree_view_get_hadjustment (GtkTreeView *tree_view);
function gtk_tree_view_get_hadjustment(tree_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_view_get_hadjustment
  type(c_ptr), value :: tree_view
end function

! void gtk_tree_view_set_hadjustment (GtkTreeView *tree_view, GtkAdjustment *adjustment);
subroutine gtk_tree_view_set_hadjustment(tree_view, adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: adjustment
end subroutine

! GtkAdjustment *gtk_tree_view_get_vadjustment (GtkTreeView *tree_view);
function gtk_tree_view_get_vadjustment(tree_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_view_get_vadjustment
  type(c_ptr), value :: tree_view
end function

! void gtk_tree_view_set_vadjustment (GtkTreeView *tree_view, GtkAdjustment *adjustment);
subroutine gtk_tree_view_set_vadjustment(tree_view, adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: adjustment
end subroutine

! gboolean gtk_tree_view_get_headers_visible (GtkTreeView *tree_view);
function gtk_tree_view_get_headers_visible(tree_view) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_get_headers_visible
  type(c_ptr), value :: tree_view
end function

! void gtk_tree_view_set_headers_visible (GtkTreeView *tree_view, gboolean headers_visible);
subroutine gtk_tree_view_set_headers_visible(tree_view, headers_visible) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_view
  logical(c_bool), value :: headers_visible
end subroutine

! void gtk_tree_view_columns_autosize (GtkTreeView *tree_view);
subroutine gtk_tree_view_columns_autosize(tree_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_view
end subroutine

! gboolean gtk_tree_view_get_headers_clickable (GtkTreeView *tree_view);
function gtk_tree_view_get_headers_clickable(tree_view) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_get_headers_clickable
  type(c_ptr), value :: tree_view
end function

! void gtk_tree_view_set_headers_clickable (GtkTreeView *tree_view, gboolean setting);
subroutine gtk_tree_view_set_headers_clickable(tree_view, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_view
  logical(c_bool), value :: setting
end subroutine

! void gtk_tree_view_set_rules_hint (GtkTreeView *tree_view, gboolean setting);
subroutine gtk_tree_view_set_rules_hint(tree_view, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_view
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_tree_view_get_rules_hint (GtkTreeView *tree_view);
function gtk_tree_view_get_rules_hint(tree_view) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_get_rules_hint
  type(c_ptr), value :: tree_view
end function

!  gint gtk_tree_view_append_column (GtkTreeView *tree_view, GtkTreeViewColumn *column);
function gtk_tree_view_append_column(tree_view, column) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_view_append_column
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: column
end function

! gint gtk_tree_view_remove_column (GtkTreeView *tree_view, GtkTreeViewColumn *column);
function gtk_tree_view_remove_column(tree_view, column) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_view_remove_column
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: column
end function

! gint gtk_tree_view_insert_column (GtkTreeView *tree_view, GtkTreeViewColumn *column, gint position);
function gtk_tree_view_insert_column(tree_view, column, position) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_view_insert_column
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: column
  integer(c_int), value :: position
end function

! gint gtk_tree_view_insert_column_with_data_func (GtkTreeView *tree_view, gint position, const gchar *title, GtkCellRenderer *cell, GtkTreeCellDataFunc func, gpointer data, GDestroyNotify dnotify);
function gtk_tree_view_insert_column_with_data_func(tree_view, position, title, &
      &cell, func, data, dnotify) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_funptr
  integer(c_int) :: gtk_tree_view_insert_column_with_data_func
  type(c_ptr), value :: tree_view
  integer(c_int), value :: position
  character(kind=c_char), dimension(*) :: title
  type(c_ptr), value :: cell
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: dnotify
end function

! GtkTreeViewColumn *gtk_tree_view_get_column (GtkTreeView *tree_view, gint n);
function gtk_tree_view_get_column(tree_view, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_tree_view_get_column
  type(c_ptr), value :: tree_view
  integer(c_int), value :: n
end function

! GList *gtk_tree_view_get_columns (GtkTreeView *tree_view);
function gtk_tree_view_get_columns(tree_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_view_get_columns
  type(c_ptr), value :: tree_view
end function

! void gtk_tree_view_move_column_after (GtkTreeView *tree_view, GtkTreeViewColumn *column, GtkTreeViewColumn *base_column);
subroutine gtk_tree_view_move_column_after(tree_view, column, base_column) bind(&
      &c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: column
  type(c_ptr), value :: base_column
end subroutine

! void gtk_tree_view_set_expander_column (GtkTreeView *tree_view, GtkTreeViewColumn *column);
subroutine gtk_tree_view_set_expander_column(tree_view, column) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: column
end subroutine

! GtkTreeViewColumn *gtk_tree_view_get_expander_column (GtkTreeView *tree_view);
function gtk_tree_view_get_expander_column(tree_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_view_get_expander_column
  type(c_ptr), value :: tree_view
end function

! void gtk_tree_view_set_column_drag_function (GtkTreeView *tree_view, GtkTreeViewColumnDropFunc func, gpointer user_data, GDestroyNotify destroy);
subroutine gtk_tree_view_set_column_drag_function(tree_view, func, user_data, de&
      &stroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: tree_view
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy
end subroutine

!  void gtk_tree_view_scroll_to_point (GtkTreeView *tree_view, gint tree_x, gint tree_y);
subroutine gtk_tree_view_scroll_to_point(tree_view, tree_x, tree_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_view
  integer(c_int), value :: tree_x
  integer(c_int), value :: tree_y
end subroutine

! void gtk_tree_view_scroll_to_cell (GtkTreeView *tree_view, GtkTreePath *path, GtkTreeViewColumn *column, gboolean use_align, gfloat row_align, gfloat col_align);
subroutine gtk_tree_view_scroll_to_cell(tree_view, path, column, use_align, row_&
      &align, col_align) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_float
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: path
  type(c_ptr), value :: column
  logical(c_bool), value :: use_align
  real(c_float), value :: row_align
  real(c_float), value :: col_align
end subroutine

! void gtk_tree_view_row_activated (GtkTreeView *tree_view, GtkTreePath *path, GtkTreeViewColumn *column);
subroutine gtk_tree_view_row_activated(tree_view, path, column) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: path
  type(c_ptr), value :: column
end subroutine

! void gtk_tree_view_expand_all (GtkTreeView *tree_view);
subroutine gtk_tree_view_expand_all(tree_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_view
end subroutine

! void gtk_tree_view_collapse_all (GtkTreeView *tree_view);
subroutine gtk_tree_view_collapse_all(tree_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_view
end subroutine

! void gtk_tree_view_expand_to_path (GtkTreeView *tree_view, GtkTreePath *path);
subroutine gtk_tree_view_expand_to_path(tree_view, path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: path
end subroutine

! gboolean gtk_tree_view_expand_row (GtkTreeView *tree_view, GtkTreePath *path, gboolean open_all);
function gtk_tree_view_expand_row(tree_view, path, open_all) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_expand_row
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: path
  logical(c_bool), value :: open_all
end function

! gboolean gtk_tree_view_collapse_row (GtkTreeView *tree_view, GtkTreePath *path);
function gtk_tree_view_collapse_row(tree_view, path) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_collapse_row
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: path
end function

! void gtk_tree_view_map_expanded_rows (GtkTreeView *tree_view, GtkTreeViewMappingFunc func, gpointer data);
subroutine gtk_tree_view_map_expanded_rows(tree_view, func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: tree_view
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end subroutine

! gboolean gtk_tree_view_row_expanded (GtkTreeView *tree_view, GtkTreePath *path);
function gtk_tree_view_row_expanded(tree_view, path) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_row_expanded
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: path
end function

! void gtk_tree_view_set_reorderable (GtkTreeView *tree_view, gboolean reorderable);
subroutine gtk_tree_view_set_reorderable(tree_view, reorderable) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_view
  logical(c_bool), value :: reorderable
end subroutine

! gboolean gtk_tree_view_get_reorderable (GtkTreeView *tree_view);
function gtk_tree_view_get_reorderable(tree_view) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_get_reorderable
  type(c_ptr), value :: tree_view
end function

! void gtk_tree_view_set_cursor (GtkTreeView *tree_view, GtkTreePath *path, GtkTreeViewColumn *focus_column, gboolean start_editing);
subroutine gtk_tree_view_set_cursor(tree_view, path, focus_column, start_editing&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: path
  type(c_ptr), value :: focus_column
  logical(c_bool), value :: start_editing
end subroutine

! void gtk_tree_view_set_cursor_on_cell (GtkTreeView *tree_view, GtkTreePath *path, GtkTreeViewColumn *focus_column, GtkCellRenderer *focus_cell, gboolean start_editing);
subroutine gtk_tree_view_set_cursor_on_cell(tree_view, path, focus_column, focus&
      &_cell, start_editing) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: path
  type(c_ptr), value :: focus_column
  type(c_ptr), value :: focus_cell
  logical(c_bool), value :: start_editing
end subroutine

! void gtk_tree_view_get_cursor (GtkTreeView *tree_view, GtkTreePath **path, GtkTreeViewColumn **focus_column);
subroutine gtk_tree_view_get_cursor(tree_view, path, focus_column) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: path
  type(c_ptr), value :: focus_column
end subroutine

!  GdkWindow *gtk_tree_view_get_bin_window (GtkTreeView *tree_view);
function gtk_tree_view_get_bin_window(tree_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_view_get_bin_window
  type(c_ptr), value :: tree_view
end function

! gboolean gtk_tree_view_get_path_at_pos (GtkTreeView *tree_view, gint x, gint y, GtkTreePath **path, GtkTreeViewColumn **column, gint *cell_x, gint *cell_y);
function gtk_tree_view_get_path_at_pos(tree_view, x, y, path, column, cell_x, ce&
      &ll_y) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_tree_view_get_path_at_pos
  type(c_ptr), value :: tree_view
  integer(c_int), value :: x
  integer(c_int), value :: y
  type(c_ptr), value :: path
  type(c_ptr), value :: column
  type(c_ptr), value :: cell_x
  type(c_ptr), value :: cell_y
end function

! void gtk_tree_view_get_cell_area (GtkTreeView *tree_view, GtkTreePath *path, GtkTreeViewColumn *column, GdkRectangle *rect);
subroutine gtk_tree_view_get_cell_area(tree_view, path, column, rect) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: path
  type(c_ptr), value :: column
  type(c_ptr), value :: rect
end subroutine

! void gtk_tree_view_get_background_area (GtkTreeView *tree_view, GtkTreePath *path, GtkTreeViewColumn *column, GdkRectangle *rect);
subroutine gtk_tree_view_get_background_area(tree_view, path, column, rect) bind&
      &(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: path
  type(c_ptr), value :: column
  type(c_ptr), value :: rect
end subroutine

! void gtk_tree_view_get_visible_rect (GtkTreeView *tree_view, GdkRectangle *visible_rect);
subroutine gtk_tree_view_get_visible_rect(tree_view, visible_rect) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: visible_rect
end subroutine

!  void gtk_tree_view_widget_to_tree_coords (GtkTreeView *tree_view, gint wx, gint wy, gint *tx, gint *ty);
subroutine gtk_tree_view_widget_to_tree_coords(tree_view, wx, wy, tx, ty) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_view
  integer(c_int), value :: wx
  integer(c_int), value :: wy
  type(c_ptr), value :: tx
  type(c_ptr), value :: ty
end subroutine

! void gtk_tree_view_tree_to_widget_coords (GtkTreeView *tree_view, gint tx, gint ty, gint *wx, gint *wy);
subroutine gtk_tree_view_tree_to_widget_coords(tree_view, tx, ty, wx, wy) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_view
  integer(c_int), value :: tx
  integer(c_int), value :: ty
  type(c_ptr), value :: wx
  type(c_ptr), value :: wy
end subroutine

!  gboolean gtk_tree_view_get_visible_range (GtkTreeView *tree_view, GtkTreePath **start_path, GtkTreePath **end_path);
function gtk_tree_view_get_visible_range(tree_view, start_path, end_path) bind(c&
      &) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_get_visible_range
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: start_path
  type(c_ptr), value :: end_path
end function

!  void gtk_tree_view_enable_model_drag_source (GtkTreeView *tree_view, GdkModifierType start_button_mask, const GtkTargetEntry *targets, gint n_targets, GdkDragAction actions);
subroutine gtk_tree_view_enable_model_drag_source(tree_view, start_button_mask, &
      &targets, n_targets, actions) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_view
  integer(c_int), value :: start_button_mask
  type(c_ptr), value :: targets
  integer(c_int), value :: n_targets
  integer(c_int), value :: actions
end subroutine

! void gtk_tree_view_enable_model_drag_dest (GtkTreeView *tree_view, const GtkTargetEntry *targets, gint n_targets, GdkDragAction actions);
subroutine gtk_tree_view_enable_model_drag_dest(tree_view, targets, n_targets, a&
      &ctions) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: targets
  integer(c_int), value :: n_targets
  integer(c_int), value :: actions
end subroutine

! void gtk_tree_view_unset_rows_drag_source (GtkTreeView *tree_view);
subroutine gtk_tree_view_unset_rows_drag_source(tree_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_view
end subroutine

! void gtk_tree_view_unset_rows_drag_dest (GtkTreeView *tree_view);
subroutine gtk_tree_view_unset_rows_drag_dest(tree_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_view
end subroutine

!  void gtk_tree_view_set_drag_dest_row (GtkTreeView *tree_view, GtkTreePath *path, GtkTreeViewDropPosition pos);
subroutine gtk_tree_view_set_drag_dest_row(tree_view, path, pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: path
  integer(c_int), value :: pos
end subroutine

! void gtk_tree_view_get_drag_dest_row (GtkTreeView *tree_view, GtkTreePath **path, GtkTreeViewDropPosition *pos);
subroutine gtk_tree_view_get_drag_dest_row(tree_view, path, pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: path
  integer(c_int), value :: pos
end subroutine

! gboolean gtk_tree_view_get_dest_row_at_pos (GtkTreeView *tree_view, gint drag_x, gint drag_y, GtkTreePath **path, GtkTreeViewDropPosition *pos);
function gtk_tree_view_get_dest_row_at_pos(tree_view, drag_x, drag_y, path, pos)&
      & bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_tree_view_get_dest_row_at_pos
  type(c_ptr), value :: tree_view
  integer(c_int), value :: drag_x
  integer(c_int), value :: drag_y
  type(c_ptr), value :: path
  integer(c_int), value :: pos
end function

! GdkPixmap *gtk_tree_view_create_row_drag_icon (GtkTreeView *tree_view, GtkTreePath *path);
function gtk_tree_view_create_row_drag_icon(tree_view, path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_view_create_row_drag_icon
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: path
end function

!  void gtk_tree_view_set_enable_search (GtkTreeView *tree_view, gboolean enable_search);
subroutine gtk_tree_view_set_enable_search(tree_view, enable_search) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_view
  logical(c_bool), value :: enable_search
end subroutine

! gboolean gtk_tree_view_get_enable_search (GtkTreeView *tree_view);
function gtk_tree_view_get_enable_search(tree_view) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_get_enable_search
  type(c_ptr), value :: tree_view
end function

! gint gtk_tree_view_get_search_column (GtkTreeView *tree_view);
function gtk_tree_view_get_search_column(tree_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_view_get_search_column
  type(c_ptr), value :: tree_view
end function

! void gtk_tree_view_set_search_column (GtkTreeView *tree_view, gint column);
subroutine gtk_tree_view_set_search_column(tree_view, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_view
  integer(c_int), value :: column
end subroutine

! GtkTreeViewSearchEqualFunc gtk_tree_view_get_search_equal_func (GtkTreeView *tree_view);
function gtk_tree_view_get_search_equal_func(tree_view) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr) :: gtk_tree_view_get_search_equal_func
  type(c_ptr), value :: tree_view
end function

! void gtk_tree_view_set_search_equal_func (GtkTreeView *tree_view, GtkTreeViewSearchEqualFunc search_equal_func, gpointer search_user_data, GDestroyNotify search_destroy);
subroutine gtk_tree_view_set_search_equal_func(tree_view, search_equal_func, sea&
      &rch_user_data, search_destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: tree_view
  type(c_funptr), value :: search_equal_func
  type(c_ptr), value :: search_user_data
  type(c_funptr), value :: search_destroy
end subroutine

!  GtkEntry *gtk_tree_view_get_search_entry (GtkTreeView *tree_view);
function gtk_tree_view_get_search_entry(tree_view) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_view_get_search_entry
  type(c_ptr), value :: tree_view
end function

! void gtk_tree_view_set_search_entry (GtkTreeView *tree_view, GtkEntry *entry);
subroutine gtk_tree_view_set_search_entry(tree_view, entry) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: entry
end subroutine

! GtkTreeViewSearchPositionFunc gtk_tree_view_get_search_position_func (GtkTreeView *tree_view);
function gtk_tree_view_get_search_position_func(tree_view) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr) :: gtk_tree_view_get_search_position_func
  type(c_ptr), value :: tree_view
end function

! void gtk_tree_view_set_search_position_func (GtkTreeView *tree_view, GtkTreeViewSearchPositionFunc func, gpointer data, GDestroyNotify destroy);
subroutine gtk_tree_view_set_search_position_func(tree_view, func, data, destroy&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: tree_view
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

!  void gtk_tree_view_convert_widget_to_tree_coords (GtkTreeView *tree_view, gint wx, gint wy, gint *tx, gint *ty);
subroutine gtk_tree_view_convert_widget_to_tree_coords(tree_view, wx, wy, tx, ty&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_view
  integer(c_int), value :: wx
  integer(c_int), value :: wy
  type(c_ptr), value :: tx
  type(c_ptr), value :: ty
end subroutine

! void gtk_tree_view_convert_tree_to_widget_coords (GtkTreeView *tree_view, gint tx, gint ty, gint *wx, gint *wy);
subroutine gtk_tree_view_convert_tree_to_widget_coords(tree_view, tx, ty, wx, wy&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_view
  integer(c_int), value :: tx
  integer(c_int), value :: ty
  type(c_ptr), value :: wx
  type(c_ptr), value :: wy
end subroutine

! void gtk_tree_view_convert_widget_to_bin_window_coords (GtkTreeView *tree_view, gint wx, gint wy, gint *bx, gint *by);
subroutine gtk_tree_view_convert_widget_to_bin_window_coords(tree_view, wx, wy, &
      &bx, by) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_view
  integer(c_int), value :: wx
  integer(c_int), value :: wy
  type(c_ptr), value :: bx
  type(c_ptr), value :: by
end subroutine

! void gtk_tree_view_convert_bin_window_to_widget_coords (GtkTreeView *tree_view, gint bx, gint by, gint *wx, gint *wy);
subroutine gtk_tree_view_convert_bin_window_to_widget_coords(tree_view, bx, by, &
      &wx, wy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_view
  integer(c_int), value :: bx
  integer(c_int), value :: by
  type(c_ptr), value :: wx
  type(c_ptr), value :: wy
end subroutine

! void gtk_tree_view_convert_tree_to_bin_window_coords (GtkTreeView *tree_view, gint tx, gint ty, gint *bx, gint *by);
subroutine gtk_tree_view_convert_tree_to_bin_window_coords(tree_view, tx, ty, bx&
      &, by) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_view
  integer(c_int), value :: tx
  integer(c_int), value :: ty
  type(c_ptr), value :: bx
  type(c_ptr), value :: by
end subroutine

! void gtk_tree_view_convert_bin_window_to_tree_coords (GtkTreeView *tree_view, gint bx, gint by, gint *tx, gint *ty);
subroutine gtk_tree_view_convert_bin_window_to_tree_coords(tree_view, bx, by, tx&
      &, ty) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_view
  integer(c_int), value :: bx
  integer(c_int), value :: by
  type(c_ptr), value :: tx
  type(c_ptr), value :: ty
end subroutine

!  void gtk_tree_view_set_destroy_count_func (GtkTreeView *tree_view, GtkTreeDestroyCountFunc func, gpointer data, GDestroyNotify destroy);
subroutine gtk_tree_view_set_destroy_count_func(tree_view, func, data, destroy) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: tree_view
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

!  void gtk_tree_view_set_fixed_height_mode (GtkTreeView *tree_view, gboolean enable);
subroutine gtk_tree_view_set_fixed_height_mode(tree_view, enable) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_view
  logical(c_bool), value :: enable
end subroutine

! gboolean gtk_tree_view_get_fixed_height_mode (GtkTreeView *tree_view);
function gtk_tree_view_get_fixed_height_mode(tree_view) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_get_fixed_height_mode
  type(c_ptr), value :: tree_view
end function

! void gtk_tree_view_set_hover_selection (GtkTreeView *tree_view, gboolean hover);
subroutine gtk_tree_view_set_hover_selection(tree_view, hover) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_view
  logical(c_bool), value :: hover
end subroutine

! gboolean gtk_tree_view_get_hover_selection (GtkTreeView *tree_view);
function gtk_tree_view_get_hover_selection(tree_view) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_get_hover_selection
  type(c_ptr), value :: tree_view
end function

! void gtk_tree_view_set_hover_expand (GtkTreeView *tree_view, gboolean expand);
subroutine gtk_tree_view_set_hover_expand(tree_view, expand) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_view
  logical(c_bool), value :: expand
end subroutine

! gboolean gtk_tree_view_get_hover_expand (GtkTreeView *tree_view);
function gtk_tree_view_get_hover_expand(tree_view) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_get_hover_expand
  type(c_ptr), value :: tree_view
end function

! void gtk_tree_view_set_rubber_banding (GtkTreeView *tree_view, gboolean enable);
subroutine gtk_tree_view_set_rubber_banding(tree_view, enable) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_view
  logical(c_bool), value :: enable
end subroutine

! gboolean gtk_tree_view_get_rubber_banding (GtkTreeView *tree_view);
function gtk_tree_view_get_rubber_banding(tree_view) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_get_rubber_banding
  type(c_ptr), value :: tree_view
end function

!  gboolean gtk_tree_view_is_rubber_banding_active (GtkTreeView *tree_view);
function gtk_tree_view_is_rubber_banding_active(tree_view) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_is_rubber_banding_active
  type(c_ptr), value :: tree_view
end function

!  GtkTreeViewRowSeparatorFunc gtk_tree_view_get_row_separator_func (GtkTreeView *tree_view);
function gtk_tree_view_get_row_separator_func(tree_view) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr) :: gtk_tree_view_get_row_separator_func
  type(c_ptr), value :: tree_view
end function

! void gtk_tree_view_set_row_separator_func (GtkTreeView *tree_view, GtkTreeViewRowSeparatorFunc func, gpointer data, GDestroyNotify destroy);
subroutine gtk_tree_view_set_row_separator_func(tree_view, func, data, destroy) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: tree_view
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

!  GtkTreeViewGridLines gtk_tree_view_get_grid_lines (GtkTreeView *tree_view);
function gtk_tree_view_get_grid_lines(tree_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_view_get_grid_lines
  type(c_ptr), value :: tree_view
end function

! void gtk_tree_view_set_grid_lines (GtkTreeView *tree_view, GtkTreeViewGridLines grid_lines);
subroutine gtk_tree_view_set_grid_lines(tree_view, grid_lines) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_view
  integer(c_int), value :: grid_lines
end subroutine

! gboolean gtk_tree_view_get_enable_tree_lines (GtkTreeView *tree_view);
function gtk_tree_view_get_enable_tree_lines(tree_view) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_get_enable_tree_lines
  type(c_ptr), value :: tree_view
end function

! void gtk_tree_view_set_enable_tree_lines (GtkTreeView *tree_view, gboolean enabled);
subroutine gtk_tree_view_set_enable_tree_lines(tree_view, enabled) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_view
  logical(c_bool), value :: enabled
end subroutine

! void gtk_tree_view_set_show_expanders (GtkTreeView *tree_view, gboolean enabled);
subroutine gtk_tree_view_set_show_expanders(tree_view, enabled) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_view
  logical(c_bool), value :: enabled
end subroutine

! gboolean gtk_tree_view_get_show_expanders (GtkTreeView *tree_view);
function gtk_tree_view_get_show_expanders(tree_view) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_get_show_expanders
  type(c_ptr), value :: tree_view
end function

! void gtk_tree_view_set_level_indentation (GtkTreeView *tree_view, gint indentation);
subroutine gtk_tree_view_set_level_indentation(tree_view, indentation) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_view
  integer(c_int), value :: indentation
end subroutine

! gint gtk_tree_view_get_level_indentation (GtkTreeView *tree_view);
function gtk_tree_view_get_level_indentation(tree_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_view_get_level_indentation
  type(c_ptr), value :: tree_view
end function

!  void gtk_tree_view_set_tooltip_row (GtkTreeView *tree_view, GtkTooltip *tooltip, GtkTreePath *path);
subroutine gtk_tree_view_set_tooltip_row(tree_view, tooltip, path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: tooltip
  type(c_ptr), value :: path
end subroutine

! void gtk_tree_view_set_tooltip_cell (GtkTreeView *tree_view, GtkTooltip *tooltip, GtkTreePath *path, GtkTreeViewColumn *column, GtkCellRenderer *cell);
subroutine gtk_tree_view_set_tooltip_cell(tree_view, tooltip, path, column, cell&
      &) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: tooltip
  type(c_ptr), value :: path
  type(c_ptr), value :: column
  type(c_ptr), value :: cell
end subroutine

! gboolean gtk_tree_view_get_tooltip_context(GtkTreeView *tree_view, gint *x, gint *y, gboolean keyboard_tip, GtkTreeModel **model, GtkTreePath **path, GtkTreeIter *iter);
function gtk_tree_view_get_tooltip_context(tree_view, x, y, keyboard_tip, model,&
      & path, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_get_tooltip_context
  type(c_ptr), value :: tree_view
  type(c_ptr), value :: x
  type(c_ptr), value :: y
  logical(c_bool), value :: keyboard_tip
  type(c_ptr), value :: model
  type(c_ptr), value :: path
  type(c_ptr), value :: iter
end function

! void gtk_tree_view_set_tooltip_column (GtkTreeView *tree_view, gint column);
subroutine gtk_tree_view_set_tooltip_column(tree_view, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_view
  integer(c_int), value :: column
end subroutine

! gint gtk_tree_view_get_tooltip_column (GtkTreeView *tree_view);
function gtk_tree_view_get_tooltip_column(tree_view) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_view_get_tooltip_column
  type(c_ptr), value :: tree_view
end function

!   GType gtk_recent_action_get_type (void) G_GNUC_CONST;
function gtk_recent_action_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_recent_action_get_type
end function

! GtkAction *gtk_recent_action_new (const gchar *name, const gchar *label, const gchar *tooltip, const gchar *stock_id);
function gtk_recent_action_new(name, label, tooltip, stock_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_recent_action_new
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: label
  character(kind=c_char), dimension(*) :: tooltip
  character(kind=c_char), dimension(*) :: stock_id
end function

! GtkAction *gtk_recent_action_new_for_manager (const gchar *name, const gchar *label, const gchar *tooltip, const gchar *stock_id, GtkRecentManager *manager);
function gtk_recent_action_new_for_manager(name, label, tooltip, stock_id, manag&
      &er) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_recent_action_new_for_manager
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: label
  character(kind=c_char), dimension(*) :: tooltip
  character(kind=c_char), dimension(*) :: stock_id
  type(c_ptr), value :: manager
end function

! gboolean gtk_recent_action_get_show_numbers (GtkRecentAction *action);
function gtk_recent_action_get_show_numbers(action) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_recent_action_get_show_numbers
  type(c_ptr), value :: action
end function

! void gtk_recent_action_set_show_numbers (GtkRecentAction *action, gboolean show_numbers);
subroutine gtk_recent_action_set_show_numbers(action, show_numbers) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: action
  logical(c_bool), value :: show_numbers
end subroutine

!   GType gtk_tree_store_get_type (void) G_GNUC_CONST;
function gtk_tree_store_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_store_get_type
end function

! GtkTreeStore *gtk_tree_store_newv (gint n_columns, GType *types);
function gtk_tree_store_newv(n_columns, types) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_tree_store_newv
  integer(c_int), value :: n_columns
  type(c_ptr), value :: types
end function

! void gtk_tree_store_set_column_types (GtkTreeStore *tree_store, gint n_columns, GType *types);
subroutine gtk_tree_store_set_column_types(tree_store, n_columns, types) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_store
  integer(c_int), value :: n_columns
  type(c_ptr), value :: types
end subroutine

!  void gtk_tree_store_set_value (GtkTreeStore *tree_store, GtkTreeIter *iter, gint column, GValue *value);
subroutine gtk_tree_store_set_value(tree_store, iter, column, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_store
  type(c_ptr), value :: iter
  integer(c_int), value :: column
  type(c_ptr), value :: value
end subroutine

! void gtk_tree_store_set_valuesv (GtkTreeStore *tree_store, GtkTreeIter *iter, gint *columns, GValue *values, gint n_values);
subroutine gtk_tree_store_set_valuesv(tree_store, iter, columns, values, n_value&
      &s) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_store
  type(c_ptr), value :: iter
  type(c_ptr), value :: columns
  type(c_ptr), value :: values
  integer(c_int), value :: n_values
end subroutine

! void gtk_tree_store_set_valist (GtkTreeStore *tree_store, GtkTreeIter *iter, va_list var_args);
subroutine gtk_tree_store_set_valist(tree_store, iter, var_args) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_store
  type(c_ptr), value :: iter
  type(c_ptr), value :: var_args
end subroutine

! gboolean gtk_tree_store_remove (GtkTreeStore *tree_store, GtkTreeIter *iter);
function gtk_tree_store_remove(tree_store, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_store_remove
  type(c_ptr), value :: tree_store
  type(c_ptr), value :: iter
end function

! void gtk_tree_store_insert (GtkTreeStore *tree_store, GtkTreeIter *iter, GtkTreeIter *parent, gint position);
subroutine gtk_tree_store_insert(tree_store, iter, parent, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_store
  type(c_ptr), value :: iter
  type(c_ptr), value :: parent
  integer(c_int), value :: position
end subroutine

! void gtk_tree_store_insert_before (GtkTreeStore *tree_store, GtkTreeIter *iter, GtkTreeIter *parent, GtkTreeIter *sibling);
subroutine gtk_tree_store_insert_before(tree_store, iter, parent, sibling) bind(&
      &c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_store
  type(c_ptr), value :: iter
  type(c_ptr), value :: parent
  type(c_ptr), value :: sibling
end subroutine

! void gtk_tree_store_insert_after (GtkTreeStore *tree_store, GtkTreeIter *iter, GtkTreeIter *parent, GtkTreeIter *sibling);
subroutine gtk_tree_store_insert_after(tree_store, iter, parent, sibling) bind(c&
      &) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_store
  type(c_ptr), value :: iter
  type(c_ptr), value :: parent
  type(c_ptr), value :: sibling
end subroutine

! void gtk_tree_store_insert_with_valuesv (GtkTreeStore *tree_store, GtkTreeIter *iter, GtkTreeIter *parent, gint position, gint *columns, GValue *values, gint n_values);
subroutine gtk_tree_store_insert_with_valuesv(tree_store, iter, parent, position&
      &, columns, values, n_values) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_store
  type(c_ptr), value :: iter
  type(c_ptr), value :: parent
  integer(c_int), value :: position
  type(c_ptr), value :: columns
  type(c_ptr), value :: values
  integer(c_int), value :: n_values
end subroutine

! void gtk_tree_store_prepend (GtkTreeStore *tree_store, GtkTreeIter *iter, GtkTreeIter *parent);
subroutine gtk_tree_store_prepend(tree_store, iter, parent) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_store
  type(c_ptr), value :: iter
  type(c_ptr), value :: parent
end subroutine

! void gtk_tree_store_append (GtkTreeStore *tree_store, GtkTreeIter *iter, GtkTreeIter *parent);
subroutine gtk_tree_store_append(tree_store, iter, parent) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_store
  type(c_ptr), value :: iter
  type(c_ptr), value :: parent
end subroutine

! gboolean gtk_tree_store_is_ancestor (GtkTreeStore *tree_store, GtkTreeIter *iter, GtkTreeIter *descendant);
function gtk_tree_store_is_ancestor(tree_store, iter, descendant) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_store_is_ancestor
  type(c_ptr), value :: tree_store
  type(c_ptr), value :: iter
  type(c_ptr), value :: descendant
end function

! gint gtk_tree_store_iter_depth (GtkTreeStore *tree_store, GtkTreeIter *iter);
function gtk_tree_store_iter_depth(tree_store, iter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_store_iter_depth
  type(c_ptr), value :: tree_store
  type(c_ptr), value :: iter
end function

! void gtk_tree_store_clear (GtkTreeStore *tree_store);
subroutine gtk_tree_store_clear(tree_store) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_store
end subroutine

! gboolean gtk_tree_store_iter_is_valid (GtkTreeStore *tree_store, GtkTreeIter *iter);
function gtk_tree_store_iter_is_valid(tree_store, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_store_iter_is_valid
  type(c_ptr), value :: tree_store
  type(c_ptr), value :: iter
end function

! void gtk_tree_store_reorder (GtkTreeStore *tree_store, GtkTreeIter *parent, gint *new_order);
subroutine gtk_tree_store_reorder(tree_store, parent, new_order) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_store
  type(c_ptr), value :: parent
  type(c_ptr), value :: new_order
end subroutine

! void gtk_tree_store_swap (GtkTreeStore *tree_store, GtkTreeIter *a, GtkTreeIter *b);
subroutine gtk_tree_store_swap(tree_store, a, b) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_store
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end subroutine

! void gtk_tree_store_move_before (GtkTreeStore *tree_store, GtkTreeIter *iter, GtkTreeIter *position);
subroutine gtk_tree_store_move_before(tree_store, iter, position) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_store
  type(c_ptr), value :: iter
  type(c_ptr), value :: position
end subroutine

! void gtk_tree_store_move_after (GtkTreeStore *tree_store, GtkTreeIter *iter, GtkTreeIter *position);
subroutine gtk_tree_store_move_after(tree_store, iter, position) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_store
  type(c_ptr), value :: iter
  type(c_ptr), value :: position
end subroutine

!   GType gtk_vpaned_get_type (void) G_GNUC_CONST;
function gtk_vpaned_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_vpaned_get_type
end function

! GtkWidget * gtk_vpaned_new (void);
function gtk_vpaned_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_vpaned_new
end function

!   GType gtk_cell_renderer_get_type (void) G_GNUC_CONST;
function gtk_cell_renderer_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_cell_renderer_get_type
end function

!  void gtk_cell_renderer_get_size (GtkCellRenderer *cell, GtkWidget *widget, const GdkRectangle *cell_area, gint *x_offset, gint *y_offset, gint *width, gint *height);
subroutine gtk_cell_renderer_get_size(cell, widget, cell_area, x_offset, y_offse&
      &t, width, height) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cell
  type(c_ptr), value :: widget
  type(c_ptr), value :: cell_area
  type(c_ptr), value :: x_offset
  type(c_ptr), value :: y_offset
  type(c_ptr), value :: width
  type(c_ptr), value :: height
end subroutine

! void gtk_cell_renderer_render (GtkCellRenderer *cell, GdkWindow *window, GtkWidget *widget, const GdkRectangle *background_area, const GdkRectangle *cell_area, const GdkRectangle *expose_area, GtkCellRendererState flags);
subroutine gtk_cell_renderer_render(cell, window, widget, background_area, cell_&
      &area, expose_area, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: cell
  type(c_ptr), value :: window
  type(c_ptr), value :: widget
  type(c_ptr), value :: background_area
  type(c_ptr), value :: cell_area
  type(c_ptr), value :: expose_area
  integer(c_int), value :: flags
end subroutine

! gboolean gtk_cell_renderer_activate (GtkCellRenderer *cell, GdkEvent *event, GtkWidget *widget, const gchar *path, const GdkRectangle *background_area, const GdkRectangle *cell_area, GtkCellRendererState flags);
function gtk_cell_renderer_activate(cell, event, widget, path, background_area, &
      &cell_area, flags) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: gtk_cell_renderer_activate
  type(c_ptr), value :: cell
  type(c_ptr), value :: event
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: path
  type(c_ptr), value :: background_area
  type(c_ptr), value :: cell_area
  integer(c_int), value :: flags
end function

! GtkCellEditable *gtk_cell_renderer_start_editing (GtkCellRenderer *cell, GdkEvent *event, GtkWidget *widget, const gchar *path, const GdkRectangle *background_area, const GdkRectangle *cell_area, GtkCellRendererState flags);
function gtk_cell_renderer_start_editing(cell, event, widget, path, background_a&
      &rea, cell_area, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: gtk_cell_renderer_start_editing
  type(c_ptr), value :: cell
  type(c_ptr), value :: event
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: path
  type(c_ptr), value :: background_area
  type(c_ptr), value :: cell_area
  integer(c_int), value :: flags
end function

!  void gtk_cell_renderer_set_fixed_size (GtkCellRenderer *cell, gint width, gint height);
subroutine gtk_cell_renderer_set_fixed_size(cell, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: cell
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_cell_renderer_get_fixed_size (GtkCellRenderer *cell, gint *width, gint *height);
subroutine gtk_cell_renderer_get_fixed_size(cell, width, height) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cell
  type(c_ptr), value :: width
  type(c_ptr), value :: height
end subroutine

!  void gtk_cell_renderer_set_alignment (GtkCellRenderer *cell, gfloat xalign, gfloat yalign);
subroutine gtk_cell_renderer_set_alignment(cell, xalign, yalign) bind(c) 
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: cell
  real(c_float), value :: xalign
  real(c_float), value :: yalign
end subroutine

! void gtk_cell_renderer_get_alignment (GtkCellRenderer *cell, gfloat *xalign, gfloat *yalign);
subroutine gtk_cell_renderer_get_alignment(cell, xalign, yalign) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cell
  type(c_ptr), value :: xalign
  type(c_ptr), value :: yalign
end subroutine

!  void gtk_cell_renderer_set_padding (GtkCellRenderer *cell, gint xpad, gint ypad);
subroutine gtk_cell_renderer_set_padding(cell, xpad, ypad) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: cell
  integer(c_int), value :: xpad
  integer(c_int), value :: ypad
end subroutine

! void gtk_cell_renderer_get_padding (GtkCellRenderer *cell, gint *xpad, gint *ypad);
subroutine gtk_cell_renderer_get_padding(cell, xpad, ypad) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cell
  type(c_ptr), value :: xpad
  type(c_ptr), value :: ypad
end subroutine

!  void gtk_cell_renderer_set_visible (GtkCellRenderer *cell, gboolean visible);
subroutine gtk_cell_renderer_set_visible(cell, visible) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: cell
  logical(c_bool), value :: visible
end subroutine

! gboolean gtk_cell_renderer_get_visible (GtkCellRenderer *cell);
function gtk_cell_renderer_get_visible(cell) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_cell_renderer_get_visible
  type(c_ptr), value :: cell
end function

!  void gtk_cell_renderer_set_sensitive (GtkCellRenderer *cell, gboolean sensitive);
subroutine gtk_cell_renderer_set_sensitive(cell, sensitive) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: cell
  logical(c_bool), value :: sensitive
end subroutine

! gboolean gtk_cell_renderer_get_sensitive (GtkCellRenderer *cell);
function gtk_cell_renderer_get_sensitive(cell) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_cell_renderer_get_sensitive
  type(c_ptr), value :: cell
end function

!  void gtk_cell_renderer_editing_canceled (GtkCellRenderer *cell);
subroutine gtk_cell_renderer_editing_canceled(cell) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cell
end subroutine

!  void gtk_cell_renderer_stop_editing (GtkCellRenderer *cell, gboolean canceled);
subroutine gtk_cell_renderer_stop_editing(cell, canceled) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: cell
  logical(c_bool), value :: canceled
end subroutine

!   GType gtk_tool_item_group_get_type (void) G_GNUC_CONST;
function gtk_tool_item_group_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tool_item_group_get_type
end function

! GtkWidget* gtk_tool_item_group_new (const gchar *label);
function gtk_tool_item_group_new(label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_tool_item_group_new
  character(kind=c_char), dimension(*) :: label
end function

!  void gtk_tool_item_group_set_label (GtkToolItemGroup *group, const gchar *label);
subroutine gtk_tool_item_group_set_label(group, label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: group
  character(kind=c_char), dimension(*) :: label
end subroutine

! void gtk_tool_item_group_set_label_widget (GtkToolItemGroup *group, GtkWidget *label_widget);
subroutine gtk_tool_item_group_set_label_widget(group, label_widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: group
  type(c_ptr), value :: label_widget
end subroutine

! void gtk_tool_item_group_set_collapsed (GtkToolItemGroup *group, gboolean collapsed);
subroutine gtk_tool_item_group_set_collapsed(group, collapsed) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: group
  logical(c_bool), value :: collapsed
end subroutine

! void gtk_tool_item_group_set_ellipsize (GtkToolItemGroup *group, PangoEllipsizeMode ellipsize);
subroutine gtk_tool_item_group_set_ellipsize(group, ellipsize) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: group
  integer(c_int), value :: ellipsize
end subroutine

! void gtk_tool_item_group_set_header_relief (GtkToolItemGroup *group, GtkReliefStyle style);
subroutine gtk_tool_item_group_set_header_relief(group, style) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: group
  integer(c_int), value :: style
end subroutine

!  G_CONST_RETURN gchar* gtk_tool_item_group_get_label (GtkToolItemGroup *group);
function gtk_tool_item_group_get_label(group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tool_item_group_get_label
  type(c_ptr), value :: group
end function

! GtkWidget *gtk_tool_item_group_get_label_widget (GtkToolItemGroup *group);
function gtk_tool_item_group_get_label_widget(group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tool_item_group_get_label_widget
  type(c_ptr), value :: group
end function

! gboolean gtk_tool_item_group_get_collapsed (GtkToolItemGroup *group);
function gtk_tool_item_group_get_collapsed(group) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tool_item_group_get_collapsed
  type(c_ptr), value :: group
end function

! PangoEllipsizeMode gtk_tool_item_group_get_ellipsize (GtkToolItemGroup *group);
function gtk_tool_item_group_get_ellipsize(group) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tool_item_group_get_ellipsize
  type(c_ptr), value :: group
end function

! GtkReliefStyle gtk_tool_item_group_get_header_relief (GtkToolItemGroup *group);
function gtk_tool_item_group_get_header_relief(group) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tool_item_group_get_header_relief
  type(c_ptr), value :: group
end function

!  void gtk_tool_item_group_insert (GtkToolItemGroup *group, GtkToolItem *item, gint position);
subroutine gtk_tool_item_group_insert(group, item, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: group
  type(c_ptr), value :: item
  integer(c_int), value :: position
end subroutine

! void gtk_tool_item_group_set_item_position (GtkToolItemGroup *group, GtkToolItem *item, gint position);
subroutine gtk_tool_item_group_set_item_position(group, item, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: group
  type(c_ptr), value :: item
  integer(c_int), value :: position
end subroutine

! gint gtk_tool_item_group_get_item_position (GtkToolItemGroup *group, GtkToolItem *item);
function gtk_tool_item_group_get_item_position(group, item) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tool_item_group_get_item_position
  type(c_ptr), value :: group
  type(c_ptr), value :: item
end function

!  guint gtk_tool_item_group_get_n_items (GtkToolItemGroup *group);
function gtk_tool_item_group_get_n_items(group) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tool_item_group_get_n_items
  type(c_ptr), value :: group
end function

! GtkToolItem* gtk_tool_item_group_get_nth_item (GtkToolItemGroup *group, guint index);
function gtk_tool_item_group_get_nth_item(group, index) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_tool_item_group_get_nth_item
  type(c_ptr), value :: group
  integer(c_int), value :: index
end function

! GtkToolItem* gtk_tool_item_group_get_drop_item (GtkToolItemGroup *group, gint x, gint y);
function gtk_tool_item_group_get_drop_item(group, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_tool_item_group_get_drop_item
  type(c_ptr), value :: group
  integer(c_int), value :: x
  integer(c_int), value :: y
end function

!   GType gtk_separator_tool_item_get_type (void) G_GNUC_CONST;
function gtk_separator_tool_item_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_separator_tool_item_get_type
end function

! GtkToolItem *gtk_separator_tool_item_new (void);
function gtk_separator_tool_item_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_separator_tool_item_new
end function

!  gboolean gtk_separator_tool_item_get_draw (GtkSeparatorToolItem *item);
function gtk_separator_tool_item_get_draw(item) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_separator_tool_item_get_draw
  type(c_ptr), value :: item
end function

! void gtk_separator_tool_item_set_draw (GtkSeparatorToolItem *item, gboolean draw);
subroutine gtk_separator_tool_item_set_draw(item, draw) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: item
  logical(c_bool), value :: draw
end subroutine

!   GType gtk_bin_get_type (void) G_GNUC_CONST;
function gtk_bin_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_bin_get_type
end function

!  GtkWidget *gtk_bin_get_child (GtkBin *bin);
function gtk_bin_get_child(bin) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_bin_get_child
  type(c_ptr), value :: bin
end function

!   GType gtk_option_menu_get_type (void) G_GNUC_CONST;
function gtk_option_menu_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_option_menu_get_type
end function

! GtkWidget* gtk_option_menu_new (void);
function gtk_option_menu_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_option_menu_new
end function

! GtkWidget* gtk_option_menu_get_menu (GtkOptionMenu *option_menu);
function gtk_option_menu_get_menu(option_menu) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_option_menu_get_menu
  type(c_ptr), value :: option_menu
end function

! void gtk_option_menu_set_menu (GtkOptionMenu *option_menu, GtkWidget *menu);
subroutine gtk_option_menu_set_menu(option_menu, menu) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: option_menu
  type(c_ptr), value :: menu
end subroutine

! void gtk_option_menu_remove_menu (GtkOptionMenu *option_menu);
subroutine gtk_option_menu_remove_menu(option_menu) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: option_menu
end subroutine

! gint gtk_option_menu_get_history (GtkOptionMenu *option_menu);
function gtk_option_menu_get_history(option_menu) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_option_menu_get_history
  type(c_ptr), value :: option_menu
end function

! void gtk_option_menu_set_history (GtkOptionMenu *option_menu, guint index_);
subroutine gtk_option_menu_set_history(option_menu, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: option_menu
  integer(c_int), value :: index_
end subroutine

!   GType ubuntu_menu_proxy_module_get_type (void) G_GNUC_CONST;
function ubuntu_menu_proxy_module_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: ubuntu_menu_proxy_module_get_type
end function

!  UbuntuMenuProxyModule *ubuntu_menu_proxy_module_get (void);
function ubuntu_menu_proxy_module_get() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: ubuntu_menu_proxy_module_get
end function

!   GType gtk_file_chooser_dialog_get_type (void) G_GNUC_CONST;
function gtk_file_chooser_dialog_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_file_chooser_dialog_get_type
end function

!   GType gtk_object_get_type (void) G_GNUC_CONST;
function gtk_object_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_object_get_type
end function

!  void gtk_object_sink (GtkObject *object);
subroutine gtk_object_sink(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
end subroutine

!  void gtk_object_destroy (GtkObject *object);
subroutine gtk_object_destroy(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
end subroutine

! GtkObject* gtk_object_ref (GtkObject *object);
function gtk_object_ref(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_object_ref
  type(c_ptr), value :: object
end function

! void gtk_object_unref (GtkObject *object);
subroutine gtk_object_unref(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
end subroutine

! void gtk_object_weakref (GtkObject *object, GDestroyNotify notify, gpointer data);
subroutine gtk_object_weakref(object, notify, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: object
  type(c_funptr), value :: notify
  type(c_ptr), value :: data
end subroutine

! void gtk_object_weakunref (GtkObject *object, GDestroyNotify notify, gpointer data);
subroutine gtk_object_weakunref(object, notify, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: object
  type(c_funptr), value :: notify
  type(c_ptr), value :: data
end subroutine

!  void gtk_object_set_data (GtkObject *object, const gchar *key, gpointer data);
subroutine gtk_object_set_data(object, key, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: data
end subroutine

! void gtk_object_set_data_full (GtkObject *object, const gchar *key, gpointer data, GDestroyNotify destroy);
subroutine gtk_object_set_data_full(object, key, data, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

! void gtk_object_remove_data (GtkObject *object, const gchar *key);
subroutine gtk_object_remove_data(object, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: key
end subroutine

! gpointer gtk_object_get_data (GtkObject *object, const gchar *key);
function gtk_object_get_data(object, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_object_get_data
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: key
end function

! void gtk_object_remove_no_notify (GtkObject *object, const gchar *key);
subroutine gtk_object_remove_no_notify(object, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: key
end subroutine

!  void gtk_object_set_user_data (GtkObject *object, gpointer data);
subroutine gtk_object_set_user_data(object, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
  type(c_ptr), value :: data
end subroutine

! gpointer gtk_object_get_user_data (GtkObject *object);
function gtk_object_get_user_data(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_object_get_user_data
  type(c_ptr), value :: object
end function

!  void gtk_object_set_data_by_id (GtkObject *object, GQuark data_id, gpointer data);
subroutine gtk_object_set_data_by_id(object, data_id, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: object
  integer(c_int32_t), value :: data_id
  type(c_ptr), value :: data
end subroutine

! void gtk_object_set_data_by_id_full (GtkObject *object, GQuark data_id, gpointer data, GDestroyNotify destroy);
subroutine gtk_object_set_data_by_id_full(object, data_id, data, destroy) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_funptr
  type(c_ptr), value :: object
  integer(c_int32_t), value :: data_id
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

! gpointer gtk_object_get_data_by_id (GtkObject *object, GQuark data_id);
function gtk_object_get_data_by_id(object, data_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: gtk_object_get_data_by_id
  type(c_ptr), value :: object
  integer(c_int32_t), value :: data_id
end function

! void gtk_object_remove_data_by_id (GtkObject *object, GQuark data_id);
subroutine gtk_object_remove_data_by_id(object, data_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: object
  integer(c_int32_t), value :: data_id
end subroutine

! void gtk_object_remove_no_notify_by_id (GtkObject *object, GQuark key_id);
subroutine gtk_object_remove_no_notify_by_id(object, key_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: object
  integer(c_int32_t), value :: key_id
end subroutine

! void gtk_object_add_arg_type (const gchar *arg_name, GType arg_type, guint arg_flags, guint arg_id);
subroutine gtk_object_add_arg_type(arg_name, arg_type, arg_flags, arg_id) bind(c&
      &) 
  use iso_c_binding, only: c_char, c_size_t, c_int
  character(kind=c_char), dimension(*) :: arg_name
  integer(c_size_t), value :: arg_type
  integer(c_int), value :: arg_flags
  integer(c_int), value :: arg_id
end subroutine

!   GType gtk_hsv_get_type (void) G_GNUC_CONST;
function gtk_hsv_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_hsv_get_type
end function

! GtkWidget* gtk_hsv_new (void);
function gtk_hsv_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_hsv_new
end function

! void gtk_hsv_set_color (GtkHSV *hsv, double h, double s, double v);
subroutine gtk_hsv_set_color(hsv, h, s, v) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: hsv
  real(c_double), value :: h
  real(c_double), value :: s
  real(c_double), value :: v
end subroutine

! void gtk_hsv_get_color (GtkHSV *hsv, gdouble *h, gdouble *s, gdouble *v);
subroutine gtk_hsv_get_color(hsv, h, s, v) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hsv
  type(c_ptr), value :: h
  type(c_ptr), value :: s
  type(c_ptr), value :: v
end subroutine

! void gtk_hsv_set_metrics (GtkHSV *hsv, gint size, gint ring_width);
subroutine gtk_hsv_set_metrics(hsv, size, ring_width) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: hsv
  integer(c_int), value :: size
  integer(c_int), value :: ring_width
end subroutine

! void gtk_hsv_get_metrics (GtkHSV *hsv, gint *size, gint *ring_width);
subroutine gtk_hsv_get_metrics(hsv, size, ring_width) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hsv
  type(c_ptr), value :: size
  type(c_ptr), value :: ring_width
end subroutine

! gboolean gtk_hsv_is_adjusting (GtkHSV *hsv);
function gtk_hsv_is_adjusting(hsv) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_hsv_is_adjusting
  type(c_ptr), value :: hsv
end function

!  void gtk_hsv_to_rgb (gdouble h, gdouble s, gdouble v, gdouble *r, gdouble *g, gdouble *b);
subroutine gtk_hsv_to_rgb(h, s, v, r, g, b) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double), value :: h
  real(c_double), value :: s
  real(c_double), value :: v
  type(c_ptr), value :: r
  type(c_ptr), value :: g
  type(c_ptr), value :: b
end subroutine

! void gtk_rgb_to_hsv (gdouble r, gdouble g, gdouble b, gdouble *h, gdouble *s, gdouble *v);
subroutine gtk_rgb_to_hsv(r, g, b, h, s, v) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double), value :: r
  real(c_double), value :: g
  real(c_double), value :: b
  type(c_ptr), value :: h
  type(c_ptr), value :: s
  type(c_ptr), value :: v
end subroutine

!   GType gtk_im_context_get_type (void) G_GNUC_CONST;
function gtk_im_context_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_im_context_get_type
end function

!  void gtk_im_context_set_client_window (GtkIMContext *context, GdkWindow *window);
subroutine gtk_im_context_set_client_window(context, window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: window
end subroutine

! void gtk_im_context_get_preedit_string (GtkIMContext *context, gchar **str, PangoAttrList **attrs, gint *cursor_pos);
subroutine gtk_im_context_get_preedit_string(context, str, attrs, cursor_pos) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: str
  type(c_ptr), value :: attrs
  type(c_ptr), value :: cursor_pos
end subroutine

! gboolean gtk_im_context_filter_keypress (GtkIMContext *context, GdkEventKey *event);
function gtk_im_context_filter_keypress(context, event) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_im_context_filter_keypress
  type(c_ptr), value :: context
  type(c_ptr), value :: event
end function

! void gtk_im_context_focus_in (GtkIMContext *context);
subroutine gtk_im_context_focus_in(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

! void gtk_im_context_focus_out (GtkIMContext *context);
subroutine gtk_im_context_focus_out(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

! void gtk_im_context_reset (GtkIMContext *context);
subroutine gtk_im_context_reset(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

! void gtk_im_context_set_cursor_location (GtkIMContext *context, const GdkRectangle *area);
subroutine gtk_im_context_set_cursor_location(context, area) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: area
end subroutine

! void gtk_im_context_set_use_preedit (GtkIMContext *context, gboolean use_preedit);
subroutine gtk_im_context_set_use_preedit(context, use_preedit) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: context
  logical(c_bool), value :: use_preedit
end subroutine

! void gtk_im_context_set_surrounding (GtkIMContext *context, const gchar *text, gint len, gint cursor_index);
subroutine gtk_im_context_set_surrounding(context, text, len, cursor_index) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: len
  integer(c_int), value :: cursor_index
end subroutine

! gboolean gtk_im_context_get_surrounding (GtkIMContext *context, gchar **text, gint *cursor_index);
function gtk_im_context_get_surrounding(context, text, cursor_index) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_im_context_get_surrounding
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: text
  type(c_ptr), value :: cursor_index
end function

! gboolean gtk_im_context_delete_surrounding (GtkIMContext *context, gint offset, gint n_chars);
function gtk_im_context_delete_surrounding(context, offset, n_chars) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_im_context_delete_surrounding
  type(c_ptr), value :: context
  integer(c_int), value :: offset
  integer(c_int), value :: n_chars
end function

!   GType gtk_viewport_get_type (void) G_GNUC_CONST;
function gtk_viewport_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_viewport_get_type
end function

! GtkWidget* gtk_viewport_new (GtkAdjustment *hadjustment, GtkAdjustment *vadjustment);
function gtk_viewport_new(hadjustment, vadjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_viewport_new
  type(c_ptr), value :: hadjustment
  type(c_ptr), value :: vadjustment
end function

! GtkAdjustment* gtk_viewport_get_hadjustment (GtkViewport *viewport);
function gtk_viewport_get_hadjustment(viewport) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_viewport_get_hadjustment
  type(c_ptr), value :: viewport
end function

! GtkAdjustment* gtk_viewport_get_vadjustment (GtkViewport *viewport);
function gtk_viewport_get_vadjustment(viewport) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_viewport_get_vadjustment
  type(c_ptr), value :: viewport
end function

! void gtk_viewport_set_hadjustment (GtkViewport *viewport, GtkAdjustment *adjustment);
subroutine gtk_viewport_set_hadjustment(viewport, adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: viewport
  type(c_ptr), value :: adjustment
end subroutine

! void gtk_viewport_set_vadjustment (GtkViewport *viewport, GtkAdjustment *adjustment);
subroutine gtk_viewport_set_vadjustment(viewport, adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: viewport
  type(c_ptr), value :: adjustment
end subroutine

! void gtk_viewport_set_shadow_type (GtkViewport *viewport, GtkShadowType type);
subroutine gtk_viewport_set_shadow_type(viewport, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: viewport
  integer(c_int), value :: type
end subroutine

! GtkShadowType gtk_viewport_get_shadow_type (GtkViewport *viewport);
function gtk_viewport_get_shadow_type(viewport) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_viewport_get_shadow_type
  type(c_ptr), value :: viewport
end function

! GdkWindow* gtk_viewport_get_bin_window (GtkViewport *viewport);
function gtk_viewport_get_bin_window(viewport) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_viewport_get_bin_window
  type(c_ptr), value :: viewport
end function

! GdkWindow* gtk_viewport_get_view_window (GtkViewport *viewport);
function gtk_viewport_get_view_window(viewport) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_viewport_get_view_window
  type(c_ptr), value :: viewport
end function

!   GType gtk_window_get_type (void) G_GNUC_CONST;
function gtk_window_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_window_get_type
end function

! GtkWidget* gtk_window_new (GtkWindowType type);
function gtk_window_new(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_window_new
  integer(c_int), value :: type
end function

! void gtk_window_set_title (GtkWindow *window, const gchar *title);
subroutine gtk_window_set_title(window, title) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: window
  character(kind=c_char), dimension(*) :: title
end subroutine

! G_CONST_RETURN gchar *gtk_window_get_title (GtkWindow *window);
function gtk_window_get_title(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_window_get_title
  type(c_ptr), value :: window
end function

! void gtk_window_set_wmclass (GtkWindow *window, const gchar *wmclass_name, const gchar *wmclass_class);
subroutine gtk_window_set_wmclass(window, wmclass_name, wmclass_class) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: window
  character(kind=c_char), dimension(*) :: wmclass_name
  character(kind=c_char), dimension(*) :: wmclass_class
end subroutine

! void gtk_window_set_role (GtkWindow *window, const gchar *role);
subroutine gtk_window_set_role(window, role) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: window
  character(kind=c_char), dimension(*) :: role
end subroutine

! void gtk_window_set_startup_id (GtkWindow *window, const gchar *startup_id);
subroutine gtk_window_set_startup_id(window, startup_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: window
  character(kind=c_char), dimension(*) :: startup_id
end subroutine

! G_CONST_RETURN gchar *gtk_window_get_role (GtkWindow *window);
function gtk_window_get_role(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_window_get_role
  type(c_ptr), value :: window
end function

! void gtk_window_add_accel_group (GtkWindow *window, GtkAccelGroup *accel_group);
subroutine gtk_window_add_accel_group(window, accel_group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: accel_group
end subroutine

! void gtk_window_remove_accel_group (GtkWindow *window, GtkAccelGroup *accel_group);
subroutine gtk_window_remove_accel_group(window, accel_group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: accel_group
end subroutine

! void gtk_window_set_position (GtkWindow *window, GtkWindowPosition position);
subroutine gtk_window_set_position(window, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: position
end subroutine

! gboolean gtk_window_activate_focus (GtkWindow *window);
function gtk_window_activate_focus(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_window_activate_focus
  type(c_ptr), value :: window
end function

! void gtk_window_set_focus (GtkWindow *window, GtkWidget *focus);
subroutine gtk_window_set_focus(window, focus) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: focus
end subroutine

! GtkWidget *gtk_window_get_focus (GtkWindow *window);
function gtk_window_get_focus(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_window_get_focus
  type(c_ptr), value :: window
end function

! void gtk_window_set_default (GtkWindow *window, GtkWidget *default_widget);
subroutine gtk_window_set_default(window, default_widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: default_widget
end subroutine

! GtkWidget *gtk_window_get_default_widget (GtkWindow *window);
function gtk_window_get_default_widget(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_window_get_default_widget
  type(c_ptr), value :: window
end function

! gboolean gtk_window_activate_default (GtkWindow *window);
function gtk_window_activate_default(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_window_activate_default
  type(c_ptr), value :: window
end function

!  void gtk_window_set_transient_for (GtkWindow *window, GtkWindow *parent);
subroutine gtk_window_set_transient_for(window, parent) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: parent
end subroutine

! GtkWindow *gtk_window_get_transient_for (GtkWindow *window);
function gtk_window_get_transient_for(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_window_get_transient_for
  type(c_ptr), value :: window
end function

! void gtk_window_set_opacity (GtkWindow *window, gdouble opacity);
subroutine gtk_window_set_opacity(window, opacity) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: window
  real(c_double), value :: opacity
end subroutine

! gdouble gtk_window_get_opacity (GtkWindow *window);
function gtk_window_get_opacity(window) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_window_get_opacity
  type(c_ptr), value :: window
end function

! void gtk_window_set_type_hint (GtkWindow *window, GdkWindowTypeHint hint);
subroutine gtk_window_set_type_hint(window, hint) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: hint
end subroutine

! GdkWindowTypeHint gtk_window_get_type_hint (GtkWindow *window);
function gtk_window_get_type_hint(window) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_window_get_type_hint
  type(c_ptr), value :: window
end function

! void gtk_window_set_skip_taskbar_hint (GtkWindow *window, gboolean setting);
subroutine gtk_window_set_skip_taskbar_hint(window, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_window_get_skip_taskbar_hint (GtkWindow *window);
function gtk_window_get_skip_taskbar_hint(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_window_get_skip_taskbar_hint
  type(c_ptr), value :: window
end function

! void gtk_window_set_skip_pager_hint (GtkWindow *window, gboolean setting);
subroutine gtk_window_set_skip_pager_hint(window, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_window_get_skip_pager_hint (GtkWindow *window);
function gtk_window_get_skip_pager_hint(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_window_get_skip_pager_hint
  type(c_ptr), value :: window
end function

! void gtk_window_set_urgency_hint (GtkWindow *window, gboolean setting);
subroutine gtk_window_set_urgency_hint(window, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_window_get_urgency_hint (GtkWindow *window);
function gtk_window_get_urgency_hint(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_window_get_urgency_hint
  type(c_ptr), value :: window
end function

! void gtk_window_set_accept_focus (GtkWindow *window, gboolean setting);
subroutine gtk_window_set_accept_focus(window, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_window_get_accept_focus (GtkWindow *window);
function gtk_window_get_accept_focus(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_window_get_accept_focus
  type(c_ptr), value :: window
end function

! void gtk_window_set_focus_on_map (GtkWindow *window, gboolean setting);
subroutine gtk_window_set_focus_on_map(window, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_window_get_focus_on_map (GtkWindow *window);
function gtk_window_get_focus_on_map(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_window_get_focus_on_map
  type(c_ptr), value :: window
end function

! void gtk_window_set_destroy_with_parent (GtkWindow *window, gboolean setting);
subroutine gtk_window_set_destroy_with_parent(window, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_window_get_destroy_with_parent (GtkWindow *window);
function gtk_window_get_destroy_with_parent(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_window_get_destroy_with_parent
  type(c_ptr), value :: window
end function

! void gtk_window_set_mnemonics_visible (GtkWindow *window, gboolean setting);
subroutine gtk_window_set_mnemonics_visible(window, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_window_get_mnemonics_visible (GtkWindow *window);
function gtk_window_get_mnemonics_visible(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_window_get_mnemonics_visible
  type(c_ptr), value :: window
end function

!  void gtk_window_set_resizable (GtkWindow *window, gboolean resizable);
subroutine gtk_window_set_resizable(window, resizable) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: resizable
end subroutine

! gboolean gtk_window_get_resizable (GtkWindow *window);
function gtk_window_get_resizable(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_window_get_resizable
  type(c_ptr), value :: window
end function

!  void gtk_window_set_gravity (GtkWindow *window, GdkGravity gravity);
subroutine gtk_window_set_gravity(window, gravity) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: gravity
end subroutine

! GdkGravity gtk_window_get_gravity (GtkWindow *window);
function gtk_window_get_gravity(window) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_window_get_gravity
  type(c_ptr), value :: window
end function

!  void gtk_window_set_geometry_hints (GtkWindow *window, GtkWidget *geometry_widget, GdkGeometry *geometry, GdkWindowHints geom_mask);
subroutine gtk_window_set_geometry_hints(window, geometry_widget, geometry, geom&
      &_mask) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  type(c_ptr), value :: geometry_widget
  type(c_ptr), value :: geometry
  integer(c_int), value :: geom_mask
end subroutine

!  void gtk_window_set_screen (GtkWindow *window, GdkScreen *screen);
subroutine gtk_window_set_screen(window, screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: screen
end subroutine

! GdkScreen* gtk_window_get_screen (GtkWindow *window);
function gtk_window_get_screen(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_window_get_screen
  type(c_ptr), value :: window
end function

!  gboolean gtk_window_is_active (GtkWindow *window);
function gtk_window_is_active(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_window_is_active
  type(c_ptr), value :: window
end function

! gboolean gtk_window_has_toplevel_focus (GtkWindow *window);
function gtk_window_has_toplevel_focus(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_window_has_toplevel_focus
  type(c_ptr), value :: window
end function

!  void gtk_window_set_has_frame (GtkWindow *window, gboolean setting);
subroutine gtk_window_set_has_frame(window, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_window_get_has_frame (GtkWindow *window);
function gtk_window_get_has_frame(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_window_get_has_frame
  type(c_ptr), value :: window
end function

! void gtk_window_set_frame_dimensions (GtkWindow *window, gint left, gint top, gint right, gint bottom);
subroutine gtk_window_set_frame_dimensions(window, left, top, right, bottom) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: left
  integer(c_int), value :: top
  integer(c_int), value :: right
  integer(c_int), value :: bottom
end subroutine

! void gtk_window_get_frame_dimensions (GtkWindow *window, gint *left, gint *top, gint *right, gint *bottom);
subroutine gtk_window_get_frame_dimensions(window, left, top, right, bottom) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: left
  type(c_ptr), value :: top
  type(c_ptr), value :: right
  type(c_ptr), value :: bottom
end subroutine

! void gtk_window_set_decorated (GtkWindow *window, gboolean setting);
subroutine gtk_window_set_decorated(window, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_window_get_decorated (GtkWindow *window);
function gtk_window_get_decorated(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_window_get_decorated
  type(c_ptr), value :: window
end function

! void gtk_window_set_deletable (GtkWindow *window, gboolean setting);
subroutine gtk_window_set_deletable(window, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_window_get_deletable (GtkWindow *window);
function gtk_window_get_deletable(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_window_get_deletable
  type(c_ptr), value :: window
end function

!  void gtk_window_set_icon_list (GtkWindow *window, GList *list);
subroutine gtk_window_set_icon_list(window, list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: list
end subroutine

! GList* gtk_window_get_icon_list (GtkWindow *window);
function gtk_window_get_icon_list(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_window_get_icon_list
  type(c_ptr), value :: window
end function

! void gtk_window_set_icon (GtkWindow *window, GdkPixbuf *icon);
subroutine gtk_window_set_icon(window, icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: icon
end subroutine

! void gtk_window_set_icon_name (GtkWindow *window, const gchar *name);
subroutine gtk_window_set_icon_name(window, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: window
  character(kind=c_char), dimension(*) :: name
end subroutine

! gboolean gtk_window_set_icon_from_file (GtkWindow *window, const gchar *filename, GError **err);
function gtk_window_set_icon_from_file(window, filename, err) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_window_set_icon_from_file
  type(c_ptr), value :: window
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: err
end function

! GdkPixbuf* gtk_window_get_icon (GtkWindow *window);
function gtk_window_get_icon(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_window_get_icon
  type(c_ptr), value :: window
end function

! G_CONST_RETURN gchar *gtk_window_get_icon_name (GtkWindow *window);
function gtk_window_get_icon_name(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_window_get_icon_name
  type(c_ptr), value :: window
end function

! void gtk_window_set_default_icon_list (GList *list);
subroutine gtk_window_set_default_icon_list(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

! GList* gtk_window_get_default_icon_list (void);
function gtk_window_get_default_icon_list() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_window_get_default_icon_list
end function

! void gtk_window_set_default_icon (GdkPixbuf *icon);
subroutine gtk_window_set_default_icon(icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: icon
end subroutine

! void gtk_window_set_default_icon_name (const gchar *name);
subroutine gtk_window_set_default_icon_name(name) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: name
end subroutine

! G_CONST_RETURN gchar *gtk_window_get_default_icon_name (void);
function gtk_window_get_default_icon_name() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_window_get_default_icon_name
end function

! gboolean gtk_window_set_default_icon_from_file (const gchar *filename, GError **err);
function gtk_window_set_default_icon_from_file(filename, err) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_ptr
  logical(c_bool) :: gtk_window_set_default_icon_from_file
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: err
end function

!  void gtk_window_set_auto_startup_notification (gboolean setting);
subroutine gtk_window_set_auto_startup_notification(setting) bind(c) 
  use iso_c_binding, only: c_bool
  logical(c_bool), value :: setting
end subroutine

!  void gtk_window_set_modal (GtkWindow *window, gboolean modal);
subroutine gtk_window_set_modal(window, modal) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: modal
end subroutine

! gboolean gtk_window_get_modal (GtkWindow *window);
function gtk_window_get_modal(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_window_get_modal
  type(c_ptr), value :: window
end function

! GList* gtk_window_list_toplevels (void);
function gtk_window_list_toplevels() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_window_list_toplevels
end function

!  void gtk_window_add_mnemonic (GtkWindow *window, guint keyval, GtkWidget *target);
subroutine gtk_window_add_mnemonic(window, keyval, target) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: keyval
  type(c_ptr), value :: target
end subroutine

! void gtk_window_remove_mnemonic (GtkWindow *window, guint keyval, GtkWidget *target);
subroutine gtk_window_remove_mnemonic(window, keyval, target) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: keyval
  type(c_ptr), value :: target
end subroutine

! gboolean gtk_window_mnemonic_activate (GtkWindow *window, guint keyval, GdkModifierType modifier);
function gtk_window_mnemonic_activate(window, keyval, modifier) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_window_mnemonic_activate
  type(c_ptr), value :: window
  integer(c_int), value :: keyval
  integer(c_int), value :: modifier
end function

! void gtk_window_set_mnemonic_modifier (GtkWindow *window, GdkModifierType modifier);
subroutine gtk_window_set_mnemonic_modifier(window, modifier) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: modifier
end subroutine

! GdkModifierType gtk_window_get_mnemonic_modifier (GtkWindow *window);
function gtk_window_get_mnemonic_modifier(window) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_window_get_mnemonic_modifier
  type(c_ptr), value :: window
end function

!  gboolean gtk_window_activate_key (GtkWindow *window, GdkEventKey *event);
function gtk_window_activate_key(window, event) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_window_activate_key
  type(c_ptr), value :: window
  type(c_ptr), value :: event
end function

! gboolean gtk_window_propagate_key_event (GtkWindow *window, GdkEventKey *event);
function gtk_window_propagate_key_event(window, event) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_window_propagate_key_event
  type(c_ptr), value :: window
  type(c_ptr), value :: event
end function

!  void gtk_window_present (GtkWindow *window);
subroutine gtk_window_present(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gtk_window_present_with_time (GtkWindow *window, guint32 timestamp);
subroutine gtk_window_present_with_time(window, timestamp) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: window
  integer(c_int32_t), value :: timestamp
end subroutine

! void gtk_window_iconify (GtkWindow *window);
subroutine gtk_window_iconify(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gtk_window_deiconify (GtkWindow *window);
subroutine gtk_window_deiconify(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gtk_window_stick (GtkWindow *window);
subroutine gtk_window_stick(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gtk_window_unstick (GtkWindow *window);
subroutine gtk_window_unstick(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gtk_window_maximize (GtkWindow *window);
subroutine gtk_window_maximize(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gtk_window_unmaximize (GtkWindow *window);
subroutine gtk_window_unmaximize(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gtk_window_fullscreen (GtkWindow *window);
subroutine gtk_window_fullscreen(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gtk_window_unfullscreen (GtkWindow *window);
subroutine gtk_window_unfullscreen(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

! void gtk_window_set_keep_above (GtkWindow *window, gboolean setting);
subroutine gtk_window_set_keep_above(window, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: setting
end subroutine

! void gtk_window_set_keep_below (GtkWindow *window, gboolean setting);
subroutine gtk_window_set_keep_below(window, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: window
  logical(c_bool), value :: setting
end subroutine

!  void gtk_window_begin_resize_drag (GtkWindow *window, GdkWindowEdge edge, gint button, gint root_x, gint root_y, guint32 timestamp);
subroutine gtk_window_begin_resize_drag(window, edge, button, root_x, root_y, ti&
      &mestamp) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int32_t
  type(c_ptr), value :: window
  integer(c_int), value :: edge
  integer(c_int), value :: button
  integer(c_int), value :: root_x
  integer(c_int), value :: root_y
  integer(c_int32_t), value :: timestamp
end subroutine

! void gtk_window_begin_move_drag (GtkWindow *window, gint button, gint root_x, gint root_y, guint32 timestamp);
subroutine gtk_window_begin_move_drag(window, button, root_x, root_y, timestamp)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int32_t
  type(c_ptr), value :: window
  integer(c_int), value :: button
  integer(c_int), value :: root_x
  integer(c_int), value :: root_y
  integer(c_int32_t), value :: timestamp
end subroutine

!  void gtk_window_set_policy (GtkWindow *window, gint allow_shrink, gint allow_grow, gint auto_shrink);
subroutine gtk_window_set_policy(window, allow_shrink, allow_grow, auto_shrink) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: allow_shrink
  integer(c_int), value :: allow_grow
  integer(c_int), value :: auto_shrink
end subroutine

!  void gtk_window_set_default_size (GtkWindow *window, gint width, gint height);
subroutine gtk_window_set_default_size(window, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_window_get_default_size (GtkWindow *window, gint *width, gint *height);
subroutine gtk_window_get_default_size(window, width, height) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: width
  type(c_ptr), value :: height
end subroutine

! void gtk_window_resize (GtkWindow *window, gint width, gint height);
subroutine gtk_window_resize(window, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_window_get_size (GtkWindow *window, gint *width, gint *height);
subroutine gtk_window_get_size(window, width, height) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: width
  type(c_ptr), value :: height
end subroutine

! void gtk_window_move (GtkWindow *window, gint x, gint y);
subroutine gtk_window_move(window, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: window
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void gtk_window_get_position (GtkWindow *window, gint *root_x, gint *root_y);
subroutine gtk_window_get_position(window, root_x, root_y) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: root_x
  type(c_ptr), value :: root_y
end subroutine

! gboolean gtk_window_parse_geometry (GtkWindow *window, const gchar *geometry);
function gtk_window_parse_geometry(window, geometry) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_window_parse_geometry
  type(c_ptr), value :: window
  character(kind=c_char), dimension(*) :: geometry
end function

! GtkWindowGroup *gtk_window_get_group (GtkWindow *window);
function gtk_window_get_group(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_window_get_group
  type(c_ptr), value :: window
end function

! gboolean gtk_window_has_group (GtkWindow *window);
function gtk_window_has_group(window) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_window_has_group
  type(c_ptr), value :: window
end function

!  void gtk_window_reshow_with_initial_size (GtkWindow *window);
subroutine gtk_window_reshow_with_initial_size(window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
end subroutine

!  GtkWindowType gtk_window_get_window_type (GtkWindow *window);
function gtk_window_get_window_type(window) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_window_get_window_type
  type(c_ptr), value :: window
end function

!  GType gtk_window_group_get_type (void) G_GNUC_CONST;
function gtk_window_group_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_window_group_get_type
end function

!  GtkWindowGroup * gtk_window_group_new (void);
function gtk_window_group_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_window_group_new
end function

! void gtk_window_group_add_window (GtkWindowGroup *window_group, GtkWindow *window);
subroutine gtk_window_group_add_window(window_group, window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window_group
  type(c_ptr), value :: window
end subroutine

! void gtk_window_group_remove_window (GtkWindowGroup *window_group, GtkWindow *window);
subroutine gtk_window_group_remove_window(window_group, window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window_group
  type(c_ptr), value :: window
end subroutine

! GList * gtk_window_group_list_windows (GtkWindowGroup *window_group);
function gtk_window_group_list_windows(window_group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_window_group_list_windows
  type(c_ptr), value :: window_group
end function

! void gtk_window_remove_embedded_xid (GtkWindow *window, GdkNativeWindow xid);
subroutine gtk_window_remove_embedded_xid(window, xid) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: xid
end subroutine

! void gtk_window_add_embedded_xid (GtkWindow *window, GdkNativeWindow xid);
subroutine gtk_window_add_embedded_xid(window, xid) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: window
  type(c_ptr), value :: xid
end subroutine

! GtkWidget *gtk_window_group_get_current_grab (GtkWindowGroup *window_group);
function gtk_window_group_get_current_grab(window_group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_window_group_get_current_grab
  type(c_ptr), value :: window_group
end function

!     GType gtk_accessible_get_type (void) G_GNUC_CONST;
function gtk_accessible_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_accessible_get_type
end function

!  void gtk_accessible_set_widget (GtkAccessible *accessible, GtkWidget *widget);
subroutine gtk_accessible_set_widget(accessible, widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: accessible
  type(c_ptr), value :: widget
end subroutine

! GtkWidget* gtk_accessible_get_widget (GtkAccessible *accessible);
function gtk_accessible_get_widget(accessible) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_accessible_get_widget
  type(c_ptr), value :: accessible
end function

! void gtk_accessible_connect_widget_destroyed (GtkAccessible *accessible);
subroutine gtk_accessible_connect_widget_destroyed(accessible) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: accessible
end subroutine

!   GType gtk_tool_item_get_type (void) G_GNUC_CONST;
function gtk_tool_item_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tool_item_get_type
end function

! GtkToolItem *gtk_tool_item_new (void);
function gtk_tool_item_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tool_item_new
end function

!  void gtk_tool_item_set_homogeneous (GtkToolItem *tool_item, gboolean homogeneous);
subroutine gtk_tool_item_set_homogeneous(tool_item, homogeneous) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tool_item
  logical(c_bool), value :: homogeneous
end subroutine

! gboolean gtk_tool_item_get_homogeneous (GtkToolItem *tool_item);
function gtk_tool_item_get_homogeneous(tool_item) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tool_item_get_homogeneous
  type(c_ptr), value :: tool_item
end function

!  void gtk_tool_item_set_expand (GtkToolItem *tool_item, gboolean expand);
subroutine gtk_tool_item_set_expand(tool_item, expand) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tool_item
  logical(c_bool), value :: expand
end subroutine

! gboolean gtk_tool_item_get_expand (GtkToolItem *tool_item);
function gtk_tool_item_get_expand(tool_item) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tool_item_get_expand
  type(c_ptr), value :: tool_item
end function

!  void gtk_tool_item_set_tooltip (GtkToolItem *tool_item, GtkTooltips *tooltips, const gchar *tip_text, const gchar *tip_private);
subroutine gtk_tool_item_set_tooltip(tool_item, tooltips, tip_text, tip_private)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: tool_item
  type(c_ptr), value :: tooltips
  character(kind=c_char), dimension(*) :: tip_text
  character(kind=c_char), dimension(*) :: tip_private
end subroutine

!  void gtk_tool_item_set_tooltip_text (GtkToolItem *tool_item, const gchar *text);
subroutine gtk_tool_item_set_tooltip_text(tool_item, text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: tool_item
  character(kind=c_char), dimension(*) :: text
end subroutine

! void gtk_tool_item_set_tooltip_markup (GtkToolItem *tool_item, const gchar *markup);
subroutine gtk_tool_item_set_tooltip_markup(tool_item, markup) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: tool_item
  character(kind=c_char), dimension(*) :: markup
end subroutine

!  void gtk_tool_item_set_use_drag_window (GtkToolItem *tool_item, gboolean use_drag_window);
subroutine gtk_tool_item_set_use_drag_window(tool_item, use_drag_window) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tool_item
  logical(c_bool), value :: use_drag_window
end subroutine

! gboolean gtk_tool_item_get_use_drag_window (GtkToolItem *tool_item);
function gtk_tool_item_get_use_drag_window(tool_item) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tool_item_get_use_drag_window
  type(c_ptr), value :: tool_item
end function

!  void gtk_tool_item_set_visible_horizontal (GtkToolItem *tool_item, gboolean visible_horizontal);
subroutine gtk_tool_item_set_visible_horizontal(tool_item, visible_horizontal) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tool_item
  logical(c_bool), value :: visible_horizontal
end subroutine

! gboolean gtk_tool_item_get_visible_horizontal (GtkToolItem *tool_item);
function gtk_tool_item_get_visible_horizontal(tool_item) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tool_item_get_visible_horizontal
  type(c_ptr), value :: tool_item
end function

!  void gtk_tool_item_set_visible_vertical (GtkToolItem *tool_item, gboolean visible_vertical);
subroutine gtk_tool_item_set_visible_vertical(tool_item, visible_vertical) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tool_item
  logical(c_bool), value :: visible_vertical
end subroutine

! gboolean gtk_tool_item_get_visible_vertical (GtkToolItem *tool_item);
function gtk_tool_item_get_visible_vertical(tool_item) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tool_item_get_visible_vertical
  type(c_ptr), value :: tool_item
end function

!  gboolean gtk_tool_item_get_is_important (GtkToolItem *tool_item);
function gtk_tool_item_get_is_important(tool_item) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tool_item_get_is_important
  type(c_ptr), value :: tool_item
end function

! void gtk_tool_item_set_is_important (GtkToolItem *tool_item, gboolean is_important);
subroutine gtk_tool_item_set_is_important(tool_item, is_important) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tool_item
  logical(c_bool), value :: is_important
end subroutine

!  PangoEllipsizeMode gtk_tool_item_get_ellipsize_mode (GtkToolItem *tool_item);
function gtk_tool_item_get_ellipsize_mode(tool_item) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tool_item_get_ellipsize_mode
  type(c_ptr), value :: tool_item
end function

! GtkIconSize gtk_tool_item_get_icon_size (GtkToolItem *tool_item);
function gtk_tool_item_get_icon_size(tool_item) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tool_item_get_icon_size
  type(c_ptr), value :: tool_item
end function

! GtkOrientation gtk_tool_item_get_orientation (GtkToolItem *tool_item);
function gtk_tool_item_get_orientation(tool_item) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tool_item_get_orientation
  type(c_ptr), value :: tool_item
end function

! GtkToolbarStyle gtk_tool_item_get_toolbar_style (GtkToolItem *tool_item);
function gtk_tool_item_get_toolbar_style(tool_item) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tool_item_get_toolbar_style
  type(c_ptr), value :: tool_item
end function

! GtkReliefStyle gtk_tool_item_get_relief_style (GtkToolItem *tool_item);
function gtk_tool_item_get_relief_style(tool_item) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tool_item_get_relief_style
  type(c_ptr), value :: tool_item
end function

! gfloat gtk_tool_item_get_text_alignment (GtkToolItem *tool_item);
function gtk_tool_item_get_text_alignment(tool_item) bind(c) 
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: gtk_tool_item_get_text_alignment
  type(c_ptr), value :: tool_item
end function

! GtkOrientation gtk_tool_item_get_text_orientation (GtkToolItem *tool_item);
function gtk_tool_item_get_text_orientation(tool_item) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tool_item_get_text_orientation
  type(c_ptr), value :: tool_item
end function

! GtkSizeGroup * gtk_tool_item_get_text_size_group (GtkToolItem *tool_item);
function gtk_tool_item_get_text_size_group(tool_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tool_item_get_text_size_group
  type(c_ptr), value :: tool_item
end function

!  GtkWidget * gtk_tool_item_retrieve_proxy_menu_item (GtkToolItem *tool_item);
function gtk_tool_item_retrieve_proxy_menu_item(tool_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tool_item_retrieve_proxy_menu_item
  type(c_ptr), value :: tool_item
end function

! GtkWidget * gtk_tool_item_get_proxy_menu_item (GtkToolItem *tool_item, const gchar *menu_item_id);
function gtk_tool_item_get_proxy_menu_item(tool_item, menu_item_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_tool_item_get_proxy_menu_item
  type(c_ptr), value :: tool_item
  character(kind=c_char), dimension(*) :: menu_item_id
end function

! void gtk_tool_item_set_proxy_menu_item (GtkToolItem *tool_item, const gchar *menu_item_id, GtkWidget *menu_item);
subroutine gtk_tool_item_set_proxy_menu_item(tool_item, menu_item_id, menu_item)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: tool_item
  character(kind=c_char), dimension(*) :: menu_item_id
  type(c_ptr), value :: menu_item
end subroutine

! void gtk_tool_item_rebuild_menu (GtkToolItem *tool_item);
subroutine gtk_tool_item_rebuild_menu(tool_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tool_item
end subroutine

!  void gtk_tool_item_toolbar_reconfigured (GtkToolItem *tool_item);
subroutine gtk_tool_item_toolbar_reconfigured(tool_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tool_item
end subroutine

!   GType gtk_cell_renderer_toggle_get_type (void) G_GNUC_CONST;
function gtk_cell_renderer_toggle_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_cell_renderer_toggle_get_type
end function

! GtkCellRenderer *gtk_cell_renderer_toggle_new (void);
function gtk_cell_renderer_toggle_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_cell_renderer_toggle_new
end function

!  gboolean gtk_cell_renderer_toggle_get_radio (GtkCellRendererToggle *toggle);
function gtk_cell_renderer_toggle_get_radio(toggle) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_cell_renderer_toggle_get_radio
  type(c_ptr), value :: toggle
end function

! void gtk_cell_renderer_toggle_set_radio (GtkCellRendererToggle *toggle, gboolean radio);
subroutine gtk_cell_renderer_toggle_set_radio(toggle, radio) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: toggle
  logical(c_bool), value :: radio
end subroutine

!  gboolean gtk_cell_renderer_toggle_get_active (GtkCellRendererToggle *toggle);
function gtk_cell_renderer_toggle_get_active(toggle) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_cell_renderer_toggle_get_active
  type(c_ptr), value :: toggle
end function

! void gtk_cell_renderer_toggle_set_active (GtkCellRendererToggle *toggle, gboolean setting);
subroutine gtk_cell_renderer_toggle_set_active(toggle, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: toggle
  logical(c_bool), value :: setting
end subroutine

!  gboolean gtk_cell_renderer_toggle_get_activatable (GtkCellRendererToggle *toggle);
function gtk_cell_renderer_toggle_get_activatable(toggle) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_cell_renderer_toggle_get_activatable
  type(c_ptr), value :: toggle
end function

! void gtk_cell_renderer_toggle_set_activatable (GtkCellRendererToggle *toggle, gboolean setting);
subroutine gtk_cell_renderer_toggle_set_activatable(toggle, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: toggle
  logical(c_bool), value :: setting
end subroutine

!   void gtk_accel_map_add_entry (const gchar *accel_path, guint accel_key, GdkModifierType accel_mods);
subroutine gtk_accel_map_add_entry(accel_path, accel_key, accel_mods) bind(c) 
  use iso_c_binding, only: c_char, c_int
  character(kind=c_char), dimension(*) :: accel_path
  integer(c_int), value :: accel_key
  integer(c_int), value :: accel_mods
end subroutine

! gboolean gtk_accel_map_lookup_entry (const gchar *accel_path, GtkAccelKey *key);
function gtk_accel_map_lookup_entry(accel_path, key) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_ptr
  logical(c_bool) :: gtk_accel_map_lookup_entry
  character(kind=c_char), dimension(*) :: accel_path
  type(c_ptr), value :: key
end function

! gboolean gtk_accel_map_change_entry (const gchar *accel_path, guint accel_key, GdkModifierType accel_mods, gboolean replace);
function gtk_accel_map_change_entry(accel_path, accel_key, accel_mods, replace) &
      &bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_int
  logical(c_bool) :: gtk_accel_map_change_entry
  character(kind=c_char), dimension(*) :: accel_path
  integer(c_int), value :: accel_key
  integer(c_int), value :: accel_mods
  logical(c_bool), value :: replace
end function

! void gtk_accel_map_load (const gchar *file_name);
subroutine gtk_accel_map_load(file_name) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: file_name
end subroutine

! void gtk_accel_map_save (const gchar *file_name);
subroutine gtk_accel_map_save(file_name) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: file_name
end subroutine

! void gtk_accel_map_foreach (gpointer data, GtkAccelMapForeach foreach_func);
subroutine gtk_accel_map_foreach(data, foreach_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: data
  type(c_funptr), value :: foreach_func
end subroutine

! void gtk_accel_map_load_fd (gint fd);
subroutine gtk_accel_map_load_fd(fd) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: fd
end subroutine

! void gtk_accel_map_load_scanner (GScanner *scanner);
subroutine gtk_accel_map_load_scanner(scanner) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: scanner
end subroutine

! void gtk_accel_map_save_fd (gint fd);
subroutine gtk_accel_map_save_fd(fd) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: fd
end subroutine

!  void gtk_accel_map_lock_path (const gchar *accel_path);
subroutine gtk_accel_map_lock_path(accel_path) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: accel_path
end subroutine

! void gtk_accel_map_unlock_path (const gchar *accel_path);
subroutine gtk_accel_map_unlock_path(accel_path) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: accel_path
end subroutine

!  void gtk_accel_map_add_filter (const gchar *filter_pattern);
subroutine gtk_accel_map_add_filter(filter_pattern) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: filter_pattern
end subroutine

! void gtk_accel_map_foreach_unfiltered (gpointer data, GtkAccelMapForeach foreach_func);
subroutine gtk_accel_map_foreach_unfiltered(data, foreach_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: data
  type(c_funptr), value :: foreach_func
end subroutine

!  GType gtk_accel_map_get_type (void) G_GNUC_CONST;
function gtk_accel_map_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_accel_map_get_type
end function

! GtkAccelMap *gtk_accel_map_get (void);
function gtk_accel_map_get() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_accel_map_get
end function

!   GType gtk_gamma_curve_get_type (void) G_GNUC_CONST;
function gtk_gamma_curve_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_gamma_curve_get_type
end function

! GtkWidget* gtk_gamma_curve_new (void);
function gtk_gamma_curve_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_gamma_curve_new
end function

!   GType gtk_button_get_type (void) G_GNUC_CONST;
function gtk_button_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_button_get_type
end function

! GtkWidget* gtk_button_new (void);
function gtk_button_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_button_new
end function

! GtkWidget* gtk_button_new_with_label (const gchar *label);
function gtk_button_new_with_label(label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_button_new_with_label
  character(kind=c_char), dimension(*) :: label
end function

! GtkWidget* gtk_button_new_from_stock (const gchar *stock_id);
function gtk_button_new_from_stock(stock_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_button_new_from_stock
  character(kind=c_char), dimension(*) :: stock_id
end function

! GtkWidget* gtk_button_new_with_mnemonic (const gchar *label);
function gtk_button_new_with_mnemonic(label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_button_new_with_mnemonic
  character(kind=c_char), dimension(*) :: label
end function

!  void gtk_button_pressed (GtkButton *button);
subroutine gtk_button_pressed(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: button
end subroutine

! void gtk_button_released (GtkButton *button);
subroutine gtk_button_released(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: button
end subroutine

!  void gtk_button_clicked (GtkButton *button);
subroutine gtk_button_clicked(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: button
end subroutine

!  void gtk_button_enter (GtkButton *button);
subroutine gtk_button_enter(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: button
end subroutine

! void gtk_button_leave (GtkButton *button);
subroutine gtk_button_leave(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: button
end subroutine

!  void gtk_button_set_relief (GtkButton *button, GtkReliefStyle newstyle);
subroutine gtk_button_set_relief(button, newstyle) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: button
  integer(c_int), value :: newstyle
end subroutine

! GtkReliefStyle gtk_button_get_relief (GtkButton *button);
function gtk_button_get_relief(button) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_button_get_relief
  type(c_ptr), value :: button
end function

! void gtk_button_set_label (GtkButton *button, const gchar *label);
subroutine gtk_button_set_label(button, label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: button
  character(kind=c_char), dimension(*) :: label
end subroutine

! G_CONST_RETURN gchar *gtk_button_get_label (GtkButton *button);
function gtk_button_get_label(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_button_get_label
  type(c_ptr), value :: button
end function

! void gtk_button_set_use_underline (GtkButton *button, gboolean use_underline);
subroutine gtk_button_set_use_underline(button, use_underline) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: button
  logical(c_bool), value :: use_underline
end subroutine

! gboolean gtk_button_get_use_underline (GtkButton *button);
function gtk_button_get_use_underline(button) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_button_get_use_underline
  type(c_ptr), value :: button
end function

! void gtk_button_set_use_stock (GtkButton *button, gboolean use_stock);
subroutine gtk_button_set_use_stock(button, use_stock) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: button
  logical(c_bool), value :: use_stock
end subroutine

! gboolean gtk_button_get_use_stock (GtkButton *button);
function gtk_button_get_use_stock(button) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_button_get_use_stock
  type(c_ptr), value :: button
end function

! void gtk_button_set_focus_on_click (GtkButton *button, gboolean focus_on_click);
subroutine gtk_button_set_focus_on_click(button, focus_on_click) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: button
  logical(c_bool), value :: focus_on_click
end subroutine

! gboolean gtk_button_get_focus_on_click (GtkButton *button);
function gtk_button_get_focus_on_click(button) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_button_get_focus_on_click
  type(c_ptr), value :: button
end function

! void gtk_button_set_alignment (GtkButton *button, gfloat xalign, gfloat yalign);
subroutine gtk_button_set_alignment(button, xalign, yalign) bind(c) 
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: button
  real(c_float), value :: xalign
  real(c_float), value :: yalign
end subroutine

! void gtk_button_get_alignment (GtkButton *button, gfloat *xalign, gfloat *yalign);
subroutine gtk_button_get_alignment(button, xalign, yalign) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: button
  type(c_ptr), value :: xalign
  type(c_ptr), value :: yalign
end subroutine

! void gtk_button_set_image (GtkButton *button, GtkWidget *image);
subroutine gtk_button_set_image(button, image) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: button
  type(c_ptr), value :: image
end subroutine

! GtkWidget* gtk_button_get_image (GtkButton *button);
function gtk_button_get_image(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_button_get_image
  type(c_ptr), value :: button
end function

! void gtk_button_set_image_position (GtkButton *button, GtkPositionType position);
subroutine gtk_button_set_image_position(button, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: button
  integer(c_int), value :: position
end subroutine

! GtkPositionType gtk_button_get_image_position (GtkButton *button);
function gtk_button_get_image_position(button) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_button_get_image_position
  type(c_ptr), value :: button
end function

!  GdkWindow* gtk_button_get_event_window (GtkButton *button);
function gtk_button_get_event_window(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_button_get_event_window
  type(c_ptr), value :: button
end function

!   GQuark gtk_print_error_quark (void);
function gtk_print_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: gtk_print_error_quark
end function

!  GType gtk_print_operation_get_type (void) G_GNUC_CONST;
function gtk_print_operation_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_print_operation_get_type
end function

! GtkPrintOperation * gtk_print_operation_new (void);
function gtk_print_operation_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_print_operation_new
end function

! void gtk_print_operation_set_default_page_setup (GtkPrintOperation *op, GtkPageSetup *default_page_setup);
subroutine gtk_print_operation_set_default_page_setup(op, default_page_setup) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: op
  integer(c_int), value :: default_page_setup
end subroutine

! GtkPageSetup * gtk_print_operation_get_default_page_setup (GtkPrintOperation *op);
function gtk_print_operation_get_default_page_setup(op) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_print_operation_get_default_page_setup
  type(c_ptr), value :: op
end function

! void gtk_print_operation_set_print_settings (GtkPrintOperation *op, GtkPrintSettings *print_settings);
subroutine gtk_print_operation_set_print_settings(op, print_settings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: op
  type(c_ptr), value :: print_settings
end subroutine

! GtkPrintSettings * gtk_print_operation_get_print_settings (GtkPrintOperation *op);
function gtk_print_operation_get_print_settings(op) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_print_operation_get_print_settings
  type(c_ptr), value :: op
end function

! void gtk_print_operation_set_job_name (GtkPrintOperation *op, const gchar *job_name);
subroutine gtk_print_operation_set_job_name(op, job_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: op
  character(kind=c_char), dimension(*) :: job_name
end subroutine

! void gtk_print_operation_set_n_pages (GtkPrintOperation *op, gint n_pages);
subroutine gtk_print_operation_set_n_pages(op, n_pages) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: op
  integer(c_int), value :: n_pages
end subroutine

! void gtk_print_operation_set_current_page (GtkPrintOperation *op, gint current_page);
subroutine gtk_print_operation_set_current_page(op, current_page) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: op
  integer(c_int), value :: current_page
end subroutine

! void gtk_print_operation_set_use_full_page (GtkPrintOperation *op, gboolean full_page);
subroutine gtk_print_operation_set_use_full_page(op, full_page) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: op
  logical(c_bool), value :: full_page
end subroutine

! void gtk_print_operation_set_unit (GtkPrintOperation *op, GtkUnit unit);
subroutine gtk_print_operation_set_unit(op, unit) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: op
  integer(c_int), value :: unit
end subroutine

! void gtk_print_operation_set_export_filename (GtkPrintOperation *op, const gchar *filename);
subroutine gtk_print_operation_set_export_filename(op, filename) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: op
  character(kind=c_char), dimension(*) :: filename
end subroutine

! void gtk_print_operation_set_track_print_status (GtkPrintOperation *op, gboolean track_status);
subroutine gtk_print_operation_set_track_print_status(op, track_status) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: op
  logical(c_bool), value :: track_status
end subroutine

! void gtk_print_operation_set_show_progress (GtkPrintOperation *op, gboolean show_progress);
subroutine gtk_print_operation_set_show_progress(op, show_progress) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: op
  logical(c_bool), value :: show_progress
end subroutine

! void gtk_print_operation_set_allow_async (GtkPrintOperation *op, gboolean allow_async);
subroutine gtk_print_operation_set_allow_async(op, allow_async) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: op
  logical(c_bool), value :: allow_async
end subroutine

! void gtk_print_operation_set_custom_tab_label (GtkPrintOperation *op, const gchar *label);
subroutine gtk_print_operation_set_custom_tab_label(op, label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: op
  character(kind=c_char), dimension(*) :: label
end subroutine

! GtkPrintOperationResult gtk_print_operation_run (GtkPrintOperation *op, GtkPrintOperationAction action, GtkWindow *parent, GError **error);
function gtk_print_operation_run(op, action, parent, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_print_operation_run
  type(c_ptr), value :: op
  integer(c_int), value :: action
  type(c_ptr), value :: parent
  type(c_ptr), value :: error
end function

! void gtk_print_operation_get_error (GtkPrintOperation *op, GError **error);
subroutine gtk_print_operation_get_error(op, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: op
  type(c_ptr), value :: error
end subroutine

! GtkPrintStatus gtk_print_operation_get_status (GtkPrintOperation *op);
function gtk_print_operation_get_status(op) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_print_operation_get_status
  type(c_ptr), value :: op
end function

! G_CONST_RETURN gchar * gtk_print_operation_get_status_string (GtkPrintOperation *op);
function gtk_print_operation_get_status_string(op) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_print_operation_get_status_string
  type(c_ptr), value :: op
end function

! gboolean gtk_print_operation_is_finished (GtkPrintOperation *op);
function gtk_print_operation_is_finished(op) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_print_operation_is_finished
  type(c_ptr), value :: op
end function

! void gtk_print_operation_cancel (GtkPrintOperation *op);
subroutine gtk_print_operation_cancel(op) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: op
end subroutine

! void gtk_print_operation_draw_page_finish (GtkPrintOperation *op);
subroutine gtk_print_operation_draw_page_finish(op) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: op
end subroutine

! void gtk_print_operation_set_defer_drawing (GtkPrintOperation *op);
subroutine gtk_print_operation_set_defer_drawing(op) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: op
end subroutine

! void gtk_print_operation_set_support_selection (GtkPrintOperation *op, gboolean support_selection);
subroutine gtk_print_operation_set_support_selection(op, support_selection) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: op
  logical(c_bool), value :: support_selection
end subroutine

! gboolean gtk_print_operation_get_support_selection (GtkPrintOperation *op);
function gtk_print_operation_get_support_selection(op) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_print_operation_get_support_selection
  type(c_ptr), value :: op
end function

! void gtk_print_operation_set_has_selection (GtkPrintOperation *op, gboolean has_selection);
subroutine gtk_print_operation_set_has_selection(op, has_selection) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: op
  logical(c_bool), value :: has_selection
end subroutine

! gboolean gtk_print_operation_get_has_selection (GtkPrintOperation *op);
function gtk_print_operation_get_has_selection(op) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_print_operation_get_has_selection
  type(c_ptr), value :: op
end function

! void gtk_print_operation_set_embed_page_setup (GtkPrintOperation *op, gboolean embed);
subroutine gtk_print_operation_set_embed_page_setup(op, embed) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: op
  logical(c_bool), value :: embed
end subroutine

! gboolean gtk_print_operation_get_embed_page_setup (GtkPrintOperation *op);
function gtk_print_operation_get_embed_page_setup(op) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_print_operation_get_embed_page_setup
  type(c_ptr), value :: op
end function

! gint gtk_print_operation_get_n_pages_to_print (GtkPrintOperation *op);
function gtk_print_operation_get_n_pages_to_print(op) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_print_operation_get_n_pages_to_print
  type(c_ptr), value :: op
end function

!  GtkPageSetup *gtk_print_run_page_setup_dialog (GtkWindow *parent, GtkPageSetup *page_setup, GtkPrintSettings *settings);
function gtk_print_run_page_setup_dialog(parent, page_setup, settings) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_print_run_page_setup_dialog
  type(c_ptr), value :: parent
  integer(c_int), value :: page_setup
  type(c_ptr), value :: settings
end function

!  void gtk_print_run_page_setup_dialog_async (GtkWindow *parent, GtkPageSetup *page_setup, GtkPrintSettings *settings, GtkPageSetupDoneFunc done_cb, gpointer data);
subroutine gtk_print_run_page_setup_dialog_async(parent, page_setup, settings, d&
      &one_cb, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: parent
  integer(c_int), value :: page_setup
  type(c_ptr), value :: settings
  integer(c_int), value :: done_cb
  type(c_ptr), value :: data
end subroutine

!   GType gtk_expander_get_type (void) G_GNUC_CONST;
function gtk_expander_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_expander_get_type
end function

!  GtkWidget *gtk_expander_new (const gchar *label);
function gtk_expander_new(label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_expander_new
  character(kind=c_char), dimension(*) :: label
end function

! GtkWidget *gtk_expander_new_with_mnemonic (const gchar *label);
function gtk_expander_new_with_mnemonic(label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_expander_new_with_mnemonic
  character(kind=c_char), dimension(*) :: label
end function

!  void gtk_expander_set_expanded (GtkExpander *expander, gboolean expanded);
subroutine gtk_expander_set_expanded(expander, expanded) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: expander
  logical(c_bool), value :: expanded
end subroutine

! gboolean gtk_expander_get_expanded (GtkExpander *expander);
function gtk_expander_get_expanded(expander) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_expander_get_expanded
  type(c_ptr), value :: expander
end function

!  void gtk_expander_set_spacing (GtkExpander *expander, gint spacing);
subroutine gtk_expander_set_spacing(expander, spacing) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: expander
  integer(c_int), value :: spacing
end subroutine

! gint gtk_expander_get_spacing (GtkExpander *expander);
function gtk_expander_get_spacing(expander) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_expander_get_spacing
  type(c_ptr), value :: expander
end function

!  void gtk_expander_set_label (GtkExpander *expander, const gchar *label);
subroutine gtk_expander_set_label(expander, label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: expander
  character(kind=c_char), dimension(*) :: label
end subroutine

! G_CONST_RETURN gchar *gtk_expander_get_label (GtkExpander *expander);
function gtk_expander_get_label(expander) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_expander_get_label
  type(c_ptr), value :: expander
end function

!  void gtk_expander_set_use_underline (GtkExpander *expander, gboolean use_underline);
subroutine gtk_expander_set_use_underline(expander, use_underline) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: expander
  logical(c_bool), value :: use_underline
end subroutine

! gboolean gtk_expander_get_use_underline (GtkExpander *expander);
function gtk_expander_get_use_underline(expander) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_expander_get_use_underline
  type(c_ptr), value :: expander
end function

!  void gtk_expander_set_use_markup (GtkExpander *expander, gboolean use_markup);
subroutine gtk_expander_set_use_markup(expander, use_markup) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: expander
  logical(c_bool), value :: use_markup
end subroutine

! gboolean gtk_expander_get_use_markup (GtkExpander *expander);
function gtk_expander_get_use_markup(expander) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_expander_get_use_markup
  type(c_ptr), value :: expander
end function

!  void gtk_expander_set_label_widget (GtkExpander *expander, GtkWidget *label_widget);
subroutine gtk_expander_set_label_widget(expander, label_widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: expander
  type(c_ptr), value :: label_widget
end subroutine

! GtkWidget *gtk_expander_get_label_widget (GtkExpander *expander);
function gtk_expander_get_label_widget(expander) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_expander_get_label_widget
  type(c_ptr), value :: expander
end function

! void gtk_expander_set_label_fill (GtkExpander *expander, gboolean label_fill);
subroutine gtk_expander_set_label_fill(expander, label_fill) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: expander
  logical(c_bool), value :: label_fill
end subroutine

! gboolean gtk_expander_get_label_fill (GtkExpander *expander);
function gtk_expander_get_label_fill(expander) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_expander_get_label_fill
  type(c_ptr), value :: expander
end function

!   GType gtk_hscale_get_type (void) G_GNUC_CONST;
function gtk_hscale_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_hscale_get_type
end function

! GtkWidget* gtk_hscale_new (GtkAdjustment *adjustment);
function gtk_hscale_new(adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_hscale_new
  type(c_ptr), value :: adjustment
end function

! GtkWidget* gtk_hscale_new_with_range (gdouble min, gdouble max, gdouble step);
function gtk_hscale_new_with_range(min, max, step) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr) :: gtk_hscale_new_with_range
  real(c_double), value :: min
  real(c_double), value :: max
  real(c_double), value :: step
end function

!   GType gtk_combo_box_entry_get_type (void) G_GNUC_CONST;
function gtk_combo_box_entry_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_combo_box_entry_get_type
end function

! GtkWidget *gtk_combo_box_entry_new (void);
function gtk_combo_box_entry_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_combo_box_entry_new
end function

! GtkWidget *gtk_combo_box_entry_new_with_model (GtkTreeModel *model, gint text_column);
function gtk_combo_box_entry_new_with_model(model, text_column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_combo_box_entry_new_with_model
  type(c_ptr), value :: model
  integer(c_int), value :: text_column
end function

!  void gtk_combo_box_entry_set_text_column (GtkComboBoxEntry *entry_box, gint text_column);
subroutine gtk_combo_box_entry_set_text_column(entry_box, text_column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: entry_box
  integer(c_int), value :: text_column
end subroutine

! gint gtk_combo_box_entry_get_text_column (GtkComboBoxEntry *entry_box);
function gtk_combo_box_entry_get_text_column(entry_box) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_combo_box_entry_get_text_column
  type(c_ptr), value :: entry_box
end function

!  GtkWidget *gtk_combo_box_entry_new_text (void);
function gtk_combo_box_entry_new_text() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_combo_box_entry_new_text
end function

!   GType gtk_cell_renderer_combo_get_type (void) G_GNUC_CONST;
function gtk_cell_renderer_combo_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_cell_renderer_combo_get_type
end function

! GtkCellRenderer *gtk_cell_renderer_combo_new (void);
function gtk_cell_renderer_combo_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_cell_renderer_combo_new
end function

!   void gtk_drag_get_data (GtkWidget *widget, GdkDragContext *context, GdkAtom target, guint32 time_);
subroutine gtk_drag_get_data(widget, context, target, time_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: widget
  type(c_ptr), value :: context
  type(c_ptr), value :: target
  integer(c_int32_t), value :: time_
end subroutine

! void gtk_drag_finish (GdkDragContext *context, gboolean success, gboolean del, guint32 time_);
subroutine gtk_drag_finish(context, success, del, time_) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_int32_t
  type(c_ptr), value :: context
  logical(c_bool), value :: success
  logical(c_bool), value :: del
  integer(c_int32_t), value :: time_
end subroutine

!  GtkWidget *gtk_drag_get_source_widget (GdkDragContext *context);
function gtk_drag_get_source_widget(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_drag_get_source_widget
  type(c_ptr), value :: context
end function

!  void gtk_drag_highlight (GtkWidget *widget);
subroutine gtk_drag_highlight(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_drag_unhighlight (GtkWidget *widget);
subroutine gtk_drag_unhighlight(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

!  void gtk_drag_dest_set (GtkWidget *widget, GtkDestDefaults flags, const GtkTargetEntry *targets, gint n_targets, GdkDragAction actions);
subroutine gtk_drag_dest_set(widget, flags, targets, n_targets, actions) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  integer(c_int), value :: flags
  type(c_ptr), value :: targets
  integer(c_int), value :: n_targets
  integer(c_int), value :: actions
end subroutine

!  void gtk_drag_dest_set_proxy (GtkWidget *widget, GdkWindow *proxy_window, GdkDragProtocol protocol, gboolean use_coordinates);
subroutine gtk_drag_dest_set_proxy(widget, proxy_window, protocol, use_coordinat&
      &es) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr), value :: widget
  type(c_ptr), value :: proxy_window
  integer(c_int), value :: protocol
  logical(c_bool), value :: use_coordinates
end subroutine

!  void gtk_drag_dest_unset (GtkWidget *widget);
subroutine gtk_drag_dest_unset(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

!  GdkAtom gtk_drag_dest_find_target (GtkWidget *widget, GdkDragContext *context, GtkTargetList *target_list);
function gtk_drag_dest_find_target(widget, context, target_list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_drag_dest_find_target
  type(c_ptr), value :: widget
  type(c_ptr), value :: context
  type(c_ptr), value :: target_list
end function

! GtkTargetList* gtk_drag_dest_get_target_list (GtkWidget *widget);
function gtk_drag_dest_get_target_list(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_drag_dest_get_target_list
  type(c_ptr), value :: widget
end function

! void gtk_drag_dest_set_target_list (GtkWidget *widget, GtkTargetList *target_list);
subroutine gtk_drag_dest_set_target_list(widget, target_list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: target_list
end subroutine

! void gtk_drag_dest_add_text_targets (GtkWidget *widget);
subroutine gtk_drag_dest_add_text_targets(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_drag_dest_add_image_targets (GtkWidget *widget);
subroutine gtk_drag_dest_add_image_targets(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_drag_dest_add_uri_targets (GtkWidget *widget);
subroutine gtk_drag_dest_add_uri_targets(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

!  void gtk_drag_dest_set_track_motion (GtkWidget *widget, gboolean track_motion);
subroutine gtk_drag_dest_set_track_motion(widget, track_motion) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: widget
  logical(c_bool), value :: track_motion
end subroutine

! gboolean gtk_drag_dest_get_track_motion (GtkWidget *widget);
function gtk_drag_dest_get_track_motion(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_drag_dest_get_track_motion
  type(c_ptr), value :: widget
end function

!  void gtk_drag_source_set (GtkWidget *widget, GdkModifierType start_button_mask, const GtkTargetEntry *targets, gint n_targets, GdkDragAction actions);
subroutine gtk_drag_source_set(widget, start_button_mask, targets, n_targets, ac&
      &tions) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  integer(c_int), value :: start_button_mask
  type(c_ptr), value :: targets
  integer(c_int), value :: n_targets
  integer(c_int), value :: actions
end subroutine

!  void gtk_drag_source_unset (GtkWidget *widget);
subroutine gtk_drag_source_unset(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

!  GtkTargetList* gtk_drag_source_get_target_list (GtkWidget *widget);
function gtk_drag_source_get_target_list(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_drag_source_get_target_list
  type(c_ptr), value :: widget
end function

! void gtk_drag_source_set_target_list (GtkWidget *widget, GtkTargetList *target_list);
subroutine gtk_drag_source_set_target_list(widget, target_list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: target_list
end subroutine

! void gtk_drag_source_add_text_targets (GtkWidget *widget);
subroutine gtk_drag_source_add_text_targets(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_drag_source_add_image_targets (GtkWidget *widget);
subroutine gtk_drag_source_add_image_targets(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_drag_source_add_uri_targets (GtkWidget *widget);
subroutine gtk_drag_source_add_uri_targets(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

!  void gtk_drag_source_set_icon (GtkWidget *widget, GdkColormap *colormap, GdkPixmap *pixmap, GdkBitmap *mask);
subroutine gtk_drag_source_set_icon(widget, colormap, pixmap, mask) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: colormap
  type(c_ptr), value :: pixmap
  type(c_ptr), value :: mask
end subroutine

! void gtk_drag_source_set_icon_pixbuf (GtkWidget *widget, GdkPixbuf *pixbuf);
subroutine gtk_drag_source_set_icon_pixbuf(widget, pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: pixbuf
end subroutine

! void gtk_drag_source_set_icon_stock (GtkWidget *widget, const gchar *stock_id);
subroutine gtk_drag_source_set_icon_stock(widget, stock_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: stock_id
end subroutine

! void gtk_drag_source_set_icon_name (GtkWidget *widget, const gchar *icon_name);
subroutine gtk_drag_source_set_icon_name(widget, icon_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: icon_name
end subroutine

!  GdkDragContext *gtk_drag_begin (GtkWidget *widget, GtkTargetList *targets, GdkDragAction actions, gint button, GdkEvent *event);
function gtk_drag_begin(widget, targets, actions, button, event) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_drag_begin
  type(c_ptr), value :: widget
  type(c_ptr), value :: targets
  integer(c_int), value :: actions
  integer(c_int), value :: button
  type(c_ptr), value :: event
end function

!  void gtk_drag_set_icon_widget (GdkDragContext *context, GtkWidget *widget, gint hot_x, gint hot_y);
subroutine gtk_drag_set_icon_widget(context, widget, hot_x, hot_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: context
  type(c_ptr), value :: widget
  integer(c_int), value :: hot_x
  integer(c_int), value :: hot_y
end subroutine

! void gtk_drag_set_icon_pixmap (GdkDragContext *context, GdkColormap *colormap, GdkPixmap *pixmap, GdkBitmap *mask, gint hot_x, gint hot_y);
subroutine gtk_drag_set_icon_pixmap(context, colormap, pixmap, mask, hot_x, hot_&
      &y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: context
  type(c_ptr), value :: colormap
  type(c_ptr), value :: pixmap
  type(c_ptr), value :: mask
  integer(c_int), value :: hot_x
  integer(c_int), value :: hot_y
end subroutine

! void gtk_drag_set_icon_pixbuf (GdkDragContext *context, GdkPixbuf *pixbuf, gint hot_x, gint hot_y);
subroutine gtk_drag_set_icon_pixbuf(context, pixbuf, hot_x, hot_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: context
  type(c_ptr), value :: pixbuf
  integer(c_int), value :: hot_x
  integer(c_int), value :: hot_y
end subroutine

! void gtk_drag_set_icon_stock (GdkDragContext *context, const gchar *stock_id, gint hot_x, gint hot_y);
subroutine gtk_drag_set_icon_stock(context, stock_id, hot_x, hot_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: stock_id
  integer(c_int), value :: hot_x
  integer(c_int), value :: hot_y
end subroutine

! void gtk_drag_set_icon_name (GdkDragContext *context, const gchar *icon_name, gint hot_x, gint hot_y);
subroutine gtk_drag_set_icon_name(context, icon_name, hot_x, hot_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: icon_name
  integer(c_int), value :: hot_x
  integer(c_int), value :: hot_y
end subroutine

!  void gtk_drag_set_icon_default (GdkDragContext *context);
subroutine gtk_drag_set_icon_default(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

!  gboolean gtk_drag_check_threshold (GtkWidget *widget, gint start_x, gint start_y, gint current_x, gint current_y);
function gtk_drag_check_threshold(widget, start_x, start_y, current_x, current_y&
      &) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_drag_check_threshold
  type(c_ptr), value :: widget
  integer(c_int), value :: start_x
  integer(c_int), value :: start_y
  integer(c_int), value :: current_x
  integer(c_int), value :: current_y
end function

!  void gtk_drag_set_default_icon (GdkColormap *colormap, GdkPixmap *pixmap, GdkBitmap *mask, gint hot_x, gint hot_y);
subroutine gtk_drag_set_default_icon(colormap, pixmap, mask, hot_x, hot_y) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: colormap
  type(c_ptr), value :: pixmap
  type(c_ptr), value :: mask
  integer(c_int), value :: hot_x
  integer(c_int), value :: hot_y
end subroutine

!   GType gtk_statusbar_get_type (void) G_GNUC_CONST;
function gtk_statusbar_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_statusbar_get_type
end function

! GtkWidget* gtk_statusbar_new (void);
function gtk_statusbar_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_statusbar_new
end function

!  guint gtk_statusbar_get_context_id (GtkStatusbar *statusbar, const gchar *context_description);
function gtk_statusbar_get_context_id(statusbar, context_description) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gtk_statusbar_get_context_id
  type(c_ptr), value :: statusbar
  character(kind=c_char), dimension(*) :: context_description
end function

!  guint gtk_statusbar_push (GtkStatusbar *statusbar, guint context_id, const gchar *text);
function gtk_statusbar_push(statusbar, context_id, text) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gtk_statusbar_push
  type(c_ptr), value :: statusbar
  integer(c_int), value :: context_id
  character(kind=c_char), dimension(*) :: text
end function

! void gtk_statusbar_pop (GtkStatusbar *statusbar, guint context_id);
subroutine gtk_statusbar_pop(statusbar, context_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: statusbar
  integer(c_int), value :: context_id
end subroutine

! void gtk_statusbar_remove (GtkStatusbar *statusbar, guint context_id, guint message_id);
subroutine gtk_statusbar_remove(statusbar, context_id, message_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: statusbar
  integer(c_int), value :: context_id
  integer(c_int), value :: message_id
end subroutine

! void gtk_statusbar_remove_all (GtkStatusbar *statusbar, guint context_id);
subroutine gtk_statusbar_remove_all(statusbar, context_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: statusbar
  integer(c_int), value :: context_id
end subroutine

!   void gtk_statusbar_set_has_resize_grip (GtkStatusbar *statusbar, gboolean setting);
subroutine gtk_statusbar_set_has_resize_grip(statusbar, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: statusbar
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_statusbar_get_has_resize_grip (GtkStatusbar *statusbar);
function gtk_statusbar_get_has_resize_grip(statusbar) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_statusbar_get_has_resize_grip
  type(c_ptr), value :: statusbar
end function

!  GtkWidget* gtk_statusbar_get_message_area (GtkStatusbar *statusbar);
function gtk_statusbar_get_message_area(statusbar) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_statusbar_get_message_area
  type(c_ptr), value :: statusbar
end function

!   GType gtk_toggle_tool_button_get_type (void) G_GNUC_CONST;
function gtk_toggle_tool_button_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_toggle_tool_button_get_type
end function

! GtkToolItem *gtk_toggle_tool_button_new (void);
function gtk_toggle_tool_button_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_toggle_tool_button_new
end function

! GtkToolItem *gtk_toggle_tool_button_new_from_stock (const gchar *stock_id);
function gtk_toggle_tool_button_new_from_stock(stock_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_toggle_tool_button_new_from_stock
  character(kind=c_char), dimension(*) :: stock_id
end function

!  void gtk_toggle_tool_button_set_active (GtkToggleToolButton *button, gboolean is_active);
subroutine gtk_toggle_tool_button_set_active(button, is_active) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: button
  logical(c_bool), value :: is_active
end subroutine

! gboolean gtk_toggle_tool_button_get_active (GtkToggleToolButton *button);
function gtk_toggle_tool_button_get_active(button) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_toggle_tool_button_get_active
  type(c_ptr), value :: button
end function

!   GType gtk_arrow_get_type (void) G_GNUC_CONST;
function gtk_arrow_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_arrow_get_type
end function

! GtkWidget* gtk_arrow_new (GtkArrowType arrow_type, GtkShadowType shadow_type);
function gtk_arrow_new(arrow_type, shadow_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_arrow_new
  integer(c_int), value :: arrow_type
  integer(c_int), value :: shadow_type
end function

! void gtk_arrow_set (GtkArrow *arrow, GtkArrowType arrow_type, GtkShadowType shadow_type);
subroutine gtk_arrow_set(arrow, arrow_type, shadow_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: arrow
  integer(c_int), value :: arrow_type
  integer(c_int), value :: shadow_type
end subroutine

!   GType gtk_entry_buffer_get_type (void) G_GNUC_CONST;
function gtk_entry_buffer_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_entry_buffer_get_type
end function

!  GtkEntryBuffer* gtk_entry_buffer_new (const gchar *initial_chars, gint n_initial_chars);
function gtk_entry_buffer_new(initial_chars, n_initial_chars) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: gtk_entry_buffer_new
  character(kind=c_char), dimension(*) :: initial_chars
  integer(c_int), value :: n_initial_chars
end function

!  gsize gtk_entry_buffer_get_bytes (GtkEntryBuffer *buffer);
function gtk_entry_buffer_get_bytes(buffer) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: gtk_entry_buffer_get_bytes
  type(c_ptr), value :: buffer
end function

!  guint gtk_entry_buffer_get_length (GtkEntryBuffer *buffer);
function gtk_entry_buffer_get_length(buffer) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_entry_buffer_get_length
  type(c_ptr), value :: buffer
end function

!  G_CONST_RETURN gchar* gtk_entry_buffer_get_text (GtkEntryBuffer *buffer);
function gtk_entry_buffer_get_text(buffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_entry_buffer_get_text
  type(c_ptr), value :: buffer
end function

!  void gtk_entry_buffer_set_text (GtkEntryBuffer *buffer, const gchar *chars, gint n_chars);
subroutine gtk_entry_buffer_set_text(buffer, chars, n_chars) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: buffer
  character(kind=c_char), dimension(*) :: chars
  integer(c_int), value :: n_chars
end subroutine

!  void gtk_entry_buffer_set_max_length (GtkEntryBuffer *buffer, gint max_length);
subroutine gtk_entry_buffer_set_max_length(buffer, max_length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: buffer
  integer(c_int), value :: max_length
end subroutine

!  gint gtk_entry_buffer_get_max_length (GtkEntryBuffer *buffer);
function gtk_entry_buffer_get_max_length(buffer) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_entry_buffer_get_max_length
  type(c_ptr), value :: buffer
end function

!  guint gtk_entry_buffer_insert_text (GtkEntryBuffer *buffer, guint position, const gchar *chars, gint n_chars);
function gtk_entry_buffer_insert_text(buffer, position, chars, n_chars) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gtk_entry_buffer_insert_text
  type(c_ptr), value :: buffer
  integer(c_int), value :: position
  character(kind=c_char), dimension(*) :: chars
  integer(c_int), value :: n_chars
end function

!  guint gtk_entry_buffer_delete_text (GtkEntryBuffer *buffer, guint position, gint n_chars);
function gtk_entry_buffer_delete_text(buffer, position, n_chars) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_entry_buffer_delete_text
  type(c_ptr), value :: buffer
  integer(c_int), value :: position
  integer(c_int), value :: n_chars
end function

!  void gtk_entry_buffer_emit_inserted_text (GtkEntryBuffer *buffer, guint position, const gchar *chars, guint n_chars);
subroutine gtk_entry_buffer_emit_inserted_text(buffer, position, chars, n_chars)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: buffer
  integer(c_int), value :: position
  character(kind=c_char), dimension(*) :: chars
  integer(c_int), value :: n_chars
end subroutine

!  void gtk_entry_buffer_emit_deleted_text (GtkEntryBuffer *buffer, guint position, guint n_chars);
subroutine gtk_entry_buffer_emit_deleted_text(buffer, position, n_chars) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: buffer
  integer(c_int), value :: position
  integer(c_int), value :: n_chars
end subroutine

!   GType gtk_menu_tool_button_get_type (void) G_GNUC_CONST;
function gtk_menu_tool_button_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_menu_tool_button_get_type
end function

! GtkToolItem *gtk_menu_tool_button_new (GtkWidget *icon_widget, const gchar *label);
function gtk_menu_tool_button_new(icon_widget, label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_menu_tool_button_new
  type(c_ptr), value :: icon_widget
  character(kind=c_char), dimension(*) :: label
end function

! GtkToolItem *gtk_menu_tool_button_new_from_stock (const gchar *stock_id);
function gtk_menu_tool_button_new_from_stock(stock_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_menu_tool_button_new_from_stock
  character(kind=c_char), dimension(*) :: stock_id
end function

!  void gtk_menu_tool_button_set_menu (GtkMenuToolButton *button, GtkWidget *menu);
subroutine gtk_menu_tool_button_set_menu(button, menu) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: button
  type(c_ptr), value :: menu
end subroutine

! GtkWidget *gtk_menu_tool_button_get_menu (GtkMenuToolButton *button);
function gtk_menu_tool_button_get_menu(button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_menu_tool_button_get_menu
  type(c_ptr), value :: button
end function

!  void gtk_menu_tool_button_set_arrow_tooltip (GtkMenuToolButton *button, GtkTooltips *tooltips, const gchar *tip_text, const gchar *tip_private);
subroutine gtk_menu_tool_button_set_arrow_tooltip(button, tooltips, tip_text, ti&
      &p_private) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: button
  type(c_ptr), value :: tooltips
  character(kind=c_char), dimension(*) :: tip_text
  character(kind=c_char), dimension(*) :: tip_private
end subroutine

!  void gtk_menu_tool_button_set_arrow_tooltip_text (GtkMenuToolButton *button, const gchar *text);
subroutine gtk_menu_tool_button_set_arrow_tooltip_text(button, text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: button
  character(kind=c_char), dimension(*) :: text
end subroutine

! void gtk_menu_tool_button_set_arrow_tooltip_markup (GtkMenuToolButton *button, const gchar *markup);
subroutine gtk_menu_tool_button_set_arrow_tooltip_markup(button, markup) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: button
  character(kind=c_char), dimension(*) :: markup
end subroutine

!   GType gtk_activatable_get_type (void) G_GNUC_CONST;
function gtk_activatable_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_activatable_get_type
end function

!  void gtk_activatable_sync_action_properties (GtkActivatable *activatable, GtkAction *action);
subroutine gtk_activatable_sync_action_properties(activatable, action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: activatable
  type(c_ptr), value :: action
end subroutine

!  void gtk_activatable_set_related_action (GtkActivatable *activatable, GtkAction *action);
subroutine gtk_activatable_set_related_action(activatable, action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: activatable
  type(c_ptr), value :: action
end subroutine

! GtkAction *gtk_activatable_get_related_action (GtkActivatable *activatable);
function gtk_activatable_get_related_action(activatable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_activatable_get_related_action
  type(c_ptr), value :: activatable
end function

!  void gtk_activatable_set_use_action_appearance (GtkActivatable *activatable, gboolean use_appearance);
subroutine gtk_activatable_set_use_action_appearance(activatable, use_appearance&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: activatable
  logical(c_bool), value :: use_appearance
end subroutine

! gboolean gtk_activatable_get_use_action_appearance (GtkActivatable *activatable);
function gtk_activatable_get_use_action_appearance(activatable) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_activatable_get_use_action_appearance
  type(c_ptr), value :: activatable
end function

!  void gtk_activatable_do_set_related_action (GtkActivatable *activatable, GtkAction *action);
subroutine gtk_activatable_do_set_related_action(activatable, action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: activatable
  type(c_ptr), value :: action
end subroutine

!   GType gtk_style_get_type (void) G_GNUC_CONST;
function gtk_style_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_style_get_type
end function

! GtkStyle* gtk_style_new (void);
function gtk_style_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_style_new
end function

! GtkStyle* gtk_style_copy (GtkStyle *style);
function gtk_style_copy(style) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_style_copy
  type(c_ptr), value :: style
end function

! GtkStyle* gtk_style_attach (GtkStyle *style, GdkWindow *window) G_GNUC_WARN_UNUSED_RESULT;
function gtk_style_attach(style, window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_style_attach
  type(c_ptr), value :: style
  type(c_ptr), value :: window
end function

! void gtk_style_detach (GtkStyle *style);
subroutine gtk_style_detach(style) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: style
end subroutine

!  GtkStyle* gtk_style_ref (GtkStyle *style);
function gtk_style_ref(style) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_style_ref
  type(c_ptr), value :: style
end function

! void gtk_style_unref (GtkStyle *style);
subroutine gtk_style_unref(style) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: style
end subroutine

!  GdkFont * gtk_style_get_font (GtkStyle *style);
function gtk_style_get_font(style) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_style_get_font
  type(c_ptr), value :: style
end function

! void gtk_style_set_font (GtkStyle *style, GdkFont *font);
subroutine gtk_style_set_font(style, font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: style
  type(c_ptr), value :: font
end subroutine

!  void gtk_style_set_background (GtkStyle *style, GdkWindow *window, GtkStateType state_type);
subroutine gtk_style_set_background(style, window, state_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
end subroutine

! void gtk_style_apply_default_background (GtkStyle *style, GdkWindow *window, gboolean set_bg, GtkStateType state_type, const GdkRectangle *area, gint x, gint y, gint width, gint height);
subroutine gtk_style_apply_default_background(style, window, set_bg, state_type,&
      & area, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_int
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  logical(c_bool), value :: set_bg
  integer(c_int), value :: state_type
  type(c_ptr), value :: area
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

!  GtkIconSet* gtk_style_lookup_icon_set (GtkStyle *style, const gchar *stock_id);
function gtk_style_lookup_icon_set(style, stock_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_style_lookup_icon_set
  type(c_ptr), value :: style
  character(kind=c_char), dimension(*) :: stock_id
end function

! gboolean gtk_style_lookup_color (GtkStyle *style, const gchar *color_name, GdkColor *color);
function gtk_style_lookup_color(style, color_name, color) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_style_lookup_color
  type(c_ptr), value :: style
  character(kind=c_char), dimension(*) :: color_name
  type(c_ptr), value :: color
end function

!  GdkPixbuf* gtk_style_render_icon (GtkStyle *style, const GtkIconSource *source, GtkTextDirection direction, GtkStateType state, GtkIconSize size, GtkWidget *widget, const gchar *detail);
function gtk_style_render_icon(style, source, direction, state, size, widget, de&
      &tail) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr) :: gtk_style_render_icon
  type(c_ptr), value :: style
  type(c_ptr), value :: source
  integer(c_int), value :: direction
  integer(c_int), value :: state
  integer(c_int), value :: size
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
end function

!  void gtk_draw_hline (GtkStyle *style, GdkWindow *window, GtkStateType state_type, gint x1, gint x2, gint y);
subroutine gtk_draw_hline(style, window, state_type, x1, x2, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: x1
  integer(c_int), value :: x2
  integer(c_int), value :: y
end subroutine

! void gtk_draw_vline (GtkStyle *style, GdkWindow *window, GtkStateType state_type, gint y1_, gint y2_, gint x);
subroutine gtk_draw_vline(style, window, state_type, y1_, y2_, x) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: y1_
  integer(c_int), value :: y2_
  integer(c_int), value :: x
end subroutine

! void gtk_draw_shadow (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height);
subroutine gtk_draw_shadow(style, window, state_type, shadow_type, x, y, width, &
      &height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_draw_polygon (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, GdkPoint *points, gint npoints, gboolean fill);
subroutine gtk_draw_polygon(style, window, state_type, shadow_type, points, npoi&
      &nts, fill) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  type(c_ptr), value :: points
  integer(c_int), value :: npoints
  logical(c_bool), value :: fill
end subroutine

! void gtk_draw_arrow (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, GtkArrowType arrow_type, gboolean fill, gint x, gint y, gint width, gint height);
subroutine gtk_draw_arrow(style, window, state_type, shadow_type, arrow_type, fi&
      &ll, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  integer(c_int), value :: arrow_type
  logical(c_bool), value :: fill
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_draw_diamond (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height);
subroutine gtk_draw_diamond(style, window, state_type, shadow_type, x, y, width,&
      & height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_draw_box (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height);
subroutine gtk_draw_box(style, window, state_type, shadow_type, x, y, width, hei&
      &ght) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_draw_flat_box (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height);
subroutine gtk_draw_flat_box(style, window, state_type, shadow_type, x, y, width&
      &, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_draw_check (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height);
subroutine gtk_draw_check(style, window, state_type, shadow_type, x, y, width, h&
      &eight) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_draw_option (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height);
subroutine gtk_draw_option(style, window, state_type, shadow_type, x, y, width, &
      &height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_draw_tab (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height);
subroutine gtk_draw_tab(style, window, state_type, shadow_type, x, y, width, hei&
      &ght) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_draw_shadow_gap (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height, GtkPositionType gap_side, gint gap_x, gint gap_width);
subroutine gtk_draw_shadow_gap(style, window, state_type, shadow_type, x, y, wid&
      &th, height, gap_side, gap_x, gap_width) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: gap_side
  integer(c_int), value :: gap_x
  integer(c_int), value :: gap_width
end subroutine

! void gtk_draw_box_gap (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height, GtkPositionType gap_side, gint gap_x, gint gap_width);
subroutine gtk_draw_box_gap(style, window, state_type, shadow_type, x, y, width,&
      & height, gap_side, gap_x, gap_width) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: gap_side
  integer(c_int), value :: gap_x
  integer(c_int), value :: gap_width
end subroutine

! void gtk_draw_extension (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height, GtkPositionType gap_side);
subroutine gtk_draw_extension(style, window, state_type, shadow_type, x, y, widt&
      &h, height, gap_side) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: gap_side
end subroutine

! void gtk_draw_focus (GtkStyle *style, GdkWindow *window, gint x, gint y, gint width, gint height);
subroutine gtk_draw_focus(style, window, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_draw_slider (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height, GtkOrientation orientation);
subroutine gtk_draw_slider(style, window, state_type, shadow_type, x, y, width, &
      &height, orientation) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: orientation
end subroutine

! void gtk_draw_handle (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, gint x, gint y, gint width, gint height, GtkOrientation orientation);
subroutine gtk_draw_handle(style, window, state_type, shadow_type, x, y, width, &
      &height, orientation) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: orientation
end subroutine

! void gtk_draw_expander (GtkStyle *style, GdkWindow *window, GtkStateType state_type, gint x, gint y, GtkExpanderStyle expander_style);
subroutine gtk_draw_expander(style, window, state_type, x, y, expander_style) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: expander_style
end subroutine

! void gtk_draw_layout (GtkStyle *style, GdkWindow *window, GtkStateType state_type, gboolean use_text, gint x, gint y, PangoLayout *layout);
subroutine gtk_draw_layout(style, window, state_type, use_text, x, y, layout) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  logical(c_bool), value :: use_text
  integer(c_int), value :: x
  integer(c_int), value :: y
  type(c_ptr), value :: layout
end subroutine

! void gtk_draw_resize_grip (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GdkWindowEdge edge, gint x, gint y, gint width, gint height);
subroutine gtk_draw_resize_grip(style, window, state_type, edge, x, y, width, he&
      &ight) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: edge
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

!  void gtk_paint_hline (GtkStyle *style, GdkWindow *window, GtkStateType state_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, gint x1, gint x2, gint y);
subroutine gtk_paint_hline(style, window, state_type, area, widget, detail, x1, &
      &x2, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: x1
  integer(c_int), value :: x2
  integer(c_int), value :: y
end subroutine

! void gtk_paint_vline (GtkStyle *style, GdkWindow *window, GtkStateType state_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, gint y1_, gint y2_, gint x);
subroutine gtk_paint_vline(style, window, state_type, area, widget, detail, y1_,&
      & y2_, x) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: y1_
  integer(c_int), value :: y2_
  integer(c_int), value :: x
end subroutine

! void gtk_paint_shadow (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, gint x, gint y, gint width, gint height);
subroutine gtk_paint_shadow(style, window, state_type, shadow_type, area, widget&
      &, detail, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_paint_polygon (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, const GdkPoint *points, gint n_points, gboolean fill);
subroutine gtk_paint_polygon(style, window, state_type, shadow_type, area, widge&
      &t, detail, points, n_points, fill) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char, c_bool
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  type(c_ptr), value :: points
  integer(c_int), value :: n_points
  logical(c_bool), value :: fill
end subroutine

! void gtk_paint_arrow (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, GtkArrowType arrow_type, gboolean fill, gint x, gint y, gint width, gint height);
subroutine gtk_paint_arrow(style, window, state_type, shadow_type, area, widget,&
      & detail, arrow_type, fill, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char, c_bool
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: arrow_type
  logical(c_bool), value :: fill
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_paint_diamond (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, gint x, gint y, gint width, gint height);
subroutine gtk_paint_diamond(style, window, state_type, shadow_type, area, widge&
      &t, detail, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_paint_box (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, gint x, gint y, gint width, gint height);
subroutine gtk_paint_box(style, window, state_type, shadow_type, area, widget, d&
      &etail, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_paint_flat_box (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, gint x, gint y, gint width, gint height);
subroutine gtk_paint_flat_box(style, window, state_type, shadow_type, area, widg&
      &et, detail, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_paint_check (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, gint x, gint y, gint width, gint height);
subroutine gtk_paint_check(style, window, state_type, shadow_type, area, widget,&
      & detail, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_paint_option (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, gint x, gint y, gint width, gint height);
subroutine gtk_paint_option(style, window, state_type, shadow_type, area, widget&
      &, detail, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_paint_tab (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, gint x, gint y, gint width, gint height);
subroutine gtk_paint_tab(style, window, state_type, shadow_type, area, widget, d&
      &etail, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_paint_shadow_gap (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, gint x, gint y, gint width, gint height, GtkPositionType gap_side, gint gap_x, gint gap_width);
subroutine gtk_paint_shadow_gap(style, window, state_type, shadow_type, area, wi&
      &dget, detail, x, y, width, height, gap_side, gap_x, gap_width) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: gap_side
  integer(c_int), value :: gap_x
  integer(c_int), value :: gap_width
end subroutine

! void gtk_paint_box_gap (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, gint x, gint y, gint width, gint height, GtkPositionType gap_side, gint gap_x, gint gap_width);
subroutine gtk_paint_box_gap(style, window, state_type, shadow_type, area, widge&
      &t, detail, x, y, width, height, gap_side, gap_x, gap_width) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: gap_side
  integer(c_int), value :: gap_x
  integer(c_int), value :: gap_width
end subroutine

! void gtk_paint_extension (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, gint x, gint y, gint width, gint height, GtkPositionType gap_side);
subroutine gtk_paint_extension(style, window, state_type, shadow_type, area, wid&
      &get, detail, x, y, width, height, gap_side) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: gap_side
end subroutine

! void gtk_paint_focus (GtkStyle *style, GdkWindow *window, GtkStateType state_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, gint x, gint y, gint width, gint height);
subroutine gtk_paint_focus(style, window, state_type, area, widget, detail, x, y&
      &, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_paint_slider (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, gint x, gint y, gint width, gint height, GtkOrientation orientation);
subroutine gtk_paint_slider(style, window, state_type, shadow_type, area, widget&
      &, detail, x, y, width, height, orientation) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: orientation
end subroutine

! void gtk_paint_handle (GtkStyle *style, GdkWindow *window, GtkStateType state_type, GtkShadowType shadow_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, gint x, gint y, gint width, gint height, GtkOrientation orientation);
subroutine gtk_paint_handle(style, window, state_type, shadow_type, area, widget&
      &, detail, x, y, width, height, orientation) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: shadow_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: orientation
end subroutine

! void gtk_paint_expander (GtkStyle *style, GdkWindow *window, GtkStateType state_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, gint x, gint y, GtkExpanderStyle expander_style);
subroutine gtk_paint_expander(style, window, state_type, area, widget, detail, x&
      &, y, expander_style) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: expander_style
end subroutine

! void gtk_paint_layout (GtkStyle *style, GdkWindow *window, GtkStateType state_type, gboolean use_text, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, gint x, gint y, PangoLayout *layout);
subroutine gtk_paint_layout(style, window, state_type, use_text, area, widget, d&
      &etail, x, y, layout) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  logical(c_bool), value :: use_text
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: x
  integer(c_int), value :: y
  type(c_ptr), value :: layout
end subroutine

! void gtk_paint_resize_grip (GtkStyle *style, GdkWindow *window, GtkStateType state_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, GdkWindowEdge edge, gint x, gint y, gint width, gint height);
subroutine gtk_paint_resize_grip(style, window, state_type, area, widget, detail&
      &, edge, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: edge
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_paint_spinner (GtkStyle *style, GdkWindow *window, GtkStateType state_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, guint step, gint x, gint y, gint width, gint height);
subroutine gtk_paint_spinner(style, window, state_type, area, widget, detail, st&
      &ep, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: step
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

!  GType gtk_border_get_type (void) G_GNUC_CONST;
function gtk_border_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_border_get_type
end function

! GtkBorder *gtk_border_new (void) G_GNUC_MALLOC;
function gtk_border_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_border_new
end function

! GtkBorder *gtk_border_copy (const GtkBorder *border_);
function gtk_border_copy(border_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_border_copy
  type(c_ptr), value :: border_
end function

! void gtk_border_free (GtkBorder *border_);
subroutine gtk_border_free(border_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: border_
end subroutine

!  void gtk_style_get_style_property (GtkStyle *style, GType widget_type, const gchar *property_name, GValue *value);
subroutine gtk_style_get_style_property(style, widget_type, property_name, value&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr), value :: style
  integer(c_size_t), value :: widget_type
  character(kind=c_char), dimension(*) :: property_name
  type(c_ptr), value :: value
end subroutine

! void gtk_style_get_valist (GtkStyle *style, GType widget_type, const gchar *first_property_name, va_list var_args);
subroutine gtk_style_get_valist(style, widget_type, first_property_name, var_arg&
      &s) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr), value :: style
  integer(c_size_t), value :: widget_type
  character(kind=c_char), dimension(*) :: first_property_name
  type(c_ptr), value :: var_args
end subroutine

!  void gtk_draw_string (GtkStyle *style, GdkWindow *window, GtkStateType state_type, gint x, gint y, const gchar *string);
subroutine gtk_draw_string(style, window, state_type, x, y, string) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  integer(c_int), value :: x
  integer(c_int), value :: y
  character(kind=c_char), dimension(*) :: string
end subroutine

! void gtk_paint_string (GtkStyle *style, GdkWindow *window, GtkStateType state_type, const GdkRectangle *area, GtkWidget *widget, const gchar *detail, gint x, gint y, const gchar *string);
subroutine gtk_paint_string(style, window, state_type, area, widget, detail, x, &
      &y, string) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: style
  type(c_ptr), value :: window
  integer(c_int), value :: state_type
  type(c_ptr), value :: area
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
  integer(c_int), value :: x
  integer(c_int), value :: y
  character(kind=c_char), dimension(*) :: string
end subroutine

!  void gtk_draw_insertion_cursor (GtkWidget *widget, GdkDrawable *drawable, const GdkRectangle *area, const GdkRectangle *location, gboolean is_primary, GtkTextDirection direction, gboolean draw_arrow);
subroutine gtk_draw_insertion_cursor(widget, drawable, area, location, is_primar&
      &y, direction, draw_arrow) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_int
  type(c_ptr), value :: widget
  type(c_ptr), value :: drawable
  type(c_ptr), value :: area
  type(c_ptr), value :: location
  logical(c_bool), value :: is_primary
  integer(c_int), value :: direction
  logical(c_bool), value :: draw_arrow
end subroutine

!   GType gtk_table_get_type (void) G_GNUC_CONST;
function gtk_table_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_table_get_type
end function

! GtkWidget* gtk_table_new (guint rows, guint columns, gboolean homogeneous);
function gtk_table_new(rows, columns, homogeneous) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr) :: gtk_table_new
  integer(c_int), value :: rows
  integer(c_int), value :: columns
  logical(c_bool), value :: homogeneous
end function

! void gtk_table_resize (GtkTable *table, guint rows, guint columns);
subroutine gtk_table_resize(table, rows, columns) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: table
  integer(c_int), value :: rows
  integer(c_int), value :: columns
end subroutine

! void gtk_table_attach (GtkTable *table, GtkWidget *child, guint left_attach, guint right_attach, guint top_attach, guint bottom_attach, GtkAttachOptions xoptions, GtkAttachOptions yoptions, guint xpadding, guint ypadding);
subroutine gtk_table_attach(table, child, left_attach, right_attach, top_attach,&
      & bottom_attach, xoptions, yoptions, xpadding, ypadding) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: table
  type(c_ptr), value :: child
  integer(c_int), value :: left_attach
  integer(c_int), value :: right_attach
  integer(c_int), value :: top_attach
  integer(c_int), value :: bottom_attach
  integer(c_int), value :: xoptions
  integer(c_int), value :: yoptions
  integer(c_int), value :: xpadding
  integer(c_int), value :: ypadding
end subroutine

! void gtk_table_attach_defaults (GtkTable *table, GtkWidget *widget, guint left_attach, guint right_attach, guint top_attach, guint bottom_attach);
subroutine gtk_table_attach_defaults(table, widget, left_attach, right_attach, t&
      &op_attach, bottom_attach) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: table
  type(c_ptr), value :: widget
  integer(c_int), value :: left_attach
  integer(c_int), value :: right_attach
  integer(c_int), value :: top_attach
  integer(c_int), value :: bottom_attach
end subroutine

! void gtk_table_set_row_spacing (GtkTable *table, guint row, guint spacing);
subroutine gtk_table_set_row_spacing(table, row, spacing) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: table
  integer(c_int), value :: row
  integer(c_int), value :: spacing
end subroutine

! guint gtk_table_get_row_spacing (GtkTable *table, guint row);
function gtk_table_get_row_spacing(table, row) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_table_get_row_spacing
  type(c_ptr), value :: table
  integer(c_int), value :: row
end function

! void gtk_table_set_col_spacing (GtkTable *table, guint column, guint spacing);
subroutine gtk_table_set_col_spacing(table, column, spacing) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: table
  integer(c_int), value :: column
  integer(c_int), value :: spacing
end subroutine

! guint gtk_table_get_col_spacing (GtkTable *table, guint column);
function gtk_table_get_col_spacing(table, column) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_table_get_col_spacing
  type(c_ptr), value :: table
  integer(c_int), value :: column
end function

! void gtk_table_set_row_spacings (GtkTable *table, guint spacing);
subroutine gtk_table_set_row_spacings(table, spacing) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: table
  integer(c_int), value :: spacing
end subroutine

! guint gtk_table_get_default_row_spacing (GtkTable *table);
function gtk_table_get_default_row_spacing(table) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_table_get_default_row_spacing
  type(c_ptr), value :: table
end function

! void gtk_table_set_col_spacings (GtkTable *table, guint spacing);
subroutine gtk_table_set_col_spacings(table, spacing) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: table
  integer(c_int), value :: spacing
end subroutine

! guint gtk_table_get_default_col_spacing (GtkTable *table);
function gtk_table_get_default_col_spacing(table) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_table_get_default_col_spacing
  type(c_ptr), value :: table
end function

! void gtk_table_set_homogeneous (GtkTable *table, gboolean homogeneous);
subroutine gtk_table_set_homogeneous(table, homogeneous) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: table
  logical(c_bool), value :: homogeneous
end subroutine

! gboolean gtk_table_get_homogeneous (GtkTable *table);
function gtk_table_get_homogeneous(table) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_table_get_homogeneous
  type(c_ptr), value :: table
end function

! void gtk_table_get_size (GtkTable *table, guint *rows, guint *columns);
subroutine gtk_table_get_size(table, rows, columns) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: table
  type(c_ptr), value :: rows
  type(c_ptr), value :: columns
end subroutine

!   GType gtk_list_store_get_type (void) G_GNUC_CONST;
function gtk_list_store_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_list_store_get_type
end function

! GtkListStore *gtk_list_store_newv (gint n_columns, GType *types);
function gtk_list_store_newv(n_columns, types) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_list_store_newv
  integer(c_int), value :: n_columns
  type(c_ptr), value :: types
end function

! void gtk_list_store_set_column_types (GtkListStore *list_store, gint n_columns, GType *types);
subroutine gtk_list_store_set_column_types(list_store, n_columns, types) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: list_store
  integer(c_int), value :: n_columns
  type(c_ptr), value :: types
end subroutine

!  void gtk_list_store_set_value (GtkListStore *list_store, GtkTreeIter *iter, gint column, GValue *value);
subroutine gtk_list_store_set_value(list_store, iter, column, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: list_store
  type(c_ptr), value :: iter
  integer(c_int), value :: column
  type(c_ptr), value :: value
end subroutine

! void gtk_list_store_set_valuesv (GtkListStore *list_store, GtkTreeIter *iter, gint *columns, GValue *values, gint n_values);
subroutine gtk_list_store_set_valuesv(list_store, iter, columns, values, n_value&
      &s) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: list_store
  type(c_ptr), value :: iter
  type(c_ptr), value :: columns
  type(c_ptr), value :: values
  integer(c_int), value :: n_values
end subroutine

! void gtk_list_store_set_valist (GtkListStore *list_store, GtkTreeIter *iter, va_list var_args);
subroutine gtk_list_store_set_valist(list_store, iter, var_args) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list_store
  type(c_ptr), value :: iter
  type(c_ptr), value :: var_args
end subroutine

! gboolean gtk_list_store_remove (GtkListStore *list_store, GtkTreeIter *iter);
function gtk_list_store_remove(list_store, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_list_store_remove
  type(c_ptr), value :: list_store
  type(c_ptr), value :: iter
end function

! void gtk_list_store_insert (GtkListStore *list_store, GtkTreeIter *iter, gint position);
subroutine gtk_list_store_insert(list_store, iter, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: list_store
  type(c_ptr), value :: iter
  integer(c_int), value :: position
end subroutine

! void gtk_list_store_insert_before (GtkListStore *list_store, GtkTreeIter *iter, GtkTreeIter *sibling);
subroutine gtk_list_store_insert_before(list_store, iter, sibling) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list_store
  type(c_ptr), value :: iter
  type(c_ptr), value :: sibling
end subroutine

! void gtk_list_store_insert_after (GtkListStore *list_store, GtkTreeIter *iter, GtkTreeIter *sibling);
subroutine gtk_list_store_insert_after(list_store, iter, sibling) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list_store
  type(c_ptr), value :: iter
  type(c_ptr), value :: sibling
end subroutine

! void gtk_list_store_insert_with_valuesv (GtkListStore *list_store, GtkTreeIter *iter, gint position, gint *columns, GValue *values, gint n_values);
subroutine gtk_list_store_insert_with_valuesv(list_store, iter, position, column&
      &s, values, n_values) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: list_store
  type(c_ptr), value :: iter
  integer(c_int), value :: position
  type(c_ptr), value :: columns
  type(c_ptr), value :: values
  integer(c_int), value :: n_values
end subroutine

! void gtk_list_store_prepend (GtkListStore *list_store, GtkTreeIter *iter);
subroutine gtk_list_store_prepend(list_store, iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list_store
  type(c_ptr), value :: iter
end subroutine

! void gtk_list_store_append (GtkListStore *list_store, GtkTreeIter *iter);
subroutine gtk_list_store_append(list_store, iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list_store
  type(c_ptr), value :: iter
end subroutine

! void gtk_list_store_clear (GtkListStore *list_store);
subroutine gtk_list_store_clear(list_store) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list_store
end subroutine

! gboolean gtk_list_store_iter_is_valid (GtkListStore *list_store, GtkTreeIter *iter);
function gtk_list_store_iter_is_valid(list_store, iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_list_store_iter_is_valid
  type(c_ptr), value :: list_store
  type(c_ptr), value :: iter
end function

! void gtk_list_store_reorder (GtkListStore *store, gint *new_order);
subroutine gtk_list_store_reorder(store, new_order) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: store
  type(c_ptr), value :: new_order
end subroutine

! void gtk_list_store_swap (GtkListStore *store, GtkTreeIter *a, GtkTreeIter *b);
subroutine gtk_list_store_swap(store, a, b) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: store
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end subroutine

! void gtk_list_store_move_after (GtkListStore *store, GtkTreeIter *iter, GtkTreeIter *position);
subroutine gtk_list_store_move_after(store, iter, position) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: store
  type(c_ptr), value :: iter
  type(c_ptr), value :: position
end subroutine

! void gtk_list_store_move_before (GtkListStore *store, GtkTreeIter *iter, GtkTreeIter *position);
subroutine gtk_list_store_move_before(store, iter, position) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: store
  type(c_ptr), value :: iter
  type(c_ptr), value :: position
end subroutine

!   GType gtk_menu_item_get_type (void) G_GNUC_CONST;
function gtk_menu_item_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_menu_item_get_type
end function

! GtkWidget* gtk_menu_item_new (void);
function gtk_menu_item_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_menu_item_new
end function

! GtkWidget* gtk_menu_item_new_with_label (const gchar *label);
function gtk_menu_item_new_with_label(label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_menu_item_new_with_label
  character(kind=c_char), dimension(*) :: label
end function

! GtkWidget* gtk_menu_item_new_with_mnemonic (const gchar *label);
function gtk_menu_item_new_with_mnemonic(label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_menu_item_new_with_mnemonic
  character(kind=c_char), dimension(*) :: label
end function

! void gtk_menu_item_set_submenu (GtkMenuItem *menu_item, GtkWidget *submenu);
subroutine gtk_menu_item_set_submenu(menu_item, submenu) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: menu_item
  type(c_ptr), value :: submenu
end subroutine

! GtkWidget* gtk_menu_item_get_submenu (GtkMenuItem *menu_item);
function gtk_menu_item_get_submenu(menu_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_menu_item_get_submenu
  type(c_ptr), value :: menu_item
end function

! void gtk_menu_item_select (GtkMenuItem *menu_item);
subroutine gtk_menu_item_select(menu_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: menu_item
end subroutine

! void gtk_menu_item_deselect (GtkMenuItem *menu_item);
subroutine gtk_menu_item_deselect(menu_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: menu_item
end subroutine

! void gtk_menu_item_activate (GtkMenuItem *menu_item);
subroutine gtk_menu_item_activate(menu_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: menu_item
end subroutine

! void gtk_menu_item_toggle_size_request (GtkMenuItem *menu_item, gint *requisition);
subroutine gtk_menu_item_toggle_size_request(menu_item, requisition) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: menu_item
  type(c_ptr), value :: requisition
end subroutine

! void gtk_menu_item_toggle_size_allocate (GtkMenuItem *menu_item, gint allocation);
subroutine gtk_menu_item_toggle_size_allocate(menu_item, allocation) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: menu_item
  integer(c_int), value :: allocation
end subroutine

! void gtk_menu_item_set_right_justified (GtkMenuItem *menu_item, gboolean right_justified);
subroutine gtk_menu_item_set_right_justified(menu_item, right_justified) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: menu_item
  logical(c_bool), value :: right_justified
end subroutine

! gboolean gtk_menu_item_get_right_justified (GtkMenuItem *menu_item);
function gtk_menu_item_get_right_justified(menu_item) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_menu_item_get_right_justified
  type(c_ptr), value :: menu_item
end function

! void gtk_menu_item_set_accel_path (GtkMenuItem *menu_item, const gchar *accel_path);
subroutine gtk_menu_item_set_accel_path(menu_item, accel_path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: menu_item
  character(kind=c_char), dimension(*) :: accel_path
end subroutine

! G_CONST_RETURN gchar* gtk_menu_item_get_accel_path (GtkMenuItem *menu_item);
function gtk_menu_item_get_accel_path(menu_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_menu_item_get_accel_path
  type(c_ptr), value :: menu_item
end function

!  void gtk_menu_item_set_label (GtkMenuItem *menu_item, const gchar *label);
subroutine gtk_menu_item_set_label(menu_item, label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: menu_item
  character(kind=c_char), dimension(*) :: label
end subroutine

! G_CONST_RETURN gchar *gtk_menu_item_get_label (GtkMenuItem *menu_item);
function gtk_menu_item_get_label(menu_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_menu_item_get_label
  type(c_ptr), value :: menu_item
end function

!  void gtk_menu_item_set_use_underline (GtkMenuItem *menu_item, gboolean setting);
subroutine gtk_menu_item_set_use_underline(menu_item, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: menu_item
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_menu_item_get_use_underline (GtkMenuItem *menu_item);
function gtk_menu_item_get_use_underline(menu_item) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_menu_item_get_use_underline
  type(c_ptr), value :: menu_item
end function

!  void gtk_menu_item_remove_submenu (GtkMenuItem *menu_item);
subroutine gtk_menu_item_remove_submenu(menu_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: menu_item
end subroutine

!   GType gtk_text_child_anchor_get_type (void) G_GNUC_CONST;
function gtk_text_child_anchor_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_text_child_anchor_get_type
end function

!  GtkTextChildAnchor* gtk_text_child_anchor_new (void);
function gtk_text_child_anchor_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_child_anchor_new
end function

!  GList* gtk_text_child_anchor_get_widgets (GtkTextChildAnchor *anchor);
function gtk_text_child_anchor_get_widgets(anchor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_child_anchor_get_widgets
  type(c_ptr), value :: anchor
end function

! gboolean gtk_text_child_anchor_get_deleted (GtkTextChildAnchor *anchor);
function gtk_text_child_anchor_get_deleted(anchor) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_child_anchor_get_deleted
  type(c_ptr), value :: anchor
end function

!   GType gtk_widget_get_type (void) G_GNUC_CONST;
function gtk_widget_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_widget_get_type
end function

! void gtk_widget_destroy (GtkWidget *widget);
subroutine gtk_widget_destroy(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_widget_destroyed (GtkWidget *widget, GtkWidget **widget_pointer);
subroutine gtk_widget_destroyed(widget, widget_pointer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: widget_pointer
end subroutine

!  GtkWidget* gtk_widget_ref (GtkWidget *widget);
function gtk_widget_ref(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_ref
  type(c_ptr), value :: widget
end function

! void gtk_widget_unref (GtkWidget *widget);
subroutine gtk_widget_unref(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

!  void gtk_widget_unparent (GtkWidget *widget);
subroutine gtk_widget_unparent(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_widget_show (GtkWidget *widget);
subroutine gtk_widget_show(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_widget_show_now (GtkWidget *widget);
subroutine gtk_widget_show_now(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_widget_hide (GtkWidget *widget);
subroutine gtk_widget_hide(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_widget_show_all (GtkWidget *widget);
subroutine gtk_widget_show_all(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_widget_hide_all (GtkWidget *widget);
subroutine gtk_widget_hide_all(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_widget_set_no_show_all (GtkWidget *widget, gboolean no_show_all);
subroutine gtk_widget_set_no_show_all(widget, no_show_all) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: widget
  logical(c_bool), value :: no_show_all
end subroutine

! gboolean gtk_widget_get_no_show_all (GtkWidget *widget);
function gtk_widget_get_no_show_all(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_get_no_show_all
  type(c_ptr), value :: widget
end function

! void gtk_widget_map (GtkWidget *widget);
subroutine gtk_widget_map(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_widget_unmap (GtkWidget *widget);
subroutine gtk_widget_unmap(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_widget_realize (GtkWidget *widget);
subroutine gtk_widget_realize(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_widget_unrealize (GtkWidget *widget);
subroutine gtk_widget_unrealize(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

!  void gtk_widget_queue_draw (GtkWidget *widget);
subroutine gtk_widget_queue_draw(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_widget_queue_draw_area (GtkWidget *widget, gint x, gint y, gint width, gint height);
subroutine gtk_widget_queue_draw_area(widget, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

!  void gtk_widget_queue_clear (GtkWidget *widget);
subroutine gtk_widget_queue_clear(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_widget_queue_clear_area (GtkWidget *widget, gint x, gint y, gint width, gint height);
subroutine gtk_widget_queue_clear_area(widget, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

!  void gtk_widget_queue_resize (GtkWidget *widget);
subroutine gtk_widget_queue_resize(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_widget_queue_resize_no_redraw (GtkWidget *widget);
subroutine gtk_widget_queue_resize_no_redraw(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

!  void gtk_widget_draw (GtkWidget *widget, const GdkRectangle *area);
subroutine gtk_widget_draw(widget, area) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: area
end subroutine

!  void gtk_widget_size_request (GtkWidget *widget, GtkRequisition *requisition);
subroutine gtk_widget_size_request(widget, requisition) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: requisition
end subroutine

! void gtk_widget_size_allocate (GtkWidget *widget, GtkAllocation *allocation);
subroutine gtk_widget_size_allocate(widget, allocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: allocation
end subroutine

! void gtk_widget_get_child_requisition (GtkWidget *widget, GtkRequisition *requisition);
subroutine gtk_widget_get_child_requisition(widget, requisition) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: requisition
end subroutine

! void gtk_widget_add_accelerator (GtkWidget *widget, const gchar *accel_signal, GtkAccelGroup *accel_group, guint accel_key, GdkModifierType accel_mods, GtkAccelFlags accel_flags);
subroutine gtk_widget_add_accelerator(widget, accel_signal, accel_group, accel_k&
      &ey, accel_mods, accel_flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: accel_signal
  type(c_ptr), value :: accel_group
  integer(c_int), value :: accel_key
  integer(c_int), value :: accel_mods
  integer(c_int), value :: accel_flags
end subroutine

! gboolean gtk_widget_remove_accelerator (GtkWidget *widget, GtkAccelGroup *accel_group, guint accel_key, GdkModifierType accel_mods);
function gtk_widget_remove_accelerator(widget, accel_group, accel_key, accel_mod&
      &s) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_widget_remove_accelerator
  type(c_ptr), value :: widget
  type(c_ptr), value :: accel_group
  integer(c_int), value :: accel_key
  integer(c_int), value :: accel_mods
end function

! void gtk_widget_set_accel_path (GtkWidget *widget, const gchar *accel_path, GtkAccelGroup *accel_group);
subroutine gtk_widget_set_accel_path(widget, accel_path, accel_group) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: accel_path
  type(c_ptr), value :: accel_group
end subroutine

! GList* gtk_widget_list_accel_closures (GtkWidget *widget);
function gtk_widget_list_accel_closures(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_list_accel_closures
  type(c_ptr), value :: widget
end function

! gboolean gtk_widget_can_activate_accel (GtkWidget *widget, guint signal_id);
function gtk_widget_can_activate_accel(widget, signal_id) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_widget_can_activate_accel
  type(c_ptr), value :: widget
  integer(c_int), value :: signal_id
end function

! gboolean gtk_widget_mnemonic_activate (GtkWidget *widget, gboolean group_cycling);
function gtk_widget_mnemonic_activate(widget, group_cycling) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_mnemonic_activate
  type(c_ptr), value :: widget
  logical(c_bool), value :: group_cycling
end function

! gboolean gtk_widget_event (GtkWidget *widget, GdkEvent *event);
function gtk_widget_event(widget, event) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_event
  type(c_ptr), value :: widget
  type(c_ptr), value :: event
end function

! gint gtk_widget_send_expose (GtkWidget *widget, GdkEvent *event);
function gtk_widget_send_expose(widget, event) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_widget_send_expose
  type(c_ptr), value :: widget
  type(c_ptr), value :: event
end function

! gboolean gtk_widget_send_focus_change (GtkWidget *widget, GdkEvent *event);
function gtk_widget_send_focus_change(widget, event) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_send_focus_change
  type(c_ptr), value :: widget
  type(c_ptr), value :: event
end function

!  gboolean gtk_widget_activate (GtkWidget *widget);
function gtk_widget_activate(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_activate
  type(c_ptr), value :: widget
end function

! gboolean gtk_widget_set_scroll_adjustments (GtkWidget *widget, GtkAdjustment *hadjustment, GtkAdjustment *vadjustment);
function gtk_widget_set_scroll_adjustments(widget, hadjustment, vadjustment) bin&
      &d(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_set_scroll_adjustments
  type(c_ptr), value :: widget
  type(c_ptr), value :: hadjustment
  type(c_ptr), value :: vadjustment
end function

!  void gtk_widget_reparent (GtkWidget *widget, GtkWidget *new_parent);
subroutine gtk_widget_reparent(widget, new_parent) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: new_parent
end subroutine

! gboolean gtk_widget_intersect (GtkWidget *widget, const GdkRectangle *area, GdkRectangle *intersection);
function gtk_widget_intersect(widget, area, intersection) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_intersect
  type(c_ptr), value :: widget
  type(c_ptr), value :: area
  type(c_ptr), value :: intersection
end function

! GdkRegion *gtk_widget_region_intersect (GtkWidget *widget, const GdkRegion *region);
function gtk_widget_region_intersect(widget, region) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_region_intersect
  type(c_ptr), value :: widget
  type(c_ptr), value :: region
end function

!  void gtk_widget_freeze_child_notify (GtkWidget *widget);
subroutine gtk_widget_freeze_child_notify(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_widget_child_notify (GtkWidget *widget, const gchar *child_property);
subroutine gtk_widget_child_notify(widget, child_property) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: child_property
end subroutine

! void gtk_widget_thaw_child_notify (GtkWidget *widget);
subroutine gtk_widget_thaw_child_notify(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

!  void gtk_widget_set_can_focus (GtkWidget *widget, gboolean can_focus);
subroutine gtk_widget_set_can_focus(widget, can_focus) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: widget
  logical(c_bool), value :: can_focus
end subroutine

! gboolean gtk_widget_get_can_focus (GtkWidget *widget);
function gtk_widget_get_can_focus(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_get_can_focus
  type(c_ptr), value :: widget
end function

! gboolean gtk_widget_has_focus (GtkWidget *widget);
function gtk_widget_has_focus(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_has_focus
  type(c_ptr), value :: widget
end function

! gboolean gtk_widget_is_focus (GtkWidget *widget);
function gtk_widget_is_focus(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_is_focus
  type(c_ptr), value :: widget
end function

! void gtk_widget_grab_focus (GtkWidget *widget);
subroutine gtk_widget_grab_focus(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

!  void gtk_widget_set_can_default (GtkWidget *widget, gboolean can_default);
subroutine gtk_widget_set_can_default(widget, can_default) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: widget
  logical(c_bool), value :: can_default
end subroutine

! gboolean gtk_widget_get_can_default (GtkWidget *widget);
function gtk_widget_get_can_default(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_get_can_default
  type(c_ptr), value :: widget
end function

! gboolean gtk_widget_has_default (GtkWidget *widget);
function gtk_widget_has_default(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_has_default
  type(c_ptr), value :: widget
end function

! void gtk_widget_grab_default (GtkWidget *widget);
subroutine gtk_widget_grab_default(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

!  void gtk_widget_set_receives_default (GtkWidget *widget, gboolean receives_default);
subroutine gtk_widget_set_receives_default(widget, receives_default) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: widget
  logical(c_bool), value :: receives_default
end subroutine

! gboolean gtk_widget_get_receives_default (GtkWidget *widget);
function gtk_widget_get_receives_default(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_get_receives_default
  type(c_ptr), value :: widget
end function

!  gboolean gtk_widget_has_grab (GtkWidget *widget);
function gtk_widget_has_grab(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_has_grab
  type(c_ptr), value :: widget
end function

!  void gtk_widget_set_name (GtkWidget *widget, const gchar *name);
subroutine gtk_widget_set_name(widget, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: name
end subroutine

! G_CONST_RETURN gchar* gtk_widget_get_name (GtkWidget *widget);
function gtk_widget_get_name(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_name
  type(c_ptr), value :: widget
end function

!  void gtk_widget_set_state (GtkWidget *widget, GtkStateType state);
subroutine gtk_widget_set_state(widget, state) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  integer(c_int), value :: state
end subroutine

! GtkStateType gtk_widget_get_state (GtkWidget *widget);
function gtk_widget_get_state(widget) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_widget_get_state
  type(c_ptr), value :: widget
end function

!  void gtk_widget_set_sensitive (GtkWidget *widget, gboolean sensitive);
subroutine gtk_widget_set_sensitive(widget, sensitive) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: widget
  logical(c_bool), value :: sensitive
end subroutine

! gboolean gtk_widget_get_sensitive (GtkWidget *widget);
function gtk_widget_get_sensitive(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_get_sensitive
  type(c_ptr), value :: widget
end function

! gboolean gtk_widget_is_sensitive (GtkWidget *widget);
function gtk_widget_is_sensitive(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_is_sensitive
  type(c_ptr), value :: widget
end function

!  void gtk_widget_set_visible (GtkWidget *widget, gboolean visible);
subroutine gtk_widget_set_visible(widget, visible) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: widget
  logical(c_bool), value :: visible
end subroutine

! gboolean gtk_widget_get_visible (GtkWidget *widget);
function gtk_widget_get_visible(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_get_visible
  type(c_ptr), value :: widget
end function

!  void gtk_widget_set_has_window (GtkWidget *widget, gboolean has_window);
subroutine gtk_widget_set_has_window(widget, has_window) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: widget
  logical(c_bool), value :: has_window
end subroutine

! gboolean gtk_widget_get_has_window (GtkWidget *widget);
function gtk_widget_get_has_window(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_get_has_window
  type(c_ptr), value :: widget
end function

!  gboolean gtk_widget_is_toplevel (GtkWidget *widget);
function gtk_widget_is_toplevel(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_is_toplevel
  type(c_ptr), value :: widget
end function

! gboolean gtk_widget_is_drawable (GtkWidget *widget);
function gtk_widget_is_drawable(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_is_drawable
  type(c_ptr), value :: widget
end function

! void gtk_widget_set_realized (GtkWidget *widget, gboolean realized);
subroutine gtk_widget_set_realized(widget, realized) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: widget
  logical(c_bool), value :: realized
end subroutine

! gboolean gtk_widget_get_realized (GtkWidget *widget);
function gtk_widget_get_realized(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_get_realized
  type(c_ptr), value :: widget
end function

! void gtk_widget_set_mapped (GtkWidget *widget, gboolean mapped);
subroutine gtk_widget_set_mapped(widget, mapped) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: widget
  logical(c_bool), value :: mapped
end subroutine

! gboolean gtk_widget_get_mapped (GtkWidget *widget);
function gtk_widget_get_mapped(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_get_mapped
  type(c_ptr), value :: widget
end function

!  void gtk_widget_set_app_paintable (GtkWidget *widget, gboolean app_paintable);
subroutine gtk_widget_set_app_paintable(widget, app_paintable) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: widget
  logical(c_bool), value :: app_paintable
end subroutine

! gboolean gtk_widget_get_app_paintable (GtkWidget *widget);
function gtk_widget_get_app_paintable(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_get_app_paintable
  type(c_ptr), value :: widget
end function

!  void gtk_widget_set_double_buffered (GtkWidget *widget, gboolean double_buffered);
subroutine gtk_widget_set_double_buffered(widget, double_buffered) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: widget
  logical(c_bool), value :: double_buffered
end subroutine

! gboolean gtk_widget_get_double_buffered (GtkWidget *widget);
function gtk_widget_get_double_buffered(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_get_double_buffered
  type(c_ptr), value :: widget
end function

!  void gtk_widget_set_redraw_on_allocate (GtkWidget *widget, gboolean redraw_on_allocate);
subroutine gtk_widget_set_redraw_on_allocate(widget, redraw_on_allocate) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: widget
  logical(c_bool), value :: redraw_on_allocate
end subroutine

!  void gtk_widget_set_parent (GtkWidget *widget, GtkWidget *parent);
subroutine gtk_widget_set_parent(widget, parent) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: parent
end subroutine

! GtkWidget * gtk_widget_get_parent (GtkWidget *widget);
function gtk_widget_get_parent(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_parent
  type(c_ptr), value :: widget
end function

!  void gtk_widget_set_parent_window (GtkWidget *widget, GdkWindow *parent_window);
subroutine gtk_widget_set_parent_window(widget, parent_window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: parent_window
end subroutine

! GdkWindow * gtk_widget_get_parent_window (GtkWidget *widget);
function gtk_widget_get_parent_window(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_parent_window
  type(c_ptr), value :: widget
end function

!  void gtk_widget_set_child_visible (GtkWidget *widget, gboolean is_visible);
subroutine gtk_widget_set_child_visible(widget, is_visible) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: widget
  logical(c_bool), value :: is_visible
end subroutine

! gboolean gtk_widget_get_child_visible (GtkWidget *widget);
function gtk_widget_get_child_visible(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_get_child_visible
  type(c_ptr), value :: widget
end function

!  void gtk_widget_set_window (GtkWidget *widget, GdkWindow *window);
subroutine gtk_widget_set_window(widget, window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: window
end subroutine

! GdkWindow * gtk_widget_get_window (GtkWidget *widget);
function gtk_widget_get_window(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_window
  type(c_ptr), value :: widget
end function

!  void gtk_widget_get_allocation (GtkWidget *widget, GtkAllocation *allocation);
subroutine gtk_widget_get_allocation(widget, allocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: allocation
end subroutine

! void gtk_widget_set_allocation (GtkWidget *widget, const GtkAllocation *allocation);
subroutine gtk_widget_set_allocation(widget, allocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: allocation
end subroutine

!  void gtk_widget_get_requisition (GtkWidget *widget, GtkRequisition *requisition);
subroutine gtk_widget_get_requisition(widget, requisition) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: requisition
end subroutine

!  gboolean gtk_widget_child_focus (GtkWidget *widget, GtkDirectionType direction);
function gtk_widget_child_focus(widget, direction) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_widget_child_focus
  type(c_ptr), value :: widget
  integer(c_int), value :: direction
end function

! gboolean gtk_widget_keynav_failed (GtkWidget *widget, GtkDirectionType direction);
function gtk_widget_keynav_failed(widget, direction) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_widget_keynav_failed
  type(c_ptr), value :: widget
  integer(c_int), value :: direction
end function

! void gtk_widget_error_bell (GtkWidget *widget);
subroutine gtk_widget_error_bell(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

!  void gtk_widget_set_size_request (GtkWidget *widget, gint width, gint height);
subroutine gtk_widget_set_size_request(widget, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void gtk_widget_get_size_request (GtkWidget *widget, gint *width, gint *height);
subroutine gtk_widget_get_size_request(widget, width, height) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: width
  type(c_ptr), value :: height
end subroutine

!  void gtk_widget_set_uposition (GtkWidget *widget, gint x, gint y);
subroutine gtk_widget_set_uposition(widget, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void gtk_widget_set_usize (GtkWidget *widget, gint width, gint height);
subroutine gtk_widget_set_usize(widget, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

!  void gtk_widget_set_events (GtkWidget *widget, gint events);
subroutine gtk_widget_set_events(widget, events) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  integer(c_int), value :: events
end subroutine

! void gtk_widget_add_events (GtkWidget *widget, gint events);
subroutine gtk_widget_add_events(widget, events) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  integer(c_int), value :: events
end subroutine

! void gtk_widget_set_extension_events (GtkWidget *widget, GdkExtensionMode mode);
subroutine gtk_widget_set_extension_events(widget, mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  integer(c_int), value :: mode
end subroutine

!  GdkExtensionMode gtk_widget_get_extension_events (GtkWidget *widget);
function gtk_widget_get_extension_events(widget) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_widget_get_extension_events
  type(c_ptr), value :: widget
end function

! GtkWidget* gtk_widget_get_toplevel (GtkWidget *widget);
function gtk_widget_get_toplevel(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_toplevel
  type(c_ptr), value :: widget
end function

! GtkWidget* gtk_widget_get_ancestor (GtkWidget *widget, GType widget_type);
function gtk_widget_get_ancestor(widget, widget_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: gtk_widget_get_ancestor
  type(c_ptr), value :: widget
  integer(c_size_t), value :: widget_type
end function

! GdkColormap* gtk_widget_get_colormap (GtkWidget *widget);
function gtk_widget_get_colormap(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_colormap
  type(c_ptr), value :: widget
end function

! GdkVisual* gtk_widget_get_visual (GtkWidget *widget);
function gtk_widget_get_visual(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_visual
  type(c_ptr), value :: widget
end function

!  GdkScreen * gtk_widget_get_screen (GtkWidget *widget);
function gtk_widget_get_screen(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_screen
  type(c_ptr), value :: widget
end function

! gboolean gtk_widget_has_screen (GtkWidget *widget);
function gtk_widget_has_screen(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_has_screen
  type(c_ptr), value :: widget
end function

! GdkDisplay * gtk_widget_get_display (GtkWidget *widget);
function gtk_widget_get_display(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_display
  type(c_ptr), value :: widget
end function

! GdkWindow * gtk_widget_get_root_window (GtkWidget *widget);
function gtk_widget_get_root_window(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_root_window
  type(c_ptr), value :: widget
end function

! GtkSettings* gtk_widget_get_settings (GtkWidget *widget);
function gtk_widget_get_settings(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_settings
  type(c_ptr), value :: widget
end function

! GtkClipboard *gtk_widget_get_clipboard (GtkWidget *widget, GdkAtom selection);
function gtk_widget_get_clipboard(widget, selection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_clipboard
  type(c_ptr), value :: widget
  type(c_ptr), value :: selection
end function

! GdkPixmap * gtk_widget_get_snapshot (GtkWidget *widget, GdkRectangle *clip_rect);
function gtk_widget_get_snapshot(widget, clip_rect) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_snapshot
  type(c_ptr), value :: widget
  type(c_ptr), value :: clip_rect
end function

!  AtkObject* gtk_widget_get_accessible (GtkWidget *widget);
function gtk_widget_get_accessible(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_accessible
  type(c_ptr), value :: widget
end function

!  void gtk_widget_set_colormap (GtkWidget *widget, GdkColormap *colormap);
subroutine gtk_widget_set_colormap(widget, colormap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: colormap
end subroutine

!  gint gtk_widget_get_events (GtkWidget *widget);
function gtk_widget_get_events(widget) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_widget_get_events
  type(c_ptr), value :: widget
end function

! void gtk_widget_get_pointer (GtkWidget *widget, gint *x, gint *y);
subroutine gtk_widget_get_pointer(widget, x, y) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: x
  type(c_ptr), value :: y
end subroutine

!  gboolean gtk_widget_is_ancestor (GtkWidget *widget, GtkWidget *ancestor);
function gtk_widget_is_ancestor(widget, ancestor) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_is_ancestor
  type(c_ptr), value :: widget
  type(c_ptr), value :: ancestor
end function

!  gboolean gtk_widget_translate_coordinates (GtkWidget *src_widget, GtkWidget *dest_widget, gint src_x, gint src_y, gint *dest_x, gint *dest_y);
function gtk_widget_translate_coordinates(src_widget, dest_widget, src_x, src_y,&
      & dest_x, dest_y) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_widget_translate_coordinates
  type(c_ptr), value :: src_widget
  type(c_ptr), value :: dest_widget
  integer(c_int), value :: src_x
  integer(c_int), value :: src_y
  type(c_ptr), value :: dest_x
  type(c_ptr), value :: dest_y
end function

!  gboolean gtk_widget_hide_on_delete (GtkWidget *widget);
function gtk_widget_hide_on_delete(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_hide_on_delete
  type(c_ptr), value :: widget
end function

!  void gtk_widget_style_attach (GtkWidget *style);
subroutine gtk_widget_style_attach(style) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: style
end subroutine

!  gboolean gtk_widget_has_rc_style (GtkWidget *widget);
function gtk_widget_has_rc_style(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_has_rc_style
  type(c_ptr), value :: widget
end function

! void gtk_widget_set_style (GtkWidget *widget, GtkStyle *style);
subroutine gtk_widget_set_style(widget, style) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: style
end subroutine

! void gtk_widget_ensure_style (GtkWidget *widget);
subroutine gtk_widget_ensure_style(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! GtkStyle * gtk_widget_get_style (GtkWidget *widget);
function gtk_widget_get_style(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_style
  type(c_ptr), value :: widget
end function

!  void gtk_widget_modify_style (GtkWidget *widget, GtkRcStyle *style);
subroutine gtk_widget_modify_style(widget, style) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: style
end subroutine

! GtkRcStyle *gtk_widget_get_modifier_style (GtkWidget *widget);
function gtk_widget_get_modifier_style(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_modifier_style
  type(c_ptr), value :: widget
end function

! void gtk_widget_modify_fg (GtkWidget *widget, GtkStateType state, const GdkColor *color);
subroutine gtk_widget_modify_fg(widget, state, color) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  integer(c_int), value :: state
  type(c_ptr), value :: color
end subroutine

! void gtk_widget_modify_bg (GtkWidget *widget, GtkStateType state, const GdkColor *color);
subroutine gtk_widget_modify_bg(widget, state, color) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  integer(c_int), value :: state
  type(c_ptr), value :: color
end subroutine

! void gtk_widget_modify_text (GtkWidget *widget, GtkStateType state, const GdkColor *color);
subroutine gtk_widget_modify_text(widget, state, color) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  integer(c_int), value :: state
  type(c_ptr), value :: color
end subroutine

! void gtk_widget_modify_base (GtkWidget *widget, GtkStateType state, const GdkColor *color);
subroutine gtk_widget_modify_base(widget, state, color) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  integer(c_int), value :: state
  type(c_ptr), value :: color
end subroutine

! void gtk_widget_modify_cursor (GtkWidget *widget, const GdkColor *primary, const GdkColor *secondary);
subroutine gtk_widget_modify_cursor(widget, primary, secondary) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: primary
  type(c_ptr), value :: secondary
end subroutine

! void gtk_widget_modify_font (GtkWidget *widget, PangoFontDescription *font_desc);
subroutine gtk_widget_modify_font(widget, font_desc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: font_desc
end subroutine

!  PangoContext *gtk_widget_create_pango_context (GtkWidget *widget);
function gtk_widget_create_pango_context(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_create_pango_context
  type(c_ptr), value :: widget
end function

! PangoContext *gtk_widget_get_pango_context (GtkWidget *widget);
function gtk_widget_get_pango_context(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_pango_context
  type(c_ptr), value :: widget
end function

! PangoLayout *gtk_widget_create_pango_layout (GtkWidget *widget, const gchar *text);
function gtk_widget_create_pango_layout(widget, text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_widget_create_pango_layout
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: text
end function

!  GdkPixbuf *gtk_widget_render_icon (GtkWidget *widget, const gchar *stock_id, GtkIconSize size, const gchar *detail);
function gtk_widget_render_icon(widget, stock_id, size, detail) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: gtk_widget_render_icon
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: stock_id
  integer(c_int), value :: size
  character(kind=c_char), dimension(*) :: detail
end function

!  void gtk_widget_set_composite_name (GtkWidget *widget, const gchar *name);
subroutine gtk_widget_set_composite_name(widget, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: name
end subroutine

! gchar* gtk_widget_get_composite_name (GtkWidget *widget);
function gtk_widget_get_composite_name(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_composite_name
  type(c_ptr), value :: widget
end function

!   void gtk_widget_reset_rc_styles (GtkWidget *widget);
subroutine gtk_widget_reset_rc_styles(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

!  void gtk_widget_push_colormap (GdkColormap *cmap);
subroutine gtk_widget_push_colormap(cmap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cmap
end subroutine

! void gtk_widget_push_composite_child (void);
subroutine gtk_widget_push_composite_child() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void gtk_widget_pop_composite_child (void);
subroutine gtk_widget_pop_composite_child() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void gtk_widget_pop_colormap (void);
subroutine gtk_widget_pop_colormap() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  void gtk_widget_class_install_style_property (GtkWidgetClass *klass, GParamSpec *pspec);
subroutine gtk_widget_class_install_style_property(klass, pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: klass
  type(c_ptr), value :: pspec
end subroutine

! void gtk_widget_class_install_style_property_parser (GtkWidgetClass *klass, GParamSpec *pspec, GtkRcPropertyParser parser);
subroutine gtk_widget_class_install_style_property_parser(klass, pspec, parser) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: klass
  type(c_ptr), value :: pspec
  type(c_funptr), value :: parser
end subroutine

! GParamSpec* gtk_widget_class_find_style_property (GtkWidgetClass *klass, const gchar *property_name);
function gtk_widget_class_find_style_property(klass, property_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_widget_class_find_style_property
  type(c_ptr), value :: klass
  character(kind=c_char), dimension(*) :: property_name
end function

! GParamSpec** gtk_widget_class_list_style_properties (GtkWidgetClass *klass, guint *n_properties);
function gtk_widget_class_list_style_properties(klass, n_properties) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_class_list_style_properties
  type(c_ptr), value :: klass
  type(c_ptr), value :: n_properties
end function

! void gtk_widget_style_get_property (GtkWidget *widget, const gchar *property_name, GValue *value);
subroutine gtk_widget_style_get_property(widget, property_name, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: property_name
  type(c_ptr), value :: value
end subroutine

! void gtk_widget_style_get_valist (GtkWidget *widget, const gchar *first_property_name, va_list var_args);
subroutine gtk_widget_style_get_valist(widget, first_property_name, var_args) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: first_property_name
  type(c_ptr), value :: var_args
end subroutine

!  void gtk_widget_set_default_colormap (GdkColormap *colormap);
subroutine gtk_widget_set_default_colormap(colormap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: colormap
end subroutine

! GtkStyle* gtk_widget_get_default_style (void);
function gtk_widget_get_default_style() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_default_style
end function

!  GdkColormap* gtk_widget_get_default_colormap (void);
function gtk_widget_get_default_colormap() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_default_colormap
end function

! GdkVisual* gtk_widget_get_default_visual (void);
function gtk_widget_get_default_visual() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_default_visual
end function

!  void gtk_widget_set_direction (GtkWidget *widget, GtkTextDirection dir);
subroutine gtk_widget_set_direction(widget, dir) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  integer(c_int), value :: dir
end subroutine

! GtkTextDirection gtk_widget_get_direction (GtkWidget *widget);
function gtk_widget_get_direction(widget) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_widget_get_direction
  type(c_ptr), value :: widget
end function

!  void gtk_widget_set_default_direction (GtkTextDirection dir);
subroutine gtk_widget_set_default_direction(dir) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: dir
end subroutine

! GtkTextDirection gtk_widget_get_default_direction (void);
function gtk_widget_get_default_direction() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gtk_widget_get_default_direction
end function

!  gboolean gtk_widget_is_composited (GtkWidget *widget);
function gtk_widget_is_composited(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_is_composited
  type(c_ptr), value :: widget
end function

!  void gtk_widget_shape_combine_mask (GtkWidget *widget, GdkBitmap *shape_mask, gint offset_x, gint offset_y);
subroutine gtk_widget_shape_combine_mask(widget, shape_mask, offset_x, offset_y)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  type(c_ptr), value :: shape_mask
  integer(c_int), value :: offset_x
  integer(c_int), value :: offset_y
end subroutine

! void gtk_widget_input_shape_combine_mask (GtkWidget *widget, GdkBitmap *shape_mask, gint offset_x, gint offset_y);
subroutine gtk_widget_input_shape_combine_mask(widget, shape_mask, offset_x, off&
      &set_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: widget
  type(c_ptr), value :: shape_mask
  integer(c_int), value :: offset_x
  integer(c_int), value :: offset_y
end subroutine

!  void gtk_widget_reset_shapes (GtkWidget *widget);
subroutine gtk_widget_reset_shapes(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

!  void gtk_widget_path (GtkWidget *widget, guint *path_length, gchar **path, gchar **path_reversed);
subroutine gtk_widget_path(widget, path_length, path, path_reversed) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: widget
  type(c_ptr), value :: path_length
  character(kind=c_char), dimension(*) :: path
  character(kind=c_char), dimension(*) :: path_reversed
end subroutine

! void gtk_widget_class_path (GtkWidget *widget, guint *path_length, gchar **path, gchar **path_reversed);
subroutine gtk_widget_class_path(widget, path_length, path, path_reversed) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: widget
  type(c_ptr), value :: path_length
  character(kind=c_char), dimension(*) :: path
  character(kind=c_char), dimension(*) :: path_reversed
end subroutine

!  GList* gtk_widget_list_mnemonic_labels (GtkWidget *widget);
function gtk_widget_list_mnemonic_labels(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_list_mnemonic_labels
  type(c_ptr), value :: widget
end function

! void gtk_widget_add_mnemonic_label (GtkWidget *widget, GtkWidget *label);
subroutine gtk_widget_add_mnemonic_label(widget, label) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: label
end subroutine

! void gtk_widget_remove_mnemonic_label (GtkWidget *widget, GtkWidget *label);
subroutine gtk_widget_remove_mnemonic_label(widget, label) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: label
end subroutine

!  void gtk_widget_set_tooltip_window (GtkWidget *widget, GtkWindow *custom_window);
subroutine gtk_widget_set_tooltip_window(widget, custom_window) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
  type(c_ptr), value :: custom_window
end subroutine

! GtkWindow *gtk_widget_get_tooltip_window (GtkWidget *widget);
function gtk_widget_get_tooltip_window(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_tooltip_window
  type(c_ptr), value :: widget
end function

! void gtk_widget_trigger_tooltip_query (GtkWidget *widget);
subroutine gtk_widget_trigger_tooltip_query(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: widget
end subroutine

! void gtk_widget_set_tooltip_text (GtkWidget *widget, const gchar *text);
subroutine gtk_widget_set_tooltip_text(widget, text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: text
end subroutine

! gchar * gtk_widget_get_tooltip_text (GtkWidget *widget);
function gtk_widget_get_tooltip_text(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_tooltip_text
  type(c_ptr), value :: widget
end function

! void gtk_widget_set_tooltip_markup (GtkWidget *widget, const gchar *markup);
subroutine gtk_widget_set_tooltip_markup(widget, markup) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: markup
end subroutine

! gchar * gtk_widget_get_tooltip_markup (GtkWidget *widget);
function gtk_widget_get_tooltip_markup(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_tooltip_markup
  type(c_ptr), value :: widget
end function

! void gtk_widget_set_has_tooltip (GtkWidget *widget, gboolean has_tooltip);
subroutine gtk_widget_set_has_tooltip(widget, has_tooltip) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: widget
  logical(c_bool), value :: has_tooltip
end subroutine

! gboolean gtk_widget_get_has_tooltip (GtkWidget *widget);
function gtk_widget_get_has_tooltip(widget) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_widget_get_has_tooltip
  type(c_ptr), value :: widget
end function

!  GType gtk_requisition_get_type (void) G_GNUC_CONST;
function gtk_requisition_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_requisition_get_type
end function

! GtkRequisition *gtk_requisition_copy (const GtkRequisition *requisition);
function gtk_requisition_copy(requisition) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_requisition_copy
  type(c_ptr), value :: requisition
end function

! void gtk_requisition_free (GtkRequisition *requisition);
subroutine gtk_requisition_free(requisition) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: requisition
end subroutine

!  void ubuntu_gtk_widget_set_has_grab (GtkWidget *widget, gboolean has_grab);
subroutine ubuntu_gtk_widget_set_has_grab(widget, has_grab) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: widget
  logical(c_bool), value :: has_grab
end subroutine

!   GType gtk_text_buffer_get_type (void) G_GNUC_CONST;
function gtk_text_buffer_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_text_buffer_get_type
end function

!  GtkTextBuffer *gtk_text_buffer_new (GtkTextTagTable *table);
function gtk_text_buffer_new(table) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_buffer_new
  type(c_ptr), value :: table
end function

! gint gtk_text_buffer_get_line_count (GtkTextBuffer *buffer);
function gtk_text_buffer_get_line_count(buffer) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_buffer_get_line_count
  type(c_ptr), value :: buffer
end function

! gint gtk_text_buffer_get_char_count (GtkTextBuffer *buffer);
function gtk_text_buffer_get_char_count(buffer) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_text_buffer_get_char_count
  type(c_ptr), value :: buffer
end function

!  GtkTextTagTable* gtk_text_buffer_get_tag_table (GtkTextBuffer *buffer);
function gtk_text_buffer_get_tag_table(buffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_buffer_get_tag_table
  type(c_ptr), value :: buffer
end function

!  void gtk_text_buffer_set_text (GtkTextBuffer *buffer, const gchar *text, gint len);
subroutine gtk_text_buffer_set_text(buffer, text, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: buffer
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: len
end subroutine

!  void gtk_text_buffer_insert (GtkTextBuffer *buffer, GtkTextIter *iter, const gchar *text, gint len);
subroutine gtk_text_buffer_insert(buffer, iter, text, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: buffer
  type(c_ptr), value :: iter
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: len
end subroutine

! void gtk_text_buffer_insert_at_cursor (GtkTextBuffer *buffer, const gchar *text, gint len);
subroutine gtk_text_buffer_insert_at_cursor(buffer, text, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: buffer
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: len
end subroutine

!  gboolean gtk_text_buffer_insert_interactive (GtkTextBuffer *buffer, GtkTextIter *iter, const gchar *text, gint len, gboolean default_editable);
function gtk_text_buffer_insert_interactive(buffer, iter, text, len, default_edi&
      &table) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: gtk_text_buffer_insert_interactive
  type(c_ptr), value :: buffer
  type(c_ptr), value :: iter
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: len
  logical(c_bool), value :: default_editable
end function

! gboolean gtk_text_buffer_insert_interactive_at_cursor (GtkTextBuffer *buffer, const gchar *text, gint len, gboolean default_editable);
function gtk_text_buffer_insert_interactive_at_cursor(buffer, text, len, default&
      &_editable) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: gtk_text_buffer_insert_interactive_at_cursor
  type(c_ptr), value :: buffer
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: len
  logical(c_bool), value :: default_editable
end function

!  void gtk_text_buffer_insert_range (GtkTextBuffer *buffer, GtkTextIter *iter, const GtkTextIter *start, const GtkTextIter *end);
subroutine gtk_text_buffer_insert_range(buffer, iter, start, end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: iter
  type(c_ptr), value :: start
  type(c_ptr), value :: end
end subroutine

! gboolean gtk_text_buffer_insert_range_interactive (GtkTextBuffer *buffer, GtkTextIter *iter, const GtkTextIter *start, const GtkTextIter *end, gboolean default_editable);
function gtk_text_buffer_insert_range_interactive(buffer, iter, start, end, defa&
      &ult_editable) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_buffer_insert_range_interactive
  type(c_ptr), value :: buffer
  type(c_ptr), value :: iter
  type(c_ptr), value :: start
  type(c_ptr), value :: end
  logical(c_bool), value :: default_editable
end function

!  void gtk_text_buffer_delete (GtkTextBuffer *buffer, GtkTextIter *start, GtkTextIter *end);
subroutine gtk_text_buffer_delete(buffer, start, end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: start
  type(c_ptr), value :: end
end subroutine

! gboolean gtk_text_buffer_delete_interactive (GtkTextBuffer *buffer, GtkTextIter *start_iter, GtkTextIter *end_iter, gboolean default_editable);
function gtk_text_buffer_delete_interactive(buffer, start_iter, end_iter, defaul&
      &t_editable) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_buffer_delete_interactive
  type(c_ptr), value :: buffer
  type(c_ptr), value :: start_iter
  type(c_ptr), value :: end_iter
  logical(c_bool), value :: default_editable
end function

! gboolean gtk_text_buffer_backspace (GtkTextBuffer *buffer, GtkTextIter *iter, gboolean interactive, gboolean default_editable);
function gtk_text_buffer_backspace(buffer, iter, interactive, default_editable) &
      &bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_buffer_backspace
  type(c_ptr), value :: buffer
  type(c_ptr), value :: iter
  logical(c_bool), value :: interactive
  logical(c_bool), value :: default_editable
end function

!  gchar *gtk_text_buffer_get_text (GtkTextBuffer *buffer, const GtkTextIter *start, const GtkTextIter *end, gboolean include_hidden_chars);
function gtk_text_buffer_get_text(buffer, start, end, include_hidden_chars) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: gtk_text_buffer_get_text
  type(c_ptr), value :: buffer
  type(c_ptr), value :: start
  type(c_ptr), value :: end
  logical(c_bool), value :: include_hidden_chars
end function

!  gchar *gtk_text_buffer_get_slice (GtkTextBuffer *buffer, const GtkTextIter *start, const GtkTextIter *end, gboolean include_hidden_chars);
function gtk_text_buffer_get_slice(buffer, start, end, include_hidden_chars) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: gtk_text_buffer_get_slice
  type(c_ptr), value :: buffer
  type(c_ptr), value :: start
  type(c_ptr), value :: end
  logical(c_bool), value :: include_hidden_chars
end function

!  void gtk_text_buffer_insert_pixbuf (GtkTextBuffer *buffer, GtkTextIter *iter, GdkPixbuf *pixbuf);
subroutine gtk_text_buffer_insert_pixbuf(buffer, iter, pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: iter
  type(c_ptr), value :: pixbuf
end subroutine

!  void gtk_text_buffer_insert_child_anchor (GtkTextBuffer *buffer, GtkTextIter *iter, GtkTextChildAnchor *anchor);
subroutine gtk_text_buffer_insert_child_anchor(buffer, iter, anchor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: iter
  type(c_ptr), value :: anchor
end subroutine

!  GtkTextChildAnchor *gtk_text_buffer_create_child_anchor (GtkTextBuffer *buffer, GtkTextIter *iter);
function gtk_text_buffer_create_child_anchor(buffer, iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_buffer_create_child_anchor
  type(c_ptr), value :: buffer
  type(c_ptr), value :: iter
end function

!  void gtk_text_buffer_add_mark (GtkTextBuffer *buffer, GtkTextMark *mark, const GtkTextIter *where);
subroutine gtk_text_buffer_add_mark(buffer, mark, where) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: mark
  type(c_ptr), value :: where
end subroutine

! GtkTextMark *gtk_text_buffer_create_mark (GtkTextBuffer *buffer, const gchar *mark_name, const GtkTextIter *where, gboolean left_gravity);
function gtk_text_buffer_create_mark(buffer, mark_name, where, left_gravity) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_char, c_bool
  type(c_ptr) :: gtk_text_buffer_create_mark
  type(c_ptr), value :: buffer
  character(kind=c_char), dimension(*) :: mark_name
  type(c_ptr), value :: where
  logical(c_bool), value :: left_gravity
end function

! void gtk_text_buffer_move_mark (GtkTextBuffer *buffer, GtkTextMark *mark, const GtkTextIter *where);
subroutine gtk_text_buffer_move_mark(buffer, mark, where) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: mark
  type(c_ptr), value :: where
end subroutine

! void gtk_text_buffer_delete_mark (GtkTextBuffer *buffer, GtkTextMark *mark);
subroutine gtk_text_buffer_delete_mark(buffer, mark) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: mark
end subroutine

! GtkTextMark* gtk_text_buffer_get_mark (GtkTextBuffer *buffer, const gchar *name);
function gtk_text_buffer_get_mark(buffer, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_text_buffer_get_mark
  type(c_ptr), value :: buffer
  character(kind=c_char), dimension(*) :: name
end function

!  void gtk_text_buffer_move_mark_by_name (GtkTextBuffer *buffer, const gchar *name, const GtkTextIter *where);
subroutine gtk_text_buffer_move_mark_by_name(buffer, name, where) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: buffer
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: where
end subroutine

! void gtk_text_buffer_delete_mark_by_name (GtkTextBuffer *buffer, const gchar *name);
subroutine gtk_text_buffer_delete_mark_by_name(buffer, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: buffer
  character(kind=c_char), dimension(*) :: name
end subroutine

!  GtkTextMark* gtk_text_buffer_get_insert (GtkTextBuffer *buffer);
function gtk_text_buffer_get_insert(buffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_buffer_get_insert
  type(c_ptr), value :: buffer
end function

! GtkTextMark* gtk_text_buffer_get_selection_bound (GtkTextBuffer *buffer);
function gtk_text_buffer_get_selection_bound(buffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_buffer_get_selection_bound
  type(c_ptr), value :: buffer
end function

!  void gtk_text_buffer_place_cursor (GtkTextBuffer *buffer, const GtkTextIter *where);
subroutine gtk_text_buffer_place_cursor(buffer, where) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: where
end subroutine

! void gtk_text_buffer_select_range (GtkTextBuffer *buffer, const GtkTextIter *ins, const GtkTextIter *bound);
subroutine gtk_text_buffer_select_range(buffer, ins, bound) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: ins
  type(c_ptr), value :: bound
end subroutine

!  void gtk_text_buffer_apply_tag (GtkTextBuffer *buffer, GtkTextTag *tag, const GtkTextIter *start, const GtkTextIter *end);
subroutine gtk_text_buffer_apply_tag(buffer, tag, start, end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: tag
  type(c_ptr), value :: start
  type(c_ptr), value :: end
end subroutine

! void gtk_text_buffer_remove_tag (GtkTextBuffer *buffer, GtkTextTag *tag, const GtkTextIter *start, const GtkTextIter *end);
subroutine gtk_text_buffer_remove_tag(buffer, tag, start, end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: tag
  type(c_ptr), value :: start
  type(c_ptr), value :: end
end subroutine

! void gtk_text_buffer_apply_tag_by_name (GtkTextBuffer *buffer, const gchar *name, const GtkTextIter *start, const GtkTextIter *end);
subroutine gtk_text_buffer_apply_tag_by_name(buffer, name, start, end) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: buffer
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: start
  type(c_ptr), value :: end
end subroutine

! void gtk_text_buffer_remove_tag_by_name (GtkTextBuffer *buffer, const gchar *name, const GtkTextIter *start, const GtkTextIter *end);
subroutine gtk_text_buffer_remove_tag_by_name(buffer, name, start, end) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: buffer
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: start
  type(c_ptr), value :: end
end subroutine

! void gtk_text_buffer_remove_all_tags (GtkTextBuffer *buffer, const GtkTextIter *start, const GtkTextIter *end);
subroutine gtk_text_buffer_remove_all_tags(buffer, start, end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: start
  type(c_ptr), value :: end
end subroutine

!  void gtk_text_buffer_get_iter_at_line_offset (GtkTextBuffer *buffer, GtkTextIter *iter, gint line_number, gint char_offset);
subroutine gtk_text_buffer_get_iter_at_line_offset(buffer, iter, line_number, ch&
      &ar_offset) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: buffer
  type(c_ptr), value :: iter
  integer(c_int), value :: line_number
  integer(c_int), value :: char_offset
end subroutine

! void gtk_text_buffer_get_iter_at_line_index (GtkTextBuffer *buffer, GtkTextIter *iter, gint line_number, gint byte_index);
subroutine gtk_text_buffer_get_iter_at_line_index(buffer, iter, line_number, byt&
      &e_index) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: buffer
  type(c_ptr), value :: iter
  integer(c_int), value :: line_number
  integer(c_int), value :: byte_index
end subroutine

! void gtk_text_buffer_get_iter_at_offset (GtkTextBuffer *buffer, GtkTextIter *iter, gint char_offset);
subroutine gtk_text_buffer_get_iter_at_offset(buffer, iter, char_offset) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: buffer
  type(c_ptr), value :: iter
  integer(c_int), value :: char_offset
end subroutine

! void gtk_text_buffer_get_iter_at_line (GtkTextBuffer *buffer, GtkTextIter *iter, gint line_number);
subroutine gtk_text_buffer_get_iter_at_line(buffer, iter, line_number) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: buffer
  type(c_ptr), value :: iter
  integer(c_int), value :: line_number
end subroutine

! void gtk_text_buffer_get_start_iter (GtkTextBuffer *buffer, GtkTextIter *iter);
subroutine gtk_text_buffer_get_start_iter(buffer, iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: iter
end subroutine

! void gtk_text_buffer_get_end_iter (GtkTextBuffer *buffer, GtkTextIter *iter);
subroutine gtk_text_buffer_get_end_iter(buffer, iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: iter
end subroutine

! void gtk_text_buffer_get_bounds (GtkTextBuffer *buffer, GtkTextIter *start, GtkTextIter *end);
subroutine gtk_text_buffer_get_bounds(buffer, start, end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: start
  type(c_ptr), value :: end
end subroutine

! void gtk_text_buffer_get_iter_at_mark (GtkTextBuffer *buffer, GtkTextIter *iter, GtkTextMark *mark);
subroutine gtk_text_buffer_get_iter_at_mark(buffer, iter, mark) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: iter
  type(c_ptr), value :: mark
end subroutine

!  void gtk_text_buffer_get_iter_at_child_anchor (GtkTextBuffer *buffer, GtkTextIter *iter, GtkTextChildAnchor *anchor);
subroutine gtk_text_buffer_get_iter_at_child_anchor(buffer, iter, anchor) bind(c&
      &) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: iter
  type(c_ptr), value :: anchor
end subroutine

!  gboolean gtk_text_buffer_get_modified (GtkTextBuffer *buffer);
function gtk_text_buffer_get_modified(buffer) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_buffer_get_modified
  type(c_ptr), value :: buffer
end function

! void gtk_text_buffer_set_modified (GtkTextBuffer *buffer, gboolean setting);
subroutine gtk_text_buffer_set_modified(buffer, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: buffer
  logical(c_bool), value :: setting
end subroutine

!  gboolean gtk_text_buffer_get_has_selection (GtkTextBuffer *buffer);
function gtk_text_buffer_get_has_selection(buffer) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_buffer_get_has_selection
  type(c_ptr), value :: buffer
end function

!  void gtk_text_buffer_add_selection_clipboard (GtkTextBuffer *buffer, GtkClipboard *clipboard);
subroutine gtk_text_buffer_add_selection_clipboard(buffer, clipboard) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: clipboard
end subroutine

! void gtk_text_buffer_remove_selection_clipboard (GtkTextBuffer *buffer, GtkClipboard *clipboard);
subroutine gtk_text_buffer_remove_selection_clipboard(buffer, clipboard) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: clipboard
end subroutine

!  void gtk_text_buffer_cut_clipboard (GtkTextBuffer *buffer, GtkClipboard *clipboard, gboolean default_editable);
subroutine gtk_text_buffer_cut_clipboard(buffer, clipboard, default_editable) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: buffer
  type(c_ptr), value :: clipboard
  logical(c_bool), value :: default_editable
end subroutine

! void gtk_text_buffer_copy_clipboard (GtkTextBuffer *buffer, GtkClipboard *clipboard);
subroutine gtk_text_buffer_copy_clipboard(buffer, clipboard) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: clipboard
end subroutine

! void gtk_text_buffer_paste_clipboard (GtkTextBuffer *buffer, GtkClipboard *clipboard, GtkTextIter *override_location, gboolean default_editable);
subroutine gtk_text_buffer_paste_clipboard(buffer, clipboard, override_location,&
      & default_editable) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: buffer
  type(c_ptr), value :: clipboard
  type(c_ptr), value :: override_location
  logical(c_bool), value :: default_editable
end subroutine

!  gboolean gtk_text_buffer_get_selection_bounds (GtkTextBuffer *buffer, GtkTextIter *start, GtkTextIter *end);
function gtk_text_buffer_get_selection_bounds(buffer, start, end) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_buffer_get_selection_bounds
  type(c_ptr), value :: buffer
  type(c_ptr), value :: start
  type(c_ptr), value :: end
end function

! gboolean gtk_text_buffer_delete_selection (GtkTextBuffer *buffer, gboolean interactive, gboolean default_editable);
function gtk_text_buffer_delete_selection(buffer, interactive, default_editable)&
      & bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_buffer_delete_selection
  type(c_ptr), value :: buffer
  logical(c_bool), value :: interactive
  logical(c_bool), value :: default_editable
end function

!  void gtk_text_buffer_begin_user_action (GtkTextBuffer *buffer);
subroutine gtk_text_buffer_begin_user_action(buffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
end subroutine

! void gtk_text_buffer_end_user_action (GtkTextBuffer *buffer);
subroutine gtk_text_buffer_end_user_action(buffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
end subroutine

!  GtkTargetList * gtk_text_buffer_get_copy_target_list (GtkTextBuffer *buffer);
function gtk_text_buffer_get_copy_target_list(buffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_buffer_get_copy_target_list
  type(c_ptr), value :: buffer
end function

! GtkTargetList * gtk_text_buffer_get_paste_target_list (GtkTextBuffer *buffer);
function gtk_text_buffer_get_paste_target_list(buffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_buffer_get_paste_target_list
  type(c_ptr), value :: buffer
end function

!   GType gtk_message_dialog_get_type (void) G_GNUC_CONST;
function gtk_message_dialog_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_message_dialog_get_type
end function

!  GtkWidget* gtk_message_dialog_new (GtkWindow *parent, GtkDialogFlags flags, GtkMessageType type, GtkButtonsType buttons, const gchar *message_format, ...) G_GNUC_PRINTF (5, 6);
function gtk_message_dialog_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_message_dialog_new
end function

!  GtkWidget* gtk_message_dialog_new_with_markup (GtkWindow *parent, GtkDialogFlags flags, GtkMessageType type, GtkButtonsType buttons, const gchar *message_format, ...) G_GNUC_PRINTF (5, 6);
function gtk_message_dialog_new_with_markup() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_message_dialog_new_with_markup
end function

!  void gtk_message_dialog_set_image (GtkMessageDialog *dialog, GtkWidget *image);
subroutine gtk_message_dialog_set_image(dialog, image) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: dialog
  type(c_ptr), value :: image
end subroutine

!  GtkWidget * gtk_message_dialog_get_image (GtkMessageDialog *dialog);
function gtk_message_dialog_get_image(dialog) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_message_dialog_get_image
  type(c_ptr), value :: dialog
end function

!  void gtk_message_dialog_set_markup (GtkMessageDialog *message_dialog, const gchar *str);
subroutine gtk_message_dialog_set_markup(message_dialog, str) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: message_dialog
  character(kind=c_char), dimension(*) :: str
end subroutine

!  void gtk_message_dialog_format_secondary_text (GtkMessageDialog *message_dialog, const gchar *message_format, ...) G_GNUC_PRINTF (2, 3);
subroutine gtk_message_dialog_format_secondary_text() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  void gtk_message_dialog_format_secondary_markup (GtkMessageDialog *message_dialog, const gchar *message_format, ...) G_GNUC_PRINTF (2, 3);
subroutine gtk_message_dialog_format_secondary_markup() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  GtkWidget *gtk_message_dialog_get_message_area (GtkMessageDialog *message_dialog);
function gtk_message_dialog_get_message_area(message_dialog) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_message_dialog_get_message_area
  type(c_ptr), value :: message_dialog
end function

!   GType gtk_info_bar_get_type (void) G_GNUC_CONST;
function gtk_info_bar_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_info_bar_get_type
end function

! GtkWidget *gtk_info_bar_new (void);
function gtk_info_bar_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_info_bar_new
end function

!  GtkWidget *gtk_info_bar_get_action_area (GtkInfoBar *info_bar);
function gtk_info_bar_get_action_area(info_bar) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_info_bar_get_action_area
  type(c_ptr), value :: info_bar
end function

! GtkWidget *gtk_info_bar_get_content_area (GtkInfoBar *info_bar);
function gtk_info_bar_get_content_area(info_bar) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_info_bar_get_content_area
  type(c_ptr), value :: info_bar
end function

! void gtk_info_bar_add_action_widget (GtkInfoBar *info_bar, GtkWidget *child, gint response_id);
subroutine gtk_info_bar_add_action_widget(info_bar, child, response_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: info_bar
  type(c_ptr), value :: child
  integer(c_int), value :: response_id
end subroutine

! GtkWidget *gtk_info_bar_add_button (GtkInfoBar *info_bar, const gchar *button_text, gint response_id);
function gtk_info_bar_add_button(info_bar, button_text, response_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: gtk_info_bar_add_button
  type(c_ptr), value :: info_bar
  character(kind=c_char), dimension(*) :: button_text
  integer(c_int), value :: response_id
end function

! void gtk_info_bar_set_response_sensitive (GtkInfoBar *info_bar, gint response_id, gboolean setting);
subroutine gtk_info_bar_set_response_sensitive(info_bar, response_id, setting) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr), value :: info_bar
  integer(c_int), value :: response_id
  logical(c_bool), value :: setting
end subroutine

! void gtk_info_bar_set_default_response (GtkInfoBar *info_bar, gint response_id);
subroutine gtk_info_bar_set_default_response(info_bar, response_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: info_bar
  integer(c_int), value :: response_id
end subroutine

!  void gtk_info_bar_response (GtkInfoBar *info_bar, gint response_id);
subroutine gtk_info_bar_response(info_bar, response_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: info_bar
  integer(c_int), value :: response_id
end subroutine

!  void gtk_info_bar_set_message_type (GtkInfoBar *info_bar, GtkMessageType message_type);
subroutine gtk_info_bar_set_message_type(info_bar, message_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: info_bar
  integer(c_int), value :: message_type
end subroutine

! GtkMessageType gtk_info_bar_get_message_type (GtkInfoBar *info_bar);
function gtk_info_bar_get_message_type(info_bar) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_info_bar_get_message_type
  type(c_ptr), value :: info_bar
end function

!   GType gtk_icon_factory_get_type (void) G_GNUC_CONST;
function gtk_icon_factory_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_icon_factory_get_type
end function

! GtkIconFactory* gtk_icon_factory_new (void);
function gtk_icon_factory_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_factory_new
end function

! void gtk_icon_factory_add (GtkIconFactory *factory, const gchar *stock_id, GtkIconSet *icon_set);
subroutine gtk_icon_factory_add(factory, stock_id, icon_set) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: factory
  character(kind=c_char), dimension(*) :: stock_id
  type(c_ptr), value :: icon_set
end subroutine

! GtkIconSet* gtk_icon_factory_lookup (GtkIconFactory *factory, const gchar *stock_id);
function gtk_icon_factory_lookup(factory, stock_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_icon_factory_lookup
  type(c_ptr), value :: factory
  character(kind=c_char), dimension(*) :: stock_id
end function

!  void gtk_icon_factory_add_default (GtkIconFactory *factory);
subroutine gtk_icon_factory_add_default(factory) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: factory
end subroutine

! void gtk_icon_factory_remove_default (GtkIconFactory *factory);
subroutine gtk_icon_factory_remove_default(factory) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: factory
end subroutine

! GtkIconSet* gtk_icon_factory_lookup_default (const gchar *stock_id);
function gtk_icon_factory_lookup_default(stock_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_icon_factory_lookup_default
  character(kind=c_char), dimension(*) :: stock_id
end function

!  gboolean gtk_icon_size_lookup (GtkIconSize size, gint *width, gint *height);
function gtk_icon_size_lookup(size, width, height) bind(c) 
  use iso_c_binding, only: c_bool, c_int, c_ptr
  logical(c_bool) :: gtk_icon_size_lookup
  integer(c_int), value :: size
  type(c_ptr), value :: width
  type(c_ptr), value :: height
end function

!  gboolean gtk_icon_size_lookup_for_settings (GtkSettings *settings, GtkIconSize size, gint *width, gint *height);
function gtk_icon_size_lookup_for_settings(settings, size, width, height) bind(c&
      &) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_icon_size_lookup_for_settings
  type(c_ptr), value :: settings
  integer(c_int), value :: size
  type(c_ptr), value :: width
  type(c_ptr), value :: height
end function

!  GtkIconSize gtk_icon_size_register (const gchar *name, gint width, gint height);
function gtk_icon_size_register(name, width, height) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: gtk_icon_size_register
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

! void gtk_icon_size_register_alias (const gchar *alias, GtkIconSize target);
subroutine gtk_icon_size_register_alias(alias, target) bind(c) 
  use iso_c_binding, only: c_char, c_int
  character(kind=c_char), dimension(*) :: alias
  integer(c_int), value :: target
end subroutine

! GtkIconSize gtk_icon_size_from_name (const gchar *name);
function gtk_icon_size_from_name(name) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: gtk_icon_size_from_name
  character(kind=c_char), dimension(*) :: name
end function

! G_CONST_RETURN gchar* gtk_icon_size_get_name (GtkIconSize size);
function gtk_icon_size_get_name(size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_icon_size_get_name
  integer(c_int), value :: size
end function

!  GType gtk_icon_set_get_type (void) G_GNUC_CONST;
function gtk_icon_set_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_icon_set_get_type
end function

! GtkIconSet* gtk_icon_set_new (void);
function gtk_icon_set_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_set_new
end function

! GtkIconSet* gtk_icon_set_new_from_pixbuf (GdkPixbuf *pixbuf);
function gtk_icon_set_new_from_pixbuf(pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_set_new_from_pixbuf
  type(c_ptr), value :: pixbuf
end function

!  GtkIconSet* gtk_icon_set_ref (GtkIconSet *icon_set);
function gtk_icon_set_ref(icon_set) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_set_ref
  type(c_ptr), value :: icon_set
end function

! void gtk_icon_set_unref (GtkIconSet *icon_set);
subroutine gtk_icon_set_unref(icon_set) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: icon_set
end subroutine

! GtkIconSet* gtk_icon_set_copy (GtkIconSet *icon_set);
function gtk_icon_set_copy(icon_set) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_set_copy
  type(c_ptr), value :: icon_set
end function

!  GdkPixbuf* gtk_icon_set_render_icon (GtkIconSet *icon_set, GtkStyle *style, GtkTextDirection direction, GtkStateType state, GtkIconSize size, GtkWidget *widget, const char *detail);
function gtk_icon_set_render_icon(icon_set, style, direction, state, size, widge&
      &t, detail) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr) :: gtk_icon_set_render_icon
  type(c_ptr), value :: icon_set
  type(c_ptr), value :: style
  integer(c_int), value :: direction
  integer(c_int), value :: state
  integer(c_int), value :: size
  type(c_ptr), value :: widget
  character(kind=c_char), dimension(*) :: detail
end function

!  void gtk_icon_set_add_source (GtkIconSet *icon_set, const GtkIconSource *source);
subroutine gtk_icon_set_add_source(icon_set, source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: icon_set
  type(c_ptr), value :: source
end subroutine

!  void gtk_icon_set_get_sizes (GtkIconSet *icon_set, GtkIconSize **sizes, gint *n_sizes);
subroutine gtk_icon_set_get_sizes(icon_set, sizes, n_sizes) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: icon_set
  integer(c_int), value :: sizes
  type(c_ptr), value :: n_sizes
end subroutine

!  GType gtk_icon_source_get_type (void) G_GNUC_CONST;
function gtk_icon_source_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_icon_source_get_type
end function

! GtkIconSource* gtk_icon_source_new (void);
function gtk_icon_source_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_source_new
end function

! GtkIconSource* gtk_icon_source_copy (const GtkIconSource *source);
function gtk_icon_source_copy(source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_source_copy
  type(c_ptr), value :: source
end function

! void gtk_icon_source_free (GtkIconSource *source);
subroutine gtk_icon_source_free(source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source
end subroutine

!  void gtk_icon_source_set_filename (GtkIconSource *source, const gchar *filename);
subroutine gtk_icon_source_set_filename(source, filename) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: source
  character(kind=c_char), dimension(*) :: filename
end subroutine

! void gtk_icon_source_set_icon_name (GtkIconSource *source, const gchar *icon_name);
subroutine gtk_icon_source_set_icon_name(source, icon_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: source
  character(kind=c_char), dimension(*) :: icon_name
end subroutine

! void gtk_icon_source_set_pixbuf (GtkIconSource *source, GdkPixbuf *pixbuf);
subroutine gtk_icon_source_set_pixbuf(source, pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: pixbuf
end subroutine

!  G_CONST_RETURN gchar* gtk_icon_source_get_filename (const GtkIconSource *source);
function gtk_icon_source_get_filename(source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_source_get_filename
  type(c_ptr), value :: source
end function

! G_CONST_RETURN gchar* gtk_icon_source_get_icon_name (const GtkIconSource *source);
function gtk_icon_source_get_icon_name(source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_source_get_icon_name
  type(c_ptr), value :: source
end function

! GdkPixbuf* gtk_icon_source_get_pixbuf (const GtkIconSource *source);
function gtk_icon_source_get_pixbuf(source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_icon_source_get_pixbuf
  type(c_ptr), value :: source
end function

!  void gtk_icon_source_set_direction_wildcarded (GtkIconSource *source, gboolean setting);
subroutine gtk_icon_source_set_direction_wildcarded(source, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: source
  logical(c_bool), value :: setting
end subroutine

! void gtk_icon_source_set_state_wildcarded (GtkIconSource *source, gboolean setting);
subroutine gtk_icon_source_set_state_wildcarded(source, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: source
  logical(c_bool), value :: setting
end subroutine

! void gtk_icon_source_set_size_wildcarded (GtkIconSource *source, gboolean setting);
subroutine gtk_icon_source_set_size_wildcarded(source, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: source
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_icon_source_get_size_wildcarded (const GtkIconSource *source);
function gtk_icon_source_get_size_wildcarded(source) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_icon_source_get_size_wildcarded
  type(c_ptr), value :: source
end function

! gboolean gtk_icon_source_get_state_wildcarded (const GtkIconSource *source);
function gtk_icon_source_get_state_wildcarded(source) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_icon_source_get_state_wildcarded
  type(c_ptr), value :: source
end function

! gboolean gtk_icon_source_get_direction_wildcarded (const GtkIconSource *source);
function gtk_icon_source_get_direction_wildcarded(source) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_icon_source_get_direction_wildcarded
  type(c_ptr), value :: source
end function

! void gtk_icon_source_set_direction (GtkIconSource *source, GtkTextDirection direction);
subroutine gtk_icon_source_set_direction(source, direction) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: source
  integer(c_int), value :: direction
end subroutine

! void gtk_icon_source_set_state (GtkIconSource *source, GtkStateType state);
subroutine gtk_icon_source_set_state(source, state) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: source
  integer(c_int), value :: state
end subroutine

! void gtk_icon_source_set_size (GtkIconSource *source, GtkIconSize size);
subroutine gtk_icon_source_set_size(source, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: source
  integer(c_int), value :: size
end subroutine

! GtkTextDirection gtk_icon_source_get_direction (const GtkIconSource *source);
function gtk_icon_source_get_direction(source) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_source_get_direction
  type(c_ptr), value :: source
end function

! GtkStateType gtk_icon_source_get_state (const GtkIconSource *source);
function gtk_icon_source_get_state(source) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_source_get_state
  type(c_ptr), value :: source
end function

! GtkIconSize gtk_icon_source_get_size (const GtkIconSource *source);
function gtk_icon_source_get_size(source) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_icon_source_get_size
  type(c_ptr), value :: source
end function

!   GType gtk_old_editable_get_type (void) G_GNUC_CONST;
function gtk_old_editable_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_old_editable_get_type
end function

! void gtk_old_editable_claim_selection (GtkOldEditable *old_editable, gboolean claim, guint32 time_);
subroutine gtk_old_editable_claim_selection(old_editable, claim, time_) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_int32_t
  type(c_ptr), value :: old_editable
  logical(c_bool), value :: claim
  integer(c_int32_t), value :: time_
end subroutine

! void gtk_old_editable_changed (GtkOldEditable *old_editable);
subroutine gtk_old_editable_changed(old_editable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: old_editable
end subroutine

!   GType gtk_tree_item_get_type (void) G_GNUC_CONST;
function gtk_tree_item_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_item_get_type
end function

! GtkWidget* gtk_tree_item_new (void);
function gtk_tree_item_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_item_new
end function

! GtkWidget* gtk_tree_item_new_with_label (const gchar *label);
function gtk_tree_item_new_with_label(label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_tree_item_new_with_label
  character(kind=c_char), dimension(*) :: label
end function

! void gtk_tree_item_set_subtree (GtkTreeItem *tree_item, GtkWidget *subtree);
subroutine gtk_tree_item_set_subtree(tree_item, subtree) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_item
  type(c_ptr), value :: subtree
end subroutine

! void gtk_tree_item_remove_subtree (GtkTreeItem *tree_item);
subroutine gtk_tree_item_remove_subtree(tree_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_item
end subroutine

! void gtk_tree_item_select (GtkTreeItem *tree_item);
subroutine gtk_tree_item_select(tree_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_item
end subroutine

! void gtk_tree_item_deselect (GtkTreeItem *tree_item);
subroutine gtk_tree_item_deselect(tree_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_item
end subroutine

! void gtk_tree_item_expand (GtkTreeItem *tree_item);
subroutine gtk_tree_item_expand(tree_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_item
end subroutine

! void gtk_tree_item_collapse (GtkTreeItem *tree_item);
subroutine gtk_tree_item_collapse(tree_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_item
end subroutine

!   GType gtk_event_box_get_type (void) G_GNUC_CONST;
function gtk_event_box_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_event_box_get_type
end function

! GtkWidget* gtk_event_box_new (void);
function gtk_event_box_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_event_box_new
end function

! gboolean gtk_event_box_get_visible_window (GtkEventBox *event_box);
function gtk_event_box_get_visible_window(event_box) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_event_box_get_visible_window
  type(c_ptr), value :: event_box
end function

! void gtk_event_box_set_visible_window (GtkEventBox *event_box, gboolean visible_window);
subroutine gtk_event_box_set_visible_window(event_box, visible_window) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: event_box
  logical(c_bool), value :: visible_window
end subroutine

! gboolean gtk_event_box_get_above_child (GtkEventBox *event_box);
function gtk_event_box_get_above_child(event_box) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_event_box_get_above_child
  type(c_ptr), value :: event_box
end function

! void gtk_event_box_set_above_child (GtkEventBox *event_box, gboolean above_child);
subroutine gtk_event_box_set_above_child(event_box, above_child) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: event_box
  logical(c_bool), value :: above_child
end subroutine

!  GType gtk_clist_get_type (void) G_GNUC_CONST;
function gtk_clist_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_clist_get_type
end function

!  GtkWidget* gtk_clist_new (gint columns);
function gtk_clist_new(columns) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_clist_new
  integer(c_int), value :: columns
end function

! GtkWidget* gtk_clist_new_with_titles (gint columns, gchar *titles[]);
function gtk_clist_new_with_titles(columns, titles) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr) :: gtk_clist_new_with_titles
  integer(c_int), value :: columns
  character(kind=c_char), dimension(*) :: titles
end function

!  void gtk_clist_set_hadjustment (GtkCList *clist, GtkAdjustment *adjustment);
subroutine gtk_clist_set_hadjustment(clist, adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: clist
  type(c_ptr), value :: adjustment
end subroutine

! void gtk_clist_set_vadjustment (GtkCList *clist, GtkAdjustment *adjustment);
subroutine gtk_clist_set_vadjustment(clist, adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: clist
  type(c_ptr), value :: adjustment
end subroutine

!  GtkAdjustment* gtk_clist_get_hadjustment (GtkCList *clist);
function gtk_clist_get_hadjustment(clist) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_clist_get_hadjustment
  type(c_ptr), value :: clist
end function

! GtkAdjustment* gtk_clist_get_vadjustment (GtkCList *clist);
function gtk_clist_get_vadjustment(clist) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_clist_get_vadjustment
  type(c_ptr), value :: clist
end function

!  void gtk_clist_set_shadow_type (GtkCList *clist, GtkShadowType type);
subroutine gtk_clist_set_shadow_type(clist, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: type
end subroutine

!  void gtk_clist_set_selection_mode (GtkCList *clist, GtkSelectionMode mode);
subroutine gtk_clist_set_selection_mode(clist, mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: mode
end subroutine

!  void gtk_clist_set_reorderable (GtkCList *clist, gboolean reorderable);
subroutine gtk_clist_set_reorderable(clist, reorderable) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: clist
  logical(c_bool), value :: reorderable
end subroutine

! void gtk_clist_set_use_drag_icons (GtkCList *clist, gboolean use_icons);
subroutine gtk_clist_set_use_drag_icons(clist, use_icons) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: clist
  logical(c_bool), value :: use_icons
end subroutine

! void gtk_clist_set_button_actions (GtkCList *clist, guint button, guint8 button_actions);
subroutine gtk_clist_set_button_actions(clist, button, button_actions) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int8_t
  type(c_ptr), value :: clist
  integer(c_int), value :: button
  integer(c_int8_t), value :: button_actions
end subroutine

!  void gtk_clist_freeze (GtkCList *clist);
subroutine gtk_clist_freeze(clist) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: clist
end subroutine

! void gtk_clist_thaw (GtkCList *clist);
subroutine gtk_clist_thaw(clist) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: clist
end subroutine

!  void gtk_clist_column_titles_show (GtkCList *clist);
subroutine gtk_clist_column_titles_show(clist) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: clist
end subroutine

! void gtk_clist_column_titles_hide (GtkCList *clist);
subroutine gtk_clist_column_titles_hide(clist) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: clist
end subroutine

!  void gtk_clist_column_title_active (GtkCList *clist, gint column);
subroutine gtk_clist_column_title_active(clist, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: column
end subroutine

! void gtk_clist_column_title_passive (GtkCList *clist, gint column);
subroutine gtk_clist_column_title_passive(clist, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: column
end subroutine

! void gtk_clist_column_titles_active (GtkCList *clist);
subroutine gtk_clist_column_titles_active(clist) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: clist
end subroutine

! void gtk_clist_column_titles_passive (GtkCList *clist);
subroutine gtk_clist_column_titles_passive(clist) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: clist
end subroutine

!  void gtk_clist_set_column_title (GtkCList *clist, gint column, const gchar *title);
subroutine gtk_clist_set_column_title(clist, column, title) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: clist
  integer(c_int), value :: column
  character(kind=c_char), dimension(*) :: title
end subroutine

!  gchar * gtk_clist_get_column_title (GtkCList *clist, gint column);
function gtk_clist_get_column_title(clist, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_clist_get_column_title
  type(c_ptr), value :: clist
  integer(c_int), value :: column
end function

!  void gtk_clist_set_column_widget (GtkCList *clist, gint column, GtkWidget *widget);
subroutine gtk_clist_set_column_widget(clist, column, widget) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: column
  type(c_ptr), value :: widget
end subroutine

!  GtkWidget * gtk_clist_get_column_widget (GtkCList *clist, gint column);
function gtk_clist_get_column_widget(clist, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_clist_get_column_widget
  type(c_ptr), value :: clist
  integer(c_int), value :: column
end function

!  void gtk_clist_set_column_justification (GtkCList *clist, gint column, GtkJustification justification);
subroutine gtk_clist_set_column_justification(clist, column, justification) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: column
  integer(c_int), value :: justification
end subroutine

!  void gtk_clist_set_column_visibility (GtkCList *clist, gint column, gboolean visible);
subroutine gtk_clist_set_column_visibility(clist, column, visible) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr), value :: clist
  integer(c_int), value :: column
  logical(c_bool), value :: visible
end subroutine

!  void gtk_clist_set_column_resizeable (GtkCList *clist, gint column, gboolean resizeable);
subroutine gtk_clist_set_column_resizeable(clist, column, resizeable) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr), value :: clist
  integer(c_int), value :: column
  logical(c_bool), value :: resizeable
end subroutine

!  void gtk_clist_set_column_auto_resize (GtkCList *clist, gint column, gboolean auto_resize);
subroutine gtk_clist_set_column_auto_resize(clist, column, auto_resize) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr), value :: clist
  integer(c_int), value :: column
  logical(c_bool), value :: auto_resize
end subroutine

!  gint gtk_clist_columns_autosize (GtkCList *clist);
function gtk_clist_columns_autosize(clist) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_clist_columns_autosize
  type(c_ptr), value :: clist
end function

!  gint gtk_clist_optimal_column_width (GtkCList *clist, gint column);
function gtk_clist_optimal_column_width(clist, column) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_clist_optimal_column_width
  type(c_ptr), value :: clist
  integer(c_int), value :: column
end function

!  void gtk_clist_set_column_width (GtkCList *clist, gint column, gint width);
subroutine gtk_clist_set_column_width(clist, column, width) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: column
  integer(c_int), value :: width
end subroutine

!  void gtk_clist_set_column_min_width (GtkCList *clist, gint column, gint min_width);
subroutine gtk_clist_set_column_min_width(clist, column, min_width) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: column
  integer(c_int), value :: min_width
end subroutine

! void gtk_clist_set_column_max_width (GtkCList *clist, gint column, gint max_width);
subroutine gtk_clist_set_column_max_width(clist, column, max_width) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: column
  integer(c_int), value :: max_width
end subroutine

!  void gtk_clist_set_row_height (GtkCList *clist, guint height);
subroutine gtk_clist_set_row_height(clist, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: height
end subroutine

!  void gtk_clist_moveto (GtkCList *clist, gint row, gint column, gfloat row_align, gfloat col_align);
subroutine gtk_clist_moveto(clist, row, column, row_align, col_align) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_float
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  integer(c_int), value :: column
  real(c_float), value :: row_align
  real(c_float), value :: col_align
end subroutine

!  GtkVisibility gtk_clist_row_is_visible (GtkCList *clist, gint row);
function gtk_clist_row_is_visible(clist, row) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_clist_row_is_visible
  type(c_ptr), value :: clist
  integer(c_int), value :: row
end function

!  GtkCellType gtk_clist_get_cell_type (GtkCList *clist, gint row, gint column);
function gtk_clist_get_cell_type(clist, row, column) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_clist_get_cell_type
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  integer(c_int), value :: column
end function

!  void gtk_clist_set_text (GtkCList *clist, gint row, gint column, const gchar *text);
subroutine gtk_clist_set_text(clist, row, column, text) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  integer(c_int), value :: column
  character(kind=c_char), dimension(*) :: text
end subroutine

!  gint gtk_clist_get_text (GtkCList *clist, gint row, gint column, gchar **text);
function gtk_clist_get_text(clist, row, column, text) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gtk_clist_get_text
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  integer(c_int), value :: column
  character(kind=c_char), dimension(*) :: text
end function

!  void gtk_clist_set_pixmap (GtkCList *clist, gint row, gint column, GdkPixmap *pixmap, GdkBitmap *mask);
subroutine gtk_clist_set_pixmap(clist, row, column, pixmap, mask) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  integer(c_int), value :: column
  type(c_ptr), value :: pixmap
  type(c_ptr), value :: mask
end subroutine

!  gint gtk_clist_get_pixmap (GtkCList *clist, gint row, gint column, GdkPixmap **pixmap, GdkBitmap **mask);
function gtk_clist_get_pixmap(clist, row, column, pixmap, mask) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_clist_get_pixmap
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  integer(c_int), value :: column
  type(c_ptr), value :: pixmap
  type(c_ptr), value :: mask
end function

!  void gtk_clist_set_pixtext (GtkCList *clist, gint row, gint column, const gchar *text, guint8 spacing, GdkPixmap *pixmap, GdkBitmap *mask);
subroutine gtk_clist_set_pixtext(clist, row, column, text, spacing, pixmap, mask&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char, c_int8_t
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  integer(c_int), value :: column
  character(kind=c_char), dimension(*) :: text
  integer(c_int8_t), value :: spacing
  type(c_ptr), value :: pixmap
  type(c_ptr), value :: mask
end subroutine

!  gint gtk_clist_get_pixtext (GtkCList *clist, gint row, gint column, gchar **text, guint8 *spacing, GdkPixmap **pixmap, GdkBitmap **mask);
function gtk_clist_get_pixtext(clist, row, column, text, spacing, pixmap, mask) &
      &bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gtk_clist_get_pixtext
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  integer(c_int), value :: column
  character(kind=c_char), dimension(*) :: text
  type(c_ptr), value :: spacing
  type(c_ptr), value :: pixmap
  type(c_ptr), value :: mask
end function

!  void gtk_clist_set_foreground (GtkCList *clist, gint row, const GdkColor *color);
subroutine gtk_clist_set_foreground(clist, row, color) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  type(c_ptr), value :: color
end subroutine

!  void gtk_clist_set_background (GtkCList *clist, gint row, const GdkColor *color);
subroutine gtk_clist_set_background(clist, row, color) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  type(c_ptr), value :: color
end subroutine

!  void gtk_clist_set_cell_style (GtkCList *clist, gint row, gint column, GtkStyle *style);
subroutine gtk_clist_set_cell_style(clist, row, column, style) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  integer(c_int), value :: column
  type(c_ptr), value :: style
end subroutine

!  GtkStyle *gtk_clist_get_cell_style (GtkCList *clist, gint row, gint column);
function gtk_clist_get_cell_style(clist, row, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_clist_get_cell_style
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  integer(c_int), value :: column
end function

!  void gtk_clist_set_row_style (GtkCList *clist, gint row, GtkStyle *style);
subroutine gtk_clist_set_row_style(clist, row, style) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  type(c_ptr), value :: style
end subroutine

!  GtkStyle *gtk_clist_get_row_style (GtkCList *clist, gint row);
function gtk_clist_get_row_style(clist, row) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_clist_get_row_style
  type(c_ptr), value :: clist
  integer(c_int), value :: row
end function

!  void gtk_clist_set_shift (GtkCList *clist, gint row, gint column, gint vertical, gint horizontal);
subroutine gtk_clist_set_shift(clist, row, column, vertical, horizontal) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  integer(c_int), value :: column
  integer(c_int), value :: vertical
  integer(c_int), value :: horizontal
end subroutine

!  void gtk_clist_set_selectable (GtkCList *clist, gint row, gboolean selectable);
subroutine gtk_clist_set_selectable(clist, row, selectable) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  logical(c_bool), value :: selectable
end subroutine

! gboolean gtk_clist_get_selectable (GtkCList *clist, gint row);
function gtk_clist_get_selectable(clist, row) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_clist_get_selectable
  type(c_ptr), value :: clist
  integer(c_int), value :: row
end function

!  gint gtk_clist_prepend (GtkCList *clist, gchar *text[]);
function gtk_clist_prepend(clist, text) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gtk_clist_prepend
  type(c_ptr), value :: clist
  character(kind=c_char), dimension(*) :: text
end function

! gint gtk_clist_append (GtkCList *clist, gchar *text[]);
function gtk_clist_append(clist, text) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gtk_clist_append
  type(c_ptr), value :: clist
  character(kind=c_char), dimension(*) :: text
end function

!  gint gtk_clist_insert (GtkCList *clist, gint row, gchar *text[]);
function gtk_clist_insert(clist, row, text) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gtk_clist_insert
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  character(kind=c_char), dimension(*) :: text
end function

!  void gtk_clist_remove (GtkCList *clist, gint row);
subroutine gtk_clist_remove(clist, row) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: row
end subroutine

!  void gtk_clist_set_row_data (GtkCList *clist, gint row, gpointer data);
subroutine gtk_clist_set_row_data(clist, row, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  type(c_ptr), value :: data
end subroutine

!  void gtk_clist_set_row_data_full (GtkCList *clist, gint row, gpointer data, GDestroyNotify destroy);
subroutine gtk_clist_set_row_data_full(clist, row, data, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

!  gpointer gtk_clist_get_row_data (GtkCList *clist, gint row);
function gtk_clist_get_row_data(clist, row) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_clist_get_row_data
  type(c_ptr), value :: clist
  integer(c_int), value :: row
end function

!  gint gtk_clist_find_row_from_data (GtkCList *clist, gpointer data);
function gtk_clist_find_row_from_data(clist, data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_clist_find_row_from_data
  type(c_ptr), value :: clist
  type(c_ptr), value :: data
end function

!  void gtk_clist_select_row (GtkCList *clist, gint row, gint column);
subroutine gtk_clist_select_row(clist, row, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  integer(c_int), value :: column
end subroutine

!  void gtk_clist_unselect_row (GtkCList *clist, gint row, gint column);
subroutine gtk_clist_unselect_row(clist, row, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: row
  integer(c_int), value :: column
end subroutine

!  void gtk_clist_undo_selection (GtkCList *clist);
subroutine gtk_clist_undo_selection(clist) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: clist
end subroutine

!  void gtk_clist_clear (GtkCList *clist);
subroutine gtk_clist_clear(clist) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: clist
end subroutine

!  gint gtk_clist_get_selection_info (GtkCList *clist, gint x, gint y, gint *row, gint *column);
function gtk_clist_get_selection_info(clist, x, y, row, column) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_clist_get_selection_info
  type(c_ptr), value :: clist
  integer(c_int), value :: x
  integer(c_int), value :: y
  type(c_ptr), value :: row
  type(c_ptr), value :: column
end function

!  void gtk_clist_select_all (GtkCList *clist);
subroutine gtk_clist_select_all(clist) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: clist
end subroutine

!  void gtk_clist_unselect_all (GtkCList *clist);
subroutine gtk_clist_unselect_all(clist) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: clist
end subroutine

!  void gtk_clist_swap_rows (GtkCList *clist, gint row1, gint row2);
subroutine gtk_clist_swap_rows(clist, row1, row2) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: row1
  integer(c_int), value :: row2
end subroutine

!  void gtk_clist_row_move (GtkCList *clist, gint source_row, gint dest_row);
subroutine gtk_clist_row_move(clist, source_row, dest_row) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: source_row
  integer(c_int), value :: dest_row
end subroutine

!  void gtk_clist_set_compare_func (GtkCList *clist, GtkCListCompareFunc cmp_func);
subroutine gtk_clist_set_compare_func(clist, cmp_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: clist
  type(c_funptr), value :: cmp_func
end subroutine

!  void gtk_clist_set_sort_column (GtkCList *clist, gint column);
subroutine gtk_clist_set_sort_column(clist, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: column
end subroutine

!  void gtk_clist_set_sort_type (GtkCList *clist, GtkSortType sort_type);
subroutine gtk_clist_set_sort_type(clist, sort_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clist
  integer(c_int), value :: sort_type
end subroutine

!  void gtk_clist_sort (GtkCList *clist);
subroutine gtk_clist_sort(clist) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: clist
end subroutine

!  void gtk_clist_set_auto_sort (GtkCList *clist, gboolean auto_sort);
subroutine gtk_clist_set_auto_sort(clist, auto_sort) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: clist
  logical(c_bool), value :: auto_sort
end subroutine

!   GType gtk_plug_get_type (void) G_GNUC_CONST;
function gtk_plug_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_plug_get_type
end function

!  void gtk_plug_construct (GtkPlug *plug, GdkNativeWindow socket_id);
subroutine gtk_plug_construct(plug, socket_id) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: plug
  type(c_ptr), value :: socket_id
end subroutine

! GtkWidget* gtk_plug_new (GdkNativeWindow socket_id);
function gtk_plug_new(socket_id) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_plug_new
  type(c_ptr), value :: socket_id
end function

!  void gtk_plug_construct_for_display (GtkPlug *plug, GdkDisplay *display, GdkNativeWindow socket_id);
subroutine gtk_plug_construct_for_display(plug, display, socket_id) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: plug
  type(c_ptr), value :: display
  type(c_ptr), value :: socket_id
end subroutine

! GtkWidget* gtk_plug_new_for_display (GdkDisplay *display, GdkNativeWindow socket_id);
function gtk_plug_new_for_display(display, socket_id) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_plug_new_for_display
  type(c_ptr), value :: display
  type(c_ptr), value :: socket_id
end function

!  GdkNativeWindow gtk_plug_get_id (GtkPlug *plug);
function gtk_plug_get_id(plug) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_plug_get_id
  type(c_ptr), value :: plug
end function

!  gboolean gtk_plug_get_embedded (GtkPlug *plug);
function gtk_plug_get_embedded(plug) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_plug_get_embedded
  type(c_ptr), value :: plug
end function

!  GdkWindow *gtk_plug_get_socket_window (GtkPlug *plug);
function gtk_plug_get_socket_window(plug) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_plug_get_socket_window
  type(c_ptr), value :: plug
end function

!   GType gtk_print_settings_get_type (void) G_GNUC_CONST;
function gtk_print_settings_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_print_settings_get_type
end function

! GtkPrintSettings *gtk_print_settings_new (void);
function gtk_print_settings_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_print_settings_new
end function

!  GtkPrintSettings *gtk_print_settings_copy (GtkPrintSettings *other);
function gtk_print_settings_copy(other) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_print_settings_copy
  type(c_ptr), value :: other
end function

!  GtkPrintSettings *gtk_print_settings_new_from_file (const gchar *file_name, GError **error);
function gtk_print_settings_new_from_file(file_name, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_print_settings_new_from_file
  character(kind=c_char), dimension(*) :: file_name
  type(c_ptr), value :: error
end function

! gboolean gtk_print_settings_load_file (GtkPrintSettings *settings, const gchar *file_name, GError **error);
function gtk_print_settings_load_file(settings, file_name, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_print_settings_load_file
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: file_name
  type(c_ptr), value :: error
end function

! gboolean gtk_print_settings_to_file (GtkPrintSettings *settings, const gchar *file_name, GError **error);
function gtk_print_settings_to_file(settings, file_name, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_print_settings_to_file
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: file_name
  type(c_ptr), value :: error
end function

! GtkPrintSettings *gtk_print_settings_new_from_key_file (GKeyFile *key_file, const gchar *group_name, GError **error);
function gtk_print_settings_new_from_key_file(key_file, group_name, error) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_print_settings_new_from_key_file
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  type(c_ptr), value :: error
end function

! gboolean gtk_print_settings_load_key_file (GtkPrintSettings *settings, GKeyFile *key_file, const gchar *group_name, GError **error);
function gtk_print_settings_load_key_file(settings, key_file, group_name, error)&
      & bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_print_settings_load_key_file
  type(c_ptr), value :: settings
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  type(c_ptr), value :: error
end function

! void gtk_print_settings_to_key_file (GtkPrintSettings *settings, GKeyFile *key_file, const gchar *group_name);
subroutine gtk_print_settings_to_key_file(settings, key_file, group_name) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: settings
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
end subroutine

! gboolean gtk_print_settings_has_key (GtkPrintSettings *settings, const gchar *key);
function gtk_print_settings_has_key(settings, key) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_print_settings_has_key
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! G_CONST_RETURN gchar *gtk_print_settings_get (GtkPrintSettings *settings, const gchar *key);
function gtk_print_settings_get(settings, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_print_settings_get
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! void gtk_print_settings_set (GtkPrintSettings *settings, const gchar *key, const gchar *value);
subroutine gtk_print_settings_set(settings, key, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: value
end subroutine

! void gtk_print_settings_unset (GtkPrintSettings *settings, const gchar *key);
subroutine gtk_print_settings_unset(settings, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end subroutine

! void gtk_print_settings_foreach (GtkPrintSettings *settings, GtkPrintSettingsFunc func, gpointer user_data);
subroutine gtk_print_settings_foreach(settings, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: settings
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! gboolean gtk_print_settings_get_bool (GtkPrintSettings *settings, const gchar *key);
function gtk_print_settings_get_bool(settings, key) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_print_settings_get_bool
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! void gtk_print_settings_set_bool (GtkPrintSettings *settings, const gchar *key, gboolean value);
subroutine gtk_print_settings_set_bool(settings, key, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_bool
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  logical(c_bool), value :: value
end subroutine

! gdouble gtk_print_settings_get_double (GtkPrintSettings *settings, const gchar *key);
function gtk_print_settings_get_double(settings, key) bind(c) 
  use iso_c_binding, only: c_double, c_ptr, c_char
  real(c_double) :: gtk_print_settings_get_double
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! gdouble gtk_print_settings_get_double_with_default (GtkPrintSettings *settings, const gchar *key, gdouble def);
function gtk_print_settings_get_double_with_default(settings, key, def) bind(c) 
  use iso_c_binding, only: c_double, c_ptr, c_char
  real(c_double) :: gtk_print_settings_get_double_with_default
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  real(c_double), value :: def
end function

! void gtk_print_settings_set_double (GtkPrintSettings *settings, const gchar *key, gdouble value);
subroutine gtk_print_settings_set_double(settings, key, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_double
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  real(c_double), value :: value
end subroutine

! gdouble gtk_print_settings_get_length (GtkPrintSettings *settings, const gchar *key, GtkUnit unit);
function gtk_print_settings_get_length(settings, key, unit) bind(c) 
  use iso_c_binding, only: c_double, c_ptr, c_char, c_int
  real(c_double) :: gtk_print_settings_get_length
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: unit
end function

! void gtk_print_settings_set_length (GtkPrintSettings *settings, const gchar *key, gdouble value, GtkUnit unit);
subroutine gtk_print_settings_set_length(settings, key, value, unit) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_double, c_int
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  real(c_double), value :: value
  integer(c_int), value :: unit
end subroutine

! gint gtk_print_settings_get_int (GtkPrintSettings *settings, const gchar *key);
function gtk_print_settings_get_int(settings, key) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gtk_print_settings_get_int
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! gint gtk_print_settings_get_int_with_default (GtkPrintSettings *settings, const gchar *key, gint def);
function gtk_print_settings_get_int_with_default(settings, key, def) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gtk_print_settings_get_int_with_default
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: def
end function

! void gtk_print_settings_set_int (GtkPrintSettings *settings, const gchar *key, gint value);
subroutine gtk_print_settings_set_int(settings, key, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: value
end subroutine

!  G_CONST_RETURN gchar *gtk_print_settings_get_printer (GtkPrintSettings *settings);
function gtk_print_settings_get_printer(settings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_print_settings_get_printer
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_printer (GtkPrintSettings *settings, const gchar *printer);
subroutine gtk_print_settings_set_printer(settings, printer) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: printer
end subroutine

! GtkPageOrientation gtk_print_settings_get_orientation (GtkPrintSettings *settings);
function gtk_print_settings_get_orientation(settings) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_print_settings_get_orientation
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_orientation (GtkPrintSettings *settings, GtkPageOrientation orientation);
subroutine gtk_print_settings_set_orientation(settings, orientation) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: settings
  integer(c_int), value :: orientation
end subroutine

! GtkPaperSize * gtk_print_settings_get_paper_size (GtkPrintSettings *settings);
function gtk_print_settings_get_paper_size(settings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_print_settings_get_paper_size
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_paper_size (GtkPrintSettings *settings, GtkPaperSize *paper_size);
subroutine gtk_print_settings_set_paper_size(settings, paper_size) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: settings
  type(c_ptr), value :: paper_size
end subroutine

! gdouble gtk_print_settings_get_paper_width (GtkPrintSettings *settings, GtkUnit unit);
function gtk_print_settings_get_paper_width(settings, unit) bind(c) 
  use iso_c_binding, only: c_double, c_ptr, c_int
  real(c_double) :: gtk_print_settings_get_paper_width
  type(c_ptr), value :: settings
  integer(c_int), value :: unit
end function

! void gtk_print_settings_set_paper_width (GtkPrintSettings *settings, gdouble width, GtkUnit unit);
subroutine gtk_print_settings_set_paper_width(settings, width, unit) bind(c) 
  use iso_c_binding, only: c_ptr, c_double, c_int
  type(c_ptr), value :: settings
  real(c_double), value :: width
  integer(c_int), value :: unit
end subroutine

! gdouble gtk_print_settings_get_paper_height (GtkPrintSettings *settings, GtkUnit unit);
function gtk_print_settings_get_paper_height(settings, unit) bind(c) 
  use iso_c_binding, only: c_double, c_ptr, c_int
  real(c_double) :: gtk_print_settings_get_paper_height
  type(c_ptr), value :: settings
  integer(c_int), value :: unit
end function

! void gtk_print_settings_set_paper_height (GtkPrintSettings *settings, gdouble height, GtkUnit unit);
subroutine gtk_print_settings_set_paper_height(settings, height, unit) bind(c) 
  use iso_c_binding, only: c_ptr, c_double, c_int
  type(c_ptr), value :: settings
  real(c_double), value :: height
  integer(c_int), value :: unit
end subroutine

! gboolean gtk_print_settings_get_use_color (GtkPrintSettings *settings);
function gtk_print_settings_get_use_color(settings) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_print_settings_get_use_color
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_use_color (GtkPrintSettings *settings, gboolean use_color);
subroutine gtk_print_settings_set_use_color(settings, use_color) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: settings
  logical(c_bool), value :: use_color
end subroutine

! gboolean gtk_print_settings_get_collate (GtkPrintSettings *settings);
function gtk_print_settings_get_collate(settings) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_print_settings_get_collate
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_collate (GtkPrintSettings *settings, gboolean collate);
subroutine gtk_print_settings_set_collate(settings, collate) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: settings
  logical(c_bool), value :: collate
end subroutine

! gboolean gtk_print_settings_get_reverse (GtkPrintSettings *settings);
function gtk_print_settings_get_reverse(settings) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_print_settings_get_reverse
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_reverse (GtkPrintSettings *settings, gboolean reverse);
subroutine gtk_print_settings_set_reverse(settings, reverse) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: settings
  logical(c_bool), value :: reverse
end subroutine

! GtkPrintDuplex gtk_print_settings_get_duplex (GtkPrintSettings *settings);
function gtk_print_settings_get_duplex(settings) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_print_settings_get_duplex
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_duplex (GtkPrintSettings *settings, GtkPrintDuplex duplex);
subroutine gtk_print_settings_set_duplex(settings, duplex) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: settings
  integer(c_int), value :: duplex
end subroutine

! GtkPrintQuality gtk_print_settings_get_quality (GtkPrintSettings *settings);
function gtk_print_settings_get_quality(settings) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_print_settings_get_quality
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_quality (GtkPrintSettings *settings, GtkPrintQuality quality);
subroutine gtk_print_settings_set_quality(settings, quality) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: settings
  integer(c_int), value :: quality
end subroutine

! gint gtk_print_settings_get_n_copies (GtkPrintSettings *settings);
function gtk_print_settings_get_n_copies(settings) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_print_settings_get_n_copies
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_n_copies (GtkPrintSettings *settings, gint num_copies);
subroutine gtk_print_settings_set_n_copies(settings, num_copies) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: settings
  integer(c_int), value :: num_copies
end subroutine

! gint gtk_print_settings_get_number_up (GtkPrintSettings *settings);
function gtk_print_settings_get_number_up(settings) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_print_settings_get_number_up
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_number_up (GtkPrintSettings *settings, gint number_up);
subroutine gtk_print_settings_set_number_up(settings, number_up) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: settings
  integer(c_int), value :: number_up
end subroutine

! GtkNumberUpLayout gtk_print_settings_get_number_up_layout (GtkPrintSettings *settings);
function gtk_print_settings_get_number_up_layout(settings) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_print_settings_get_number_up_layout
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_number_up_layout (GtkPrintSettings *settings, GtkNumberUpLayout number_up_layout);
subroutine gtk_print_settings_set_number_up_layout(settings, number_up_layout) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: settings
  integer(c_int), value :: number_up_layout
end subroutine

! gint gtk_print_settings_get_resolution (GtkPrintSettings *settings);
function gtk_print_settings_get_resolution(settings) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_print_settings_get_resolution
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_resolution (GtkPrintSettings *settings, gint resolution);
subroutine gtk_print_settings_set_resolution(settings, resolution) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: settings
  integer(c_int), value :: resolution
end subroutine

! gint gtk_print_settings_get_resolution_x (GtkPrintSettings *settings);
function gtk_print_settings_get_resolution_x(settings) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_print_settings_get_resolution_x
  type(c_ptr), value :: settings
end function

! gint gtk_print_settings_get_resolution_y (GtkPrintSettings *settings);
function gtk_print_settings_get_resolution_y(settings) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_print_settings_get_resolution_y
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_resolution_xy (GtkPrintSettings *settings, gint resolution_x, gint resolution_y);
subroutine gtk_print_settings_set_resolution_xy(settings, resolution_x, resoluti&
      &on_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: settings
  integer(c_int), value :: resolution_x
  integer(c_int), value :: resolution_y
end subroutine

! gdouble gtk_print_settings_get_printer_lpi (GtkPrintSettings *settings);
function gtk_print_settings_get_printer_lpi(settings) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_print_settings_get_printer_lpi
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_printer_lpi (GtkPrintSettings *settings, gdouble lpi);
subroutine gtk_print_settings_set_printer_lpi(settings, lpi) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: settings
  real(c_double), value :: lpi
end subroutine

! gdouble gtk_print_settings_get_scale (GtkPrintSettings *settings);
function gtk_print_settings_get_scale(settings) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_print_settings_get_scale
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_scale (GtkPrintSettings *settings, gdouble scale);
subroutine gtk_print_settings_set_scale(settings, scale) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: settings
  real(c_double), value :: scale
end subroutine

! GtkPrintPages gtk_print_settings_get_print_pages (GtkPrintSettings *settings);
function gtk_print_settings_get_print_pages(settings) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_print_settings_get_print_pages
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_print_pages (GtkPrintSettings *settings, GtkPrintPages pages);
subroutine gtk_print_settings_set_print_pages(settings, pages) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: settings
  integer(c_int), value :: pages
end subroutine

! GtkPageRange * gtk_print_settings_get_page_ranges (GtkPrintSettings *settings, gint *num_ranges);
function gtk_print_settings_get_page_ranges(settings, num_ranges) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_print_settings_get_page_ranges
  type(c_ptr), value :: settings
  type(c_ptr), value :: num_ranges
end function

! void gtk_print_settings_set_page_ranges (GtkPrintSettings *settings, GtkPageRange *page_ranges, gint num_ranges);
subroutine gtk_print_settings_set_page_ranges(settings, page_ranges, num_ranges)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: settings
  type(c_ptr), value :: page_ranges
  integer(c_int), value :: num_ranges
end subroutine

! GtkPageSet gtk_print_settings_get_page_set (GtkPrintSettings *settings);
function gtk_print_settings_get_page_set(settings) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_print_settings_get_page_set
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_page_set (GtkPrintSettings *settings, GtkPageSet page_set);
subroutine gtk_print_settings_set_page_set(settings, page_set) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: settings
  integer(c_int), value :: page_set
end subroutine

! G_CONST_RETURN gchar *gtk_print_settings_get_default_source (GtkPrintSettings *settings);
function gtk_print_settings_get_default_source(settings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_print_settings_get_default_source
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_default_source (GtkPrintSettings *settings, const gchar *default_source);
subroutine gtk_print_settings_set_default_source(settings, default_source) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: default_source
end subroutine

! G_CONST_RETURN gchar *gtk_print_settings_get_media_type (GtkPrintSettings *settings);
function gtk_print_settings_get_media_type(settings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_print_settings_get_media_type
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_media_type (GtkPrintSettings *settings, const gchar *media_type);
subroutine gtk_print_settings_set_media_type(settings, media_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: media_type
end subroutine

! G_CONST_RETURN gchar *gtk_print_settings_get_dither (GtkPrintSettings *settings);
function gtk_print_settings_get_dither(settings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_print_settings_get_dither
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_dither (GtkPrintSettings *settings, const gchar *dither);
subroutine gtk_print_settings_set_dither(settings, dither) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: dither
end subroutine

! G_CONST_RETURN gchar *gtk_print_settings_get_finishings (GtkPrintSettings *settings);
function gtk_print_settings_get_finishings(settings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_print_settings_get_finishings
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_finishings (GtkPrintSettings *settings, const gchar *finishings);
subroutine gtk_print_settings_set_finishings(settings, finishings) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: finishings
end subroutine

! G_CONST_RETURN gchar *gtk_print_settings_get_output_bin (GtkPrintSettings *settings);
function gtk_print_settings_get_output_bin(settings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_print_settings_get_output_bin
  type(c_ptr), value :: settings
end function

! void gtk_print_settings_set_output_bin (GtkPrintSettings *settings, const gchar *output_bin);
subroutine gtk_print_settings_set_output_bin(settings, output_bin) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: output_bin
end subroutine

!   GType gtk_file_filter_get_type (void) G_GNUC_CONST;
function gtk_file_filter_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_file_filter_get_type
end function

!  GtkFileFilter * gtk_file_filter_new (void);
function gtk_file_filter_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_filter_new
end function

! void gtk_file_filter_set_name (GtkFileFilter *filter, const gchar *name);
subroutine gtk_file_filter_set_name(filter, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: filter
  character(kind=c_char), dimension(*) :: name
end subroutine

! G_CONST_RETURN gchar *gtk_file_filter_get_name (GtkFileFilter *filter);
function gtk_file_filter_get_name(filter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_file_filter_get_name
  type(c_ptr), value :: filter
end function

!  void gtk_file_filter_add_mime_type (GtkFileFilter *filter, const gchar *mime_type);
subroutine gtk_file_filter_add_mime_type(filter, mime_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: filter
  character(kind=c_char), dimension(*) :: mime_type
end subroutine

! void gtk_file_filter_add_pattern (GtkFileFilter *filter, const gchar *pattern);
subroutine gtk_file_filter_add_pattern(filter, pattern) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: filter
  character(kind=c_char), dimension(*) :: pattern
end subroutine

! void gtk_file_filter_add_pixbuf_formats (GtkFileFilter *filter);
subroutine gtk_file_filter_add_pixbuf_formats(filter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: filter
end subroutine

! void gtk_file_filter_add_custom (GtkFileFilter *filter, GtkFileFilterFlags needed, GtkFileFilterFunc func, gpointer data, GDestroyNotify notify);
subroutine gtk_file_filter_add_custom(filter, needed, func, data, notify) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: filter
  integer(c_int), value :: needed
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end subroutine

!  GtkFileFilterFlags gtk_file_filter_get_needed (GtkFileFilter *filter);
function gtk_file_filter_get_needed(filter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_file_filter_get_needed
  type(c_ptr), value :: filter
end function

! gboolean gtk_file_filter_filter (GtkFileFilter *filter, const GtkFileFilterInfo *filter_info);
function gtk_file_filter_filter(filter, filter_info) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_file_filter_filter
  type(c_ptr), value :: filter
  type(c_ptr), value :: filter_info
end function

!   GType gtk_print_context_get_type (void) G_GNUC_CONST;
function gtk_print_context_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_print_context_get_type
end function

!  cairo_t *gtk_print_context_get_cairo_context (GtkPrintContext *context);
function gtk_print_context_get_cairo_context(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_print_context_get_cairo_context
  type(c_ptr), value :: context
end function

!  GtkPageSetup *gtk_print_context_get_page_setup (GtkPrintContext *context);
function gtk_print_context_get_page_setup(context) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_print_context_get_page_setup
  type(c_ptr), value :: context
end function

! gdouble gtk_print_context_get_width (GtkPrintContext *context);
function gtk_print_context_get_width(context) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_print_context_get_width
  type(c_ptr), value :: context
end function

! gdouble gtk_print_context_get_height (GtkPrintContext *context);
function gtk_print_context_get_height(context) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_print_context_get_height
  type(c_ptr), value :: context
end function

! gdouble gtk_print_context_get_dpi_x (GtkPrintContext *context);
function gtk_print_context_get_dpi_x(context) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_print_context_get_dpi_x
  type(c_ptr), value :: context
end function

! gdouble gtk_print_context_get_dpi_y (GtkPrintContext *context);
function gtk_print_context_get_dpi_y(context) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_print_context_get_dpi_y
  type(c_ptr), value :: context
end function

! gboolean gtk_print_context_get_hard_margins (GtkPrintContext *context, gdouble *top, gdouble *bottom, gdouble *left, gdouble *right);
function gtk_print_context_get_hard_margins(context, top, bottom, left, right) b&
      &ind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_print_context_get_hard_margins
  type(c_ptr), value :: context
  type(c_ptr), value :: top
  type(c_ptr), value :: bottom
  type(c_ptr), value :: left
  type(c_ptr), value :: right
end function

!  PangoFontMap *gtk_print_context_get_pango_fontmap (GtkPrintContext *context);
function gtk_print_context_get_pango_fontmap(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_print_context_get_pango_fontmap
  type(c_ptr), value :: context
end function

! PangoContext *gtk_print_context_create_pango_context (GtkPrintContext *context);
function gtk_print_context_create_pango_context(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_print_context_create_pango_context
  type(c_ptr), value :: context
end function

! PangoLayout *gtk_print_context_create_pango_layout (GtkPrintContext *context);
function gtk_print_context_create_pango_layout(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_print_context_create_pango_layout
  type(c_ptr), value :: context
end function

!  void gtk_print_context_set_cairo_context (GtkPrintContext *context, cairo_t *cr, double dpi_x, double dpi_y);
subroutine gtk_print_context_set_cairo_context(context, cr, dpi_x, dpi_y) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: context
  type(c_ptr), value :: cr
  real(c_double), value :: dpi_x
  real(c_double), value :: dpi_y
end subroutine

!   GType gtk_cell_renderer_spin_get_type (void);
function gtk_cell_renderer_spin_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_cell_renderer_spin_get_type
end function

! GtkCellRenderer *gtk_cell_renderer_spin_new (void);
function gtk_cell_renderer_spin_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_cell_renderer_spin_new
end function

!   GType gtk_vruler_get_type (void) G_GNUC_CONST;
function gtk_vruler_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_vruler_get_type
end function

! GtkWidget* gtk_vruler_new (void);
function gtk_vruler_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_vruler_new
end function

!   GType gtk_clipboard_get_type (void) G_GNUC_CONST;
function gtk_clipboard_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_clipboard_get_type
end function

!  GtkClipboard *gtk_clipboard_get_for_display (GdkDisplay *display, GdkAtom selection);
function gtk_clipboard_get_for_display(display, selection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_clipboard_get_for_display
  type(c_ptr), value :: display
  type(c_ptr), value :: selection
end function

!  GtkClipboard *gtk_clipboard_get (GdkAtom selection);
function gtk_clipboard_get(selection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_clipboard_get
  type(c_ptr), value :: selection
end function

!  GdkDisplay *gtk_clipboard_get_display (GtkClipboard *clipboard);
function gtk_clipboard_get_display(clipboard) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_clipboard_get_display
  type(c_ptr), value :: clipboard
end function

!  gboolean gtk_clipboard_set_with_data (GtkClipboard *clipboard, const GtkTargetEntry *targets, guint n_targets, GtkClipboardGetFunc get_func, GtkClipboardClearFunc clear_func, gpointer user_data);
function gtk_clipboard_set_with_data(clipboard, targets, n_targets, get_func, cl&
      &ear_func, user_data) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int, c_funptr
  logical(c_bool) :: gtk_clipboard_set_with_data
  type(c_ptr), value :: clipboard
  type(c_ptr), value :: targets
  integer(c_int), value :: n_targets
  type(c_funptr), value :: get_func
  type(c_funptr), value :: clear_func
  type(c_ptr), value :: user_data
end function

! gboolean gtk_clipboard_set_with_owner (GtkClipboard *clipboard, const GtkTargetEntry *targets, guint n_targets, GtkClipboardGetFunc get_func, GtkClipboardClearFunc clear_func, GObject *owner);
function gtk_clipboard_set_with_owner(clipboard, targets, n_targets, get_func, c&
      &lear_func, owner) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int, c_funptr
  logical(c_bool) :: gtk_clipboard_set_with_owner
  type(c_ptr), value :: clipboard
  type(c_ptr), value :: targets
  integer(c_int), value :: n_targets
  type(c_funptr), value :: get_func
  type(c_funptr), value :: clear_func
  type(c_ptr), value :: owner
end function

! GObject *gtk_clipboard_get_owner (GtkClipboard *clipboard);
function gtk_clipboard_get_owner(clipboard) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_clipboard_get_owner
  type(c_ptr), value :: clipboard
end function

! void gtk_clipboard_clear (GtkClipboard *clipboard);
subroutine gtk_clipboard_clear(clipboard) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: clipboard
end subroutine

! void gtk_clipboard_set_text (GtkClipboard *clipboard, const gchar *text, gint len);
subroutine gtk_clipboard_set_text(clipboard, text, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: clipboard
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: len
end subroutine

! void gtk_clipboard_set_image (GtkClipboard *clipboard, GdkPixbuf *pixbuf);
subroutine gtk_clipboard_set_image(clipboard, pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: clipboard
  type(c_ptr), value :: pixbuf
end subroutine

!  void gtk_clipboard_request_contents (GtkClipboard *clipboard, GdkAtom target, GtkClipboardReceivedFunc callback, gpointer user_data);
subroutine gtk_clipboard_request_contents(clipboard, target, callback, user_data&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: clipboard
  type(c_ptr), value :: target
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! void gtk_clipboard_request_text (GtkClipboard *clipboard, GtkClipboardTextReceivedFunc callback, gpointer user_data);
subroutine gtk_clipboard_request_text(clipboard, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: clipboard
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! void gtk_clipboard_request_rich_text (GtkClipboard *clipboard, GtkTextBuffer *buffer, GtkClipboardRichTextReceivedFunc callback, gpointer user_data);
subroutine gtk_clipboard_request_rich_text(clipboard, buffer, callback, user_dat&
      &a) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: clipboard
  type(c_ptr), value :: buffer
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! void gtk_clipboard_request_image (GtkClipboard *clipboard, GtkClipboardImageReceivedFunc callback, gpointer user_data);
subroutine gtk_clipboard_request_image(clipboard, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: clipboard
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! void gtk_clipboard_request_uris (GtkClipboard *clipboard, GtkClipboardURIReceivedFunc callback, gpointer user_data);
subroutine gtk_clipboard_request_uris(clipboard, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: clipboard
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! void gtk_clipboard_request_targets (GtkClipboard *clipboard, GtkClipboardTargetsReceivedFunc callback, gpointer user_data);
subroutine gtk_clipboard_request_targets(clipboard, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: clipboard
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

!  GtkSelectionData *gtk_clipboard_wait_for_contents (GtkClipboard *clipboard, GdkAtom target);
function gtk_clipboard_wait_for_contents(clipboard, target) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_clipboard_wait_for_contents
  type(c_ptr), value :: clipboard
  type(c_ptr), value :: target
end function

! gchar * gtk_clipboard_wait_for_text (GtkClipboard *clipboard);
function gtk_clipboard_wait_for_text(clipboard) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_clipboard_wait_for_text
  type(c_ptr), value :: clipboard
end function

! guint8 * gtk_clipboard_wait_for_rich_text (GtkClipboard *clipboard, GtkTextBuffer *buffer, GdkAtom *format, gsize *length);
function gtk_clipboard_wait_for_rich_text(clipboard, buffer, format, length) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_clipboard_wait_for_rich_text
  type(c_ptr), value :: clipboard
  type(c_ptr), value :: buffer
  type(c_ptr), value :: format
  type(c_ptr), value :: length
end function

! GdkPixbuf * gtk_clipboard_wait_for_image (GtkClipboard *clipboard);
function gtk_clipboard_wait_for_image(clipboard) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_clipboard_wait_for_image
  type(c_ptr), value :: clipboard
end function

! gchar ** gtk_clipboard_wait_for_uris (GtkClipboard *clipboard);
function gtk_clipboard_wait_for_uris(clipboard) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_clipboard_wait_for_uris
  type(c_ptr), value :: clipboard
end function

! gboolean gtk_clipboard_wait_for_targets (GtkClipboard *clipboard, GdkAtom **targets, gint *n_targets);
function gtk_clipboard_wait_for_targets(clipboard, targets, n_targets) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_clipboard_wait_for_targets
  type(c_ptr), value :: clipboard
  type(c_ptr), value :: targets
  type(c_ptr), value :: n_targets
end function

!  gboolean gtk_clipboard_wait_is_text_available (GtkClipboard *clipboard);
function gtk_clipboard_wait_is_text_available(clipboard) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_clipboard_wait_is_text_available
  type(c_ptr), value :: clipboard
end function

! gboolean gtk_clipboard_wait_is_rich_text_available (GtkClipboard *clipboard, GtkTextBuffer *buffer);
function gtk_clipboard_wait_is_rich_text_available(clipboard, buffer) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_clipboard_wait_is_rich_text_available
  type(c_ptr), value :: clipboard
  type(c_ptr), value :: buffer
end function

! gboolean gtk_clipboard_wait_is_image_available (GtkClipboard *clipboard);
function gtk_clipboard_wait_is_image_available(clipboard) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_clipboard_wait_is_image_available
  type(c_ptr), value :: clipboard
end function

! gboolean gtk_clipboard_wait_is_uris_available (GtkClipboard *clipboard);
function gtk_clipboard_wait_is_uris_available(clipboard) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_clipboard_wait_is_uris_available
  type(c_ptr), value :: clipboard
end function

! gboolean gtk_clipboard_wait_is_target_available (GtkClipboard *clipboard, GdkAtom target);
function gtk_clipboard_wait_is_target_available(clipboard, target) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_clipboard_wait_is_target_available
  type(c_ptr), value :: clipboard
  type(c_ptr), value :: target
end function

!  void gtk_clipboard_set_can_store (GtkClipboard *clipboard, const GtkTargetEntry *targets, gint n_targets);
subroutine gtk_clipboard_set_can_store(clipboard, targets, n_targets) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: clipboard
  type(c_ptr), value :: targets
  integer(c_int), value :: n_targets
end subroutine

!  void gtk_clipboard_store (GtkClipboard *clipboard);
subroutine gtk_clipboard_store(clipboard) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: clipboard
end subroutine

!   GType gtk_radio_button_get_type (void) G_GNUC_CONST;
function gtk_radio_button_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_radio_button_get_type
end function

!  GtkWidget* gtk_radio_button_new (GSList *group);
function gtk_radio_button_new(group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_radio_button_new
  type(c_ptr), value :: group
end function

! GtkWidget* gtk_radio_button_new_from_widget (GtkRadioButton *radio_group_member);
function gtk_radio_button_new_from_widget(radio_group_member) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_radio_button_new_from_widget
  type(c_ptr), value :: radio_group_member
end function

! GtkWidget* gtk_radio_button_new_with_label (GSList *group, const gchar *label);
function gtk_radio_button_new_with_label(group, label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_radio_button_new_with_label
  type(c_ptr), value :: group
  character(kind=c_char), dimension(*) :: label
end function

! GtkWidget* gtk_radio_button_new_with_label_from_widget (GtkRadioButton *radio_group_member, const gchar *label);
function gtk_radio_button_new_with_label_from_widget(radio_group_member, label) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_radio_button_new_with_label_from_widget
  type(c_ptr), value :: radio_group_member
  character(kind=c_char), dimension(*) :: label
end function

! GtkWidget* gtk_radio_button_new_with_mnemonic (GSList *group, const gchar *label);
function gtk_radio_button_new_with_mnemonic(group, label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_radio_button_new_with_mnemonic
  type(c_ptr), value :: group
  character(kind=c_char), dimension(*) :: label
end function

! GtkWidget* gtk_radio_button_new_with_mnemonic_from_widget (GtkRadioButton *radio_group_member, const gchar *label);
function gtk_radio_button_new_with_mnemonic_from_widget(radio_group_member, labe&
      &l) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_radio_button_new_with_mnemonic_from_widget
  type(c_ptr), value :: radio_group_member
  character(kind=c_char), dimension(*) :: label
end function

! GSList* gtk_radio_button_get_group (GtkRadioButton *radio_button);
function gtk_radio_button_get_group(radio_button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_radio_button_get_group
  type(c_ptr), value :: radio_button
end function

! void gtk_radio_button_set_group (GtkRadioButton *radio_button, GSList *group);
subroutine gtk_radio_button_set_group(radio_button, group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: radio_button
  type(c_ptr), value :: group
end subroutine

!   GdkAtom gtk_text_buffer_register_serialize_format (GtkTextBuffer *buffer, const gchar *mime_type, GtkTextBufferSerializeFunc function, gpointer user_data, GDestroyNotify user_data_destroy);
function gtk_text_buffer_register_serialize_format(buffer, mime_type, function, &
      &user_data, user_data_destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr) :: gtk_text_buffer_register_serialize_format
  type(c_ptr), value :: buffer
  character(kind=c_char), dimension(*) :: mime_type
  type(c_funptr), value :: function
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_destroy
end function

! GdkAtom gtk_text_buffer_register_serialize_tagset (GtkTextBuffer *buffer, const gchar *tagset_name);
function gtk_text_buffer_register_serialize_tagset(buffer, tagset_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_text_buffer_register_serialize_tagset
  type(c_ptr), value :: buffer
  character(kind=c_char), dimension(*) :: tagset_name
end function

!  GdkAtom gtk_text_buffer_register_deserialize_format (GtkTextBuffer *buffer, const gchar *mime_type, GtkTextBufferDeserializeFunc function, gpointer user_data, GDestroyNotify user_data_destroy);
function gtk_text_buffer_register_deserialize_format(buffer, mime_type, function&
      &, user_data, user_data_destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr) :: gtk_text_buffer_register_deserialize_format
  type(c_ptr), value :: buffer
  character(kind=c_char), dimension(*) :: mime_type
  type(c_funptr), value :: function
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_destroy
end function

! GdkAtom gtk_text_buffer_register_deserialize_tagset (GtkTextBuffer *buffer, const gchar *tagset_name);
function gtk_text_buffer_register_deserialize_tagset(buffer, tagset_name) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_text_buffer_register_deserialize_tagset
  type(c_ptr), value :: buffer
  character(kind=c_char), dimension(*) :: tagset_name
end function

!  void gtk_text_buffer_unregister_serialize_format (GtkTextBuffer *buffer, GdkAtom format);
subroutine gtk_text_buffer_unregister_serialize_format(buffer, format) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: format
end subroutine

! void gtk_text_buffer_unregister_deserialize_format (GtkTextBuffer *buffer, GdkAtom format);
subroutine gtk_text_buffer_unregister_deserialize_format(buffer, format) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: format
end subroutine

!  void gtk_text_buffer_deserialize_set_can_create_tags (GtkTextBuffer *buffer, GdkAtom format, gboolean can_create_tags);
subroutine gtk_text_buffer_deserialize_set_can_create_tags(buffer, format, can_c&
      &reate_tags) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: buffer
  type(c_ptr), value :: format
  logical(c_bool), value :: can_create_tags
end subroutine

! gboolean gtk_text_buffer_deserialize_get_can_create_tags (GtkTextBuffer *buffer, GdkAtom format);
function gtk_text_buffer_deserialize_get_can_create_tags(buffer, format) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_buffer_deserialize_get_can_create_tags
  type(c_ptr), value :: buffer
  type(c_ptr), value :: format
end function

!  GdkAtom * gtk_text_buffer_get_serialize_formats (GtkTextBuffer *buffer, gint *n_formats);
function gtk_text_buffer_get_serialize_formats(buffer, n_formats) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_buffer_get_serialize_formats
  type(c_ptr), value :: buffer
  type(c_ptr), value :: n_formats
end function

! GdkAtom * gtk_text_buffer_get_deserialize_formats (GtkTextBuffer *buffer, gint *n_formats);
function gtk_text_buffer_get_deserialize_formats(buffer, n_formats) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_buffer_get_deserialize_formats
  type(c_ptr), value :: buffer
  type(c_ptr), value :: n_formats
end function

!  guint8 * gtk_text_buffer_serialize (GtkTextBuffer *register_buffer, GtkTextBuffer *content_buffer, GdkAtom format, const GtkTextIter *start, const GtkTextIter *end, gsize *length);
function gtk_text_buffer_serialize(register_buffer, content_buffer, format, star&
      &t, end, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_buffer_serialize
  type(c_ptr), value :: register_buffer
  type(c_ptr), value :: content_buffer
  type(c_ptr), value :: format
  type(c_ptr), value :: start
  type(c_ptr), value :: end
  type(c_ptr), value :: length
end function

! gboolean gtk_text_buffer_deserialize (GtkTextBuffer *register_buffer, GtkTextBuffer *content_buffer, GdkAtom format, GtkTextIter *iter, const guint8 *data, gsize length, GError **error);
function gtk_text_buffer_deserialize(register_buffer, content_buffer, format, it&
      &er, data, length, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_size_t
  logical(c_bool) :: gtk_text_buffer_deserialize
  type(c_ptr), value :: register_buffer
  type(c_ptr), value :: content_buffer
  type(c_ptr), value :: format
  type(c_ptr), value :: iter
  type(c_ptr), value :: data
  integer(c_size_t), value :: length
  type(c_ptr), value :: error
end function

!   GType gtk_calendar_get_type (void) G_GNUC_CONST;
function gtk_calendar_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_calendar_get_type
end function

! GtkWidget* gtk_calendar_new (void);
function gtk_calendar_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_calendar_new
end function

!  gboolean gtk_calendar_select_month (GtkCalendar *calendar, guint month, guint year);
function gtk_calendar_select_month(calendar, month, year) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_calendar_select_month
  type(c_ptr), value :: calendar
  integer(c_int), value :: month
  integer(c_int), value :: year
end function

! void gtk_calendar_select_day (GtkCalendar *calendar, guint day);
subroutine gtk_calendar_select_day(calendar, day) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: calendar
  integer(c_int), value :: day
end subroutine

!  gboolean gtk_calendar_mark_day (GtkCalendar *calendar, guint day);
function gtk_calendar_mark_day(calendar, day) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_calendar_mark_day
  type(c_ptr), value :: calendar
  integer(c_int), value :: day
end function

! gboolean gtk_calendar_unmark_day (GtkCalendar *calendar, guint day);
function gtk_calendar_unmark_day(calendar, day) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_calendar_unmark_day
  type(c_ptr), value :: calendar
  integer(c_int), value :: day
end function

! void gtk_calendar_clear_marks (GtkCalendar *calendar);
subroutine gtk_calendar_clear_marks(calendar) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: calendar
end subroutine

!  void gtk_calendar_set_display_options (GtkCalendar *calendar, GtkCalendarDisplayOptions flags);
subroutine gtk_calendar_set_display_options(calendar, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: calendar
  integer(c_int), value :: flags
end subroutine

! GtkCalendarDisplayOptions gtk_calendar_get_display_options (GtkCalendar *calendar);
function gtk_calendar_get_display_options(calendar) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_calendar_get_display_options
  type(c_ptr), value :: calendar
end function

!  void gtk_calendar_display_options (GtkCalendar *calendar, GtkCalendarDisplayOptions flags);
subroutine gtk_calendar_display_options(calendar, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: calendar
  integer(c_int), value :: flags
end subroutine

!  void gtk_calendar_get_date (GtkCalendar *calendar, guint *year, guint *month, guint *day);
subroutine gtk_calendar_get_date(calendar, year, month, day) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: calendar
  type(c_ptr), value :: year
  type(c_ptr), value :: month
  type(c_ptr), value :: day
end subroutine

!  void gtk_calendar_set_detail_func (GtkCalendar *calendar, GtkCalendarDetailFunc func, gpointer data, GDestroyNotify destroy);
subroutine gtk_calendar_set_detail_func(calendar, func, data, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: calendar
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

!  void gtk_calendar_set_detail_width_chars (GtkCalendar *calendar, gint chars);
subroutine gtk_calendar_set_detail_width_chars(calendar, chars) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: calendar
  integer(c_int), value :: chars
end subroutine

! void gtk_calendar_set_detail_height_rows (GtkCalendar *calendar, gint rows);
subroutine gtk_calendar_set_detail_height_rows(calendar, rows) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: calendar
  integer(c_int), value :: rows
end subroutine

!  gint gtk_calendar_get_detail_width_chars (GtkCalendar *calendar);
function gtk_calendar_get_detail_width_chars(calendar) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_calendar_get_detail_width_chars
  type(c_ptr), value :: calendar
end function

! gint gtk_calendar_get_detail_height_rows (GtkCalendar *calendar);
function gtk_calendar_get_detail_height_rows(calendar) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_calendar_get_detail_height_rows
  type(c_ptr), value :: calendar
end function

!  void gtk_calendar_freeze (GtkCalendar *calendar);
subroutine gtk_calendar_freeze(calendar) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: calendar
end subroutine

! void gtk_calendar_thaw (GtkCalendar *calendar);
subroutine gtk_calendar_thaw(calendar) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: calendar
end subroutine

!   GType gtk_action_get_type (void) G_GNUC_CONST;
function gtk_action_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_action_get_type
end function

! GtkAction *gtk_action_new (const gchar *name, const gchar *label, const gchar *tooltip, const gchar *stock_id);
function gtk_action_new(name, label, tooltip, stock_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_action_new
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: label
  character(kind=c_char), dimension(*) :: tooltip
  character(kind=c_char), dimension(*) :: stock_id
end function

! G_CONST_RETURN gchar* gtk_action_get_name (GtkAction *action);
function gtk_action_get_name(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_action_get_name
  type(c_ptr), value :: action
end function

! gboolean gtk_action_is_sensitive (GtkAction *action);
function gtk_action_is_sensitive(action) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_action_is_sensitive
  type(c_ptr), value :: action
end function

! gboolean gtk_action_get_sensitive (GtkAction *action);
function gtk_action_get_sensitive(action) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_action_get_sensitive
  type(c_ptr), value :: action
end function

! void gtk_action_set_sensitive (GtkAction *action, gboolean sensitive);
subroutine gtk_action_set_sensitive(action, sensitive) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: action
  logical(c_bool), value :: sensitive
end subroutine

! gboolean gtk_action_is_visible (GtkAction *action);
function gtk_action_is_visible(action) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_action_is_visible
  type(c_ptr), value :: action
end function

! gboolean gtk_action_get_visible (GtkAction *action);
function gtk_action_get_visible(action) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_action_get_visible
  type(c_ptr), value :: action
end function

! void gtk_action_set_visible (GtkAction *action, gboolean visible);
subroutine gtk_action_set_visible(action, visible) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: action
  logical(c_bool), value :: visible
end subroutine

! void gtk_action_activate (GtkAction *action);
subroutine gtk_action_activate(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: action
end subroutine

! GtkWidget * gtk_action_create_icon (GtkAction *action, GtkIconSize icon_size);
function gtk_action_create_icon(action, icon_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_action_create_icon
  type(c_ptr), value :: action
  integer(c_int), value :: icon_size
end function

! GtkWidget * gtk_action_create_menu_item (GtkAction *action);
function gtk_action_create_menu_item(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_action_create_menu_item
  type(c_ptr), value :: action
end function

! GtkWidget * gtk_action_create_tool_item (GtkAction *action);
function gtk_action_create_tool_item(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_action_create_tool_item
  type(c_ptr), value :: action
end function

! GtkWidget * gtk_action_create_menu (GtkAction *action);
function gtk_action_create_menu(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_action_create_menu
  type(c_ptr), value :: action
end function

! GSList * gtk_action_get_proxies (GtkAction *action);
function gtk_action_get_proxies(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_action_get_proxies
  type(c_ptr), value :: action
end function

! void gtk_action_connect_accelerator (GtkAction *action);
subroutine gtk_action_connect_accelerator(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: action
end subroutine

! void gtk_action_disconnect_accelerator (GtkAction *action);
subroutine gtk_action_disconnect_accelerator(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: action
end subroutine

! G_CONST_RETURN gchar *gtk_action_get_accel_path (GtkAction *action);
function gtk_action_get_accel_path(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_action_get_accel_path
  type(c_ptr), value :: action
end function

! GClosure *gtk_action_get_accel_closure (GtkAction *action);
function gtk_action_get_accel_closure(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_action_get_accel_closure
  type(c_ptr), value :: action
end function

!  GtkAction *gtk_widget_get_action (GtkWidget *widget);
function gtk_widget_get_action(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_widget_get_action
  type(c_ptr), value :: widget
end function

! void gtk_action_connect_proxy (GtkAction *action, GtkWidget *proxy);
subroutine gtk_action_connect_proxy(action, proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: action
  type(c_ptr), value :: proxy
end subroutine

! void gtk_action_disconnect_proxy (GtkAction *action, GtkWidget *proxy);
subroutine gtk_action_disconnect_proxy(action, proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: action
  type(c_ptr), value :: proxy
end subroutine

! void gtk_action_block_activate_from (GtkAction *action, GtkWidget *proxy);
subroutine gtk_action_block_activate_from(action, proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: action
  type(c_ptr), value :: proxy
end subroutine

! void gtk_action_unblock_activate_from (GtkAction *action, GtkWidget *proxy);
subroutine gtk_action_unblock_activate_from(action, proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: action
  type(c_ptr), value :: proxy
end subroutine

!  void gtk_action_block_activate (GtkAction *action);
subroutine gtk_action_block_activate(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: action
end subroutine

! void gtk_action_unblock_activate (GtkAction *action);
subroutine gtk_action_unblock_activate(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: action
end subroutine

!  void gtk_action_set_accel_path (GtkAction *action, const gchar *accel_path);
subroutine gtk_action_set_accel_path(action, accel_path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: action
  character(kind=c_char), dimension(*) :: accel_path
end subroutine

! void gtk_action_set_accel_group (GtkAction *action, GtkAccelGroup *accel_group);
subroutine gtk_action_set_accel_group(action, accel_group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: action
  type(c_ptr), value :: accel_group
end subroutine

!  void gtk_action_set_label (GtkAction *action, const gchar *label);
subroutine gtk_action_set_label(action, label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: action
  character(kind=c_char), dimension(*) :: label
end subroutine

! G_CONST_RETURN gchar *gtk_action_get_label (GtkAction *action);
function gtk_action_get_label(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_action_get_label
  type(c_ptr), value :: action
end function

! void gtk_action_set_short_label (GtkAction *action, const gchar *short_label);
subroutine gtk_action_set_short_label(action, short_label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: action
  character(kind=c_char), dimension(*) :: short_label
end subroutine

! G_CONST_RETURN gchar *gtk_action_get_short_label (GtkAction *action);
function gtk_action_get_short_label(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_action_get_short_label
  type(c_ptr), value :: action
end function

! void gtk_action_set_tooltip (GtkAction *action, const gchar *tooltip);
subroutine gtk_action_set_tooltip(action, tooltip) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: action
  character(kind=c_char), dimension(*) :: tooltip
end subroutine

! G_CONST_RETURN gchar *gtk_action_get_tooltip (GtkAction *action);
function gtk_action_get_tooltip(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_action_get_tooltip
  type(c_ptr), value :: action
end function

! void gtk_action_set_stock_id (GtkAction *action, const gchar *stock_id);
subroutine gtk_action_set_stock_id(action, stock_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: action
  character(kind=c_char), dimension(*) :: stock_id
end subroutine

! G_CONST_RETURN gchar *gtk_action_get_stock_id (GtkAction *action);
function gtk_action_get_stock_id(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_action_get_stock_id
  type(c_ptr), value :: action
end function

! void gtk_action_set_gicon (GtkAction *action, GIcon *icon);
subroutine gtk_action_set_gicon(action, icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: action
  type(c_ptr), value :: icon
end subroutine

! GIcon *gtk_action_get_gicon (GtkAction *action);
function gtk_action_get_gicon(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_action_get_gicon
  type(c_ptr), value :: action
end function

! void gtk_action_set_icon_name (GtkAction *action, const gchar *icon_name);
subroutine gtk_action_set_icon_name(action, icon_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: action
  character(kind=c_char), dimension(*) :: icon_name
end subroutine

! G_CONST_RETURN gchar *gtk_action_get_icon_name (GtkAction *action);
function gtk_action_get_icon_name(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_action_get_icon_name
  type(c_ptr), value :: action
end function

! void gtk_action_set_visible_horizontal (GtkAction *action, gboolean visible_horizontal);
subroutine gtk_action_set_visible_horizontal(action, visible_horizontal) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: action
  logical(c_bool), value :: visible_horizontal
end subroutine

! gboolean gtk_action_get_visible_horizontal (GtkAction *action);
function gtk_action_get_visible_horizontal(action) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_action_get_visible_horizontal
  type(c_ptr), value :: action
end function

! void gtk_action_set_visible_vertical (GtkAction *action, gboolean visible_vertical);
subroutine gtk_action_set_visible_vertical(action, visible_vertical) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: action
  logical(c_bool), value :: visible_vertical
end subroutine

! gboolean gtk_action_get_visible_vertical (GtkAction *action);
function gtk_action_get_visible_vertical(action) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_action_get_visible_vertical
  type(c_ptr), value :: action
end function

! void gtk_action_set_is_important (GtkAction *action, gboolean is_important);
subroutine gtk_action_set_is_important(action, is_important) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: action
  logical(c_bool), value :: is_important
end subroutine

! gboolean gtk_action_get_is_important (GtkAction *action);
function gtk_action_get_is_important(action) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_action_get_is_important
  type(c_ptr), value :: action
end function

! void gtk_action_set_always_show_image (GtkAction *action, gboolean always_show);
subroutine gtk_action_set_always_show_image(action, always_show) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: action
  logical(c_bool), value :: always_show
end subroutine

! gboolean gtk_action_get_always_show_image (GtkAction *action);
function gtk_action_get_always_show_image(action) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_action_get_always_show_image
  type(c_ptr), value :: action
end function

!   GType gtk_hbox_get_type (void) G_GNUC_CONST;
function gtk_hbox_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_hbox_get_type
end function

! GtkWidget * gtk_hbox_new (gboolean homogeneous, gint spacing);
function gtk_hbox_new(homogeneous, spacing) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_int
  type(c_ptr) :: gtk_hbox_new
  logical(c_bool), value :: homogeneous
  integer(c_int), value :: spacing
end function

!   GType gtk_text_mark_get_type (void) G_GNUC_CONST;
function gtk_text_mark_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_text_mark_get_type
end function

!  void gtk_text_mark_set_visible (GtkTextMark *mark, gboolean setting);
subroutine gtk_text_mark_set_visible(mark, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: mark
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_text_mark_get_visible (GtkTextMark *mark);
function gtk_text_mark_get_visible(mark) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_mark_get_visible
  type(c_ptr), value :: mark
end function

!  GtkTextMark *gtk_text_mark_new (const gchar *name, gboolean left_gravity);
function gtk_text_mark_new(name, left_gravity) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_bool
  type(c_ptr) :: gtk_text_mark_new
  character(kind=c_char), dimension(*) :: name
  logical(c_bool), value :: left_gravity
end function

! G_CONST_RETURN gchar* gtk_text_mark_get_name (GtkTextMark *mark);
function gtk_text_mark_get_name(mark) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_mark_get_name
  type(c_ptr), value :: mark
end function

! gboolean gtk_text_mark_get_deleted (GtkTextMark *mark);
function gtk_text_mark_get_deleted(mark) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_mark_get_deleted
  type(c_ptr), value :: mark
end function

! GtkTextBuffer* gtk_text_mark_get_buffer (GtkTextMark *mark);
function gtk_text_mark_get_buffer(mark) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_text_mark_get_buffer
  type(c_ptr), value :: mark
end function

! gboolean gtk_text_mark_get_left_gravity (GtkTextMark *mark);
function gtk_text_mark_get_left_gravity(mark) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_text_mark_get_left_gravity
  type(c_ptr), value :: mark
end function

!   GType gtk_spin_button_get_type (void) G_GNUC_CONST;
function gtk_spin_button_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_spin_button_get_type
end function

!  void gtk_spin_button_configure (GtkSpinButton *spin_button, GtkAdjustment *adjustment, gdouble climb_rate, guint digits);
subroutine gtk_spin_button_configure(spin_button, adjustment, climb_rate, digits&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_double, c_int
  type(c_ptr), value :: spin_button
  type(c_ptr), value :: adjustment
  real(c_double), value :: climb_rate
  integer(c_int), value :: digits
end subroutine

!  GtkWidget* gtk_spin_button_new (GtkAdjustment *adjustment, gdouble climb_rate, guint digits);
function gtk_spin_button_new(adjustment, climb_rate, digits) bind(c) 
  use iso_c_binding, only: c_ptr, c_double, c_int
  type(c_ptr) :: gtk_spin_button_new
  type(c_ptr), value :: adjustment
  real(c_double), value :: climb_rate
  integer(c_int), value :: digits
end function

!  GtkWidget* gtk_spin_button_new_with_range (gdouble min, gdouble max, gdouble step);
function gtk_spin_button_new_with_range(min, max, step) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr) :: gtk_spin_button_new_with_range
  real(c_double), value :: min
  real(c_double), value :: max
  real(c_double), value :: step
end function

!  void gtk_spin_button_set_adjustment (GtkSpinButton *spin_button, GtkAdjustment *adjustment);
subroutine gtk_spin_button_set_adjustment(spin_button, adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: spin_button
  type(c_ptr), value :: adjustment
end subroutine

!  GtkAdjustment* gtk_spin_button_get_adjustment (GtkSpinButton *spin_button);
function gtk_spin_button_get_adjustment(spin_button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_spin_button_get_adjustment
  type(c_ptr), value :: spin_button
end function

!  void gtk_spin_button_set_digits (GtkSpinButton *spin_button, guint digits);
subroutine gtk_spin_button_set_digits(spin_button, digits) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: spin_button
  integer(c_int), value :: digits
end subroutine

! guint gtk_spin_button_get_digits (GtkSpinButton *spin_button);
function gtk_spin_button_get_digits(spin_button) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_spin_button_get_digits
  type(c_ptr), value :: spin_button
end function

!  void gtk_spin_button_set_increments (GtkSpinButton *spin_button, gdouble step, gdouble page);
subroutine gtk_spin_button_set_increments(spin_button, step, page) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: spin_button
  real(c_double), value :: step
  real(c_double), value :: page
end subroutine

! void gtk_spin_button_get_increments (GtkSpinButton *spin_button, gdouble *step, gdouble *page);
subroutine gtk_spin_button_get_increments(spin_button, step, page) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: spin_button
  type(c_ptr), value :: step
  type(c_ptr), value :: page
end subroutine

!  void gtk_spin_button_set_range (GtkSpinButton *spin_button, gdouble min, gdouble max);
subroutine gtk_spin_button_set_range(spin_button, min, max) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: spin_button
  real(c_double), value :: min
  real(c_double), value :: max
end subroutine

! void gtk_spin_button_get_range (GtkSpinButton *spin_button, gdouble *min, gdouble *max);
subroutine gtk_spin_button_get_range(spin_button, min, max) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: spin_button
  type(c_ptr), value :: min
  type(c_ptr), value :: max
end subroutine

!  gdouble gtk_spin_button_get_value (GtkSpinButton *spin_button);
function gtk_spin_button_get_value(spin_button) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_spin_button_get_value
  type(c_ptr), value :: spin_button
end function

!  gint gtk_spin_button_get_value_as_int (GtkSpinButton *spin_button);
function gtk_spin_button_get_value_as_int(spin_button) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_spin_button_get_value_as_int
  type(c_ptr), value :: spin_button
end function

!  void gtk_spin_button_set_value (GtkSpinButton *spin_button, gdouble value);
subroutine gtk_spin_button_set_value(spin_button, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: spin_button
  real(c_double), value :: value
end subroutine

!  void gtk_spin_button_set_update_policy (GtkSpinButton *spin_button, GtkSpinButtonUpdatePolicy policy);
subroutine gtk_spin_button_set_update_policy(spin_button, policy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: spin_button
  integer(c_int), value :: policy
end subroutine

! GtkSpinButtonUpdatePolicy gtk_spin_button_get_update_policy (GtkSpinButton *spin_button);
function gtk_spin_button_get_update_policy(spin_button) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_spin_button_get_update_policy
  type(c_ptr), value :: spin_button
end function

!  void gtk_spin_button_set_numeric (GtkSpinButton *spin_button, gboolean numeric);
subroutine gtk_spin_button_set_numeric(spin_button, numeric) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: spin_button
  logical(c_bool), value :: numeric
end subroutine

! gboolean gtk_spin_button_get_numeric (GtkSpinButton *spin_button);
function gtk_spin_button_get_numeric(spin_button) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_spin_button_get_numeric
  type(c_ptr), value :: spin_button
end function

!  void gtk_spin_button_spin (GtkSpinButton *spin_button, GtkSpinType direction, gdouble increment);
subroutine gtk_spin_button_spin(spin_button, direction, increment) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_double
  type(c_ptr), value :: spin_button
  integer(c_int), value :: direction
  real(c_double), value :: increment
end subroutine

!  void gtk_spin_button_set_wrap (GtkSpinButton *spin_button, gboolean wrap);
subroutine gtk_spin_button_set_wrap(spin_button, wrap) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: spin_button
  logical(c_bool), value :: wrap
end subroutine

! gboolean gtk_spin_button_get_wrap (GtkSpinButton *spin_button);
function gtk_spin_button_get_wrap(spin_button) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_spin_button_get_wrap
  type(c_ptr), value :: spin_button
end function

!  void gtk_spin_button_set_snap_to_ticks (GtkSpinButton *spin_button, gboolean snap_to_ticks);
subroutine gtk_spin_button_set_snap_to_ticks(spin_button, snap_to_ticks) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: spin_button
  logical(c_bool), value :: snap_to_ticks
end subroutine

! gboolean gtk_spin_button_get_snap_to_ticks (GtkSpinButton *spin_button);
function gtk_spin_button_get_snap_to_ticks(spin_button) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_spin_button_get_snap_to_ticks
  type(c_ptr), value :: spin_button
end function

! void gtk_spin_button_update (GtkSpinButton *spin_button);
subroutine gtk_spin_button_update(spin_button) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: spin_button
end subroutine

!   GType gtk_orientable_get_type (void) G_GNUC_CONST;
function gtk_orientable_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_orientable_get_type
end function

!  void gtk_orientable_set_orientation (GtkOrientable *orientable, GtkOrientation orientation);
subroutine gtk_orientable_set_orientation(orientable, orientation) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: orientable
  integer(c_int), value :: orientation
end subroutine

! GtkOrientation gtk_orientable_get_orientation (GtkOrientable *orientable);
function gtk_orientable_get_orientation(orientable) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_orientable_get_orientation
  type(c_ptr), value :: orientable
end function

!   GType gtk_tool_shell_get_type (void) G_GNUC_CONST;
function gtk_tool_shell_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tool_shell_get_type
end function

!  GtkIconSize gtk_tool_shell_get_icon_size (GtkToolShell *shell);
function gtk_tool_shell_get_icon_size(shell) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tool_shell_get_icon_size
  type(c_ptr), value :: shell
end function

! GtkOrientation gtk_tool_shell_get_orientation (GtkToolShell *shell);
function gtk_tool_shell_get_orientation(shell) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tool_shell_get_orientation
  type(c_ptr), value :: shell
end function

! GtkToolbarStyle gtk_tool_shell_get_style (GtkToolShell *shell);
function gtk_tool_shell_get_style(shell) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tool_shell_get_style
  type(c_ptr), value :: shell
end function

! GtkReliefStyle gtk_tool_shell_get_relief_style (GtkToolShell *shell);
function gtk_tool_shell_get_relief_style(shell) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tool_shell_get_relief_style
  type(c_ptr), value :: shell
end function

! void gtk_tool_shell_rebuild_menu (GtkToolShell *shell);
subroutine gtk_tool_shell_rebuild_menu(shell) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: shell
end subroutine

! GtkOrientation gtk_tool_shell_get_text_orientation (GtkToolShell *shell);
function gtk_tool_shell_get_text_orientation(shell) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tool_shell_get_text_orientation
  type(c_ptr), value :: shell
end function

! gfloat gtk_tool_shell_get_text_alignment (GtkToolShell *shell);
function gtk_tool_shell_get_text_alignment(shell) bind(c) 
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: gtk_tool_shell_get_text_alignment
  type(c_ptr), value :: shell
end function

! PangoEllipsizeMode gtk_tool_shell_get_ellipsize_mode (GtkToolShell *shell);
function gtk_tool_shell_get_ellipsize_mode(shell) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tool_shell_get_ellipsize_mode
  type(c_ptr), value :: shell
end function

! GtkSizeGroup * gtk_tool_shell_get_text_size_group (GtkToolShell *shell);
function gtk_tool_shell_get_text_size_group(shell) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tool_shell_get_text_size_group
  type(c_ptr), value :: shell
end function

!   GType gtk_tearoff_menu_item_get_type (void) G_GNUC_CONST;
function gtk_tearoff_menu_item_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tearoff_menu_item_get_type
end function

! GtkWidget* gtk_tearoff_menu_item_new (void);
function gtk_tearoff_menu_item_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tearoff_menu_item_new
end function

!   GType gtk_frame_get_type (void) G_GNUC_CONST;
function gtk_frame_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_frame_get_type
end function

! GtkWidget* gtk_frame_new (const gchar *label);
function gtk_frame_new(label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_frame_new
  character(kind=c_char), dimension(*) :: label
end function

!  void gtk_frame_set_label (GtkFrame *frame, const gchar *label);
subroutine gtk_frame_set_label(frame, label) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: frame
  character(kind=c_char), dimension(*) :: label
end subroutine

! G_CONST_RETURN gchar *gtk_frame_get_label (GtkFrame *frame);
function gtk_frame_get_label(frame) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_frame_get_label
  type(c_ptr), value :: frame
end function

!  void gtk_frame_set_label_widget (GtkFrame *frame, GtkWidget *label_widget);
subroutine gtk_frame_set_label_widget(frame, label_widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: frame
  type(c_ptr), value :: label_widget
end subroutine

! GtkWidget *gtk_frame_get_label_widget (GtkFrame *frame);
function gtk_frame_get_label_widget(frame) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_frame_get_label_widget
  type(c_ptr), value :: frame
end function

! void gtk_frame_set_label_align (GtkFrame *frame, gfloat xalign, gfloat yalign);
subroutine gtk_frame_set_label_align(frame, xalign, yalign) bind(c) 
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: frame
  real(c_float), value :: xalign
  real(c_float), value :: yalign
end subroutine

! void gtk_frame_get_label_align (GtkFrame *frame, gfloat *xalign, gfloat *yalign);
subroutine gtk_frame_get_label_align(frame, xalign, yalign) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: frame
  type(c_ptr), value :: xalign
  type(c_ptr), value :: yalign
end subroutine

! void gtk_frame_set_shadow_type (GtkFrame *frame, GtkShadowType type);
subroutine gtk_frame_set_shadow_type(frame, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: frame
  integer(c_int), value :: type
end subroutine

! GtkShadowType gtk_frame_get_shadow_type (GtkFrame *frame);
function gtk_frame_get_shadow_type(frame) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_frame_get_shadow_type
  type(c_ptr), value :: frame
end function

!   GType gtk_container_get_type (void) G_GNUC_CONST;
function gtk_container_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_container_get_type
end function

! void gtk_container_set_border_width (GtkContainer *container, guint border_width);
subroutine gtk_container_set_border_width(container, border_width) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: container
  integer(c_int), value :: border_width
end subroutine

! guint gtk_container_get_border_width (GtkContainer *container);
function gtk_container_get_border_width(container) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_container_get_border_width
  type(c_ptr), value :: container
end function

! void gtk_container_add (GtkContainer *container, GtkWidget *widget);
subroutine gtk_container_add(container, widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: container
  type(c_ptr), value :: widget
end subroutine

! void gtk_container_remove (GtkContainer *container, GtkWidget *widget);
subroutine gtk_container_remove(container, widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: container
  type(c_ptr), value :: widget
end subroutine

!  void gtk_container_set_resize_mode (GtkContainer *container, GtkResizeMode resize_mode);
subroutine gtk_container_set_resize_mode(container, resize_mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: container
  integer(c_int), value :: resize_mode
end subroutine

! GtkResizeMode gtk_container_get_resize_mode (GtkContainer *container);
function gtk_container_get_resize_mode(container) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_container_get_resize_mode
  type(c_ptr), value :: container
end function

!  void gtk_container_check_resize (GtkContainer *container);
subroutine gtk_container_check_resize(container) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: container
end subroutine

!  void gtk_container_foreach (GtkContainer *container, GtkCallback callback, gpointer callback_data);
subroutine gtk_container_foreach(container, callback, callback_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: container
  type(c_funptr), value :: callback
  type(c_ptr), value :: callback_data
end subroutine

!  void gtk_container_foreach_full (GtkContainer *container, GtkCallback callback, GtkCallbackMarshal marshal, gpointer callback_data, GDestroyNotify notify);
subroutine gtk_container_foreach_full(container, callback, marshal, callback_dat&
      &a, notify) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: container
  type(c_funptr), value :: callback
  type(c_funptr), value :: marshal
  type(c_ptr), value :: callback_data
  type(c_funptr), value :: notify
end subroutine

!  GList* gtk_container_get_children (GtkContainer *container);
function gtk_container_get_children(container) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_container_get_children
  type(c_ptr), value :: container
end function

!  void gtk_container_propagate_expose (GtkContainer *container, GtkWidget *child, GdkEventExpose *event);
subroutine gtk_container_propagate_expose(container, child, event) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: container
  type(c_ptr), value :: child
  type(c_ptr), value :: event
end subroutine

!  void gtk_container_set_focus_chain (GtkContainer *container, GList *focusable_widgets);
subroutine gtk_container_set_focus_chain(container, focusable_widgets) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: container
  type(c_ptr), value :: focusable_widgets
end subroutine

! gboolean gtk_container_get_focus_chain (GtkContainer *container, GList **focusable_widgets);
function gtk_container_get_focus_chain(container, focusable_widgets) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_container_get_focus_chain
  type(c_ptr), value :: container
  type(c_ptr), value :: focusable_widgets
end function

! void gtk_container_unset_focus_chain (GtkContainer *container);
subroutine gtk_container_unset_focus_chain(container) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: container
end subroutine

!  void gtk_container_set_reallocate_redraws (GtkContainer *container, gboolean needs_redraws);
subroutine gtk_container_set_reallocate_redraws(container, needs_redraws) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: container
  logical(c_bool), value :: needs_redraws
end subroutine

! void gtk_container_set_focus_child (GtkContainer *container, GtkWidget *child);
subroutine gtk_container_set_focus_child(container, child) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: container
  type(c_ptr), value :: child
end subroutine

! GtkWidget * gtk_container_get_focus_child (GtkContainer *container);
function gtk_container_get_focus_child(container) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_container_get_focus_child
  type(c_ptr), value :: container
end function

! void gtk_container_set_focus_vadjustment (GtkContainer *container, GtkAdjustment *adjustment);
subroutine gtk_container_set_focus_vadjustment(container, adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: container
  type(c_ptr), value :: adjustment
end subroutine

! GtkAdjustment *gtk_container_get_focus_vadjustment (GtkContainer *container);
function gtk_container_get_focus_vadjustment(container) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_container_get_focus_vadjustment
  type(c_ptr), value :: container
end function

! void gtk_container_set_focus_hadjustment (GtkContainer *container, GtkAdjustment *adjustment);
subroutine gtk_container_set_focus_hadjustment(container, adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: container
  type(c_ptr), value :: adjustment
end subroutine

! GtkAdjustment *gtk_container_get_focus_hadjustment (GtkContainer *container);
function gtk_container_get_focus_hadjustment(container) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_container_get_focus_hadjustment
  type(c_ptr), value :: container
end function

!  void gtk_container_resize_children (GtkContainer *container);
subroutine gtk_container_resize_children(container) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: container
end subroutine

!  GType gtk_container_child_type (GtkContainer *container);
function gtk_container_child_type(container) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: gtk_container_child_type
  type(c_ptr), value :: container
end function

!  void gtk_container_class_install_child_property (GtkContainerClass *cclass, guint property_id, GParamSpec *pspec);
subroutine gtk_container_class_install_child_property(cclass, property_id, pspec&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: cclass
  integer(c_int), value :: property_id
  type(c_ptr), value :: pspec
end subroutine

! GParamSpec* gtk_container_class_find_child_property (GObjectClass *cclass, const gchar *property_name);
function gtk_container_class_find_child_property(cclass, property_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_container_class_find_child_property
  type(c_ptr), value :: cclass
  character(kind=c_char), dimension(*) :: property_name
end function

! GParamSpec** gtk_container_class_list_child_properties (GObjectClass *cclass, guint *n_properties);
function gtk_container_class_list_child_properties(cclass, n_properties) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_container_class_list_child_properties
  type(c_ptr), value :: cclass
  type(c_ptr), value :: n_properties
end function

! void gtk_container_child_set_valist (GtkContainer *container, GtkWidget *child, const gchar *first_property_name, va_list var_args);
subroutine gtk_container_child_set_valist(container, child, first_property_name,&
      & var_args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: container
  type(c_ptr), value :: child
  character(kind=c_char), dimension(*) :: first_property_name
  type(c_ptr), value :: var_args
end subroutine

! void gtk_container_child_get_valist (GtkContainer *container, GtkWidget *child, const gchar *first_property_name, va_list var_args);
subroutine gtk_container_child_get_valist(container, child, first_property_name,&
      & var_args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: container
  type(c_ptr), value :: child
  character(kind=c_char), dimension(*) :: first_property_name
  type(c_ptr), value :: var_args
end subroutine

! void gtk_container_child_set_property (GtkContainer *container, GtkWidget *child, const gchar *property_name, const GValue *value);
subroutine gtk_container_child_set_property(container, child, property_name, val&
      &ue) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: container
  type(c_ptr), value :: child
  character(kind=c_char), dimension(*) :: property_name
  type(c_ptr), value :: value
end subroutine

! void gtk_container_child_get_property (GtkContainer *container, GtkWidget *child, const gchar *property_name, GValue *value);
subroutine gtk_container_child_get_property(container, child, property_name, val&
      &ue) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: container
  type(c_ptr), value :: child
  character(kind=c_char), dimension(*) :: property_name
  type(c_ptr), value :: value
end subroutine

!  void gtk_container_forall (GtkContainer *container, GtkCallback callback, gpointer callback_data);
subroutine gtk_container_forall(container, callback, callback_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: container
  type(c_funptr), value :: callback
  type(c_ptr), value :: callback_data
end subroutine

!  void hildon_gtk_file_chooser_install_properties (GObjectClass *klass);
subroutine hildon_gtk_file_chooser_install_properties(klass) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: klass
end subroutine

!   GType gtk_toggle_action_get_type (void) G_GNUC_CONST;
function gtk_toggle_action_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_toggle_action_get_type
end function

! GtkToggleAction *gtk_toggle_action_new (const gchar *name, const gchar *label, const gchar *tooltip, const gchar *stock_id);
function gtk_toggle_action_new(name, label, tooltip, stock_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_toggle_action_new
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: label
  character(kind=c_char), dimension(*) :: tooltip
  character(kind=c_char), dimension(*) :: stock_id
end function

! void gtk_toggle_action_toggled (GtkToggleAction *action);
subroutine gtk_toggle_action_toggled(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: action
end subroutine

! void gtk_toggle_action_set_active (GtkToggleAction *action, gboolean is_active);
subroutine gtk_toggle_action_set_active(action, is_active) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: action
  logical(c_bool), value :: is_active
end subroutine

! gboolean gtk_toggle_action_get_active (GtkToggleAction *action);
function gtk_toggle_action_get_active(action) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_toggle_action_get_active
  type(c_ptr), value :: action
end function

! void gtk_toggle_action_set_draw_as_radio (GtkToggleAction *action, gboolean draw_as_radio);
subroutine gtk_toggle_action_set_draw_as_radio(action, draw_as_radio) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: action
  logical(c_bool), value :: draw_as_radio
end subroutine

! gboolean gtk_toggle_action_get_draw_as_radio (GtkToggleAction *action);
function gtk_toggle_action_get_draw_as_radio(action) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_toggle_action_get_draw_as_radio
  type(c_ptr), value :: action
end function

!   GType gtk_hscrollbar_get_type (void) G_GNUC_CONST;
function gtk_hscrollbar_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_hscrollbar_get_type
end function

! GtkWidget* gtk_hscrollbar_new (GtkAdjustment *adjustment);
function gtk_hscrollbar_new(adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_hscrollbar_new
  type(c_ptr), value :: adjustment
end function

!   GType gtk_hruler_get_type (void) G_GNUC_CONST;
function gtk_hruler_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_hruler_get_type
end function

! GtkWidget* gtk_hruler_new (void);
function gtk_hruler_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_hruler_new
end function

!   GType gtk_tooltip_get_type (void);
function gtk_tooltip_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tooltip_get_type
end function

!  void gtk_tooltip_set_markup (GtkTooltip *tooltip, const gchar *markup);
subroutine gtk_tooltip_set_markup(tooltip, markup) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: tooltip
  character(kind=c_char), dimension(*) :: markup
end subroutine

! void gtk_tooltip_set_text (GtkTooltip *tooltip, const gchar *text);
subroutine gtk_tooltip_set_text(tooltip, text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: tooltip
  character(kind=c_char), dimension(*) :: text
end subroutine

! void gtk_tooltip_set_icon (GtkTooltip *tooltip, GdkPixbuf *pixbuf);
subroutine gtk_tooltip_set_icon(tooltip, pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tooltip
  type(c_ptr), value :: pixbuf
end subroutine

! void gtk_tooltip_set_icon_from_stock (GtkTooltip *tooltip, const gchar *stock_id, GtkIconSize size);
subroutine gtk_tooltip_set_icon_from_stock(tooltip, stock_id, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: tooltip
  character(kind=c_char), dimension(*) :: stock_id
  integer(c_int), value :: size
end subroutine

! void gtk_tooltip_set_icon_from_icon_name (GtkTooltip *tooltip, const gchar *icon_name, GtkIconSize size);
subroutine gtk_tooltip_set_icon_from_icon_name(tooltip, icon_name, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: tooltip
  character(kind=c_char), dimension(*) :: icon_name
  integer(c_int), value :: size
end subroutine

! void gtk_tooltip_set_icon_from_gicon (GtkTooltip *tooltip, GIcon *gicon, GtkIconSize size);
subroutine gtk_tooltip_set_icon_from_gicon(tooltip, gicon, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tooltip
  type(c_ptr), value :: gicon
  integer(c_int), value :: size
end subroutine

! void gtk_tooltip_set_custom (GtkTooltip *tooltip, GtkWidget *custom_widget);
subroutine gtk_tooltip_set_custom(tooltip, custom_widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tooltip
  type(c_ptr), value :: custom_widget
end subroutine

!  void gtk_tooltip_set_tip_area (GtkTooltip *tooltip, const GdkRectangle *rect);
subroutine gtk_tooltip_set_tip_area(tooltip, rect) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tooltip
  type(c_ptr), value :: rect
end subroutine

!  void gtk_tooltip_trigger_tooltip_query (GdkDisplay *display);
subroutine gtk_tooltip_trigger_tooltip_query(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: display
end subroutine

!   GType gtk_recent_chooser_dialog_get_type (void) G_GNUC_CONST;
function gtk_recent_chooser_dialog_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_recent_chooser_dialog_get_type
end function

!   GType gtk_item_factory_get_type (void) G_GNUC_CONST;
function gtk_item_factory_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_item_factory_get_type
end function

!  GtkItemFactory* gtk_item_factory_new (GType container_type, const gchar *path, GtkAccelGroup *accel_group);
function gtk_item_factory_new(container_type, path, accel_group) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr) :: gtk_item_factory_new
  integer(c_size_t), value :: container_type
  character(kind=c_char), dimension(*) :: path
  type(c_ptr), value :: accel_group
end function

! void gtk_item_factory_construct (GtkItemFactory *ifactory, GType container_type, const gchar *path, GtkAccelGroup *accel_group);
subroutine gtk_item_factory_construct(ifactory, container_type, path, accel_grou&
      &p) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr), value :: ifactory
  integer(c_size_t), value :: container_type
  character(kind=c_char), dimension(*) :: path
  type(c_ptr), value :: accel_group
end subroutine

!   void gtk_item_factory_add_foreign (GtkWidget *accel_widget, const gchar *full_path, GtkAccelGroup *accel_group, guint keyval, GdkModifierType modifiers);
subroutine gtk_item_factory_add_foreign(accel_widget, full_path, accel_group, ke&
      &yval, modifiers) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: accel_widget
  character(kind=c_char), dimension(*) :: full_path
  type(c_ptr), value :: accel_group
  integer(c_int), value :: keyval
  integer(c_int), value :: modifiers
end subroutine

!  GtkItemFactory* gtk_item_factory_from_widget (GtkWidget *widget);
function gtk_item_factory_from_widget(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_item_factory_from_widget
  type(c_ptr), value :: widget
end function

! G_CONST_RETURN gchar* gtk_item_factory_path_from_widget (GtkWidget *widget);
function gtk_item_factory_path_from_widget(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_item_factory_path_from_widget
  type(c_ptr), value :: widget
end function

!  GtkWidget* gtk_item_factory_get_item (GtkItemFactory *ifactory, const gchar *path);
function gtk_item_factory_get_item(ifactory, path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_item_factory_get_item
  type(c_ptr), value :: ifactory
  character(kind=c_char), dimension(*) :: path
end function

! GtkWidget* gtk_item_factory_get_widget (GtkItemFactory *ifactory, const gchar *path);
function gtk_item_factory_get_widget(ifactory, path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_item_factory_get_widget
  type(c_ptr), value :: ifactory
  character(kind=c_char), dimension(*) :: path
end function

! GtkWidget* gtk_item_factory_get_widget_by_action (GtkItemFactory *ifactory, guint action);
function gtk_item_factory_get_widget_by_action(ifactory, action) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_item_factory_get_widget_by_action
  type(c_ptr), value :: ifactory
  integer(c_int), value :: action
end function

! GtkWidget* gtk_item_factory_get_item_by_action (GtkItemFactory *ifactory, guint action);
function gtk_item_factory_get_item_by_action(ifactory, action) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_item_factory_get_item_by_action
  type(c_ptr), value :: ifactory
  integer(c_int), value :: action
end function

!  void gtk_item_factory_create_item (GtkItemFactory *ifactory, GtkItemFactoryEntry *entry, gpointer callback_data, guint callback_type);
subroutine gtk_item_factory_create_item(ifactory, entry, callback_data, callback&
      &_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: ifactory
  type(c_ptr), value :: entry
  type(c_ptr), value :: callback_data
  integer(c_int), value :: callback_type
end subroutine

! void gtk_item_factory_create_items (GtkItemFactory *ifactory, guint n_entries, GtkItemFactoryEntry *entries, gpointer callback_data);
subroutine gtk_item_factory_create_items(ifactory, n_entries, entries, callback_&
      &data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: ifactory
  integer(c_int), value :: n_entries
  type(c_ptr), value :: entries
  type(c_ptr), value :: callback_data
end subroutine

! void gtk_item_factory_delete_item (GtkItemFactory *ifactory, const gchar *path);
subroutine gtk_item_factory_delete_item(ifactory, path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: ifactory
  character(kind=c_char), dimension(*) :: path
end subroutine

! void gtk_item_factory_delete_entry (GtkItemFactory *ifactory, GtkItemFactoryEntry *entry);
subroutine gtk_item_factory_delete_entry(ifactory, entry) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ifactory
  type(c_ptr), value :: entry
end subroutine

! void gtk_item_factory_delete_entries (GtkItemFactory *ifactory, guint n_entries, GtkItemFactoryEntry *entries);
subroutine gtk_item_factory_delete_entries(ifactory, n_entries, entries) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: ifactory
  integer(c_int), value :: n_entries
  type(c_ptr), value :: entries
end subroutine

! void gtk_item_factory_popup (GtkItemFactory *ifactory, guint x, guint y, guint mouse_button, guint32 time_);
subroutine gtk_item_factory_popup(ifactory, x, y, mouse_button, time_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int32_t
  type(c_ptr), value :: ifactory
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: mouse_button
  integer(c_int32_t), value :: time_
end subroutine

! void gtk_item_factory_popup_with_data(GtkItemFactory *ifactory, gpointer popup_data, GDestroyNotify destroy, guint x, guint y, guint mouse_button, guint32 time_);
subroutine gtk_item_factory_popup_with_data(ifactory, popup_data, destroy, x, y,&
      & mouse_button, time_) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr, c_int, c_int32_t
  type(c_ptr), value :: ifactory
  type(c_ptr), value :: popup_data
  type(c_funptr), value :: destroy
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: mouse_button
  integer(c_int32_t), value :: time_
end subroutine

! gpointer gtk_item_factory_popup_data (GtkItemFactory *ifactory);
function gtk_item_factory_popup_data(ifactory) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_item_factory_popup_data
  type(c_ptr), value :: ifactory
end function

! gpointer gtk_item_factory_popup_data_from_widget (GtkWidget *widget);
function gtk_item_factory_popup_data_from_widget(widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_item_factory_popup_data_from_widget
  type(c_ptr), value :: widget
end function

! void gtk_item_factory_set_translate_func (GtkItemFactory *ifactory, GtkTranslateFunc func, gpointer data, GDestroyNotify notify);
subroutine gtk_item_factory_set_translate_func(ifactory, func, data, notify) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: ifactory
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end subroutine

!  void gtk_item_factory_create_items_ac (GtkItemFactory *ifactory, guint n_entries, GtkItemFactoryEntry *entries, gpointer callback_data, guint callback_type);
subroutine gtk_item_factory_create_items_ac(ifactory, n_entries, entries, callba&
      &ck_data, callback_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: ifactory
  integer(c_int), value :: n_entries
  type(c_ptr), value :: entries
  type(c_ptr), value :: callback_data
  integer(c_int), value :: callback_type
end subroutine

!  GtkItemFactory* gtk_item_factory_from_path (const gchar *path);
function gtk_item_factory_from_path(path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_item_factory_from_path
  character(kind=c_char), dimension(*) :: path
end function

! void gtk_item_factory_create_menu_entries (guint n_entries, GtkMenuEntry *entries);
subroutine gtk_item_factory_create_menu_entries(n_entries, entries) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int), value :: n_entries
  type(c_ptr), value :: entries
end subroutine

! void gtk_item_factories_path_delete (const gchar *ifactory_path, const gchar *path);
subroutine gtk_item_factories_path_delete(ifactory_path, path) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: ifactory_path
  character(kind=c_char), dimension(*) :: path
end subroutine

!   GType gtk_tips_query_get_type (void) G_GNUC_CONST;
function gtk_tips_query_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tips_query_get_type
end function

! GtkWidget* gtk_tips_query_new (void);
function gtk_tips_query_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tips_query_new
end function

! void gtk_tips_query_start_query (GtkTipsQuery *tips_query);
subroutine gtk_tips_query_start_query(tips_query) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tips_query
end subroutine

! void gtk_tips_query_stop_query (GtkTipsQuery *tips_query);
subroutine gtk_tips_query_stop_query(tips_query) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tips_query
end subroutine

! void gtk_tips_query_set_caller (GtkTipsQuery *tips_query, GtkWidget *caller);
subroutine gtk_tips_query_set_caller(tips_query, caller) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tips_query
  type(c_ptr), value :: caller
end subroutine

! void gtk_tips_query_set_labels (GtkTipsQuery *tips_query, const gchar *label_inactive, const gchar *label_no_tip);
subroutine gtk_tips_query_set_labels(tips_query, label_inactive, label_no_tip) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: tips_query
  character(kind=c_char), dimension(*) :: label_inactive
  character(kind=c_char), dimension(*) :: label_no_tip
end subroutine

!   GType gtk_progress_get_type (void) G_GNUC_CONST;
function gtk_progress_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_progress_get_type
end function

! void gtk_progress_set_show_text (GtkProgress *progress, gboolean show_text);
subroutine gtk_progress_set_show_text(progress, show_text) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: progress
  logical(c_bool), value :: show_text
end subroutine

! void gtk_progress_set_text_alignment (GtkProgress *progress, gfloat x_align, gfloat y_align);
subroutine gtk_progress_set_text_alignment(progress, x_align, y_align) bind(c) 
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: progress
  real(c_float), value :: x_align
  real(c_float), value :: y_align
end subroutine

! void gtk_progress_set_format_string (GtkProgress *progress, const gchar *format);
subroutine gtk_progress_set_format_string(progress, format) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: progress
  character(kind=c_char), dimension(*) :: format
end subroutine

! void gtk_progress_set_adjustment (GtkProgress *progress, GtkAdjustment *adjustment);
subroutine gtk_progress_set_adjustment(progress, adjustment) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: progress
  type(c_ptr), value :: adjustment
end subroutine

! void gtk_progress_configure (GtkProgress *progress, gdouble value, gdouble min, gdouble max);
subroutine gtk_progress_configure(progress, value, min, max) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: progress
  real(c_double), value :: value
  real(c_double), value :: min
  real(c_double), value :: max
end subroutine

! void gtk_progress_set_percentage (GtkProgress *progress, gdouble percentage);
subroutine gtk_progress_set_percentage(progress, percentage) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: progress
  real(c_double), value :: percentage
end subroutine

! void gtk_progress_set_value (GtkProgress *progress, gdouble value);
subroutine gtk_progress_set_value(progress, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: progress
  real(c_double), value :: value
end subroutine

! gdouble gtk_progress_get_value (GtkProgress *progress);
function gtk_progress_get_value(progress) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_progress_get_value
  type(c_ptr), value :: progress
end function

! void gtk_progress_set_activity_mode (GtkProgress *progress, gboolean activity_mode);
subroutine gtk_progress_set_activity_mode(progress, activity_mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: progress
  logical(c_bool), value :: activity_mode
end subroutine

! gchar* gtk_progress_get_current_text (GtkProgress *progress);
function gtk_progress_get_current_text(progress) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_progress_get_current_text
  type(c_ptr), value :: progress
end function

! gchar* gtk_progress_get_text_from_value (GtkProgress *progress, gdouble value);
function gtk_progress_get_text_from_value(progress, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr) :: gtk_progress_get_text_from_value
  type(c_ptr), value :: progress
  real(c_double), value :: value
end function

! gdouble gtk_progress_get_current_percentage (GtkProgress *progress);
function gtk_progress_get_current_percentage(progress) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_progress_get_current_percentage
  type(c_ptr), value :: progress
end function

! gdouble gtk_progress_get_percentage_from_value (GtkProgress *progress, gdouble value);
function gtk_progress_get_percentage_from_value(progress, value) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_progress_get_percentage_from_value
  type(c_ptr), value :: progress
  real(c_double), value :: value
end function

!   GType gtk_recent_chooser_menu_get_type (void) G_GNUC_CONST;
function gtk_recent_chooser_menu_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_recent_chooser_menu_get_type
end function

!  GtkWidget *gtk_recent_chooser_menu_new (void);
function gtk_recent_chooser_menu_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_chooser_menu_new
end function

! GtkWidget *gtk_recent_chooser_menu_new_for_manager (GtkRecentManager *manager);
function gtk_recent_chooser_menu_new_for_manager(manager) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_chooser_menu_new_for_manager
  type(c_ptr), value :: manager
end function

!  gboolean gtk_recent_chooser_menu_get_show_numbers (GtkRecentChooserMenu *menu);
function gtk_recent_chooser_menu_get_show_numbers(menu) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_recent_chooser_menu_get_show_numbers
  type(c_ptr), value :: menu
end function

! void gtk_recent_chooser_menu_set_show_numbers (GtkRecentChooserMenu *menu, gboolean show_numbers);
subroutine gtk_recent_chooser_menu_set_show_numbers(menu, show_numbers) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: menu
  logical(c_bool), value :: show_numbers
end subroutine

!   GType gtk_buildable_get_type (void) G_GNUC_CONST;
function gtk_buildable_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_buildable_get_type
end function

!  void gtk_buildable_set_name (GtkBuildable *buildable, const gchar *name);
subroutine gtk_buildable_set_name(buildable, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: buildable
  character(kind=c_char), dimension(*) :: name
end subroutine

! const gchar * gtk_buildable_get_name (GtkBuildable *buildable);
function gtk_buildable_get_name(buildable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_buildable_get_name
  type(c_ptr), value :: buildable
end function

! void gtk_buildable_add_child (GtkBuildable *buildable, GtkBuilder *builder, GObject *child, const gchar *type);
subroutine gtk_buildable_add_child(buildable, builder, child, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: buildable
  type(c_ptr), value :: builder
  type(c_ptr), value :: child
  character(kind=c_char), dimension(*) :: type
end subroutine

! void gtk_buildable_set_buildable_property (GtkBuildable *buildable, GtkBuilder *builder, const gchar *name, const GValue *value);
subroutine gtk_buildable_set_buildable_property(buildable, builder, name, value)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: buildable
  type(c_ptr), value :: builder
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: value
end subroutine

! GObject * gtk_buildable_construct_child (GtkBuildable *buildable, GtkBuilder *builder, const gchar *name);
function gtk_buildable_construct_child(buildable, builder, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_buildable_construct_child
  type(c_ptr), value :: buildable
  type(c_ptr), value :: builder
  character(kind=c_char), dimension(*) :: name
end function

! gboolean gtk_buildable_custom_tag_start (GtkBuildable *buildable, GtkBuilder *builder, GObject *child, const gchar *tagname, GMarkupParser *parser, gpointer *data);
function gtk_buildable_custom_tag_start(buildable, builder, child, tagname, pars&
      &er, data) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_buildable_custom_tag_start
  type(c_ptr), value :: buildable
  type(c_ptr), value :: builder
  type(c_ptr), value :: child
  character(kind=c_char), dimension(*) :: tagname
  type(c_ptr), value :: parser
  type(c_ptr), value :: data
end function

! void gtk_buildable_custom_tag_end (GtkBuildable *buildable, GtkBuilder *builder, GObject *child, const gchar *tagname, gpointer *data);
subroutine gtk_buildable_custom_tag_end(buildable, builder, child, tagname, data&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: buildable
  type(c_ptr), value :: builder
  type(c_ptr), value :: child
  character(kind=c_char), dimension(*) :: tagname
  type(c_ptr), value :: data
end subroutine

! void gtk_buildable_custom_finished (GtkBuildable *buildable, GtkBuilder *builder, GObject *child, const gchar *tagname, gpointer data);
subroutine gtk_buildable_custom_finished(buildable, builder, child, tagname, dat&
      &a) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: buildable
  type(c_ptr), value :: builder
  type(c_ptr), value :: child
  character(kind=c_char), dimension(*) :: tagname
  type(c_ptr), value :: data
end subroutine

! void gtk_buildable_parser_finished (GtkBuildable *buildable, GtkBuilder *builder);
subroutine gtk_buildable_parser_finished(buildable, builder) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buildable
  type(c_ptr), value :: builder
end subroutine

! GObject * gtk_buildable_get_internal_child (GtkBuildable *buildable, GtkBuilder *builder, const gchar *childname);
function gtk_buildable_get_internal_child(buildable, builder, childname) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_buildable_get_internal_child
  type(c_ptr), value :: buildable
  type(c_ptr), value :: builder
  character(kind=c_char), dimension(*) :: childname
end function

!   GQuark gtk_recent_chooser_error_quark (void);
function gtk_recent_chooser_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: gtk_recent_chooser_error_quark
end function

!  GType gtk_recent_chooser_get_type (void) G_GNUC_CONST;
function gtk_recent_chooser_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_recent_chooser_get_type
end function

!  void gtk_recent_chooser_set_show_private (GtkRecentChooser *chooser, gboolean show_private);
subroutine gtk_recent_chooser_set_show_private(chooser, show_private) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: chooser
  logical(c_bool), value :: show_private
end subroutine

! gboolean gtk_recent_chooser_get_show_private (GtkRecentChooser *chooser);
function gtk_recent_chooser_get_show_private(chooser) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_recent_chooser_get_show_private
  type(c_ptr), value :: chooser
end function

! void gtk_recent_chooser_set_show_not_found (GtkRecentChooser *chooser, gboolean show_not_found);
subroutine gtk_recent_chooser_set_show_not_found(chooser, show_not_found) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: chooser
  logical(c_bool), value :: show_not_found
end subroutine

! gboolean gtk_recent_chooser_get_show_not_found (GtkRecentChooser *chooser);
function gtk_recent_chooser_get_show_not_found(chooser) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_recent_chooser_get_show_not_found
  type(c_ptr), value :: chooser
end function

! void gtk_recent_chooser_set_select_multiple (GtkRecentChooser *chooser, gboolean select_multiple);
subroutine gtk_recent_chooser_set_select_multiple(chooser, select_multiple) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: chooser
  logical(c_bool), value :: select_multiple
end subroutine

! gboolean gtk_recent_chooser_get_select_multiple (GtkRecentChooser *chooser);
function gtk_recent_chooser_get_select_multiple(chooser) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_recent_chooser_get_select_multiple
  type(c_ptr), value :: chooser
end function

! void gtk_recent_chooser_set_limit (GtkRecentChooser *chooser, gint limit);
subroutine gtk_recent_chooser_set_limit(chooser, limit) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: chooser
  integer(c_int), value :: limit
end subroutine

! gint gtk_recent_chooser_get_limit (GtkRecentChooser *chooser);
function gtk_recent_chooser_get_limit(chooser) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_recent_chooser_get_limit
  type(c_ptr), value :: chooser
end function

! void gtk_recent_chooser_set_local_only (GtkRecentChooser *chooser, gboolean local_only);
subroutine gtk_recent_chooser_set_local_only(chooser, local_only) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: chooser
  logical(c_bool), value :: local_only
end subroutine

! gboolean gtk_recent_chooser_get_local_only (GtkRecentChooser *chooser);
function gtk_recent_chooser_get_local_only(chooser) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_recent_chooser_get_local_only
  type(c_ptr), value :: chooser
end function

! void gtk_recent_chooser_set_show_tips (GtkRecentChooser *chooser, gboolean show_tips);
subroutine gtk_recent_chooser_set_show_tips(chooser, show_tips) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: chooser
  logical(c_bool), value :: show_tips
end subroutine

! gboolean gtk_recent_chooser_get_show_tips (GtkRecentChooser *chooser);
function gtk_recent_chooser_get_show_tips(chooser) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_recent_chooser_get_show_tips
  type(c_ptr), value :: chooser
end function

!  void gtk_recent_chooser_set_show_numbers (GtkRecentChooser *chooser, gboolean show_numbers);
subroutine gtk_recent_chooser_set_show_numbers(chooser, show_numbers) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: chooser
  logical(c_bool), value :: show_numbers
end subroutine

! gboolean gtk_recent_chooser_get_show_numbers (GtkRecentChooser *chooser);
function gtk_recent_chooser_get_show_numbers(chooser) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_recent_chooser_get_show_numbers
  type(c_ptr), value :: chooser
end function

!  void gtk_recent_chooser_set_show_icons (GtkRecentChooser *chooser, gboolean show_icons);
subroutine gtk_recent_chooser_set_show_icons(chooser, show_icons) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: chooser
  logical(c_bool), value :: show_icons
end subroutine

! gboolean gtk_recent_chooser_get_show_icons (GtkRecentChooser *chooser);
function gtk_recent_chooser_get_show_icons(chooser) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_recent_chooser_get_show_icons
  type(c_ptr), value :: chooser
end function

! void gtk_recent_chooser_set_sort_type (GtkRecentChooser *chooser, GtkRecentSortType sort_type);
subroutine gtk_recent_chooser_set_sort_type(chooser, sort_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: chooser
  integer(c_int), value :: sort_type
end subroutine

! GtkRecentSortType gtk_recent_chooser_get_sort_type (GtkRecentChooser *chooser);
function gtk_recent_chooser_get_sort_type(chooser) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_recent_chooser_get_sort_type
  type(c_ptr), value :: chooser
end function

! void gtk_recent_chooser_set_sort_func (GtkRecentChooser *chooser, GtkRecentSortFunc sort_func, gpointer sort_data, GDestroyNotify data_destroy);
subroutine gtk_recent_chooser_set_sort_func(chooser, sort_func, sort_data, data_&
      &destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: chooser
  type(c_funptr), value :: sort_func
  type(c_ptr), value :: sort_data
  type(c_funptr), value :: data_destroy
end subroutine

!  gboolean gtk_recent_chooser_set_current_uri (GtkRecentChooser *chooser, const gchar *uri, GError **error);
function gtk_recent_chooser_set_current_uri(chooser, uri, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_recent_chooser_set_current_uri
  type(c_ptr), value :: chooser
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! gchar * gtk_recent_chooser_get_current_uri (GtkRecentChooser *chooser);
function gtk_recent_chooser_get_current_uri(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_chooser_get_current_uri
  type(c_ptr), value :: chooser
end function

! GtkRecentInfo *gtk_recent_chooser_get_current_item (GtkRecentChooser *chooser);
function gtk_recent_chooser_get_current_item(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_chooser_get_current_item
  type(c_ptr), value :: chooser
end function

! gboolean gtk_recent_chooser_select_uri (GtkRecentChooser *chooser, const gchar *uri, GError **error);
function gtk_recent_chooser_select_uri(chooser, uri, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_recent_chooser_select_uri
  type(c_ptr), value :: chooser
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! void gtk_recent_chooser_unselect_uri (GtkRecentChooser *chooser, const gchar *uri);
subroutine gtk_recent_chooser_unselect_uri(chooser, uri) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: chooser
  character(kind=c_char), dimension(*) :: uri
end subroutine

! void gtk_recent_chooser_select_all (GtkRecentChooser *chooser);
subroutine gtk_recent_chooser_select_all(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: chooser
end subroutine

! void gtk_recent_chooser_unselect_all (GtkRecentChooser *chooser);
subroutine gtk_recent_chooser_unselect_all(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: chooser
end subroutine

! GList * gtk_recent_chooser_get_items (GtkRecentChooser *chooser);
function gtk_recent_chooser_get_items(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_chooser_get_items
  type(c_ptr), value :: chooser
end function

! gchar ** gtk_recent_chooser_get_uris (GtkRecentChooser *chooser, gsize *length);
function gtk_recent_chooser_get_uris(chooser, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_chooser_get_uris
  type(c_ptr), value :: chooser
  type(c_ptr), value :: length
end function

!  void gtk_recent_chooser_add_filter (GtkRecentChooser *chooser, GtkRecentFilter *filter);
subroutine gtk_recent_chooser_add_filter(chooser, filter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: chooser
  type(c_ptr), value :: filter
end subroutine

! void gtk_recent_chooser_remove_filter (GtkRecentChooser *chooser, GtkRecentFilter *filter);
subroutine gtk_recent_chooser_remove_filter(chooser, filter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: chooser
  type(c_ptr), value :: filter
end subroutine

! GSList * gtk_recent_chooser_list_filters (GtkRecentChooser *chooser);
function gtk_recent_chooser_list_filters(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_chooser_list_filters
  type(c_ptr), value :: chooser
end function

! void gtk_recent_chooser_set_filter (GtkRecentChooser *chooser, GtkRecentFilter *filter);
subroutine gtk_recent_chooser_set_filter(chooser, filter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: chooser
  type(c_ptr), value :: filter
end subroutine

! GtkRecentFilter *gtk_recent_chooser_get_filter (GtkRecentChooser *chooser);
function gtk_recent_chooser_get_filter(chooser) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_chooser_get_filter
  type(c_ptr), value :: chooser
end function

!   GType gtk_label_get_type (void) G_GNUC_CONST;
function gtk_label_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_label_get_type
end function

! GtkWidget* gtk_label_new (const gchar *str);
function gtk_label_new(str) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_label_new
  character(kind=c_char), dimension(*) :: str
end function

! GtkWidget* gtk_label_new_with_mnemonic (const gchar *str);
function gtk_label_new_with_mnemonic(str) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gtk_label_new_with_mnemonic
  character(kind=c_char), dimension(*) :: str
end function

! void gtk_label_set_text (GtkLabel *label, const gchar *str);
subroutine gtk_label_set_text(label, str) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: label
  character(kind=c_char), dimension(*) :: str
end subroutine

! G_CONST_RETURN gchar* gtk_label_get_text (GtkLabel *label);
function gtk_label_get_text(label) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_label_get_text
  type(c_ptr), value :: label
end function

! void gtk_label_set_attributes (GtkLabel *label, PangoAttrList *attrs);
subroutine gtk_label_set_attributes(label, attrs) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: label
  type(c_ptr), value :: attrs
end subroutine

! PangoAttrList *gtk_label_get_attributes (GtkLabel *label);
function gtk_label_get_attributes(label) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_label_get_attributes
  type(c_ptr), value :: label
end function

! void gtk_label_set_label (GtkLabel *label, const gchar *str);
subroutine gtk_label_set_label(label, str) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: label
  character(kind=c_char), dimension(*) :: str
end subroutine

! G_CONST_RETURN gchar *gtk_label_get_label (GtkLabel *label);
function gtk_label_get_label(label) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_label_get_label
  type(c_ptr), value :: label
end function

! void gtk_label_set_markup (GtkLabel *label, const gchar *str);
subroutine gtk_label_set_markup(label, str) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: label
  character(kind=c_char), dimension(*) :: str
end subroutine

! void gtk_label_set_use_markup (GtkLabel *label, gboolean setting);
subroutine gtk_label_set_use_markup(label, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: label
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_label_get_use_markup (GtkLabel *label);
function gtk_label_get_use_markup(label) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_label_get_use_markup
  type(c_ptr), value :: label
end function

! void gtk_label_set_use_underline (GtkLabel *label, gboolean setting);
subroutine gtk_label_set_use_underline(label, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: label
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_label_get_use_underline (GtkLabel *label);
function gtk_label_get_use_underline(label) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_label_get_use_underline
  type(c_ptr), value :: label
end function

!  void gtk_label_set_markup_with_mnemonic (GtkLabel *label, const gchar *str);
subroutine gtk_label_set_markup_with_mnemonic(label, str) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: label
  character(kind=c_char), dimension(*) :: str
end subroutine

! guint gtk_label_get_mnemonic_keyval (GtkLabel *label);
function gtk_label_get_mnemonic_keyval(label) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_label_get_mnemonic_keyval
  type(c_ptr), value :: label
end function

! void gtk_label_set_mnemonic_widget (GtkLabel *label, GtkWidget *widget);
subroutine gtk_label_set_mnemonic_widget(label, widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: label
  type(c_ptr), value :: widget
end subroutine

! GtkWidget *gtk_label_get_mnemonic_widget (GtkLabel *label);
function gtk_label_get_mnemonic_widget(label) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_label_get_mnemonic_widget
  type(c_ptr), value :: label
end function

! void gtk_label_set_text_with_mnemonic (GtkLabel *label, const gchar *str);
subroutine gtk_label_set_text_with_mnemonic(label, str) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: label
  character(kind=c_char), dimension(*) :: str
end subroutine

! void gtk_label_set_justify (GtkLabel *label, GtkJustification jtype);
subroutine gtk_label_set_justify(label, jtype) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: label
  integer(c_int), value :: jtype
end subroutine

! GtkJustification gtk_label_get_justify (GtkLabel *label);
function gtk_label_get_justify(label) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_label_get_justify
  type(c_ptr), value :: label
end function

! void gtk_label_set_ellipsize (GtkLabel *label, PangoEllipsizeMode mode);
subroutine gtk_label_set_ellipsize(label, mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: label
  integer(c_int), value :: mode
end subroutine

! PangoEllipsizeMode gtk_label_get_ellipsize (GtkLabel *label);
function gtk_label_get_ellipsize(label) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_label_get_ellipsize
  type(c_ptr), value :: label
end function

! void gtk_label_set_width_chars (GtkLabel *label, gint n_chars);
subroutine gtk_label_set_width_chars(label, n_chars) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: label
  integer(c_int), value :: n_chars
end subroutine

! gint gtk_label_get_width_chars (GtkLabel *label);
function gtk_label_get_width_chars(label) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_label_get_width_chars
  type(c_ptr), value :: label
end function

! void gtk_label_set_max_width_chars (GtkLabel *label, gint n_chars);
subroutine gtk_label_set_max_width_chars(label, n_chars) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: label
  integer(c_int), value :: n_chars
end subroutine

! gint gtk_label_get_max_width_chars (GtkLabel *label);
function gtk_label_get_max_width_chars(label) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_label_get_max_width_chars
  type(c_ptr), value :: label
end function

! void gtk_label_set_pattern (GtkLabel *label, const gchar *pattern);
subroutine gtk_label_set_pattern(label, pattern) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: label
  character(kind=c_char), dimension(*) :: pattern
end subroutine

! void gtk_label_set_line_wrap (GtkLabel *label, gboolean wrap);
subroutine gtk_label_set_line_wrap(label, wrap) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: label
  logical(c_bool), value :: wrap
end subroutine

! gboolean gtk_label_get_line_wrap (GtkLabel *label);
function gtk_label_get_line_wrap(label) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_label_get_line_wrap
  type(c_ptr), value :: label
end function

! void gtk_label_set_line_wrap_mode (GtkLabel *label, PangoWrapMode wrap_mode);
subroutine gtk_label_set_line_wrap_mode(label, wrap_mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: label
  integer(c_int), value :: wrap_mode
end subroutine

! PangoWrapMode gtk_label_get_line_wrap_mode (GtkLabel *label);
function gtk_label_get_line_wrap_mode(label) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_label_get_line_wrap_mode
  type(c_ptr), value :: label
end function

! void gtk_label_set_selectable (GtkLabel *label, gboolean setting);
subroutine gtk_label_set_selectable(label, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: label
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_label_get_selectable (GtkLabel *label);
function gtk_label_get_selectable(label) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_label_get_selectable
  type(c_ptr), value :: label
end function

! void gtk_label_set_angle (GtkLabel *label, gdouble angle);
subroutine gtk_label_set_angle(label, angle) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: label
  real(c_double), value :: angle
end subroutine

! gdouble gtk_label_get_angle (GtkLabel *label);
function gtk_label_get_angle(label) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: gtk_label_get_angle
  type(c_ptr), value :: label
end function

! void gtk_label_select_region (GtkLabel *label, gint start_offset, gint end_offset);
subroutine gtk_label_select_region(label, start_offset, end_offset) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: label
  integer(c_int), value :: start_offset
  integer(c_int), value :: end_offset
end subroutine

! gboolean gtk_label_get_selection_bounds (GtkLabel *label, gint *start, gint *end);
function gtk_label_get_selection_bounds(label, start, end) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_label_get_selection_bounds
  type(c_ptr), value :: label
  type(c_ptr), value :: start
  type(c_ptr), value :: end
end function

!  PangoLayout *gtk_label_get_layout (GtkLabel *label);
function gtk_label_get_layout(label) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_label_get_layout
  type(c_ptr), value :: label
end function

! void gtk_label_get_layout_offsets (GtkLabel *label, gint *x, gint *y);
subroutine gtk_label_get_layout_offsets(label, x, y) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: label
  type(c_ptr), value :: x
  type(c_ptr), value :: y
end subroutine

!  void gtk_label_set_single_line_mode (GtkLabel *label, gboolean single_line_mode);
subroutine gtk_label_set_single_line_mode(label, single_line_mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: label
  logical(c_bool), value :: single_line_mode
end subroutine

! gboolean gtk_label_get_single_line_mode (GtkLabel *label);
function gtk_label_get_single_line_mode(label) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_label_get_single_line_mode
  type(c_ptr), value :: label
end function

!  G_CONST_RETURN gchar *gtk_label_get_current_uri (GtkLabel *label);
function gtk_label_get_current_uri(label) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_label_get_current_uri
  type(c_ptr), value :: label
end function

! void gtk_label_set_track_visited_links (GtkLabel *label, gboolean track_links);
subroutine gtk_label_set_track_visited_links(label, track_links) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: label
  logical(c_bool), value :: track_links
end subroutine

! gboolean gtk_label_get_track_visited_links (GtkLabel *label);
function gtk_label_get_track_visited_links(label) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_label_get_track_visited_links
  type(c_ptr), value :: label
end function

!  void gtk_label_get (GtkLabel *label, gchar **str);
subroutine gtk_label_get(label, str) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: label
  character(kind=c_char), dimension(*) :: str
end subroutine

!  guint gtk_label_parse_uline (GtkLabel *label, const gchar *string);
function gtk_label_parse_uline(label, string) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: gtk_label_parse_uline
  type(c_ptr), value :: label
  character(kind=c_char), dimension(*) :: string
end function

!   GType gtk_recent_filter_get_type (void) G_GNUC_CONST;
function gtk_recent_filter_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_recent_filter_get_type
end function

!  GtkRecentFilter * gtk_recent_filter_new (void);
function gtk_recent_filter_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_filter_new
end function

! void gtk_recent_filter_set_name (GtkRecentFilter *filter, const gchar *name);
subroutine gtk_recent_filter_set_name(filter, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: filter
  character(kind=c_char), dimension(*) :: name
end subroutine

! G_CONST_RETURN gchar *gtk_recent_filter_get_name (GtkRecentFilter *filter);
function gtk_recent_filter_get_name(filter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_recent_filter_get_name
  type(c_ptr), value :: filter
end function

!  void gtk_recent_filter_add_mime_type (GtkRecentFilter *filter, const gchar *mime_type);
subroutine gtk_recent_filter_add_mime_type(filter, mime_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: filter
  character(kind=c_char), dimension(*) :: mime_type
end subroutine

! void gtk_recent_filter_add_pattern (GtkRecentFilter *filter, const gchar *pattern);
subroutine gtk_recent_filter_add_pattern(filter, pattern) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: filter
  character(kind=c_char), dimension(*) :: pattern
end subroutine

! void gtk_recent_filter_add_pixbuf_formats (GtkRecentFilter *filter);
subroutine gtk_recent_filter_add_pixbuf_formats(filter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: filter
end subroutine

! void gtk_recent_filter_add_application (GtkRecentFilter *filter, const gchar *application);
subroutine gtk_recent_filter_add_application(filter, application) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: filter
  character(kind=c_char), dimension(*) :: application
end subroutine

! void gtk_recent_filter_add_group (GtkRecentFilter *filter, const gchar *group);
subroutine gtk_recent_filter_add_group(filter, group) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: filter
  character(kind=c_char), dimension(*) :: group
end subroutine

! void gtk_recent_filter_add_age (GtkRecentFilter *filter, gint days);
subroutine gtk_recent_filter_add_age(filter, days) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: filter
  integer(c_int), value :: days
end subroutine

! void gtk_recent_filter_add_custom (GtkRecentFilter *filter, GtkRecentFilterFlags needed, GtkRecentFilterFunc func, gpointer data, GDestroyNotify data_destroy);
subroutine gtk_recent_filter_add_custom(filter, needed, func, data, data_destroy&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: filter
  integer(c_int), value :: needed
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: data_destroy
end subroutine

!  GtkRecentFilterFlags gtk_recent_filter_get_needed (GtkRecentFilter *filter);
function gtk_recent_filter_get_needed(filter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_recent_filter_get_needed
  type(c_ptr), value :: filter
end function

! gboolean gtk_recent_filter_filter (GtkRecentFilter *filter, const GtkRecentFilterInfo *filter_info);
function gtk_recent_filter_filter(filter, filter_info) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_recent_filter_filter
  type(c_ptr), value :: filter
  type(c_ptr), value :: filter_info
end function

!   GType gtk_ctree_get_type (void) G_GNUC_CONST;
function gtk_ctree_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_ctree_get_type
end function

! GtkWidget * gtk_ctree_new_with_titles (gint columns, gint tree_column, gchar *titles[]);
function gtk_ctree_new_with_titles(columns, tree_column, titles) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr) :: gtk_ctree_new_with_titles
  integer(c_int), value :: columns
  integer(c_int), value :: tree_column
  character(kind=c_char), dimension(*) :: titles
end function

! GtkWidget * gtk_ctree_new (gint columns, gint tree_column);
function gtk_ctree_new(columns, tree_column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_ctree_new
  integer(c_int), value :: columns
  integer(c_int), value :: tree_column
end function

! GtkCTreeNode * gtk_ctree_insert_node (GtkCTree *ctree, GtkCTreeNode *parent, GtkCTreeNode *sibling, gchar *text[], guint8 spacing, GdkPixmap *pixmap_closed, GdkBitmap *mask_closed, GdkPixmap *pixmap_opened, GdkBitmap *mask_opened, gboolean is_leaf, gboolean expanded);
function gtk_ctree_insert_node(ctree, parent, sibling, text, spacing, pixmap_clo&
      &sed, mask_closed, pixmap_opened, mask_opened, is_leaf, expanded) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int8_t, c_bool
  type(c_ptr) :: gtk_ctree_insert_node
  type(c_ptr), value :: ctree
  type(c_ptr), value :: parent
  type(c_ptr), value :: sibling
  character(kind=c_char), dimension(*) :: text
  integer(c_int8_t), value :: spacing
  type(c_ptr), value :: pixmap_closed
  type(c_ptr), value :: mask_closed
  type(c_ptr), value :: pixmap_opened
  type(c_ptr), value :: mask_opened
  logical(c_bool), value :: is_leaf
  logical(c_bool), value :: expanded
end function

! void gtk_ctree_remove_node (GtkCTree *ctree, GtkCTreeNode *node);
subroutine gtk_ctree_remove_node(ctree, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
end subroutine

! GtkCTreeNode * gtk_ctree_insert_gnode (GtkCTree *ctree, GtkCTreeNode *parent, GtkCTreeNode *sibling, GNode *gnode, GtkCTreeGNodeFunc func, gpointer data);
function gtk_ctree_insert_gnode(ctree, parent, sibling, gnode, func, data) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: gtk_ctree_insert_gnode
  type(c_ptr), value :: ctree
  type(c_ptr), value :: parent
  type(c_ptr), value :: sibling
  type(c_ptr), value :: gnode
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end function

! GNode * gtk_ctree_export_to_gnode (GtkCTree *ctree, GNode *parent, GNode *sibling, GtkCTreeNode *node, GtkCTreeGNodeFunc func, gpointer data);
function gtk_ctree_export_to_gnode(ctree, parent, sibling, node, func, data) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: gtk_ctree_export_to_gnode
  type(c_ptr), value :: ctree
  type(c_ptr), value :: parent
  type(c_ptr), value :: sibling
  type(c_ptr), value :: node
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end function

!  void gtk_ctree_post_recursive (GtkCTree *ctree, GtkCTreeNode *node, GtkCTreeFunc func, gpointer data);
subroutine gtk_ctree_post_recursive(ctree, node, func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end subroutine

! void gtk_ctree_post_recursive_to_depth (GtkCTree *ctree, GtkCTreeNode *node, gint depth, GtkCTreeFunc func, gpointer data);
subroutine gtk_ctree_post_recursive_to_depth(ctree, node, depth, func, data) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  integer(c_int), value :: depth
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end subroutine

! void gtk_ctree_pre_recursive (GtkCTree *ctree, GtkCTreeNode *node, GtkCTreeFunc func, gpointer data);
subroutine gtk_ctree_pre_recursive(ctree, node, func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end subroutine

! void gtk_ctree_pre_recursive_to_depth (GtkCTree *ctree, GtkCTreeNode *node, gint depth, GtkCTreeFunc func, gpointer data);
subroutine gtk_ctree_pre_recursive_to_depth(ctree, node, depth, func, data) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  integer(c_int), value :: depth
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end subroutine

! gboolean gtk_ctree_is_viewable (GtkCTree *ctree, GtkCTreeNode *node);
function gtk_ctree_is_viewable(ctree, node) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_ctree_is_viewable
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
end function

! GtkCTreeNode * gtk_ctree_last (GtkCTree *ctree, GtkCTreeNode *node);
function gtk_ctree_last(ctree, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_ctree_last
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
end function

! GtkCTreeNode * gtk_ctree_find_node_ptr (GtkCTree *ctree, GtkCTreeRow *ctree_row);
function gtk_ctree_find_node_ptr(ctree, ctree_row) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_ctree_find_node_ptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: ctree_row
end function

! GtkCTreeNode * gtk_ctree_node_nth (GtkCTree *ctree, guint row);
function gtk_ctree_node_nth(ctree, row) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_ctree_node_nth
  type(c_ptr), value :: ctree
  integer(c_int), value :: row
end function

! gboolean gtk_ctree_find (GtkCTree *ctree, GtkCTreeNode *node, GtkCTreeNode *child);
function gtk_ctree_find(ctree, node, child) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_ctree_find
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  type(c_ptr), value :: child
end function

! gboolean gtk_ctree_is_ancestor (GtkCTree *ctree, GtkCTreeNode *node, GtkCTreeNode *child);
function gtk_ctree_is_ancestor(ctree, node, child) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_ctree_is_ancestor
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  type(c_ptr), value :: child
end function

! GtkCTreeNode * gtk_ctree_find_by_row_data (GtkCTree *ctree, GtkCTreeNode *node, gpointer data);
function gtk_ctree_find_by_row_data(ctree, node, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_ctree_find_by_row_data
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  type(c_ptr), value :: data
end function

!  GList * gtk_ctree_find_all_by_row_data (GtkCTree *ctree, GtkCTreeNode *node, gpointer data);
function gtk_ctree_find_all_by_row_data(ctree, node, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_ctree_find_all_by_row_data
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  type(c_ptr), value :: data
end function

! GtkCTreeNode * gtk_ctree_find_by_row_data_custom (GtkCTree *ctree, GtkCTreeNode *node, gpointer data, GCompareFunc func);
function gtk_ctree_find_by_row_data_custom(ctree, node, data, func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: gtk_ctree_find_by_row_data_custom
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  type(c_ptr), value :: data
  type(c_funptr), value :: func
end function

!  GList * gtk_ctree_find_all_by_row_data_custom (GtkCTree *ctree, GtkCTreeNode *node, gpointer data, GCompareFunc func);
function gtk_ctree_find_all_by_row_data_custom(ctree, node, data, func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: gtk_ctree_find_all_by_row_data_custom
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  type(c_ptr), value :: data
  type(c_funptr), value :: func
end function

! gboolean gtk_ctree_is_hot_spot (GtkCTree *ctree, gint x, gint y);
function gtk_ctree_is_hot_spot(ctree, x, y) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_ctree_is_hot_spot
  type(c_ptr), value :: ctree
  integer(c_int), value :: x
  integer(c_int), value :: y
end function

!  void gtk_ctree_move (GtkCTree *ctree, GtkCTreeNode *node, GtkCTreeNode *new_parent, GtkCTreeNode *new_sibling);
subroutine gtk_ctree_move(ctree, node, new_parent, new_sibling) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  type(c_ptr), value :: new_parent
  type(c_ptr), value :: new_sibling
end subroutine

! void gtk_ctree_expand (GtkCTree *ctree, GtkCTreeNode *node);
subroutine gtk_ctree_expand(ctree, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
end subroutine

! void gtk_ctree_expand_recursive (GtkCTree *ctree, GtkCTreeNode *node);
subroutine gtk_ctree_expand_recursive(ctree, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
end subroutine

! void gtk_ctree_expand_to_depth (GtkCTree *ctree, GtkCTreeNode *node, gint depth);
subroutine gtk_ctree_expand_to_depth(ctree, node, depth) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  integer(c_int), value :: depth
end subroutine

! void gtk_ctree_collapse (GtkCTree *ctree, GtkCTreeNode *node);
subroutine gtk_ctree_collapse(ctree, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
end subroutine

! void gtk_ctree_collapse_recursive (GtkCTree *ctree, GtkCTreeNode *node);
subroutine gtk_ctree_collapse_recursive(ctree, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
end subroutine

! void gtk_ctree_collapse_to_depth (GtkCTree *ctree, GtkCTreeNode *node, gint depth);
subroutine gtk_ctree_collapse_to_depth(ctree, node, depth) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  integer(c_int), value :: depth
end subroutine

! void gtk_ctree_toggle_expansion (GtkCTree *ctree, GtkCTreeNode *node);
subroutine gtk_ctree_toggle_expansion(ctree, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
end subroutine

! void gtk_ctree_toggle_expansion_recursive (GtkCTree *ctree, GtkCTreeNode *node);
subroutine gtk_ctree_toggle_expansion_recursive(ctree, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
end subroutine

! void gtk_ctree_select (GtkCTree *ctree, GtkCTreeNode *node);
subroutine gtk_ctree_select(ctree, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
end subroutine

! void gtk_ctree_select_recursive (GtkCTree *ctree, GtkCTreeNode *node);
subroutine gtk_ctree_select_recursive(ctree, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
end subroutine

! void gtk_ctree_unselect (GtkCTree *ctree, GtkCTreeNode *node);
subroutine gtk_ctree_unselect(ctree, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
end subroutine

! void gtk_ctree_unselect_recursive (GtkCTree *ctree, GtkCTreeNode *node);
subroutine gtk_ctree_unselect_recursive(ctree, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
end subroutine

! void gtk_ctree_real_select_recursive (GtkCTree *ctree, GtkCTreeNode *node, gint state);
subroutine gtk_ctree_real_select_recursive(ctree, node, state) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  integer(c_int), value :: state
end subroutine

!  void gtk_ctree_node_set_text (GtkCTree *ctree, GtkCTreeNode *node, gint column, const gchar *text);
subroutine gtk_ctree_node_set_text(ctree, node, column, text) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  integer(c_int), value :: column
  character(kind=c_char), dimension(*) :: text
end subroutine

! void gtk_ctree_node_set_pixmap (GtkCTree *ctree, GtkCTreeNode *node, gint column, GdkPixmap *pixmap, GdkBitmap *mask);
subroutine gtk_ctree_node_set_pixmap(ctree, node, column, pixmap, mask) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  integer(c_int), value :: column
  type(c_ptr), value :: pixmap
  type(c_ptr), value :: mask
end subroutine

! void gtk_ctree_node_set_pixtext (GtkCTree *ctree, GtkCTreeNode *node, gint column, const gchar *text, guint8 spacing, GdkPixmap *pixmap, GdkBitmap *mask);
subroutine gtk_ctree_node_set_pixtext(ctree, node, column, text, spacing, pixmap&
      &, mask) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char, c_int8_t
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  integer(c_int), value :: column
  character(kind=c_char), dimension(*) :: text
  integer(c_int8_t), value :: spacing
  type(c_ptr), value :: pixmap
  type(c_ptr), value :: mask
end subroutine

! void gtk_ctree_set_node_info (GtkCTree *ctree, GtkCTreeNode *node, const gchar *text, guint8 spacing, GdkPixmap *pixmap_closed, GdkBitmap *mask_closed, GdkPixmap *pixmap_opened, GdkBitmap *mask_opened, gboolean is_leaf, gboolean expanded);
subroutine gtk_ctree_set_node_info(ctree, node, text, spacing, pixmap_closed, ma&
      &sk_closed, pixmap_opened, mask_opened, is_leaf, expanded) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int8_t, c_bool
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  character(kind=c_char), dimension(*) :: text
  integer(c_int8_t), value :: spacing
  type(c_ptr), value :: pixmap_closed
  type(c_ptr), value :: mask_closed
  type(c_ptr), value :: pixmap_opened
  type(c_ptr), value :: mask_opened
  logical(c_bool), value :: is_leaf
  logical(c_bool), value :: expanded
end subroutine

! void gtk_ctree_node_set_shift (GtkCTree *ctree, GtkCTreeNode *node, gint column, gint vertical, gint horizontal);
subroutine gtk_ctree_node_set_shift(ctree, node, column, vertical, horizontal) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  integer(c_int), value :: column
  integer(c_int), value :: vertical
  integer(c_int), value :: horizontal
end subroutine

! void gtk_ctree_node_set_selectable (GtkCTree *ctree, GtkCTreeNode *node, gboolean selectable);
subroutine gtk_ctree_node_set_selectable(ctree, node, selectable) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  logical(c_bool), value :: selectable
end subroutine

! gboolean gtk_ctree_node_get_selectable (GtkCTree *ctree, GtkCTreeNode *node);
function gtk_ctree_node_get_selectable(ctree, node) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_ctree_node_get_selectable
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
end function

! GtkCellType gtk_ctree_node_get_cell_type (GtkCTree *ctree, GtkCTreeNode *node, gint column);
function gtk_ctree_node_get_cell_type(ctree, node, column) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_ctree_node_get_cell_type
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  integer(c_int), value :: column
end function

! gboolean gtk_ctree_node_get_text (GtkCTree *ctree, GtkCTreeNode *node, gint column, gchar **text);
function gtk_ctree_node_get_text(ctree, node, column, text) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int, c_char
  logical(c_bool) :: gtk_ctree_node_get_text
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  integer(c_int), value :: column
  character(kind=c_char), dimension(*) :: text
end function

! gboolean gtk_ctree_node_get_pixmap (GtkCTree *ctree, GtkCTreeNode *node, gint column, GdkPixmap **pixmap, GdkBitmap **mask);
function gtk_ctree_node_get_pixmap(ctree, node, column, pixmap, mask) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_ctree_node_get_pixmap
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  integer(c_int), value :: column
  type(c_ptr), value :: pixmap
  type(c_ptr), value :: mask
end function

! gboolean gtk_ctree_node_get_pixtext (GtkCTree *ctree, GtkCTreeNode *node, gint column, gchar **text, guint8 *spacing, GdkPixmap **pixmap, GdkBitmap **mask);
function gtk_ctree_node_get_pixtext(ctree, node, column, text, spacing, pixmap, &
      &mask) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int, c_char
  logical(c_bool) :: gtk_ctree_node_get_pixtext
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  integer(c_int), value :: column
  character(kind=c_char), dimension(*) :: text
  type(c_ptr), value :: spacing
  type(c_ptr), value :: pixmap
  type(c_ptr), value :: mask
end function

! gboolean gtk_ctree_get_node_info (GtkCTree *ctree, GtkCTreeNode *node, gchar **text, guint8 *spacing, GdkPixmap **pixmap_closed, GdkBitmap **mask_closed, GdkPixmap **pixmap_opened, GdkBitmap **mask_opened, gboolean *is_leaf, gboolean *expanded);
function gtk_ctree_get_node_info(ctree, node, text, spacing, pixmap_closed, mask&
      &_closed, pixmap_opened, mask_opened, is_leaf, expanded) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gtk_ctree_get_node_info
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  character(kind=c_char), dimension(*) :: text
  type(c_ptr), value :: spacing
  type(c_ptr), value :: pixmap_closed
  type(c_ptr), value :: mask_closed
  type(c_ptr), value :: pixmap_opened
  type(c_ptr), value :: mask_opened
  type(c_ptr), value :: is_leaf
  type(c_ptr), value :: expanded
end function

! void gtk_ctree_node_set_row_style (GtkCTree *ctree, GtkCTreeNode *node, GtkStyle *style);
subroutine gtk_ctree_node_set_row_style(ctree, node, style) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  type(c_ptr), value :: style
end subroutine

! GtkStyle * gtk_ctree_node_get_row_style (GtkCTree *ctree, GtkCTreeNode *node);
function gtk_ctree_node_get_row_style(ctree, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_ctree_node_get_row_style
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
end function

! void gtk_ctree_node_set_cell_style (GtkCTree *ctree, GtkCTreeNode *node, gint column, GtkStyle *style);
subroutine gtk_ctree_node_set_cell_style(ctree, node, column, style) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  integer(c_int), value :: column
  type(c_ptr), value :: style
end subroutine

! GtkStyle * gtk_ctree_node_get_cell_style (GtkCTree *ctree, GtkCTreeNode *node, gint column);
function gtk_ctree_node_get_cell_style(ctree, node, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_ctree_node_get_cell_style
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  integer(c_int), value :: column
end function

! void gtk_ctree_node_set_foreground (GtkCTree *ctree, GtkCTreeNode *node, const GdkColor *color);
subroutine gtk_ctree_node_set_foreground(ctree, node, color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  type(c_ptr), value :: color
end subroutine

! void gtk_ctree_node_set_background (GtkCTree *ctree, GtkCTreeNode *node, const GdkColor *color);
subroutine gtk_ctree_node_set_background(ctree, node, color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  type(c_ptr), value :: color
end subroutine

! void gtk_ctree_node_set_row_data (GtkCTree *ctree, GtkCTreeNode *node, gpointer data);
subroutine gtk_ctree_node_set_row_data(ctree, node, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  type(c_ptr), value :: data
end subroutine

! void gtk_ctree_node_set_row_data_full (GtkCTree *ctree, GtkCTreeNode *node, gpointer data, GDestroyNotify destroy);
subroutine gtk_ctree_node_set_row_data_full(ctree, node, data, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

! gpointer gtk_ctree_node_get_row_data (GtkCTree *ctree, GtkCTreeNode *node);
function gtk_ctree_node_get_row_data(ctree, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_ctree_node_get_row_data
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
end function

! void gtk_ctree_node_moveto (GtkCTree *ctree, GtkCTreeNode *node, gint column, gfloat row_align, gfloat col_align);
subroutine gtk_ctree_node_moveto(ctree, node, column, row_align, col_align) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_int, c_float
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
  integer(c_int), value :: column
  real(c_float), value :: row_align
  real(c_float), value :: col_align
end subroutine

! GtkVisibility gtk_ctree_node_is_visible (GtkCTree *ctree, GtkCTreeNode *node);
function gtk_ctree_node_is_visible(ctree, node) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_ctree_node_is_visible
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
end function

!  void gtk_ctree_set_indent (GtkCTree *ctree, gint indent);
subroutine gtk_ctree_set_indent(ctree, indent) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: ctree
  integer(c_int), value :: indent
end subroutine

! void gtk_ctree_set_spacing (GtkCTree *ctree, gint spacing);
subroutine gtk_ctree_set_spacing(ctree, spacing) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: ctree
  integer(c_int), value :: spacing
end subroutine

! void gtk_ctree_set_show_stub (GtkCTree *ctree, gboolean show_stub);
subroutine gtk_ctree_set_show_stub(ctree, show_stub) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: ctree
  logical(c_bool), value :: show_stub
end subroutine

! void gtk_ctree_set_line_style (GtkCTree *ctree, GtkCTreeLineStyle line_style);
subroutine gtk_ctree_set_line_style(ctree, line_style) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: ctree
  integer(c_int), value :: line_style
end subroutine

! void gtk_ctree_set_expander_style (GtkCTree *ctree, GtkCTreeExpanderStyle expander_style);
subroutine gtk_ctree_set_expander_style(ctree, expander_style) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: ctree
  integer(c_int), value :: expander_style
end subroutine

! void gtk_ctree_set_drag_compare_func (GtkCTree *ctree, GtkCTreeCompareDragFunc cmp_func);
subroutine gtk_ctree_set_drag_compare_func(ctree, cmp_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: ctree
  type(c_funptr), value :: cmp_func
end subroutine

!  void gtk_ctree_sort_node (GtkCTree *ctree, GtkCTreeNode *node);
subroutine gtk_ctree_sort_node(ctree, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
end subroutine

! void gtk_ctree_sort_recursive (GtkCTree *ctree, GtkCTreeNode *node);
subroutine gtk_ctree_sort_recursive(ctree, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ctree
  type(c_ptr), value :: node
end subroutine

!  GType gtk_ctree_node_get_type (void) G_GNUC_CONST;
function gtk_ctree_node_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_ctree_node_get_type
end function

!   GType gtk_color_selection_get_type (void) G_GNUC_CONST;
function gtk_color_selection_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_color_selection_get_type
end function

! GtkWidget *gtk_color_selection_new (void);
function gtk_color_selection_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_color_selection_new
end function

! gboolean gtk_color_selection_get_has_opacity_control (GtkColorSelection *colorsel);
function gtk_color_selection_get_has_opacity_control(colorsel) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_color_selection_get_has_opacity_control
  type(c_ptr), value :: colorsel
end function

! void gtk_color_selection_set_has_opacity_control (GtkColorSelection *colorsel, gboolean has_opacity);
subroutine gtk_color_selection_set_has_opacity_control(colorsel, has_opacity) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: colorsel
  logical(c_bool), value :: has_opacity
end subroutine

! gboolean gtk_color_selection_get_has_palette (GtkColorSelection *colorsel);
function gtk_color_selection_get_has_palette(colorsel) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_color_selection_get_has_palette
  type(c_ptr), value :: colorsel
end function

! void gtk_color_selection_set_has_palette (GtkColorSelection *colorsel, gboolean has_palette);
subroutine gtk_color_selection_set_has_palette(colorsel, has_palette) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: colorsel
  logical(c_bool), value :: has_palette
end subroutine

!  void gtk_color_selection_set_current_color (GtkColorSelection *colorsel, const GdkColor *color);
subroutine gtk_color_selection_set_current_color(colorsel, color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: colorsel
  type(c_ptr), value :: color
end subroutine

! void gtk_color_selection_set_current_alpha (GtkColorSelection *colorsel, guint16 alpha);
subroutine gtk_color_selection_set_current_alpha(colorsel, alpha) bind(c) 
  use iso_c_binding, only: c_ptr, c_int16_t
  type(c_ptr), value :: colorsel
  integer(c_int16_t), value :: alpha
end subroutine

! void gtk_color_selection_get_current_color (GtkColorSelection *colorsel, GdkColor *color);
subroutine gtk_color_selection_get_current_color(colorsel, color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: colorsel
  type(c_ptr), value :: color
end subroutine

! guint16 gtk_color_selection_get_current_alpha (GtkColorSelection *colorsel);
function gtk_color_selection_get_current_alpha(colorsel) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: gtk_color_selection_get_current_alpha
  type(c_ptr), value :: colorsel
end function

! void gtk_color_selection_set_previous_color (GtkColorSelection *colorsel, const GdkColor *color);
subroutine gtk_color_selection_set_previous_color(colorsel, color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: colorsel
  type(c_ptr), value :: color
end subroutine

! void gtk_color_selection_set_previous_alpha (GtkColorSelection *colorsel, guint16 alpha);
subroutine gtk_color_selection_set_previous_alpha(colorsel, alpha) bind(c) 
  use iso_c_binding, only: c_ptr, c_int16_t
  type(c_ptr), value :: colorsel
  integer(c_int16_t), value :: alpha
end subroutine

! void gtk_color_selection_get_previous_color (GtkColorSelection *colorsel, GdkColor *color);
subroutine gtk_color_selection_get_previous_color(colorsel, color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: colorsel
  type(c_ptr), value :: color
end subroutine

! guint16 gtk_color_selection_get_previous_alpha (GtkColorSelection *colorsel);
function gtk_color_selection_get_previous_alpha(colorsel) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: gtk_color_selection_get_previous_alpha
  type(c_ptr), value :: colorsel
end function

!  gboolean gtk_color_selection_is_adjusting (GtkColorSelection *colorsel);
function gtk_color_selection_is_adjusting(colorsel) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_color_selection_is_adjusting
  type(c_ptr), value :: colorsel
end function

!  gboolean gtk_color_selection_palette_from_string (const gchar *str, GdkColor **colors, gint *n_colors);
function gtk_color_selection_palette_from_string(str, colors, n_colors) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_ptr
  logical(c_bool) :: gtk_color_selection_palette_from_string
  character(kind=c_char), dimension(*) :: str
  type(c_ptr), value :: colors
  type(c_ptr), value :: n_colors
end function

! gchar* gtk_color_selection_palette_to_string (const GdkColor *colors, gint n_colors);
function gtk_color_selection_palette_to_string(colors, n_colors) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_color_selection_palette_to_string
  type(c_ptr), value :: colors
  integer(c_int), value :: n_colors
end function

!  GtkColorSelectionChangePaletteFunc gtk_color_selection_set_change_palette_hook (GtkColorSelectionChangePaletteFunc func);
function gtk_color_selection_set_change_palette_hook(func) bind(c) 
  use iso_c_binding, only: c_funptr
  type(c_funptr) :: gtk_color_selection_set_change_palette_hook
  type(c_funptr), value :: func
end function

!  GtkColorSelectionChangePaletteWithScreenFunc gtk_color_selection_set_change_palette_with_screen_hook (GtkColorSelectionChangePaletteWithScreenFunc func);
function gtk_color_selection_set_change_palette_with_screen_hook(func) bind(c) 
  use iso_c_binding, only: c_funptr
  type(c_funptr) :: gtk_color_selection_set_change_palette_with_screen_hook
  type(c_funptr), value :: func
end function

!  void gtk_color_selection_set_color (GtkColorSelection *colorsel, gdouble *color);
subroutine gtk_color_selection_set_color(colorsel, color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: colorsel
  type(c_ptr), value :: color
end subroutine

! void gtk_color_selection_get_color (GtkColorSelection *colorsel, gdouble *color);
subroutine gtk_color_selection_get_color(colorsel, color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: colorsel
  type(c_ptr), value :: color
end subroutine

! void gtk_color_selection_set_update_policy (GtkColorSelection *colorsel, GtkUpdateType policy);
subroutine gtk_color_selection_set_update_policy(colorsel, policy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: colorsel
  integer(c_int), value :: policy
end subroutine

!   GType gtk_tree_get_type (void) G_GNUC_CONST;
function gtk_tree_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_get_type
end function

! GtkWidget* gtk_tree_new (void);
function gtk_tree_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_new
end function

! void gtk_tree_append (GtkTree *tree, GtkWidget *tree_item);
subroutine gtk_tree_append(tree, tree_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree
  type(c_ptr), value :: tree_item
end subroutine

! void gtk_tree_prepend (GtkTree *tree, GtkWidget *tree_item);
subroutine gtk_tree_prepend(tree, tree_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree
  type(c_ptr), value :: tree_item
end subroutine

! void gtk_tree_insert (GtkTree *tree, GtkWidget *tree_item, gint position);
subroutine gtk_tree_insert(tree, tree_item, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree
  type(c_ptr), value :: tree_item
  integer(c_int), value :: position
end subroutine

! void gtk_tree_remove_items (GtkTree *tree, GList *items);
subroutine gtk_tree_remove_items(tree, items) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree
  type(c_ptr), value :: items
end subroutine

! void gtk_tree_clear_items (GtkTree *tree, gint start, gint end);
subroutine gtk_tree_clear_items(tree, start, end) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree
  integer(c_int), value :: start
  integer(c_int), value :: end
end subroutine

! void gtk_tree_select_item (GtkTree *tree, gint item);
subroutine gtk_tree_select_item(tree, item) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree
  integer(c_int), value :: item
end subroutine

! void gtk_tree_unselect_item (GtkTree *tree, gint item);
subroutine gtk_tree_unselect_item(tree, item) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree
  integer(c_int), value :: item
end subroutine

! void gtk_tree_select_child (GtkTree *tree, GtkWidget *tree_item);
subroutine gtk_tree_select_child(tree, tree_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree
  type(c_ptr), value :: tree_item
end subroutine

! void gtk_tree_unselect_child (GtkTree *tree, GtkWidget *tree_item);
subroutine gtk_tree_unselect_child(tree, tree_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree
  type(c_ptr), value :: tree_item
end subroutine

! gint gtk_tree_child_position (GtkTree *tree, GtkWidget *child);
function gtk_tree_child_position(tree, child) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_child_position
  type(c_ptr), value :: tree
  type(c_ptr), value :: child
end function

! void gtk_tree_set_selection_mode (GtkTree *tree, GtkSelectionMode mode);
subroutine gtk_tree_set_selection_mode(tree, mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree
  integer(c_int), value :: mode
end subroutine

! void gtk_tree_set_view_mode (GtkTree *tree, GtkTreeViewMode mode);
subroutine gtk_tree_set_view_mode(tree, mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree
  integer(c_int), value :: mode
end subroutine

! void gtk_tree_set_view_lines (GtkTree *tree, gboolean flag);
subroutine gtk_tree_set_view_lines(tree, flag) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree
  logical(c_bool), value :: flag
end subroutine

!  void gtk_tree_remove_item (GtkTree *tree, GtkWidget *child);
subroutine gtk_tree_remove_item(tree, child) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree
  type(c_ptr), value :: child
end subroutine

!   GType gtk_notebook_get_type (void) G_GNUC_CONST;
function gtk_notebook_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_notebook_get_type
end function

! GtkWidget * gtk_notebook_new (void);
function gtk_notebook_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_notebook_new
end function

! gint gtk_notebook_append_page (GtkNotebook *notebook, GtkWidget *child, GtkWidget *tab_label);
function gtk_notebook_append_page(notebook, child, tab_label) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_notebook_append_page
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
  type(c_ptr), value :: tab_label
end function

! gint gtk_notebook_append_page_menu (GtkNotebook *notebook, GtkWidget *child, GtkWidget *tab_label, GtkWidget *menu_label);
function gtk_notebook_append_page_menu(notebook, child, tab_label, menu_label) b&
      &ind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_notebook_append_page_menu
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
  type(c_ptr), value :: tab_label
  type(c_ptr), value :: menu_label
end function

! gint gtk_notebook_prepend_page (GtkNotebook *notebook, GtkWidget *child, GtkWidget *tab_label);
function gtk_notebook_prepend_page(notebook, child, tab_label) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_notebook_prepend_page
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
  type(c_ptr), value :: tab_label
end function

! gint gtk_notebook_prepend_page_menu (GtkNotebook *notebook, GtkWidget *child, GtkWidget *tab_label, GtkWidget *menu_label);
function gtk_notebook_prepend_page_menu(notebook, child, tab_label, menu_label) &
      &bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_notebook_prepend_page_menu
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
  type(c_ptr), value :: tab_label
  type(c_ptr), value :: menu_label
end function

! gint gtk_notebook_insert_page (GtkNotebook *notebook, GtkWidget *child, GtkWidget *tab_label, gint position);
function gtk_notebook_insert_page(notebook, child, tab_label, position) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_notebook_insert_page
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
  type(c_ptr), value :: tab_label
  integer(c_int), value :: position
end function

! gint gtk_notebook_insert_page_menu (GtkNotebook *notebook, GtkWidget *child, GtkWidget *tab_label, GtkWidget *menu_label, gint position);
function gtk_notebook_insert_page_menu(notebook, child, tab_label, menu_label, p&
      &osition) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_notebook_insert_page_menu
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
  type(c_ptr), value :: tab_label
  type(c_ptr), value :: menu_label
  integer(c_int), value :: position
end function

! void gtk_notebook_remove_page (GtkNotebook *notebook, gint page_num);
subroutine gtk_notebook_remove_page(notebook, page_num) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: notebook
  integer(c_int), value :: page_num
end subroutine

!  void gtk_notebook_set_window_creation_hook (GtkNotebookWindowCreationFunc func, gpointer data, GDestroyNotify destroy);
subroutine gtk_notebook_set_window_creation_hook(func, data, destroy) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

!  void gtk_notebook_set_group_id (GtkNotebook *notebook, gint group_id);
subroutine gtk_notebook_set_group_id(notebook, group_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: notebook
  integer(c_int), value :: group_id
end subroutine

! gint gtk_notebook_get_group_id (GtkNotebook *notebook);
function gtk_notebook_get_group_id(notebook) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_notebook_get_group_id
  type(c_ptr), value :: notebook
end function

!  void gtk_notebook_set_group (GtkNotebook *notebook, gpointer group);
subroutine gtk_notebook_set_group(notebook, group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: notebook
  type(c_ptr), value :: group
end subroutine

! gpointer gtk_notebook_get_group (GtkNotebook *notebook);
function gtk_notebook_get_group(notebook) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_notebook_get_group
  type(c_ptr), value :: notebook
end function

!  gint gtk_notebook_get_current_page (GtkNotebook *notebook);
function gtk_notebook_get_current_page(notebook) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_notebook_get_current_page
  type(c_ptr), value :: notebook
end function

! GtkWidget* gtk_notebook_get_nth_page (GtkNotebook *notebook, gint page_num);
function gtk_notebook_get_nth_page(notebook, page_num) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_notebook_get_nth_page
  type(c_ptr), value :: notebook
  integer(c_int), value :: page_num
end function

! gint gtk_notebook_get_n_pages (GtkNotebook *notebook);
function gtk_notebook_get_n_pages(notebook) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_notebook_get_n_pages
  type(c_ptr), value :: notebook
end function

! gint gtk_notebook_page_num (GtkNotebook *notebook, GtkWidget *child);
function gtk_notebook_page_num(notebook, child) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_notebook_page_num
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
end function

! void gtk_notebook_set_current_page (GtkNotebook *notebook, gint page_num);
subroutine gtk_notebook_set_current_page(notebook, page_num) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: notebook
  integer(c_int), value :: page_num
end subroutine

! void gtk_notebook_next_page (GtkNotebook *notebook);
subroutine gtk_notebook_next_page(notebook) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: notebook
end subroutine

! void gtk_notebook_prev_page (GtkNotebook *notebook);
subroutine gtk_notebook_prev_page(notebook) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: notebook
end subroutine

!  void gtk_notebook_set_show_border (GtkNotebook *notebook, gboolean show_border);
subroutine gtk_notebook_set_show_border(notebook, show_border) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: notebook
  logical(c_bool), value :: show_border
end subroutine

! gboolean gtk_notebook_get_show_border (GtkNotebook *notebook);
function gtk_notebook_get_show_border(notebook) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_notebook_get_show_border
  type(c_ptr), value :: notebook
end function

! void gtk_notebook_set_show_tabs (GtkNotebook *notebook, gboolean show_tabs);
subroutine gtk_notebook_set_show_tabs(notebook, show_tabs) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: notebook
  logical(c_bool), value :: show_tabs
end subroutine

! gboolean gtk_notebook_get_show_tabs (GtkNotebook *notebook);
function gtk_notebook_get_show_tabs(notebook) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_notebook_get_show_tabs
  type(c_ptr), value :: notebook
end function

! void gtk_notebook_set_tab_pos (GtkNotebook *notebook, GtkPositionType pos);
subroutine gtk_notebook_set_tab_pos(notebook, pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: notebook
  integer(c_int), value :: pos
end subroutine

! GtkPositionType gtk_notebook_get_tab_pos (GtkNotebook *notebook);
function gtk_notebook_get_tab_pos(notebook) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_notebook_get_tab_pos
  type(c_ptr), value :: notebook
end function

!  void gtk_notebook_set_homogeneous_tabs (GtkNotebook *notebook, gboolean homogeneous);
subroutine gtk_notebook_set_homogeneous_tabs(notebook, homogeneous) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: notebook
  logical(c_bool), value :: homogeneous
end subroutine

! void gtk_notebook_set_tab_border (GtkNotebook *notebook, guint border_width);
subroutine gtk_notebook_set_tab_border(notebook, border_width) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: notebook
  integer(c_int), value :: border_width
end subroutine

! void gtk_notebook_set_tab_hborder (GtkNotebook *notebook, guint tab_hborder);
subroutine gtk_notebook_set_tab_hborder(notebook, tab_hborder) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: notebook
  integer(c_int), value :: tab_hborder
end subroutine

! void gtk_notebook_set_tab_vborder (GtkNotebook *notebook, guint tab_vborder);
subroutine gtk_notebook_set_tab_vborder(notebook, tab_vborder) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: notebook
  integer(c_int), value :: tab_vborder
end subroutine

!  void gtk_notebook_set_scrollable (GtkNotebook *notebook, gboolean scrollable);
subroutine gtk_notebook_set_scrollable(notebook, scrollable) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: notebook
  logical(c_bool), value :: scrollable
end subroutine

! gboolean gtk_notebook_get_scrollable (GtkNotebook *notebook);
function gtk_notebook_get_scrollable(notebook) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_notebook_get_scrollable
  type(c_ptr), value :: notebook
end function

! guint16 gtk_notebook_get_tab_hborder (GtkNotebook *notebook);
function gtk_notebook_get_tab_hborder(notebook) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: gtk_notebook_get_tab_hborder
  type(c_ptr), value :: notebook
end function

! guint16 gtk_notebook_get_tab_vborder (GtkNotebook *notebook);
function gtk_notebook_get_tab_vborder(notebook) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: gtk_notebook_get_tab_vborder
  type(c_ptr), value :: notebook
end function

!  void gtk_notebook_popup_enable (GtkNotebook *notebook);
subroutine gtk_notebook_popup_enable(notebook) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: notebook
end subroutine

! void gtk_notebook_popup_disable (GtkNotebook *notebook);
subroutine gtk_notebook_popup_disable(notebook) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: notebook
end subroutine

!  GtkWidget * gtk_notebook_get_tab_label (GtkNotebook *notebook, GtkWidget *child);
function gtk_notebook_get_tab_label(notebook, child) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_notebook_get_tab_label
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
end function

! void gtk_notebook_set_tab_label (GtkNotebook *notebook, GtkWidget *child, GtkWidget *tab_label);
subroutine gtk_notebook_set_tab_label(notebook, child, tab_label) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
  type(c_ptr), value :: tab_label
end subroutine

! void gtk_notebook_set_tab_label_text (GtkNotebook *notebook, GtkWidget *child, const gchar *tab_text);
subroutine gtk_notebook_set_tab_label_text(notebook, child, tab_text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
  character(kind=c_char), dimension(*) :: tab_text
end subroutine

! G_CONST_RETURN gchar *gtk_notebook_get_tab_label_text (GtkNotebook *notebook, GtkWidget *child);
function gtk_notebook_get_tab_label_text(notebook, child) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_notebook_get_tab_label_text
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
end function

! GtkWidget * gtk_notebook_get_menu_label (GtkNotebook *notebook, GtkWidget *child);
function gtk_notebook_get_menu_label(notebook, child) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_notebook_get_menu_label
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
end function

! void gtk_notebook_set_menu_label (GtkNotebook *notebook, GtkWidget *child, GtkWidget *menu_label);
subroutine gtk_notebook_set_menu_label(notebook, child, menu_label) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
  type(c_ptr), value :: menu_label
end subroutine

! void gtk_notebook_set_menu_label_text (GtkNotebook *notebook, GtkWidget *child, const gchar *menu_text);
subroutine gtk_notebook_set_menu_label_text(notebook, child, menu_text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
  character(kind=c_char), dimension(*) :: menu_text
end subroutine

! G_CONST_RETURN gchar *gtk_notebook_get_menu_label_text (GtkNotebook *notebook, GtkWidget *child);
function gtk_notebook_get_menu_label_text(notebook, child) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_notebook_get_menu_label_text
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
end function

!  void gtk_notebook_query_tab_label_packing (GtkNotebook *notebook, GtkWidget *child, gboolean *expand, gboolean *fill, GtkPackType *pack_type);
subroutine gtk_notebook_query_tab_label_packing(notebook, child, expand, fill, p&
      &ack_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
  type(c_ptr), value :: expand
  type(c_ptr), value :: fill
  integer(c_int), value :: pack_type
end subroutine

! void gtk_notebook_set_tab_label_packing (GtkNotebook *notebook, GtkWidget *child, gboolean expand, gboolean fill, GtkPackType pack_type);
subroutine gtk_notebook_set_tab_label_packing(notebook, child, expand, fill, pac&
      &k_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_int
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
  logical(c_bool), value :: expand
  logical(c_bool), value :: fill
  integer(c_int), value :: pack_type
end subroutine

!  void gtk_notebook_reorder_child (GtkNotebook *notebook, GtkWidget *child, gint position);
subroutine gtk_notebook_reorder_child(notebook, child, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
  integer(c_int), value :: position
end subroutine

! gboolean gtk_notebook_get_tab_reorderable (GtkNotebook *notebook, GtkWidget *child);
function gtk_notebook_get_tab_reorderable(notebook, child) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_notebook_get_tab_reorderable
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
end function

! void gtk_notebook_set_tab_reorderable (GtkNotebook *notebook, GtkWidget *child, gboolean reorderable);
subroutine gtk_notebook_set_tab_reorderable(notebook, child, reorderable) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
  logical(c_bool), value :: reorderable
end subroutine

! gboolean gtk_notebook_get_tab_detachable (GtkNotebook *notebook, GtkWidget *child);
function gtk_notebook_get_tab_detachable(notebook, child) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_notebook_get_tab_detachable
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
end function

! void gtk_notebook_set_tab_detachable (GtkNotebook *notebook, GtkWidget *child, gboolean detachable);
subroutine gtk_notebook_set_tab_detachable(notebook, child, detachable) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: notebook
  type(c_ptr), value :: child
  logical(c_bool), value :: detachable
end subroutine

!  GtkWidget* gtk_notebook_get_action_widget (GtkNotebook *notebook, GtkPackType pack_type);
function gtk_notebook_get_action_widget(notebook, pack_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_notebook_get_action_widget
  type(c_ptr), value :: notebook
  integer(c_int), value :: pack_type
end function

! void gtk_notebook_set_action_widget (GtkNotebook *notebook, GtkWidget *widget, GtkPackType pack_type);
subroutine gtk_notebook_set_action_widget(notebook, widget, pack_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: notebook
  type(c_ptr), value :: widget
  integer(c_int), value :: pack_type
end subroutine

!   GType gtk_list_get_type (void) G_GNUC_CONST;
function gtk_list_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_list_get_type
end function

! GtkWidget* gtk_list_new (void);
function gtk_list_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_list_new
end function

! void gtk_list_insert_items (GtkList *list, GList *items, gint position);
subroutine gtk_list_insert_items(list, items, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: list
  type(c_ptr), value :: items
  integer(c_int), value :: position
end subroutine

! void gtk_list_append_items (GtkList *list, GList *items);
subroutine gtk_list_append_items(list, items) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
  type(c_ptr), value :: items
end subroutine

! void gtk_list_prepend_items (GtkList *list, GList *items);
subroutine gtk_list_prepend_items(list, items) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
  type(c_ptr), value :: items
end subroutine

! void gtk_list_remove_items (GtkList *list, GList *items);
subroutine gtk_list_remove_items(list, items) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
  type(c_ptr), value :: items
end subroutine

! void gtk_list_remove_items_no_unref (GtkList *list, GList *items);
subroutine gtk_list_remove_items_no_unref(list, items) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
  type(c_ptr), value :: items
end subroutine

! void gtk_list_clear_items (GtkList *list, gint start, gint end);
subroutine gtk_list_clear_items(list, start, end) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: list
  integer(c_int), value :: start
  integer(c_int), value :: end
end subroutine

! void gtk_list_select_item (GtkList *list, gint item);
subroutine gtk_list_select_item(list, item) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: list
  integer(c_int), value :: item
end subroutine

! void gtk_list_unselect_item (GtkList *list, gint item);
subroutine gtk_list_unselect_item(list, item) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: list
  integer(c_int), value :: item
end subroutine

! void gtk_list_select_child (GtkList *list, GtkWidget *child);
subroutine gtk_list_select_child(list, child) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
  type(c_ptr), value :: child
end subroutine

! void gtk_list_unselect_child (GtkList *list, GtkWidget *child);
subroutine gtk_list_unselect_child(list, child) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
  type(c_ptr), value :: child
end subroutine

! gint gtk_list_child_position (GtkList *list, GtkWidget *child);
function gtk_list_child_position(list, child) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_list_child_position
  type(c_ptr), value :: list
  type(c_ptr), value :: child
end function

! void gtk_list_set_selection_mode (GtkList *list, GtkSelectionMode mode);
subroutine gtk_list_set_selection_mode(list, mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: list
  integer(c_int), value :: mode
end subroutine

!  void gtk_list_extend_selection (GtkList *list, GtkScrollType scroll_type, gfloat position, gboolean auto_start_selection);
subroutine gtk_list_extend_selection(list, scroll_type, position, auto_start_sel&
      &ection) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_float, c_bool
  type(c_ptr), value :: list
  integer(c_int), value :: scroll_type
  real(c_float), value :: position
  logical(c_bool), value :: auto_start_selection
end subroutine

! void gtk_list_start_selection (GtkList *list);
subroutine gtk_list_start_selection(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

! void gtk_list_end_selection (GtkList *list);
subroutine gtk_list_end_selection(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

! void gtk_list_select_all (GtkList *list);
subroutine gtk_list_select_all(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

! void gtk_list_unselect_all (GtkList *list);
subroutine gtk_list_unselect_all(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

! void gtk_list_scroll_horizontal (GtkList *list, GtkScrollType scroll_type, gfloat position);
subroutine gtk_list_scroll_horizontal(list, scroll_type, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_float
  type(c_ptr), value :: list
  integer(c_int), value :: scroll_type
  real(c_float), value :: position
end subroutine

! void gtk_list_scroll_vertical (GtkList *list, GtkScrollType scroll_type, gfloat position);
subroutine gtk_list_scroll_vertical(list, scroll_type, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_float
  type(c_ptr), value :: list
  integer(c_int), value :: scroll_type
  real(c_float), value :: position
end subroutine

! void gtk_list_toggle_add_mode (GtkList *list);
subroutine gtk_list_toggle_add_mode(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

! void gtk_list_toggle_focus_row (GtkList *list);
subroutine gtk_list_toggle_focus_row(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

! void gtk_list_toggle_row (GtkList *list, GtkWidget *item);
subroutine gtk_list_toggle_row(list, item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
  type(c_ptr), value :: item
end subroutine

! void gtk_list_undo_selection (GtkList *list);
subroutine gtk_list_undo_selection(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

! void gtk_list_end_drag_selection (GtkList *list);
subroutine gtk_list_end_drag_selection(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

!   GType gtk_file_chooser_widget_get_type (void) G_GNUC_CONST;
function gtk_file_chooser_widget_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_file_chooser_widget_get_type
end function

! GtkWidget *gtk_file_chooser_widget_new (GtkFileChooserAction action);
function gtk_file_chooser_widget_new(action) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gtk_file_chooser_widget_new
  integer(c_int), value :: action
end function

!  GtkWidget *gtk_file_chooser_widget_new_with_backend (GtkFileChooserAction action, const gchar *backend);
function gtk_file_chooser_widget_new_with_backend(action, backend) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr) :: gtk_file_chooser_widget_new_with_backend
  integer(c_int), value :: action
  character(kind=c_char), dimension(*) :: backend
end function

!   gboolean gtk_show_uri (GdkScreen *screen, const gchar *uri, guint32 timestamp, GError **error);
function gtk_show_uri(screen, uri, timestamp, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int32_t
  logical(c_bool) :: gtk_show_uri
  type(c_ptr), value :: screen
  character(kind=c_char), dimension(*) :: uri
  integer(c_int32_t), value :: timestamp
  type(c_ptr), value :: error
end function

!   GType gtk_drawing_area_get_type (void) G_GNUC_CONST;
function gtk_drawing_area_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_drawing_area_get_type
end function

! GtkWidget* gtk_drawing_area_new (void);
function gtk_drawing_area_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_drawing_area_new
end function

!  void gtk_drawing_area_size (GtkDrawingArea *darea, gint width, gint height);
subroutine gtk_drawing_area_size(darea, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: darea
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

!   GType gtk_tree_view_column_get_type (void) G_GNUC_CONST;
function gtk_tree_view_column_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_tree_view_column_get_type
end function

! GtkTreeViewColumn *gtk_tree_view_column_new (void);
function gtk_tree_view_column_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_view_column_new
end function

! void gtk_tree_view_column_pack_start (GtkTreeViewColumn *tree_column, GtkCellRenderer *cell, gboolean expand);
subroutine gtk_tree_view_column_pack_start(tree_column, cell, expand) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_column
  type(c_ptr), value :: cell
  logical(c_bool), value :: expand
end subroutine

! void gtk_tree_view_column_pack_end (GtkTreeViewColumn *tree_column, GtkCellRenderer *cell, gboolean expand);
subroutine gtk_tree_view_column_pack_end(tree_column, cell, expand) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_column
  type(c_ptr), value :: cell
  logical(c_bool), value :: expand
end subroutine

! void gtk_tree_view_column_clear (GtkTreeViewColumn *tree_column);
subroutine gtk_tree_view_column_clear(tree_column) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_column
end subroutine

!  GList *gtk_tree_view_column_get_cell_renderers (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_get_cell_renderers(tree_column) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_view_column_get_cell_renderers
  type(c_ptr), value :: tree_column
end function

!  void gtk_tree_view_column_add_attribute (GtkTreeViewColumn *tree_column, GtkCellRenderer *cell_renderer, const gchar *attribute, gint column);
subroutine gtk_tree_view_column_add_attribute(tree_column, cell_renderer, attrib&
      &ute, column) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: tree_column
  type(c_ptr), value :: cell_renderer
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int), value :: column
end subroutine

! void gtk_tree_view_column_set_cell_data_func (GtkTreeViewColumn *tree_column, GtkCellRenderer *cell_renderer, GtkTreeCellDataFunc func, gpointer func_data, GDestroyNotify destroy);
subroutine gtk_tree_view_column_set_cell_data_func(tree_column, cell_renderer, f&
      &unc, func_data, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: tree_column
  type(c_ptr), value :: cell_renderer
  type(c_funptr), value :: func
  type(c_ptr), value :: func_data
  type(c_funptr), value :: destroy
end subroutine

! void gtk_tree_view_column_clear_attributes (GtkTreeViewColumn *tree_column, GtkCellRenderer *cell_renderer);
subroutine gtk_tree_view_column_clear_attributes(tree_column, cell_renderer) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_column
  type(c_ptr), value :: cell_renderer
end subroutine

! void gtk_tree_view_column_set_spacing (GtkTreeViewColumn *tree_column, gint spacing);
subroutine gtk_tree_view_column_set_spacing(tree_column, spacing) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_column
  integer(c_int), value :: spacing
end subroutine

! gint gtk_tree_view_column_get_spacing (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_get_spacing(tree_column) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_view_column_get_spacing
  type(c_ptr), value :: tree_column
end function

! void gtk_tree_view_column_set_visible (GtkTreeViewColumn *tree_column, gboolean visible);
subroutine gtk_tree_view_column_set_visible(tree_column, visible) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_column
  logical(c_bool), value :: visible
end subroutine

! gboolean gtk_tree_view_column_get_visible (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_get_visible(tree_column) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_column_get_visible
  type(c_ptr), value :: tree_column
end function

! void gtk_tree_view_column_set_resizable (GtkTreeViewColumn *tree_column, gboolean resizable);
subroutine gtk_tree_view_column_set_resizable(tree_column, resizable) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_column
  logical(c_bool), value :: resizable
end subroutine

! gboolean gtk_tree_view_column_get_resizable (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_get_resizable(tree_column) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_column_get_resizable
  type(c_ptr), value :: tree_column
end function

! void gtk_tree_view_column_set_sizing (GtkTreeViewColumn *tree_column, GtkTreeViewColumnSizing type);
subroutine gtk_tree_view_column_set_sizing(tree_column, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_column
  integer(c_int), value :: type
end subroutine

! GtkTreeViewColumnSizing gtk_tree_view_column_get_sizing (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_get_sizing(tree_column) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_view_column_get_sizing
  type(c_ptr), value :: tree_column
end function

! gint gtk_tree_view_column_get_width (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_get_width(tree_column) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_view_column_get_width
  type(c_ptr), value :: tree_column
end function

! gint gtk_tree_view_column_get_fixed_width (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_get_fixed_width(tree_column) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_view_column_get_fixed_width
  type(c_ptr), value :: tree_column
end function

! void gtk_tree_view_column_set_fixed_width (GtkTreeViewColumn *tree_column, gint fixed_width);
subroutine gtk_tree_view_column_set_fixed_width(tree_column, fixed_width) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_column
  integer(c_int), value :: fixed_width
end subroutine

! void gtk_tree_view_column_set_min_width (GtkTreeViewColumn *tree_column, gint min_width);
subroutine gtk_tree_view_column_set_min_width(tree_column, min_width) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_column
  integer(c_int), value :: min_width
end subroutine

! gint gtk_tree_view_column_get_min_width (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_get_min_width(tree_column) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_view_column_get_min_width
  type(c_ptr), value :: tree_column
end function

! void gtk_tree_view_column_set_max_width (GtkTreeViewColumn *tree_column, gint max_width);
subroutine gtk_tree_view_column_set_max_width(tree_column, max_width) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_column
  integer(c_int), value :: max_width
end subroutine

! gint gtk_tree_view_column_get_max_width (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_get_max_width(tree_column) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_view_column_get_max_width
  type(c_ptr), value :: tree_column
end function

! void gtk_tree_view_column_clicked (GtkTreeViewColumn *tree_column);
subroutine gtk_tree_view_column_clicked(tree_column) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_column
end subroutine

!  void gtk_tree_view_column_set_title (GtkTreeViewColumn *tree_column, const gchar *title);
subroutine gtk_tree_view_column_set_title(tree_column, title) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: tree_column
  character(kind=c_char), dimension(*) :: title
end subroutine

! G_CONST_RETURN gchar *gtk_tree_view_column_get_title (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_get_title(tree_column) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_view_column_get_title
  type(c_ptr), value :: tree_column
end function

! void gtk_tree_view_column_set_expand (GtkTreeViewColumn *tree_column, gboolean expand);
subroutine gtk_tree_view_column_set_expand(tree_column, expand) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_column
  logical(c_bool), value :: expand
end subroutine

! gboolean gtk_tree_view_column_get_expand (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_get_expand(tree_column) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_column_get_expand
  type(c_ptr), value :: tree_column
end function

! void gtk_tree_view_column_set_clickable (GtkTreeViewColumn *tree_column, gboolean clickable);
subroutine gtk_tree_view_column_set_clickable(tree_column, clickable) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_column
  logical(c_bool), value :: clickable
end subroutine

! gboolean gtk_tree_view_column_get_clickable (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_get_clickable(tree_column) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_column_get_clickable
  type(c_ptr), value :: tree_column
end function

! void gtk_tree_view_column_set_widget (GtkTreeViewColumn *tree_column, GtkWidget *widget);
subroutine gtk_tree_view_column_set_widget(tree_column, widget) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_column
  type(c_ptr), value :: widget
end subroutine

! GtkWidget *gtk_tree_view_column_get_widget (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_get_widget(tree_column) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_view_column_get_widget
  type(c_ptr), value :: tree_column
end function

! void gtk_tree_view_column_set_alignment (GtkTreeViewColumn *tree_column, gfloat xalign);
subroutine gtk_tree_view_column_set_alignment(tree_column, xalign) bind(c) 
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: tree_column
  real(c_float), value :: xalign
end subroutine

! gfloat gtk_tree_view_column_get_alignment (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_get_alignment(tree_column) bind(c) 
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: gtk_tree_view_column_get_alignment
  type(c_ptr), value :: tree_column
end function

! void gtk_tree_view_column_set_reorderable (GtkTreeViewColumn *tree_column, gboolean reorderable);
subroutine gtk_tree_view_column_set_reorderable(tree_column, reorderable) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_column
  logical(c_bool), value :: reorderable
end subroutine

! gboolean gtk_tree_view_column_get_reorderable (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_get_reorderable(tree_column) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_column_get_reorderable
  type(c_ptr), value :: tree_column
end function

!  void gtk_tree_view_column_set_sort_column_id (GtkTreeViewColumn *tree_column, gint sort_column_id);
subroutine gtk_tree_view_column_set_sort_column_id(tree_column, sort_column_id) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_column
  integer(c_int), value :: sort_column_id
end subroutine

! gint gtk_tree_view_column_get_sort_column_id (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_get_sort_column_id(tree_column) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_view_column_get_sort_column_id
  type(c_ptr), value :: tree_column
end function

! void gtk_tree_view_column_set_sort_indicator (GtkTreeViewColumn *tree_column, gboolean setting);
subroutine gtk_tree_view_column_set_sort_indicator(tree_column, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_column
  logical(c_bool), value :: setting
end subroutine

! gboolean gtk_tree_view_column_get_sort_indicator (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_get_sort_indicator(tree_column) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_column_get_sort_indicator
  type(c_ptr), value :: tree_column
end function

! void gtk_tree_view_column_set_sort_order (GtkTreeViewColumn *tree_column, GtkSortType order);
subroutine gtk_tree_view_column_set_sort_order(tree_column, order) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tree_column
  integer(c_int), value :: order
end subroutine

! GtkSortType gtk_tree_view_column_get_sort_order (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_get_sort_order(tree_column) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gtk_tree_view_column_get_sort_order
  type(c_ptr), value :: tree_column
end function

!  void gtk_tree_view_column_cell_set_cell_data (GtkTreeViewColumn *tree_column, GtkTreeModel *tree_model, GtkTreeIter *iter, gboolean is_expander, gboolean is_expanded);
subroutine gtk_tree_view_column_cell_set_cell_data(tree_column, tree_model, iter&
      &, is_expander, is_expanded) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: tree_column
  type(c_ptr), value :: tree_model
  type(c_ptr), value :: iter
  logical(c_bool), value :: is_expander
  logical(c_bool), value :: is_expanded
end subroutine

! void gtk_tree_view_column_cell_get_size (GtkTreeViewColumn *tree_column, const GdkRectangle *cell_area, gint *x_offset, gint *y_offset, gint *width, gint *height);
subroutine gtk_tree_view_column_cell_get_size(tree_column, cell_area, x_offset, &
      &y_offset, width, height) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_column
  type(c_ptr), value :: cell_area
  type(c_ptr), value :: x_offset
  type(c_ptr), value :: y_offset
  type(c_ptr), value :: width
  type(c_ptr), value :: height
end subroutine

! gboolean gtk_tree_view_column_cell_is_visible (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_cell_is_visible(tree_column) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_column_cell_is_visible
  type(c_ptr), value :: tree_column
end function

! void gtk_tree_view_column_focus_cell (GtkTreeViewColumn *tree_column, GtkCellRenderer *cell);
subroutine gtk_tree_view_column_focus_cell(tree_column, cell) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_column
  type(c_ptr), value :: cell
end subroutine

! gboolean gtk_tree_view_column_cell_get_position (GtkTreeViewColumn *tree_column, GtkCellRenderer *cell_renderer, gint *start_pos, gint *width);
function gtk_tree_view_column_cell_get_position(tree_column, cell_renderer, star&
      &t_pos, width) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gtk_tree_view_column_cell_get_position
  type(c_ptr), value :: tree_column
  type(c_ptr), value :: cell_renderer
  type(c_ptr), value :: start_pos
  type(c_ptr), value :: width
end function

! void gtk_tree_view_column_queue_resize (GtkTreeViewColumn *tree_column);
subroutine gtk_tree_view_column_queue_resize(tree_column) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree_column
end subroutine

! GtkWidget *gtk_tree_view_column_get_tree_view (GtkTreeViewColumn *tree_column);
function gtk_tree_view_column_get_tree_view(tree_column) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_tree_view_column_get_tree_view
  type(c_ptr), value :: tree_column
end function

!   GType gtk_vbutton_box_get_type (void) G_GNUC_CONST;
function gtk_vbutton_box_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_vbutton_box_get_type
end function

! GtkWidget *gtk_vbutton_box_new (void);
function gtk_vbutton_box_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gtk_vbutton_box_new
end function

!  gint gtk_vbutton_box_get_spacing_default (void);
function gtk_vbutton_box_get_spacing_default() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gtk_vbutton_box_get_spacing_default
end function

! void gtk_vbutton_box_set_spacing_default (gint spacing);
subroutine gtk_vbutton_box_set_spacing_default(spacing) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: spacing
end subroutine

!  GtkButtonBoxStyle gtk_vbutton_box_get_layout_default (void);
function gtk_vbutton_box_get_layout_default() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: gtk_vbutton_box_get_layout_default
end function

! void gtk_vbutton_box_set_layout_default (GtkButtonBoxStyle layout);
subroutine gtk_vbutton_box_set_layout_default(layout) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: layout
end subroutine

!   GType gtk_cell_editable_get_type (void) G_GNUC_CONST;
function gtk_cell_editable_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_cell_editable_get_type
end function

!  void gtk_cell_editable_start_editing (GtkCellEditable *cell_editable, GdkEvent *event);
subroutine gtk_cell_editable_start_editing(cell_editable, event) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cell_editable
  type(c_ptr), value :: event
end subroutine

! void gtk_cell_editable_editing_done (GtkCellEditable *cell_editable);
subroutine gtk_cell_editable_editing_done(cell_editable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cell_editable
end subroutine

! void gtk_cell_editable_remove_widget (GtkCellEditable *cell_editable);
subroutine gtk_cell_editable_remove_widget(cell_editable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cell_editable
end subroutine

!   GType gtk_print_operation_preview_get_type (void) G_GNUC_CONST;
function gtk_print_operation_preview_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_print_operation_preview_get_type
end function

!  void gtk_print_operation_preview_render_page (GtkPrintOperationPreview *preview, gint page_nr);
subroutine gtk_print_operation_preview_render_page(preview, page_nr) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: preview
  integer(c_int), value :: page_nr
end subroutine

! void gtk_print_operation_preview_end_preview (GtkPrintOperationPreview *preview);
subroutine gtk_print_operation_preview_end_preview(preview) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: preview
end subroutine

! gboolean gtk_print_operation_preview_is_selected (GtkPrintOperationPreview *preview, gint page_nr);
function gtk_print_operation_preview_is_selected(preview, page_nr) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gtk_print_operation_preview_is_selected
  type(c_ptr), value :: preview
  integer(c_int), value :: page_nr
end function

!   GType gtk_vbox_get_type (void) G_GNUC_CONST;
function gtk_vbox_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gtk_vbox_get_type
end function

! GtkWidget * gtk_vbox_new (gboolean homogeneous, gint spacing);
function gtk_vbox_new(homogeneous, spacing) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_int
  type(c_ptr) :: gtk_vbox_new
  logical(c_bool), value :: homogeneous
  integer(c_int), value :: spacing
end function

!   cairo_surface_t * cairo_xlib_surface_create (Display *dpy, Drawable drawable, Visual *visual, int width, int height);
function cairo_xlib_surface_create(dpy, drawable, visual, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_long, c_int
  type(c_ptr) :: cairo_xlib_surface_create
  type(c_ptr), value :: dpy
  integer(c_long), value :: drawable
  type(c_ptr), value :: visual
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

!  cairo_surface_t * cairo_xlib_surface_create_for_bitmap (Display *dpy, Pixmap bitmap, Screen *screen, int width, int height);
function cairo_xlib_surface_create_for_bitmap(dpy, bitmap, screen, width, height&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_long, c_int
  type(c_ptr) :: cairo_xlib_surface_create_for_bitmap
  type(c_ptr), value :: dpy
  integer(c_long), value :: bitmap
  type(c_ptr), value :: screen
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

!  void cairo_xlib_surface_set_size (cairo_surface_t *surface, int width, int height);
subroutine cairo_xlib_surface_set_size(surface, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: surface
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

!  void cairo_xlib_surface_set_drawable (cairo_surface_t *surface, Drawable drawable, int width, int height);
subroutine cairo_xlib_surface_set_drawable(surface, drawable, width, height) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_long, c_int
  type(c_ptr), value :: surface
  integer(c_long), value :: drawable
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

!  Display * cairo_xlib_surface_get_display (cairo_surface_t *surface);
function cairo_xlib_surface_get_display(surface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_xlib_surface_get_display
  type(c_ptr), value :: surface
end function

!  Drawable cairo_xlib_surface_get_drawable (cairo_surface_t *surface);
function cairo_xlib_surface_get_drawable(surface) bind(c) 
  use iso_c_binding, only: c_long, c_ptr
  integer(c_long) :: cairo_xlib_surface_get_drawable
  type(c_ptr), value :: surface
end function

!  Screen * cairo_xlib_surface_get_screen (cairo_surface_t *surface);
function cairo_xlib_surface_get_screen(surface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_xlib_surface_get_screen
  type(c_ptr), value :: surface
end function

!  Visual * cairo_xlib_surface_get_visual (cairo_surface_t *surface);
function cairo_xlib_surface_get_visual(surface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_xlib_surface_get_visual
  type(c_ptr), value :: surface
end function

!  int cairo_xlib_surface_get_depth (cairo_surface_t *surface);
function cairo_xlib_surface_get_depth(surface) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_xlib_surface_get_depth
  type(c_ptr), value :: surface
end function

!  int cairo_xlib_surface_get_width (cairo_surface_t *surface);
function cairo_xlib_surface_get_width(surface) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_xlib_surface_get_width
  type(c_ptr), value :: surface
end function

!  int cairo_xlib_surface_get_height (cairo_surface_t *surface);
function cairo_xlib_surface_get_height(surface) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_xlib_surface_get_height
  type(c_ptr), value :: surface
end function

!   cairo_surface_t * cairo_xcb_surface_create (xcb_connection_t *connection, xcb_drawable_t drawable, xcb_visualtype_t *visual, int width, int height);
function cairo_xcb_surface_create(connection, drawable, visual, width, height) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_int
  type(c_ptr) :: cairo_xcb_surface_create
  type(c_ptr), value :: connection
  integer(c_int32_t), value :: drawable
  type(c_ptr), value :: visual
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

!  cairo_surface_t * cairo_xcb_surface_create_for_bitmap (xcb_connection_t *connection, xcb_screen_t *screen, xcb_pixmap_t bitmap, int width, int height);
function cairo_xcb_surface_create_for_bitmap(connection, screen, bitmap, width, &
      &height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_int
  type(c_ptr) :: cairo_xcb_surface_create_for_bitmap
  type(c_ptr), value :: connection
  type(c_ptr), value :: screen
  integer(c_int32_t), value :: bitmap
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

!  cairo_surface_t * cairo_xcb_surface_create_with_xrender_format (xcb_connection_t *connection, xcb_screen_t *screen, xcb_drawable_t drawable, xcb_render_pictforminfo_t *format, int width, int height);
function cairo_xcb_surface_create_with_xrender_format(connection, screen, drawab&
      &le, format, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_int
  type(c_ptr) :: cairo_xcb_surface_create_with_xrender_format
  type(c_ptr), value :: connection
  type(c_ptr), value :: screen
  integer(c_int32_t), value :: drawable
  type(c_ptr), value :: format
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

!  void cairo_xcb_surface_set_size (cairo_surface_t *surface, int width, int height);
subroutine cairo_xcb_surface_set_size(surface, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: surface
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

!  void cairo_xcb_device_debug_cap_xshm_version (cairo_device_t *device, int major_version, int minor_version);
subroutine cairo_xcb_device_debug_cap_xshm_version(device, major_version, minor_&
      &version) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: device
  integer(c_int), value :: major_version
  integer(c_int), value :: minor_version
end subroutine

!  void cairo_xcb_device_debug_cap_xrender_version (cairo_device_t *device, int major_version, int minor_version);
subroutine cairo_xcb_device_debug_cap_xrender_version(device, major_version, min&
      &or_version) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: device
  integer(c_int), value :: major_version
  integer(c_int), value :: minor_version
end subroutine

!   GType cairo_gobject_context_get_type (void);
function cairo_gobject_context_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_context_get_type
end function

!  GType cairo_gobject_device_get_type (void);
function cairo_gobject_device_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_device_get_type
end function

!  GType cairo_gobject_pattern_get_type (void);
function cairo_gobject_pattern_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_pattern_get_type
end function

!  GType cairo_gobject_surface_get_type (void);
function cairo_gobject_surface_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_surface_get_type
end function

!  GType cairo_gobject_rectangle_get_type (void);
function cairo_gobject_rectangle_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_rectangle_get_type
end function

!  GType cairo_gobject_scaled_font_get_type (void);
function cairo_gobject_scaled_font_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_scaled_font_get_type
end function

!  GType cairo_gobject_font_face_get_type (void);
function cairo_gobject_font_face_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_font_face_get_type
end function

!  GType cairo_gobject_font_options_get_type (void);
function cairo_gobject_font_options_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_font_options_get_type
end function

!  GType cairo_gobject_rectangle_int_get_type (void);
function cairo_gobject_rectangle_int_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_rectangle_int_get_type
end function

!  GType cairo_gobject_region_get_type (void);
function cairo_gobject_region_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_region_get_type
end function

!  GType cairo_gobject_status_get_type (void);
function cairo_gobject_status_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_status_get_type
end function

!  GType cairo_gobject_content_get_type (void);
function cairo_gobject_content_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_content_get_type
end function

!  GType cairo_gobject_operator_get_type (void);
function cairo_gobject_operator_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_operator_get_type
end function

!  GType cairo_gobject_antialias_get_type (void);
function cairo_gobject_antialias_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_antialias_get_type
end function

!  GType cairo_gobject_fill_rule_get_type (void);
function cairo_gobject_fill_rule_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_fill_rule_get_type
end function

!  GType cairo_gobject_line_cap_get_type (void);
function cairo_gobject_line_cap_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_line_cap_get_type
end function

!  GType cairo_gobject_line_join_get_type (void);
function cairo_gobject_line_join_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_line_join_get_type
end function

!  GType cairo_gobject_text_cluster_flags_get_type (void);
function cairo_gobject_text_cluster_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_text_cluster_flags_get_type
end function

!  GType cairo_gobject_font_slant_get_type (void);
function cairo_gobject_font_slant_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_font_slant_get_type
end function

!  GType cairo_gobject_font_weight_get_type (void);
function cairo_gobject_font_weight_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_font_weight_get_type
end function

!  GType cairo_gobject_subpixel_order_get_type (void);
function cairo_gobject_subpixel_order_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_subpixel_order_get_type
end function

!  GType cairo_gobject_hint_style_get_type (void);
function cairo_gobject_hint_style_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_hint_style_get_type
end function

!  GType cairo_gobject_hint_metrics_get_type (void);
function cairo_gobject_hint_metrics_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_hint_metrics_get_type
end function

!  GType cairo_gobject_font_type_get_type (void);
function cairo_gobject_font_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_font_type_get_type
end function

!  GType cairo_gobject_path_data_type_get_type (void);
function cairo_gobject_path_data_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_path_data_type_get_type
end function

!  GType cairo_gobject_device_type_get_type (void);
function cairo_gobject_device_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_device_type_get_type
end function

!  GType cairo_gobject_surface_type_get_type (void);
function cairo_gobject_surface_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_surface_type_get_type
end function

!  GType cairo_gobject_format_get_type (void);
function cairo_gobject_format_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_format_get_type
end function

!  GType cairo_gobject_pattern_type_get_type (void);
function cairo_gobject_pattern_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_pattern_type_get_type
end function

!  GType cairo_gobject_extend_get_type (void);
function cairo_gobject_extend_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_extend_get_type
end function

!  GType cairo_gobject_filter_get_type (void);
function cairo_gobject_filter_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_filter_get_type
end function

!  GType cairo_gobject_region_overlap_get_type (void);
function cairo_gobject_region_overlap_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: cairo_gobject_region_overlap_get_type
end function

!   cairo_surface_t * cairo_svg_surface_create (const char *filename, double width_in_points, double height_in_points);
function cairo_svg_surface_create(filename, width_in_points, height_in_points) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_double
  type(c_ptr) :: cairo_svg_surface_create
  character(kind=c_char), dimension(*) :: filename
  real(c_double), value :: width_in_points
  real(c_double), value :: height_in_points
end function

!  cairo_surface_t * cairo_svg_surface_create_for_stream (cairo_write_func_t write_func, void *closure, double width_in_points, double height_in_points);
function cairo_svg_surface_create_for_stream(write_func, closure, width_in_point&
      &s, height_in_points) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr, c_double
  type(c_ptr) :: cairo_svg_surface_create_for_stream
  type(c_funptr), value :: write_func
  type(c_ptr), value :: closure
  real(c_double), value :: width_in_points
  real(c_double), value :: height_in_points
end function

!  void cairo_svg_surface_restrict_to_version (cairo_surface_t *surface, cairo_svg_version_t version);
subroutine cairo_svg_surface_restrict_to_version(surface, version) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: surface
  integer(c_int), value :: version
end subroutine

!  void cairo_svg_get_versions (cairo_svg_version_t const **versions, int *num_versions);
subroutine cairo_svg_get_versions(versions, num_versions) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int), value :: versions
  type(c_ptr), value :: num_versions
end subroutine

!  const char * cairo_svg_version_to_string (cairo_svg_version_t version);
function cairo_svg_version_to_string(version) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: cairo_svg_version_to_string
  integer(c_int), value :: version
end function

!   cairo_surface_t * cairo_ps_surface_create (const char *filename, double width_in_points, double height_in_points);
function cairo_ps_surface_create(filename, width_in_points, height_in_points) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_char, c_double
  type(c_ptr) :: cairo_ps_surface_create
  character(kind=c_char), dimension(*) :: filename
  real(c_double), value :: width_in_points
  real(c_double), value :: height_in_points
end function

!  cairo_surface_t * cairo_ps_surface_create_for_stream (cairo_write_func_t write_func, void *closure, double width_in_points, double height_in_points);
function cairo_ps_surface_create_for_stream(write_func, closure, width_in_points&
      &, height_in_points) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr, c_double
  type(c_ptr) :: cairo_ps_surface_create_for_stream
  type(c_funptr), value :: write_func
  type(c_ptr), value :: closure
  real(c_double), value :: width_in_points
  real(c_double), value :: height_in_points
end function

!  void cairo_ps_surface_restrict_to_level (cairo_surface_t *surface, cairo_ps_level_t level);
subroutine cairo_ps_surface_restrict_to_level(surface, level) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: surface
  integer(c_int), value :: level
end subroutine

!  void cairo_ps_get_levels (cairo_ps_level_t const **levels, int *num_levels);
subroutine cairo_ps_get_levels(levels, num_levels) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int), value :: levels
  type(c_ptr), value :: num_levels
end subroutine

!  const char * cairo_ps_level_to_string (cairo_ps_level_t level);
function cairo_ps_level_to_string(level) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: cairo_ps_level_to_string
  integer(c_int), value :: level
end function

!  void cairo_ps_surface_set_eps (cairo_surface_t *surface, cairo_bool_t eps);
subroutine cairo_ps_surface_set_eps(surface, eps) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: surface
  integer(c_int), value :: eps
end subroutine

!  cairo_bool_t cairo_ps_surface_get_eps (cairo_surface_t *surface);
function cairo_ps_surface_get_eps(surface) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_ps_surface_get_eps
  type(c_ptr), value :: surface
end function

!  void cairo_ps_surface_set_size (cairo_surface_t *surface, double width_in_points, double height_in_points);
subroutine cairo_ps_surface_set_size(surface, width_in_points, height_in_points)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: surface
  real(c_double), value :: width_in_points
  real(c_double), value :: height_in_points
end subroutine

!  void cairo_ps_surface_dsc_comment (cairo_surface_t *surface, const char *comment);
subroutine cairo_ps_surface_dsc_comment(surface, comment) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: surface
  character(kind=c_char), dimension(*) :: comment
end subroutine

!  void cairo_ps_surface_dsc_begin_setup (cairo_surface_t *surface);
subroutine cairo_ps_surface_dsc_begin_setup(surface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: surface
end subroutine

!  void cairo_ps_surface_dsc_begin_page_setup (cairo_surface_t *surface);
subroutine cairo_ps_surface_dsc_begin_page_setup(surface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: surface
end subroutine

!   cairo_surface_t * cairo_pdf_surface_create (const char *filename, double width_in_points, double height_in_points);
function cairo_pdf_surface_create(filename, width_in_points, height_in_points) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_double
  type(c_ptr) :: cairo_pdf_surface_create
  character(kind=c_char), dimension(*) :: filename
  real(c_double), value :: width_in_points
  real(c_double), value :: height_in_points
end function

!  cairo_surface_t * cairo_pdf_surface_create_for_stream (cairo_write_func_t write_func, void *closure, double width_in_points, double height_in_points);
function cairo_pdf_surface_create_for_stream(write_func, closure, width_in_point&
      &s, height_in_points) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr, c_double
  type(c_ptr) :: cairo_pdf_surface_create_for_stream
  type(c_funptr), value :: write_func
  type(c_ptr), value :: closure
  real(c_double), value :: width_in_points
  real(c_double), value :: height_in_points
end function

!  void cairo_pdf_surface_restrict_to_version (cairo_surface_t *surface, cairo_pdf_version_t version);
subroutine cairo_pdf_surface_restrict_to_version(surface, version) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: surface
  integer(c_int), value :: version
end subroutine

!  void cairo_pdf_get_versions (cairo_pdf_version_t const **versions, int *num_versions);
subroutine cairo_pdf_get_versions(versions, num_versions) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int), value :: versions
  type(c_ptr), value :: num_versions
end subroutine

!  const char * cairo_pdf_version_to_string (cairo_pdf_version_t version);
function cairo_pdf_version_to_string(version) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: cairo_pdf_version_to_string
  integer(c_int), value :: version
end function

!  void cairo_pdf_surface_set_size (cairo_surface_t *surface, double width_in_points, double height_in_points);
subroutine cairo_pdf_surface_set_size(surface, width_in_points, height_in_points&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: surface
  real(c_double), value :: width_in_points
  real(c_double), value :: height_in_points
end subroutine

!  cairo_script_interpreter_t * cairo_script_interpreter_create (void);
function cairo_script_interpreter_create() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_script_interpreter_create
end function

!  void cairo_script_interpreter_install_hooks (cairo_script_interpreter_t *ctx, const cairo_script_interpreter_hooks_t *hooks);
subroutine cairo_script_interpreter_install_hooks(ctx, hooks) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ctx
  type(c_ptr), value :: hooks
end subroutine

!  cairo_status_t cairo_script_interpreter_run (cairo_script_interpreter_t *ctx, const char *filename);
function cairo_script_interpreter_run(ctx, filename) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: cairo_script_interpreter_run
  type(c_ptr), value :: ctx
  character(kind=c_char), dimension(*) :: filename
end function

!  cairo_status_t cairo_script_interpreter_feed_stream (cairo_script_interpreter_t *ctx, FILE *stream);
function cairo_script_interpreter_feed_stream(ctx, stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_script_interpreter_feed_stream
  type(c_ptr), value :: ctx
  type(c_ptr), value :: stream
end function

!  cairo_status_t cairo_script_interpreter_feed_string (cairo_script_interpreter_t *ctx, const char *line, int len);
function cairo_script_interpreter_feed_string(ctx, line, len) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: cairo_script_interpreter_feed_string
  type(c_ptr), value :: ctx
  character(kind=c_char), dimension(*) :: line
  integer(c_int), value :: len
end function

!  unsigned int cairo_script_interpreter_get_line_number (cairo_script_interpreter_t *ctx);
function cairo_script_interpreter_get_line_number(ctx) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_script_interpreter_get_line_number
  type(c_ptr), value :: ctx
end function

!  cairo_script_interpreter_t * cairo_script_interpreter_reference (cairo_script_interpreter_t *ctx);
function cairo_script_interpreter_reference(ctx) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_script_interpreter_reference
  type(c_ptr), value :: ctx
end function

!  cairo_status_t cairo_script_interpreter_finish (cairo_script_interpreter_t *ctx);
function cairo_script_interpreter_finish(ctx) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_script_interpreter_finish
  type(c_ptr), value :: ctx
end function

!  cairo_status_t cairo_script_interpreter_destroy (cairo_script_interpreter_t *ctx);
function cairo_script_interpreter_destroy(ctx) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_script_interpreter_destroy
  type(c_ptr), value :: ctx
end function

!  cairo_status_t cairo_script_interpreter_translate_stream (FILE *stream, cairo_write_func_t write_func, void *closure);
function cairo_script_interpreter_translate_stream(stream, write_func, closure) &
      &bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int) :: cairo_script_interpreter_translate_stream
  type(c_ptr), value :: stream
  type(c_funptr), value :: write_func
  type(c_ptr), value :: closure
end function

!   cairo_surface_t * cairo_xlib_surface_create_with_xrender_format (Display *dpy, Drawable drawable, Screen *screen, XRenderPictFormat *format, int width, int height);
function cairo_xlib_surface_create_with_xrender_format(dpy, drawable, screen, fo&
      &rmat, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_long, c_int
  type(c_ptr) :: cairo_xlib_surface_create_with_xrender_format
  type(c_ptr), value :: dpy
  integer(c_long), value :: drawable
  type(c_ptr), value :: screen
  type(c_ptr), value :: format
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

!  XRenderPictFormat * cairo_xlib_surface_get_xrender_format (cairo_surface_t *surface);
function cairo_xlib_surface_get_xrender_format(surface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_xlib_surface_get_xrender_format
  type(c_ptr), value :: surface
end function

!   int cairo_version (void);
function cairo_version() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: cairo_version
end function

!  const char* cairo_version_string (void);
function cairo_version_string() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_version_string
end function

!  cairo_t * cairo_create (cairo_surface_t *target);
function cairo_create(target) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_create
  type(c_ptr), value :: target
end function

!  cairo_t * cairo_reference (cairo_t *cr);
function cairo_reference(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_reference
  type(c_ptr), value :: cr
end function

!  void cairo_destroy (cairo_t *cr);
subroutine cairo_destroy(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
end subroutine

!  unsigned int cairo_get_reference_count (cairo_t *cr);
function cairo_get_reference_count(cr) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_get_reference_count
  type(c_ptr), value :: cr
end function

!  void * cairo_get_user_data (cairo_t *cr, const cairo_user_data_key_t *key);
subroutine cairo_get_user_data(cr, key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: key
end subroutine

!  cairo_status_t cairo_set_user_data (cairo_t *cr, const cairo_user_data_key_t *key, void *user_data, cairo_destroy_func_t destroy);
function cairo_set_user_data(cr, key, user_data, destroy) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int) :: cairo_set_user_data
  type(c_ptr), value :: cr
  type(c_ptr), value :: key
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy
end function

!  void cairo_save (cairo_t *cr);
subroutine cairo_save(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
end subroutine

!  void cairo_restore (cairo_t *cr);
subroutine cairo_restore(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
end subroutine

!  void cairo_push_group (cairo_t *cr);
subroutine cairo_push_group(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
end subroutine

!  void cairo_push_group_with_content (cairo_t *cr, cairo_content_t content);
subroutine cairo_push_group_with_content(cr, content) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: cr
  integer(c_int), value :: content
end subroutine

!  cairo_pattern_t * cairo_pop_group (cairo_t *cr);
function cairo_pop_group(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_pop_group
  type(c_ptr), value :: cr
end function

!  void cairo_pop_group_to_source (cairo_t *cr);
subroutine cairo_pop_group_to_source(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
end subroutine

!  void cairo_set_operator (cairo_t *cr, cairo_operator_t op);
subroutine cairo_set_operator(cr, op) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: cr
  integer(c_int), value :: op
end subroutine

!  void cairo_set_source (cairo_t *cr, cairo_pattern_t *source);
subroutine cairo_set_source(cr, source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: source
end subroutine

!  void cairo_set_source_rgb (cairo_t *cr, double red, double green, double blue);
subroutine cairo_set_source_rgb(cr, red, green, blue) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: red
  real(c_double), value :: green
  real(c_double), value :: blue
end subroutine

!  void cairo_set_source_rgba (cairo_t *cr, double red, double green, double blue, double alpha);
subroutine cairo_set_source_rgba(cr, red, green, blue, alpha) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: red
  real(c_double), value :: green
  real(c_double), value :: blue
  real(c_double), value :: alpha
end subroutine

!  void cairo_set_source_surface (cairo_t *cr, cairo_surface_t *surface, double x, double y);
subroutine cairo_set_source_surface(cr, surface, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  type(c_ptr), value :: surface
  real(c_double), value :: x
  real(c_double), value :: y
end subroutine

!  void cairo_set_tolerance (cairo_t *cr, double tolerance);
subroutine cairo_set_tolerance(cr, tolerance) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: tolerance
end subroutine

!  void cairo_set_antialias (cairo_t *cr, cairo_antialias_t antialias);
subroutine cairo_set_antialias(cr, antialias) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: cr
  integer(c_int), value :: antialias
end subroutine

!  void cairo_set_fill_rule (cairo_t *cr, cairo_fill_rule_t fill_rule);
subroutine cairo_set_fill_rule(cr, fill_rule) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: cr
  integer(c_int), value :: fill_rule
end subroutine

!  void cairo_set_line_width (cairo_t *cr, double width);
subroutine cairo_set_line_width(cr, width) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: width
end subroutine

!  void cairo_set_line_cap (cairo_t *cr, cairo_line_cap_t line_cap);
subroutine cairo_set_line_cap(cr, line_cap) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: cr
  integer(c_int), value :: line_cap
end subroutine

!  void cairo_set_line_join (cairo_t *cr, cairo_line_join_t line_join);
subroutine cairo_set_line_join(cr, line_join) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: cr
  integer(c_int), value :: line_join
end subroutine

!  void cairo_set_dash (cairo_t *cr, const double *dashes, int num_dashes, double offset);
subroutine cairo_set_dash(cr, dashes, num_dashes, offset) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_double
  type(c_ptr), value :: cr
  type(c_ptr), value :: dashes
  integer(c_int), value :: num_dashes
  real(c_double), value :: offset
end subroutine

!  void cairo_set_miter_limit (cairo_t *cr, double limit);
subroutine cairo_set_miter_limit(cr, limit) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: limit
end subroutine

!  void cairo_translate (cairo_t *cr, double tx, double ty);
subroutine cairo_translate(cr, tx, ty) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: tx
  real(c_double), value :: ty
end subroutine

!  void cairo_scale (cairo_t *cr, double sx, double sy);
subroutine cairo_scale(cr, sx, sy) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: sx
  real(c_double), value :: sy
end subroutine

!  void cairo_rotate (cairo_t *cr, double angle);
subroutine cairo_rotate(cr, angle) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: angle
end subroutine

!  void cairo_transform (cairo_t *cr, const cairo_matrix_t *matrix);
subroutine cairo_transform(cr, matrix) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: matrix
end subroutine

!  void cairo_set_matrix (cairo_t *cr, const cairo_matrix_t *matrix);
subroutine cairo_set_matrix(cr, matrix) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: matrix
end subroutine

!  void cairo_identity_matrix (cairo_t *cr);
subroutine cairo_identity_matrix(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
end subroutine

!  void cairo_user_to_device (cairo_t *cr, double *x, double *y);
subroutine cairo_user_to_device(cr, x, y) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: x
  type(c_ptr), value :: y
end subroutine

!  void cairo_user_to_device_distance (cairo_t *cr, double *dx, double *dy);
subroutine cairo_user_to_device_distance(cr, dx, dy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: dx
  type(c_ptr), value :: dy
end subroutine

!  void cairo_device_to_user (cairo_t *cr, double *x, double *y);
subroutine cairo_device_to_user(cr, x, y) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: x
  type(c_ptr), value :: y
end subroutine

!  void cairo_device_to_user_distance (cairo_t *cr, double *dx, double *dy);
subroutine cairo_device_to_user_distance(cr, dx, dy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: dx
  type(c_ptr), value :: dy
end subroutine

!  void cairo_new_path (cairo_t *cr);
subroutine cairo_new_path(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
end subroutine

!  void cairo_move_to (cairo_t *cr, double x, double y);
subroutine cairo_move_to(cr, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: x
  real(c_double), value :: y
end subroutine

!  void cairo_new_sub_path (cairo_t *cr);
subroutine cairo_new_sub_path(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
end subroutine

!  void cairo_line_to (cairo_t *cr, double x, double y);
subroutine cairo_line_to(cr, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: x
  real(c_double), value :: y
end subroutine

!  void cairo_curve_to (cairo_t *cr, double x1, double y1, double x2, double y2, double x3, double y3);
subroutine cairo_curve_to(cr, x1, y1, x2, y2, x3, y3) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: x1
  real(c_double), value :: y1
  real(c_double), value :: x2
  real(c_double), value :: y2
  real(c_double), value :: x3
  real(c_double), value :: y3
end subroutine

!  void cairo_arc (cairo_t *cr, double xc, double yc, double radius, double angle1, double angle2);
subroutine cairo_arc(cr, xc, yc, radius, angle1, angle2) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: xc
  real(c_double), value :: yc
  real(c_double), value :: radius
  real(c_double), value :: angle1
  real(c_double), value :: angle2
end subroutine

!  void cairo_arc_negative (cairo_t *cr, double xc, double yc, double radius, double angle1, double angle2);
subroutine cairo_arc_negative(cr, xc, yc, radius, angle1, angle2) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: xc
  real(c_double), value :: yc
  real(c_double), value :: radius
  real(c_double), value :: angle1
  real(c_double), value :: angle2
end subroutine

!  void cairo_rel_move_to (cairo_t *cr, double dx, double dy);
subroutine cairo_rel_move_to(cr, dx, dy) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: dx
  real(c_double), value :: dy
end subroutine

!  void cairo_rel_line_to (cairo_t *cr, double dx, double dy);
subroutine cairo_rel_line_to(cr, dx, dy) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: dx
  real(c_double), value :: dy
end subroutine

!  void cairo_rel_curve_to (cairo_t *cr, double dx1, double dy1, double dx2, double dy2, double dx3, double dy3);
subroutine cairo_rel_curve_to(cr, dx1, dy1, dx2, dy2, dx3, dy3) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: dx1
  real(c_double), value :: dy1
  real(c_double), value :: dx2
  real(c_double), value :: dy2
  real(c_double), value :: dx3
  real(c_double), value :: dy3
end subroutine

!  void cairo_rectangle (cairo_t *cr, double x, double y, double width, double height);
subroutine cairo_rectangle(cr, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: x
  real(c_double), value :: y
  real(c_double), value :: width
  real(c_double), value :: height
end subroutine

!  void cairo_close_path (cairo_t *cr);
subroutine cairo_close_path(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
end subroutine

!  void cairo_path_extents (cairo_t *cr, double *x1, double *y1, double *x2, double *y2);
subroutine cairo_path_extents(cr, x1, y1, x2, y2) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: x1
  type(c_ptr), value :: y1
  type(c_ptr), value :: x2
  type(c_ptr), value :: y2
end subroutine

!  void cairo_paint (cairo_t *cr);
subroutine cairo_paint(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
end subroutine

!  void cairo_paint_with_alpha (cairo_t *cr, double alpha);
subroutine cairo_paint_with_alpha(cr, alpha) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: alpha
end subroutine

!  void cairo_mask (cairo_t *cr, cairo_pattern_t *pattern);
subroutine cairo_mask(cr, pattern) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: pattern
end subroutine

!  void cairo_mask_surface (cairo_t *cr, cairo_surface_t *surface, double surface_x, double surface_y);
subroutine cairo_mask_surface(cr, surface, surface_x, surface_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  type(c_ptr), value :: surface
  real(c_double), value :: surface_x
  real(c_double), value :: surface_y
end subroutine

!  void cairo_stroke (cairo_t *cr);
subroutine cairo_stroke(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
end subroutine

!  void cairo_stroke_preserve (cairo_t *cr);
subroutine cairo_stroke_preserve(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
end subroutine

!  void cairo_fill (cairo_t *cr);
subroutine cairo_fill(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
end subroutine

!  void cairo_fill_preserve (cairo_t *cr);
subroutine cairo_fill_preserve(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
end subroutine

!  void cairo_copy_page (cairo_t *cr);
subroutine cairo_copy_page(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
end subroutine

!  void cairo_show_page (cairo_t *cr);
subroutine cairo_show_page(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
end subroutine

!  cairo_bool_t cairo_in_stroke (cairo_t *cr, double x, double y);
function cairo_in_stroke(cr, x, y) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_double
  integer(c_int) :: cairo_in_stroke
  type(c_ptr), value :: cr
  real(c_double), value :: x
  real(c_double), value :: y
end function

!  cairo_bool_t cairo_in_fill (cairo_t *cr, double x, double y);
function cairo_in_fill(cr, x, y) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_double
  integer(c_int) :: cairo_in_fill
  type(c_ptr), value :: cr
  real(c_double), value :: x
  real(c_double), value :: y
end function

!  cairo_bool_t cairo_in_clip (cairo_t *cr, double x, double y);
function cairo_in_clip(cr, x, y) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_double
  integer(c_int) :: cairo_in_clip
  type(c_ptr), value :: cr
  real(c_double), value :: x
  real(c_double), value :: y
end function

!  void cairo_stroke_extents (cairo_t *cr, double *x1, double *y1, double *x2, double *y2);
subroutine cairo_stroke_extents(cr, x1, y1, x2, y2) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: x1
  type(c_ptr), value :: y1
  type(c_ptr), value :: x2
  type(c_ptr), value :: y2
end subroutine

!  void cairo_fill_extents (cairo_t *cr, double *x1, double *y1, double *x2, double *y2);
subroutine cairo_fill_extents(cr, x1, y1, x2, y2) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: x1
  type(c_ptr), value :: y1
  type(c_ptr), value :: x2
  type(c_ptr), value :: y2
end subroutine

!  void cairo_reset_clip (cairo_t *cr);
subroutine cairo_reset_clip(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
end subroutine

!  void cairo_clip (cairo_t *cr);
subroutine cairo_clip(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
end subroutine

!  void cairo_clip_preserve (cairo_t *cr);
subroutine cairo_clip_preserve(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
end subroutine

!  void cairo_clip_extents (cairo_t *cr, double *x1, double *y1, double *x2, double *y2);
subroutine cairo_clip_extents(cr, x1, y1, x2, y2) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: x1
  type(c_ptr), value :: y1
  type(c_ptr), value :: x2
  type(c_ptr), value :: y2
end subroutine

!  cairo_rectangle_list_t * cairo_copy_clip_rectangle_list (cairo_t *cr);
function cairo_copy_clip_rectangle_list(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_copy_clip_rectangle_list
  type(c_ptr), value :: cr
end function

!  void cairo_rectangle_list_destroy (cairo_rectangle_list_t *rectangle_list);
subroutine cairo_rectangle_list_destroy(rectangle_list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: rectangle_list
end subroutine

!  cairo_glyph_t * cairo_glyph_allocate (int num_glyphs);
function cairo_glyph_allocate(num_glyphs) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: cairo_glyph_allocate
  integer(c_int), value :: num_glyphs
end function

!  void cairo_glyph_free (cairo_glyph_t *glyphs);
subroutine cairo_glyph_free(glyphs) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: glyphs
end subroutine

!  cairo_text_cluster_t * cairo_text_cluster_allocate (int num_clusters);
function cairo_text_cluster_allocate(num_clusters) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: cairo_text_cluster_allocate
  integer(c_int), value :: num_clusters
end function

!  void cairo_text_cluster_free (cairo_text_cluster_t *clusters);
subroutine cairo_text_cluster_free(clusters) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: clusters
end subroutine

!  cairo_font_options_t * cairo_font_options_create (void);
function cairo_font_options_create() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_font_options_create
end function

!  cairo_font_options_t * cairo_font_options_copy (const cairo_font_options_t *original);
function cairo_font_options_copy(original) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_font_options_copy
  type(c_ptr), value :: original
end function

!  void cairo_font_options_destroy (cairo_font_options_t *options);
subroutine cairo_font_options_destroy(options) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: options
end subroutine

!  cairo_status_t cairo_font_options_status (cairo_font_options_t *options);
function cairo_font_options_status(options) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_font_options_status
  type(c_ptr), value :: options
end function

!  void cairo_font_options_merge (cairo_font_options_t *options, const cairo_font_options_t *other);
subroutine cairo_font_options_merge(options, other) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: options
  type(c_ptr), value :: other
end subroutine

! cairo_bool_t cairo_font_options_equal (const cairo_font_options_t *options, const cairo_font_options_t *other);
function cairo_font_options_equal(options, other) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_font_options_equal
  type(c_ptr), value :: options
  type(c_ptr), value :: other
end function

!  unsigned long cairo_font_options_hash (const cairo_font_options_t *options);
function cairo_font_options_hash(options) bind(c) 
  use iso_c_binding, only: c_long, c_ptr
  integer(c_long) :: cairo_font_options_hash
  type(c_ptr), value :: options
end function

!  void cairo_font_options_set_antialias (cairo_font_options_t *options, cairo_antialias_t antialias);
subroutine cairo_font_options_set_antialias(options, antialias) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: options
  integer(c_int), value :: antialias
end subroutine

! cairo_antialias_t cairo_font_options_get_antialias (const cairo_font_options_t *options);
function cairo_font_options_get_antialias(options) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_font_options_get_antialias
  type(c_ptr), value :: options
end function

!  void cairo_font_options_set_subpixel_order (cairo_font_options_t *options, cairo_subpixel_order_t subpixel_order);
subroutine cairo_font_options_set_subpixel_order(options, subpixel_order) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: options
  integer(c_int), value :: subpixel_order
end subroutine

! cairo_subpixel_order_t cairo_font_options_get_subpixel_order (const cairo_font_options_t *options);
function cairo_font_options_get_subpixel_order(options) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_font_options_get_subpixel_order
  type(c_ptr), value :: options
end function

!  void cairo_font_options_set_hint_style (cairo_font_options_t *options, cairo_hint_style_t hint_style);
subroutine cairo_font_options_set_hint_style(options, hint_style) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: options
  integer(c_int), value :: hint_style
end subroutine

! cairo_hint_style_t cairo_font_options_get_hint_style (const cairo_font_options_t *options);
function cairo_font_options_get_hint_style(options) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_font_options_get_hint_style
  type(c_ptr), value :: options
end function

!  void cairo_font_options_set_hint_metrics (cairo_font_options_t *options, cairo_hint_metrics_t hint_metrics);
subroutine cairo_font_options_set_hint_metrics(options, hint_metrics) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: options
  integer(c_int), value :: hint_metrics
end subroutine

! cairo_hint_metrics_t cairo_font_options_get_hint_metrics (const cairo_font_options_t *options);
function cairo_font_options_get_hint_metrics(options) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_font_options_get_hint_metrics
  type(c_ptr), value :: options
end function

!  void cairo_select_font_face (cairo_t *cr, const char *family, cairo_font_slant_t slant, cairo_font_weight_t weight);
subroutine cairo_select_font_face(cr, family, slant, weight) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: cr
  character(kind=c_char), dimension(*) :: family
  integer(c_int), value :: slant
  integer(c_int), value :: weight
end subroutine

!  void cairo_set_font_size (cairo_t *cr, double size);
subroutine cairo_set_font_size(cr, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: size
end subroutine

!  void cairo_set_font_matrix (cairo_t *cr, const cairo_matrix_t *matrix);
subroutine cairo_set_font_matrix(cr, matrix) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: matrix
end subroutine

!  void cairo_get_font_matrix (cairo_t *cr, cairo_matrix_t *matrix);
subroutine cairo_get_font_matrix(cr, matrix) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: matrix
end subroutine

!  void cairo_set_font_options (cairo_t *cr, const cairo_font_options_t *options);
subroutine cairo_set_font_options(cr, options) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: options
end subroutine

!  void cairo_get_font_options (cairo_t *cr, cairo_font_options_t *options);
subroutine cairo_get_font_options(cr, options) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: options
end subroutine

!  void cairo_set_font_face (cairo_t *cr, cairo_font_face_t *font_face);
subroutine cairo_set_font_face(cr, font_face) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: font_face
end subroutine

!  cairo_font_face_t * cairo_get_font_face (cairo_t *cr);
function cairo_get_font_face(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_get_font_face
  type(c_ptr), value :: cr
end function

!  void cairo_set_scaled_font (cairo_t *cr, const cairo_scaled_font_t *scaled_font);
subroutine cairo_set_scaled_font(cr, scaled_font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: scaled_font
end subroutine

!  cairo_scaled_font_t * cairo_get_scaled_font (cairo_t *cr);
function cairo_get_scaled_font(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_get_scaled_font
  type(c_ptr), value :: cr
end function

!  void cairo_show_text (cairo_t *cr, const char *utf8);
subroutine cairo_show_text(cr, utf8) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: cr
  character(kind=c_char), dimension(*) :: utf8
end subroutine

!  void cairo_show_glyphs (cairo_t *cr, const cairo_glyph_t *glyphs, int num_glyphs);
subroutine cairo_show_glyphs(cr, glyphs, num_glyphs) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: cr
  type(c_ptr), value :: glyphs
  integer(c_int), value :: num_glyphs
end subroutine

!  void cairo_show_text_glyphs (cairo_t *cr, const char *utf8, int utf8_len, const cairo_glyph_t *glyphs, int num_glyphs, const cairo_text_cluster_t *clusters, int num_clusters, cairo_text_cluster_flags_t cluster_flags);
subroutine cairo_show_text_glyphs(cr, utf8, utf8_len, glyphs, num_glyphs, cluste&
      &rs, num_clusters, cluster_flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: cr
  character(kind=c_char), dimension(*) :: utf8
  integer(c_int), value :: utf8_len
  type(c_ptr), value :: glyphs
  integer(c_int), value :: num_glyphs
  type(c_ptr), value :: clusters
  integer(c_int), value :: num_clusters
  integer(c_int), value :: cluster_flags
end subroutine

!  void cairo_text_path (cairo_t *cr, const char *utf8);
subroutine cairo_text_path(cr, utf8) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: cr
  character(kind=c_char), dimension(*) :: utf8
end subroutine

!  void cairo_glyph_path (cairo_t *cr, const cairo_glyph_t *glyphs, int num_glyphs);
subroutine cairo_glyph_path(cr, glyphs, num_glyphs) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: cr
  type(c_ptr), value :: glyphs
  integer(c_int), value :: num_glyphs
end subroutine

!  void cairo_text_extents (cairo_t *cr, const char *utf8, cairo_text_extents_t *extents);
subroutine cairo_text_extents(cr, utf8, extents) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: cr
  character(kind=c_char), dimension(*) :: utf8
  type(c_ptr), value :: extents
end subroutine

!  void cairo_glyph_extents (cairo_t *cr, const cairo_glyph_t *glyphs, int num_glyphs, cairo_text_extents_t *extents);
subroutine cairo_glyph_extents(cr, glyphs, num_glyphs, extents) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: cr
  type(c_ptr), value :: glyphs
  integer(c_int), value :: num_glyphs
  type(c_ptr), value :: extents
end subroutine

!  void cairo_font_extents (cairo_t *cr, cairo_font_extents_t *extents);
subroutine cairo_font_extents(cr, extents) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: extents
end subroutine

!  cairo_font_face_t * cairo_font_face_reference (cairo_font_face_t *font_face);
function cairo_font_face_reference(font_face) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_font_face_reference
  type(c_ptr), value :: font_face
end function

!  void cairo_font_face_destroy (cairo_font_face_t *font_face);
subroutine cairo_font_face_destroy(font_face) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: font_face
end subroutine

!  unsigned int cairo_font_face_get_reference_count (cairo_font_face_t *font_face);
function cairo_font_face_get_reference_count(font_face) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_font_face_get_reference_count
  type(c_ptr), value :: font_face
end function

!  cairo_status_t cairo_font_face_status (cairo_font_face_t *font_face);
function cairo_font_face_status(font_face) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_font_face_status
  type(c_ptr), value :: font_face
end function

!  cairo_font_type_t cairo_font_face_get_type (cairo_font_face_t *font_face);
function cairo_font_face_get_type(font_face) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_font_face_get_type
  type(c_ptr), value :: font_face
end function

!  void * cairo_font_face_get_user_data (cairo_font_face_t *font_face, const cairo_user_data_key_t *key);
subroutine cairo_font_face_get_user_data(font_face, key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: font_face
  type(c_ptr), value :: key
end subroutine

!  cairo_status_t cairo_font_face_set_user_data (cairo_font_face_t *font_face, const cairo_user_data_key_t *key, void *user_data, cairo_destroy_func_t destroy);
function cairo_font_face_set_user_data(font_face, key, user_data, destroy) bind(&
      &c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int) :: cairo_font_face_set_user_data
  type(c_ptr), value :: font_face
  type(c_ptr), value :: key
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy
end function

!  cairo_scaled_font_t * cairo_scaled_font_create (cairo_font_face_t *font_face, const cairo_matrix_t *font_matrix, const cairo_matrix_t *ctm, const cairo_font_options_t *options);
function cairo_scaled_font_create(font_face, font_matrix, ctm, options) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_scaled_font_create
  type(c_ptr), value :: font_face
  type(c_ptr), value :: font_matrix
  type(c_ptr), value :: ctm
  type(c_ptr), value :: options
end function

!  cairo_scaled_font_t * cairo_scaled_font_reference (cairo_scaled_font_t *scaled_font);
function cairo_scaled_font_reference(scaled_font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_scaled_font_reference
  type(c_ptr), value :: scaled_font
end function

!  void cairo_scaled_font_destroy (cairo_scaled_font_t *scaled_font);
subroutine cairo_scaled_font_destroy(scaled_font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: scaled_font
end subroutine

!  unsigned int cairo_scaled_font_get_reference_count (cairo_scaled_font_t *scaled_font);
function cairo_scaled_font_get_reference_count(scaled_font) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_scaled_font_get_reference_count
  type(c_ptr), value :: scaled_font
end function

!  cairo_status_t cairo_scaled_font_status (cairo_scaled_font_t *scaled_font);
function cairo_scaled_font_status(scaled_font) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_scaled_font_status
  type(c_ptr), value :: scaled_font
end function

!  cairo_font_type_t cairo_scaled_font_get_type (cairo_scaled_font_t *scaled_font);
function cairo_scaled_font_get_type(scaled_font) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_scaled_font_get_type
  type(c_ptr), value :: scaled_font
end function

!  void * cairo_scaled_font_get_user_data (cairo_scaled_font_t *scaled_font, const cairo_user_data_key_t *key);
subroutine cairo_scaled_font_get_user_data(scaled_font, key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: scaled_font
  type(c_ptr), value :: key
end subroutine

!  cairo_status_t cairo_scaled_font_set_user_data (cairo_scaled_font_t *scaled_font, const cairo_user_data_key_t *key, void *user_data, cairo_destroy_func_t destroy);
function cairo_scaled_font_set_user_data(scaled_font, key, user_data, destroy) b&
      &ind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int) :: cairo_scaled_font_set_user_data
  type(c_ptr), value :: scaled_font
  type(c_ptr), value :: key
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy
end function

!  void cairo_scaled_font_extents (cairo_scaled_font_t *scaled_font, cairo_font_extents_t *extents);
subroutine cairo_scaled_font_extents(scaled_font, extents) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: scaled_font
  type(c_ptr), value :: extents
end subroutine

!  void cairo_scaled_font_text_extents (cairo_scaled_font_t *scaled_font, const char *utf8, cairo_text_extents_t *extents);
subroutine cairo_scaled_font_text_extents(scaled_font, utf8, extents) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: scaled_font
  character(kind=c_char), dimension(*) :: utf8
  type(c_ptr), value :: extents
end subroutine

!  void cairo_scaled_font_glyph_extents (cairo_scaled_font_t *scaled_font, const cairo_glyph_t *glyphs, int num_glyphs, cairo_text_extents_t *extents);
subroutine cairo_scaled_font_glyph_extents(scaled_font, glyphs, num_glyphs, exte&
      &nts) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: scaled_font
  type(c_ptr), value :: glyphs
  integer(c_int), value :: num_glyphs
  type(c_ptr), value :: extents
end subroutine

!  cairo_status_t cairo_scaled_font_text_to_glyphs (cairo_scaled_font_t *scaled_font, double x, double y, const char *utf8, int utf8_len, cairo_glyph_t **glyphs, int *num_glyphs, cairo_text_cluster_t **clusters, int *num_clusters, cairo_text_cluster_flags_t *cluster_flags);
function cairo_scaled_font_text_to_glyphs(scaled_font, x, y, utf8, utf8_len, gly&
      &phs, num_glyphs, clusters, num_clusters, cluster_flags) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_double, c_char
  integer(c_int) :: cairo_scaled_font_text_to_glyphs
  type(c_ptr), value :: scaled_font
  real(c_double), value :: x
  real(c_double), value :: y
  character(kind=c_char), dimension(*) :: utf8
  integer(c_int), value :: utf8_len
  type(c_ptr), value :: glyphs
  type(c_ptr), value :: num_glyphs
  type(c_ptr), value :: clusters
  type(c_ptr), value :: num_clusters
  integer(c_int), value :: cluster_flags
end function

!  cairo_font_face_t * cairo_scaled_font_get_font_face (cairo_scaled_font_t *scaled_font);
function cairo_scaled_font_get_font_face(scaled_font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_scaled_font_get_font_face
  type(c_ptr), value :: scaled_font
end function

!  void cairo_scaled_font_get_font_matrix (cairo_scaled_font_t *scaled_font, cairo_matrix_t *font_matrix);
subroutine cairo_scaled_font_get_font_matrix(scaled_font, font_matrix) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: scaled_font
  type(c_ptr), value :: font_matrix
end subroutine

!  void cairo_scaled_font_get_ctm (cairo_scaled_font_t *scaled_font, cairo_matrix_t *ctm);
subroutine cairo_scaled_font_get_ctm(scaled_font, ctm) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: scaled_font
  type(c_ptr), value :: ctm
end subroutine

!  void cairo_scaled_font_get_scale_matrix (cairo_scaled_font_t *scaled_font, cairo_matrix_t *scale_matrix);
subroutine cairo_scaled_font_get_scale_matrix(scaled_font, scale_matrix) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: scaled_font
  type(c_ptr), value :: scale_matrix
end subroutine

!  void cairo_scaled_font_get_font_options (cairo_scaled_font_t *scaled_font, cairo_font_options_t *options);
subroutine cairo_scaled_font_get_font_options(scaled_font, options) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: scaled_font
  type(c_ptr), value :: options
end subroutine

!  cairo_font_face_t * cairo_toy_font_face_create (const char *family, cairo_font_slant_t slant, cairo_font_weight_t weight);
function cairo_toy_font_face_create(family, slant, weight) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: cairo_toy_font_face_create
  character(kind=c_char), dimension(*) :: family
  integer(c_int), value :: slant
  integer(c_int), value :: weight
end function

!  const char * cairo_toy_font_face_get_family (cairo_font_face_t *font_face);
function cairo_toy_font_face_get_family(font_face) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_toy_font_face_get_family
  type(c_ptr), value :: font_face
end function

!  cairo_font_slant_t cairo_toy_font_face_get_slant (cairo_font_face_t *font_face);
function cairo_toy_font_face_get_slant(font_face) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_toy_font_face_get_slant
  type(c_ptr), value :: font_face
end function

!  cairo_font_weight_t cairo_toy_font_face_get_weight (cairo_font_face_t *font_face);
function cairo_toy_font_face_get_weight(font_face) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_toy_font_face_get_weight
  type(c_ptr), value :: font_face
end function

!  cairo_font_face_t * cairo_user_font_face_create (void);
function cairo_user_font_face_create() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_user_font_face_create
end function

!  void cairo_user_font_face_set_init_func (cairo_font_face_t *font_face, cairo_user_scaled_font_init_func_t init_func);
subroutine cairo_user_font_face_set_init_func(font_face, init_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: font_face
  type(c_funptr), value :: init_func
end subroutine

!  void cairo_user_font_face_set_render_glyph_func (cairo_font_face_t *font_face, cairo_user_scaled_font_render_glyph_func_t render_glyph_func);
subroutine cairo_user_font_face_set_render_glyph_func(font_face, render_glyph_fu&
      &nc) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: font_face
  type(c_funptr), value :: render_glyph_func
end subroutine

!  void cairo_user_font_face_set_text_to_glyphs_func (cairo_font_face_t *font_face, cairo_user_scaled_font_text_to_glyphs_func_t text_to_glyphs_func);
subroutine cairo_user_font_face_set_text_to_glyphs_func(font_face, text_to_glyph&
      &s_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: font_face
  type(c_funptr), value :: text_to_glyphs_func
end subroutine

!  void cairo_user_font_face_set_unicode_to_glyph_func (cairo_font_face_t *font_face, cairo_user_scaled_font_unicode_to_glyph_func_t unicode_to_glyph_func);
subroutine cairo_user_font_face_set_unicode_to_glyph_func(font_face, unicode_to_&
      &glyph_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: font_face
  type(c_funptr), value :: unicode_to_glyph_func
end subroutine

!  cairo_user_scaled_font_init_func_t cairo_user_font_face_get_init_func (cairo_font_face_t *font_face);
function cairo_user_font_face_get_init_func(font_face) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr) :: cairo_user_font_face_get_init_func
  type(c_ptr), value :: font_face
end function

!  cairo_user_scaled_font_render_glyph_func_t cairo_user_font_face_get_render_glyph_func (cairo_font_face_t *font_face);
function cairo_user_font_face_get_render_glyph_func(font_face) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr) :: cairo_user_font_face_get_render_glyph_func
  type(c_ptr), value :: font_face
end function

!  cairo_user_scaled_font_text_to_glyphs_func_t cairo_user_font_face_get_text_to_glyphs_func (cairo_font_face_t *font_face);
function cairo_user_font_face_get_text_to_glyphs_func(font_face) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr) :: cairo_user_font_face_get_text_to_glyphs_func
  type(c_ptr), value :: font_face
end function

!  cairo_user_scaled_font_unicode_to_glyph_func_t cairo_user_font_face_get_unicode_to_glyph_func (cairo_font_face_t *font_face);
function cairo_user_font_face_get_unicode_to_glyph_func(font_face) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr) :: cairo_user_font_face_get_unicode_to_glyph_func
  type(c_ptr), value :: font_face
end function

!  cairo_operator_t cairo_get_operator (cairo_t *cr);
function cairo_get_operator(cr) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_get_operator
  type(c_ptr), value :: cr
end function

!  cairo_pattern_t * cairo_get_source (cairo_t *cr);
function cairo_get_source(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_get_source
  type(c_ptr), value :: cr
end function

!  double cairo_get_tolerance (cairo_t *cr);
function cairo_get_tolerance(cr) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: cairo_get_tolerance
  type(c_ptr), value :: cr
end function

!  cairo_antialias_t cairo_get_antialias (cairo_t *cr);
function cairo_get_antialias(cr) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_get_antialias
  type(c_ptr), value :: cr
end function

!  cairo_bool_t cairo_has_current_point (cairo_t *cr);
function cairo_has_current_point(cr) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_has_current_point
  type(c_ptr), value :: cr
end function

!  void cairo_get_current_point (cairo_t *cr, double *x, double *y);
subroutine cairo_get_current_point(cr, x, y) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: x
  type(c_ptr), value :: y
end subroutine

!  cairo_fill_rule_t cairo_get_fill_rule (cairo_t *cr);
function cairo_get_fill_rule(cr) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_get_fill_rule
  type(c_ptr), value :: cr
end function

!  double cairo_get_line_width (cairo_t *cr);
function cairo_get_line_width(cr) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: cairo_get_line_width
  type(c_ptr), value :: cr
end function

!  cairo_line_cap_t cairo_get_line_cap (cairo_t *cr);
function cairo_get_line_cap(cr) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_get_line_cap
  type(c_ptr), value :: cr
end function

!  cairo_line_join_t cairo_get_line_join (cairo_t *cr);
function cairo_get_line_join(cr) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_get_line_join
  type(c_ptr), value :: cr
end function

!  double cairo_get_miter_limit (cairo_t *cr);
function cairo_get_miter_limit(cr) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: cairo_get_miter_limit
  type(c_ptr), value :: cr
end function

!  int cairo_get_dash_count (cairo_t *cr);
function cairo_get_dash_count(cr) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_get_dash_count
  type(c_ptr), value :: cr
end function

!  void cairo_get_dash (cairo_t *cr, double *dashes, double *offset);
subroutine cairo_get_dash(cr, dashes, offset) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: dashes
  type(c_ptr), value :: offset
end subroutine

!  void cairo_get_matrix (cairo_t *cr, cairo_matrix_t *matrix);
subroutine cairo_get_matrix(cr, matrix) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: matrix
end subroutine

!  cairo_surface_t * cairo_get_target (cairo_t *cr);
function cairo_get_target(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_get_target
  type(c_ptr), value :: cr
end function

!  cairo_surface_t * cairo_get_group_target (cairo_t *cr);
function cairo_get_group_target(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_get_group_target
  type(c_ptr), value :: cr
end function

!  cairo_path_t * cairo_copy_path (cairo_t *cr);
function cairo_copy_path(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_copy_path
  type(c_ptr), value :: cr
end function

!  cairo_path_t * cairo_copy_path_flat (cairo_t *cr);
function cairo_copy_path_flat(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_copy_path_flat
  type(c_ptr), value :: cr
end function

!  void cairo_append_path (cairo_t *cr, const cairo_path_t *path);
subroutine cairo_append_path(cr, path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: path
end subroutine

!  void cairo_path_destroy (cairo_path_t *path);
subroutine cairo_path_destroy(path) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: path
end subroutine

!  cairo_status_t cairo_status (cairo_t *cr);
function cairo_status(cr) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_status
  type(c_ptr), value :: cr
end function

!  const char * cairo_status_to_string (cairo_status_t status);
function cairo_status_to_string(status) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: cairo_status_to_string
  integer(c_int), value :: status
end function

!  cairo_device_t * cairo_device_reference (cairo_device_t *device);
function cairo_device_reference(device) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_device_reference
  type(c_ptr), value :: device
end function

!  cairo_device_type_t cairo_device_get_type (cairo_device_t *device);
function cairo_device_get_type(device) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_device_get_type
  type(c_ptr), value :: device
end function

!  cairo_status_t cairo_device_status (cairo_device_t *device);
function cairo_device_status(device) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_device_status
  type(c_ptr), value :: device
end function

!  cairo_status_t cairo_device_acquire (cairo_device_t *device);
function cairo_device_acquire(device) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_device_acquire
  type(c_ptr), value :: device
end function

!  void cairo_device_release (cairo_device_t *device);
subroutine cairo_device_release(device) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: device
end subroutine

!  void cairo_device_flush (cairo_device_t *device);
subroutine cairo_device_flush(device) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: device
end subroutine

!  void cairo_device_finish (cairo_device_t *device);
subroutine cairo_device_finish(device) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: device
end subroutine

!  void cairo_device_destroy (cairo_device_t *device);
subroutine cairo_device_destroy(device) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: device
end subroutine

!  unsigned int cairo_device_get_reference_count (cairo_device_t *device);
function cairo_device_get_reference_count(device) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_device_get_reference_count
  type(c_ptr), value :: device
end function

!  void * cairo_device_get_user_data (cairo_device_t *device, const cairo_user_data_key_t *key);
subroutine cairo_device_get_user_data(device, key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: device
  type(c_ptr), value :: key
end subroutine

!  cairo_status_t cairo_device_set_user_data (cairo_device_t *device, const cairo_user_data_key_t *key, void *user_data, cairo_destroy_func_t destroy);
function cairo_device_set_user_data(device, key, user_data, destroy) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int) :: cairo_device_set_user_data
  type(c_ptr), value :: device
  type(c_ptr), value :: key
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy
end function

!  cairo_surface_t * cairo_surface_create_similar (cairo_surface_t *other, cairo_content_t content, int width, int height);
function cairo_surface_create_similar(other, content, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: cairo_surface_create_similar
  type(c_ptr), value :: other
  integer(c_int), value :: content
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

!  cairo_surface_t * cairo_surface_create_for_rectangle (cairo_surface_t *target, double x, double y, double width, double height);
function cairo_surface_create_for_rectangle(target, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr) :: cairo_surface_create_for_rectangle
  type(c_ptr), value :: target
  real(c_double), value :: x
  real(c_double), value :: y
  real(c_double), value :: width
  real(c_double), value :: height
end function

!  cairo_surface_t * cairo_surface_reference (cairo_surface_t *surface);
function cairo_surface_reference(surface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_surface_reference
  type(c_ptr), value :: surface
end function

!  void cairo_surface_finish (cairo_surface_t *surface);
subroutine cairo_surface_finish(surface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: surface
end subroutine

!  void cairo_surface_destroy (cairo_surface_t *surface);
subroutine cairo_surface_destroy(surface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: surface
end subroutine

!  cairo_device_t * cairo_surface_get_device (cairo_surface_t *surface);
function cairo_surface_get_device(surface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_surface_get_device
  type(c_ptr), value :: surface
end function

!  unsigned int cairo_surface_get_reference_count (cairo_surface_t *surface);
function cairo_surface_get_reference_count(surface) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_surface_get_reference_count
  type(c_ptr), value :: surface
end function

!  cairo_status_t cairo_surface_status (cairo_surface_t *surface);
function cairo_surface_status(surface) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_surface_status
  type(c_ptr), value :: surface
end function

!  cairo_surface_type_t cairo_surface_get_type (cairo_surface_t *surface);
function cairo_surface_get_type(surface) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_surface_get_type
  type(c_ptr), value :: surface
end function

!  cairo_content_t cairo_surface_get_content (cairo_surface_t *surface);
function cairo_surface_get_content(surface) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_surface_get_content
  type(c_ptr), value :: surface
end function

!  cairo_status_t cairo_surface_write_to_png (cairo_surface_t *surface, const char *filename);
function cairo_surface_write_to_png(surface, filename) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: cairo_surface_write_to_png
  type(c_ptr), value :: surface
  character(kind=c_char), dimension(*) :: filename
end function

!  cairo_status_t cairo_surface_write_to_png_stream (cairo_surface_t *surface, cairo_write_func_t write_func, void *closure);
function cairo_surface_write_to_png_stream(surface, write_func, closure) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int) :: cairo_surface_write_to_png_stream
  type(c_ptr), value :: surface
  type(c_funptr), value :: write_func
  type(c_ptr), value :: closure
end function

!  void * cairo_surface_get_user_data (cairo_surface_t *surface, const cairo_user_data_key_t *key);
subroutine cairo_surface_get_user_data(surface, key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: surface
  type(c_ptr), value :: key
end subroutine

!  cairo_status_t cairo_surface_set_user_data (cairo_surface_t *surface, const cairo_user_data_key_t *key, void *user_data, cairo_destroy_func_t destroy);
function cairo_surface_set_user_data(surface, key, user_data, destroy) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int) :: cairo_surface_set_user_data
  type(c_ptr), value :: surface
  type(c_ptr), value :: key
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy
end function

!  void cairo_surface_get_mime_data (cairo_surface_t *surface, const char *mime_type, const unsigned char **data, unsigned long *length);
subroutine cairo_surface_get_mime_data(surface, mime_type, data, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: surface
  character(kind=c_char), dimension(*) :: mime_type
  type(c_ptr), value :: data
  type(c_ptr), value :: length
end subroutine

!  cairo_status_t cairo_surface_set_mime_data (cairo_surface_t *surface, const char *mime_type, const unsigned char *data, unsigned long length, cairo_destroy_func_t destroy, void *closure);
function cairo_surface_set_mime_data(surface, mime_type, data, length, destroy, &
      &closure) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_long, c_funptr
  integer(c_int) :: cairo_surface_set_mime_data
  type(c_ptr), value :: surface
  character(kind=c_char), dimension(*) :: mime_type
  type(c_ptr), value :: data
  integer(c_long), value :: length
  type(c_funptr), value :: destroy
  type(c_ptr), value :: closure
end function

!  void cairo_surface_get_font_options (cairo_surface_t *surface, cairo_font_options_t *options);
subroutine cairo_surface_get_font_options(surface, options) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: surface
  type(c_ptr), value :: options
end subroutine

!  void cairo_surface_flush (cairo_surface_t *surface);
subroutine cairo_surface_flush(surface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: surface
end subroutine

!  void cairo_surface_mark_dirty (cairo_surface_t *surface);
subroutine cairo_surface_mark_dirty(surface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: surface
end subroutine

!  void cairo_surface_mark_dirty_rectangle (cairo_surface_t *surface, int x, int y, int width, int height);
subroutine cairo_surface_mark_dirty_rectangle(surface, x, y, width, height) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: surface
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

!  void cairo_surface_set_device_offset (cairo_surface_t *surface, double x_offset, double y_offset);
subroutine cairo_surface_set_device_offset(surface, x_offset, y_offset) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: surface
  real(c_double), value :: x_offset
  real(c_double), value :: y_offset
end subroutine

!  void cairo_surface_get_device_offset (cairo_surface_t *surface, double *x_offset, double *y_offset);
subroutine cairo_surface_get_device_offset(surface, x_offset, y_offset) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: surface
  type(c_ptr), value :: x_offset
  type(c_ptr), value :: y_offset
end subroutine

!  void cairo_surface_set_fallback_resolution (cairo_surface_t *surface, double x_pixels_per_inch, double y_pixels_per_inch);
subroutine cairo_surface_set_fallback_resolution(surface, x_pixels_per_inch, y_p&
      &ixels_per_inch) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: surface
  real(c_double), value :: x_pixels_per_inch
  real(c_double), value :: y_pixels_per_inch
end subroutine

!  void cairo_surface_get_fallback_resolution (cairo_surface_t *surface, double *x_pixels_per_inch, double *y_pixels_per_inch);
subroutine cairo_surface_get_fallback_resolution(surface, x_pixels_per_inch, y_p&
      &ixels_per_inch) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: surface
  type(c_ptr), value :: x_pixels_per_inch
  type(c_ptr), value :: y_pixels_per_inch
end subroutine

!  void cairo_surface_copy_page (cairo_surface_t *surface);
subroutine cairo_surface_copy_page(surface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: surface
end subroutine

!  void cairo_surface_show_page (cairo_surface_t *surface);
subroutine cairo_surface_show_page(surface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: surface
end subroutine

!  cairo_bool_t cairo_surface_has_show_text_glyphs (cairo_surface_t *surface);
function cairo_surface_has_show_text_glyphs(surface) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_surface_has_show_text_glyphs
  type(c_ptr), value :: surface
end function

!  cairo_surface_t * cairo_image_surface_create (cairo_format_t format, int width, int height);
function cairo_image_surface_create(format, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: cairo_image_surface_create
  integer(c_int), value :: format
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

!  int cairo_format_stride_for_width (cairo_format_t format, int width);
function cairo_format_stride_for_width(format, width) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: cairo_format_stride_for_width
  integer(c_int), value :: format
  integer(c_int), value :: width
end function

!  cairo_surface_t * cairo_image_surface_create_for_data (unsigned char *data, cairo_format_t format, int width, int height, int stride);
function cairo_image_surface_create_for_data(data, format, width, height, stride&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: cairo_image_surface_create_for_data
  type(c_ptr), value :: data
  integer(c_int), value :: format
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: stride
end function

!  unsigned char * cairo_image_surface_get_data (cairo_surface_t *surface);
function cairo_image_surface_get_data(surface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_image_surface_get_data
  type(c_ptr), value :: surface
end function

!  cairo_format_t cairo_image_surface_get_format (cairo_surface_t *surface);
function cairo_image_surface_get_format(surface) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_image_surface_get_format
  type(c_ptr), value :: surface
end function

!  int cairo_image_surface_get_width (cairo_surface_t *surface);
function cairo_image_surface_get_width(surface) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_image_surface_get_width
  type(c_ptr), value :: surface
end function

!  int cairo_image_surface_get_height (cairo_surface_t *surface);
function cairo_image_surface_get_height(surface) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_image_surface_get_height
  type(c_ptr), value :: surface
end function

!  int cairo_image_surface_get_stride (cairo_surface_t *surface);
function cairo_image_surface_get_stride(surface) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_image_surface_get_stride
  type(c_ptr), value :: surface
end function

!  cairo_surface_t * cairo_image_surface_create_from_png (const char *filename);
function cairo_image_surface_create_from_png(filename) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: cairo_image_surface_create_from_png
  character(kind=c_char), dimension(*) :: filename
end function

!  cairo_surface_t * cairo_image_surface_create_from_png_stream (cairo_read_func_t read_func, void *closure);
function cairo_image_surface_create_from_png_stream(read_func, closure) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: cairo_image_surface_create_from_png_stream
  type(c_funptr), value :: read_func
  type(c_ptr), value :: closure
end function

!  cairo_surface_t * cairo_recording_surface_create (cairo_content_t content, const cairo_rectangle_t *extents);
function cairo_recording_surface_create(content, extents) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: cairo_recording_surface_create
  integer(c_int), value :: content
  type(c_ptr), value :: extents
end function

!  void cairo_recording_surface_ink_extents (cairo_surface_t *surface, double *x0, double *y0, double *width, double *height);
subroutine cairo_recording_surface_ink_extents(surface, x0, y0, width, height) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: surface
  type(c_ptr), value :: x0
  type(c_ptr), value :: y0
  type(c_ptr), value :: width
  type(c_ptr), value :: height
end subroutine

!  cairo_pattern_t * cairo_pattern_create_rgb (double red, double green, double blue);
function cairo_pattern_create_rgb(red, green, blue) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr) :: cairo_pattern_create_rgb
  real(c_double), value :: red
  real(c_double), value :: green
  real(c_double), value :: blue
end function

!  cairo_pattern_t * cairo_pattern_create_rgba (double red, double green, double blue, double alpha);
function cairo_pattern_create_rgba(red, green, blue, alpha) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr) :: cairo_pattern_create_rgba
  real(c_double), value :: red
  real(c_double), value :: green
  real(c_double), value :: blue
  real(c_double), value :: alpha
end function

!  cairo_pattern_t * cairo_pattern_create_for_surface (cairo_surface_t *surface);
function cairo_pattern_create_for_surface(surface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_pattern_create_for_surface
  type(c_ptr), value :: surface
end function

!  cairo_pattern_t * cairo_pattern_create_linear (double x0, double y0, double x1, double y1);
function cairo_pattern_create_linear(x0, y0, x1, y1) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr) :: cairo_pattern_create_linear
  real(c_double), value :: x0
  real(c_double), value :: y0
  real(c_double), value :: x1
  real(c_double), value :: y1
end function

!  cairo_pattern_t * cairo_pattern_create_radial (double cx0, double cy0, double radius0, double cx1, double cy1, double radius1);
function cairo_pattern_create_radial(cx0, cy0, radius0, cx1, cy1, radius1) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr) :: cairo_pattern_create_radial
  real(c_double), value :: cx0
  real(c_double), value :: cy0
  real(c_double), value :: radius0
  real(c_double), value :: cx1
  real(c_double), value :: cy1
  real(c_double), value :: radius1
end function

!  cairo_pattern_t * cairo_pattern_reference (cairo_pattern_t *pattern);
function cairo_pattern_reference(pattern) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_pattern_reference
  type(c_ptr), value :: pattern
end function

!  void cairo_pattern_destroy (cairo_pattern_t *pattern);
subroutine cairo_pattern_destroy(pattern) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pattern
end subroutine

!  unsigned int cairo_pattern_get_reference_count (cairo_pattern_t *pattern);
function cairo_pattern_get_reference_count(pattern) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_pattern_get_reference_count
  type(c_ptr), value :: pattern
end function

!  cairo_status_t cairo_pattern_status (cairo_pattern_t *pattern);
function cairo_pattern_status(pattern) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_pattern_status
  type(c_ptr), value :: pattern
end function

!  void * cairo_pattern_get_user_data (cairo_pattern_t *pattern, const cairo_user_data_key_t *key);
subroutine cairo_pattern_get_user_data(pattern, key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pattern
  type(c_ptr), value :: key
end subroutine

!  cairo_status_t cairo_pattern_set_user_data (cairo_pattern_t *pattern, const cairo_user_data_key_t *key, void *user_data, cairo_destroy_func_t destroy);
function cairo_pattern_set_user_data(pattern, key, user_data, destroy) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int) :: cairo_pattern_set_user_data
  type(c_ptr), value :: pattern
  type(c_ptr), value :: key
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy
end function

!  cairo_pattern_type_t cairo_pattern_get_type (cairo_pattern_t *pattern);
function cairo_pattern_get_type(pattern) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_pattern_get_type
  type(c_ptr), value :: pattern
end function

!  void cairo_pattern_add_color_stop_rgb (cairo_pattern_t *pattern, double offset, double red, double green, double blue);
subroutine cairo_pattern_add_color_stop_rgb(pattern, offset, red, green, blue) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: pattern
  real(c_double), value :: offset
  real(c_double), value :: red
  real(c_double), value :: green
  real(c_double), value :: blue
end subroutine

!  void cairo_pattern_add_color_stop_rgba (cairo_pattern_t *pattern, double offset, double red, double green, double blue, double alpha);
subroutine cairo_pattern_add_color_stop_rgba(pattern, offset, red, green, blue, &
      &alpha) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: pattern
  real(c_double), value :: offset
  real(c_double), value :: red
  real(c_double), value :: green
  real(c_double), value :: blue
  real(c_double), value :: alpha
end subroutine

!  void cairo_pattern_set_matrix (cairo_pattern_t *pattern, const cairo_matrix_t *matrix);
subroutine cairo_pattern_set_matrix(pattern, matrix) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pattern
  type(c_ptr), value :: matrix
end subroutine

!  void cairo_pattern_get_matrix (cairo_pattern_t *pattern, cairo_matrix_t *matrix);
subroutine cairo_pattern_get_matrix(pattern, matrix) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pattern
  type(c_ptr), value :: matrix
end subroutine

!  void cairo_pattern_set_extend (cairo_pattern_t *pattern, cairo_extend_t extend);
subroutine cairo_pattern_set_extend(pattern, extend) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: pattern
  integer(c_int), value :: extend
end subroutine

!  cairo_extend_t cairo_pattern_get_extend (cairo_pattern_t *pattern);
function cairo_pattern_get_extend(pattern) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_pattern_get_extend
  type(c_ptr), value :: pattern
end function

!  void cairo_pattern_set_filter (cairo_pattern_t *pattern, cairo_filter_t filter);
subroutine cairo_pattern_set_filter(pattern, filter) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: pattern
  integer(c_int), value :: filter
end subroutine

!  cairo_filter_t cairo_pattern_get_filter (cairo_pattern_t *pattern);
function cairo_pattern_get_filter(pattern) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_pattern_get_filter
  type(c_ptr), value :: pattern
end function

!  cairo_status_t cairo_pattern_get_rgba (cairo_pattern_t *pattern, double *red, double *green, double *blue, double *alpha);
function cairo_pattern_get_rgba(pattern, red, green, blue, alpha) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_pattern_get_rgba
  type(c_ptr), value :: pattern
  type(c_ptr), value :: red
  type(c_ptr), value :: green
  type(c_ptr), value :: blue
  type(c_ptr), value :: alpha
end function

!  cairo_status_t cairo_pattern_get_surface (cairo_pattern_t *pattern, cairo_surface_t **surface);
function cairo_pattern_get_surface(pattern, surface) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_pattern_get_surface
  type(c_ptr), value :: pattern
  type(c_ptr), value :: surface
end function

!  cairo_status_t cairo_pattern_get_color_stop_rgba (cairo_pattern_t *pattern, int index, double *offset, double *red, double *green, double *blue, double *alpha);
function cairo_pattern_get_color_stop_rgba(pattern, index, offset, red, green, b&
      &lue, alpha) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_pattern_get_color_stop_rgba
  type(c_ptr), value :: pattern
  integer(c_int), value :: index
  type(c_ptr), value :: offset
  type(c_ptr), value :: red
  type(c_ptr), value :: green
  type(c_ptr), value :: blue
  type(c_ptr), value :: alpha
end function

!  cairo_status_t cairo_pattern_get_color_stop_count (cairo_pattern_t *pattern, int *count);
function cairo_pattern_get_color_stop_count(pattern, count) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_pattern_get_color_stop_count
  type(c_ptr), value :: pattern
  type(c_ptr), value :: count
end function

!  cairo_status_t cairo_pattern_get_linear_points (cairo_pattern_t *pattern, double *x0, double *y0, double *x1, double *y1);
function cairo_pattern_get_linear_points(pattern, x0, y0, x1, y1) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_pattern_get_linear_points
  type(c_ptr), value :: pattern
  type(c_ptr), value :: x0
  type(c_ptr), value :: y0
  type(c_ptr), value :: x1
  type(c_ptr), value :: y1
end function

!  cairo_status_t cairo_pattern_get_radial_circles (cairo_pattern_t *pattern, double *x0, double *y0, double *r0, double *x1, double *y1, double *r1);
function cairo_pattern_get_radial_circles(pattern, x0, y0, r0, x1, y1, r1) bind(&
      &c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_pattern_get_radial_circles
  type(c_ptr), value :: pattern
  type(c_ptr), value :: x0
  type(c_ptr), value :: y0
  type(c_ptr), value :: r0
  type(c_ptr), value :: x1
  type(c_ptr), value :: y1
  type(c_ptr), value :: r1
end function

!  void cairo_matrix_init (cairo_matrix_t *matrix, double xx, double yx, double xy, double yy, double x0, double y0);
subroutine cairo_matrix_init(matrix, xx, yx, xy, yy, x0, y0) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: matrix
  real(c_double), value :: xx
  real(c_double), value :: yx
  real(c_double), value :: xy
  real(c_double), value :: yy
  real(c_double), value :: x0
  real(c_double), value :: y0
end subroutine

!  void cairo_matrix_init_identity (cairo_matrix_t *matrix);
subroutine cairo_matrix_init_identity(matrix) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: matrix
end subroutine

!  void cairo_matrix_init_translate (cairo_matrix_t *matrix, double tx, double ty);
subroutine cairo_matrix_init_translate(matrix, tx, ty) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: matrix
  real(c_double), value :: tx
  real(c_double), value :: ty
end subroutine

!  void cairo_matrix_init_scale (cairo_matrix_t *matrix, double sx, double sy);
subroutine cairo_matrix_init_scale(matrix, sx, sy) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: matrix
  real(c_double), value :: sx
  real(c_double), value :: sy
end subroutine

!  void cairo_matrix_init_rotate (cairo_matrix_t *matrix, double radians);
subroutine cairo_matrix_init_rotate(matrix, radians) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: matrix
  real(c_double), value :: radians
end subroutine

!  void cairo_matrix_translate (cairo_matrix_t *matrix, double tx, double ty);
subroutine cairo_matrix_translate(matrix, tx, ty) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: matrix
  real(c_double), value :: tx
  real(c_double), value :: ty
end subroutine

!  void cairo_matrix_scale (cairo_matrix_t *matrix, double sx, double sy);
subroutine cairo_matrix_scale(matrix, sx, sy) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: matrix
  real(c_double), value :: sx
  real(c_double), value :: sy
end subroutine

!  void cairo_matrix_rotate (cairo_matrix_t *matrix, double radians);
subroutine cairo_matrix_rotate(matrix, radians) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: matrix
  real(c_double), value :: radians
end subroutine

!  cairo_status_t cairo_matrix_invert (cairo_matrix_t *matrix);
function cairo_matrix_invert(matrix) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_matrix_invert
  type(c_ptr), value :: matrix
end function

!  void cairo_matrix_multiply (cairo_matrix_t *result, const cairo_matrix_t *a, const cairo_matrix_t *b);
subroutine cairo_matrix_multiply(result, a, b) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: result
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end subroutine

!  void cairo_matrix_transform_distance (const cairo_matrix_t *matrix, double *dx, double *dy);
subroutine cairo_matrix_transform_distance(matrix, dx, dy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: matrix
  type(c_ptr), value :: dx
  type(c_ptr), value :: dy
end subroutine

!  void cairo_matrix_transform_point (const cairo_matrix_t *matrix, double *x, double *y);
subroutine cairo_matrix_transform_point(matrix, x, y) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: matrix
  type(c_ptr), value :: x
  type(c_ptr), value :: y
end subroutine

!  cairo_region_t * cairo_region_create (void);
function cairo_region_create() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_region_create
end function

!  cairo_region_t * cairo_region_create_rectangle (const cairo_rectangle_int_t *rectangle);
function cairo_region_create_rectangle(rectangle) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_region_create_rectangle
  type(c_ptr), value :: rectangle
end function

!  cairo_region_t * cairo_region_create_rectangles (const cairo_rectangle_int_t *rects, int count);
function cairo_region_create_rectangles(rects, count) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: cairo_region_create_rectangles
  type(c_ptr), value :: rects
  integer(c_int), value :: count
end function

!  cairo_region_t * cairo_region_copy (const cairo_region_t *original);
function cairo_region_copy(original) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_region_copy
  type(c_ptr), value :: original
end function

!  cairo_region_t * cairo_region_reference (cairo_region_t *region);
function cairo_region_reference(region) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_region_reference
  type(c_ptr), value :: region
end function

!  void cairo_region_destroy (cairo_region_t *region);
subroutine cairo_region_destroy(region) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: region
end subroutine

!  cairo_bool_t cairo_region_equal (const cairo_region_t *a, const cairo_region_t *b);
function cairo_region_equal(a, b) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_region_equal
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

!  cairo_status_t cairo_region_status (const cairo_region_t *region);
function cairo_region_status(region) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_region_status
  type(c_ptr), value :: region
end function

!  void cairo_region_get_extents (const cairo_region_t *region, cairo_rectangle_int_t *extents);
subroutine cairo_region_get_extents(region, extents) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: region
  type(c_ptr), value :: extents
end subroutine

!  int cairo_region_num_rectangles (const cairo_region_t *region);
function cairo_region_num_rectangles(region) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_region_num_rectangles
  type(c_ptr), value :: region
end function

!  void cairo_region_get_rectangle (const cairo_region_t *region, int nth, cairo_rectangle_int_t *rectangle);
subroutine cairo_region_get_rectangle(region, nth, rectangle) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: region
  integer(c_int), value :: nth
  type(c_ptr), value :: rectangle
end subroutine

!  cairo_bool_t cairo_region_is_empty (const cairo_region_t *region);
function cairo_region_is_empty(region) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_region_is_empty
  type(c_ptr), value :: region
end function

!  cairo_region_overlap_t cairo_region_contains_rectangle (const cairo_region_t *region, const cairo_rectangle_int_t *rectangle);
function cairo_region_contains_rectangle(region, rectangle) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_region_contains_rectangle
  type(c_ptr), value :: region
  type(c_ptr), value :: rectangle
end function

!  cairo_bool_t cairo_region_contains_point (const cairo_region_t *region, int x, int y);
function cairo_region_contains_point(region, x, y) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_region_contains_point
  type(c_ptr), value :: region
  integer(c_int), value :: x
  integer(c_int), value :: y
end function

!  void cairo_region_translate (cairo_region_t *region, int dx, int dy);
subroutine cairo_region_translate(region, dx, dy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: region
  integer(c_int), value :: dx
  integer(c_int), value :: dy
end subroutine

!  cairo_status_t cairo_region_subtract (cairo_region_t *dst, const cairo_region_t *other);
function cairo_region_subtract(dst, other) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_region_subtract
  type(c_ptr), value :: dst
  type(c_ptr), value :: other
end function

!  cairo_status_t cairo_region_subtract_rectangle (cairo_region_t *dst, const cairo_rectangle_int_t *rectangle);
function cairo_region_subtract_rectangle(dst, rectangle) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_region_subtract_rectangle
  type(c_ptr), value :: dst
  type(c_ptr), value :: rectangle
end function

!  cairo_status_t cairo_region_intersect (cairo_region_t *dst, const cairo_region_t *other);
function cairo_region_intersect(dst, other) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_region_intersect
  type(c_ptr), value :: dst
  type(c_ptr), value :: other
end function

!  cairo_status_t cairo_region_intersect_rectangle (cairo_region_t *dst, const cairo_rectangle_int_t *rectangle);
function cairo_region_intersect_rectangle(dst, rectangle) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_region_intersect_rectangle
  type(c_ptr), value :: dst
  type(c_ptr), value :: rectangle
end function

!  cairo_status_t cairo_region_union (cairo_region_t *dst, const cairo_region_t *other);
function cairo_region_union(dst, other) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_region_union
  type(c_ptr), value :: dst
  type(c_ptr), value :: other
end function

!  cairo_status_t cairo_region_union_rectangle (cairo_region_t *dst, const cairo_rectangle_int_t *rectangle);
function cairo_region_union_rectangle(dst, rectangle) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_region_union_rectangle
  type(c_ptr), value :: dst
  type(c_ptr), value :: rectangle
end function

!  cairo_status_t cairo_region_xor (cairo_region_t *dst, const cairo_region_t *other);
function cairo_region_xor(dst, other) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_region_xor
  type(c_ptr), value :: dst
  type(c_ptr), value :: other
end function

!  cairo_status_t cairo_region_xor_rectangle (cairo_region_t *dst, const cairo_rectangle_int_t *rectangle);
function cairo_region_xor_rectangle(dst, rectangle) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: cairo_region_xor_rectangle
  type(c_ptr), value :: dst
  type(c_ptr), value :: rectangle
end function

!  void cairo_debug_reset_static_data (void);
subroutine cairo_debug_reset_static_data() bind(c) 
  use iso_c_binding, only: 
end subroutine

!   cairo_font_face_t * cairo_ft_font_face_create_for_ft_face (FT_Face face, int load_flags);
function cairo_ft_font_face_create_for_ft_face(face, load_flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: cairo_ft_font_face_create_for_ft_face
  type(c_ptr), value :: face
  integer(c_int), value :: load_flags
end function

!  FT_Face cairo_ft_scaled_font_lock_face (cairo_scaled_font_t *scaled_font);
function cairo_ft_scaled_font_lock_face(scaled_font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_ft_scaled_font_lock_face
  type(c_ptr), value :: scaled_font
end function

!  void cairo_ft_scaled_font_unlock_face (cairo_scaled_font_t *scaled_font);
subroutine cairo_ft_scaled_font_unlock_face(scaled_font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: scaled_font
end subroutine

!  cairo_font_face_t * cairo_ft_font_face_create_for_pattern (FcPattern *pattern);
function cairo_ft_font_face_create_for_pattern(pattern) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: cairo_ft_font_face_create_for_pattern
  type(c_ptr), value :: pattern
end function

!  void cairo_ft_font_options_substitute (const cairo_font_options_t *options, FcPattern *pattern);
subroutine cairo_ft_font_options_substitute(options, pattern) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: options
  type(c_ptr), value :: pattern
end subroutine

!   double pango_gravity_to_rotation (PangoGravity gravity) G_GNUC_CONST;
function pango_gravity_to_rotation(gravity) bind(c) 
  use iso_c_binding, only: c_double, c_int
  real(c_double) :: pango_gravity_to_rotation
  integer(c_int), value :: gravity
end function

! PangoGravity pango_gravity_get_for_matrix (const PangoMatrix *matrix) G_GNUC_PURE;
function pango_gravity_get_for_matrix(matrix) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_gravity_get_for_matrix
  type(c_ptr), value :: matrix
end function

! PangoGravity pango_gravity_get_for_script (PangoScript script, PangoGravity base_gravity, PangoGravityHint hint) G_GNUC_CONST;
function pango_gravity_get_for_script(script, base_gravity, hint) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: pango_gravity_get_for_script
  integer(c_int), value :: script
  integer(c_int), value :: base_gravity
  integer(c_int), value :: hint
end function

! PangoGravity pango_gravity_get_for_script_and_width (PangoScript script, gboolean wide, PangoGravity base_gravity, PangoGravityHint hint) G_GNUC_CONST;
function pango_gravity_get_for_script_and_width(script, wide, base_gravity, hint&
      &) bind(c) 
  use iso_c_binding, only: c_int, c_bool
  integer(c_int) :: pango_gravity_get_for_script_and_width
  integer(c_int), value :: script
  logical(c_bool), value :: wide
  integer(c_int), value :: base_gravity
  integer(c_int), value :: hint
end function

!   GType pango_item_get_type (void) G_GNUC_CONST;
function pango_item_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_item_get_type
end function

!  PangoItem *pango_item_new (void);
function pango_item_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_item_new
end function

! PangoItem *pango_item_copy (PangoItem *item);
function pango_item_copy(item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_item_copy
  type(c_ptr), value :: item
end function

! void pango_item_free (PangoItem *item);
subroutine pango_item_free(item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: item
end subroutine

! PangoItem *pango_item_split (PangoItem *orig, int split_index, int split_offset);
function pango_item_split(orig, split_index, split_offset) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_item_split
  type(c_ptr), value :: orig
  integer(c_int), value :: split_index
  integer(c_int), value :: split_offset
end function

!   PangoLanguage *pango_fc_fontset_key_get_language (const PangoFcFontsetKey *key);
function pango_fc_fontset_key_get_language(key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_fc_fontset_key_get_language
  type(c_ptr), value :: key
end function

! const PangoFontDescription *pango_fc_fontset_key_get_description (const PangoFcFontsetKey *key);
function pango_fc_fontset_key_get_description(key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_fc_fontset_key_get_description
  type(c_ptr), value :: key
end function

! const PangoMatrix *pango_fc_fontset_key_get_matrix (const PangoFcFontsetKey *key);
function pango_fc_fontset_key_get_matrix(key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_fc_fontset_key_get_matrix
  type(c_ptr), value :: key
end function

! double pango_fc_fontset_key_get_absolute_size (const PangoFcFontsetKey *key);
function pango_fc_fontset_key_get_absolute_size(key) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: pango_fc_fontset_key_get_absolute_size
  type(c_ptr), value :: key
end function

! double pango_fc_fontset_key_get_resolution (const PangoFcFontsetKey *key);
function pango_fc_fontset_key_get_resolution(key) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: pango_fc_fontset_key_get_resolution
  type(c_ptr), value :: key
end function

! gpointer pango_fc_fontset_key_get_context_key (const PangoFcFontsetKey *key);
function pango_fc_fontset_key_get_context_key(key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_fc_fontset_key_get_context_key
  type(c_ptr), value :: key
end function

!  const FcPattern *pango_fc_font_key_get_pattern (const PangoFcFontKey *key);
function pango_fc_font_key_get_pattern(key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_fc_font_key_get_pattern
  type(c_ptr), value :: key
end function

! const PangoMatrix *pango_fc_font_key_get_matrix (const PangoFcFontKey *key);
function pango_fc_font_key_get_matrix(key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_fc_font_key_get_matrix
  type(c_ptr), value :: key
end function

! gpointer pango_fc_font_key_get_context_key (const PangoFcFontKey *key);
function pango_fc_font_key_get_context_key(key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_fc_font_key_get_context_key
  type(c_ptr), value :: key
end function

!  PangoContext * pango_fc_font_map_create_context (PangoFcFontMap *fcfontmap);
function pango_fc_font_map_create_context(fcfontmap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_fc_font_map_create_context
  type(c_ptr), value :: fcfontmap
end function

!  void pango_fc_font_map_shutdown (PangoFcFontMap *fcfontmap);
subroutine pango_fc_font_map_shutdown(fcfontmap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: fcfontmap
end subroutine

!  GType pango_fc_font_map_get_type (void) G_GNUC_CONST;
function pango_fc_font_map_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_fc_font_map_get_type
end function

!  void pango_fc_font_map_cache_clear (PangoFcFontMap *fcfontmap);
subroutine pango_fc_font_map_cache_clear(fcfontmap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: fcfontmap
end subroutine

!  void pango_fc_font_map_add_decoder_find_func (PangoFcFontMap *fcfontmap, PangoFcDecoderFindFunc findfunc, gpointer user_data, GDestroyNotify dnotify);
subroutine pango_fc_font_map_add_decoder_find_func(fcfontmap, findfunc, user_dat&
      &a, dnotify) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: fcfontmap
  type(c_funptr), value :: findfunc
  type(c_ptr), value :: user_data
  type(c_funptr), value :: dnotify
end subroutine

! PangoFcDecoder *pango_fc_font_map_find_decoder (PangoFcFontMap *fcfontmap, FcPattern *pattern);
function pango_fc_font_map_find_decoder(fcfontmap, pattern) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_fc_font_map_find_decoder
  type(c_ptr), value :: fcfontmap
  type(c_ptr), value :: pattern
end function

!  PangoFontDescription *pango_fc_font_description_from_pattern (FcPattern *pattern, gboolean include_size);
function pango_fc_font_description_from_pattern(pattern, include_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: pango_fc_font_description_from_pattern
  type(c_ptr), value :: pattern
  logical(c_bool), value :: include_size
end function

!   GType pango_cairo_font_map_get_type (void) G_GNUC_CONST;
function pango_cairo_font_map_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_cairo_font_map_get_type
end function

!  PangoFontMap *pango_cairo_font_map_new (void);
function pango_cairo_font_map_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_cairo_font_map_new
end function

! PangoFontMap *pango_cairo_font_map_new_for_font_type (cairo_font_type_t fonttype);
function pango_cairo_font_map_new_for_font_type(fonttype) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_cairo_font_map_new_for_font_type
  integer(c_int), value :: fonttype
end function

! PangoFontMap *pango_cairo_font_map_get_default (void);
function pango_cairo_font_map_get_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_cairo_font_map_get_default
end function

! void pango_cairo_font_map_set_default (PangoCairoFontMap *fontmap);
subroutine pango_cairo_font_map_set_default(fontmap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: fontmap
end subroutine

! cairo_font_type_t pango_cairo_font_map_get_font_type (PangoCairoFontMap *fontmap);
function pango_cairo_font_map_get_font_type(fontmap) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_cairo_font_map_get_font_type
  type(c_ptr), value :: fontmap
end function

!  void pango_cairo_font_map_set_resolution (PangoCairoFontMap *fontmap, double dpi);
subroutine pango_cairo_font_map_set_resolution(fontmap, dpi) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: fontmap
  real(c_double), value :: dpi
end subroutine

! double pango_cairo_font_map_get_resolution (PangoCairoFontMap *fontmap);
function pango_cairo_font_map_get_resolution(fontmap) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: pango_cairo_font_map_get_resolution
  type(c_ptr), value :: fontmap
end function

!  PangoContext *pango_cairo_font_map_create_context (PangoCairoFontMap *fontmap);
function pango_cairo_font_map_create_context(fontmap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_cairo_font_map_create_context
  type(c_ptr), value :: fontmap
end function

!  GType pango_cairo_font_get_type (void) G_GNUC_CONST;
function pango_cairo_font_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_cairo_font_get_type
end function

!  cairo_scaled_font_t *pango_cairo_font_get_scaled_font (PangoCairoFont *font);
function pango_cairo_font_get_scaled_font(font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_cairo_font_get_scaled_font
  type(c_ptr), value :: font
end function

!  void pango_cairo_update_context (cairo_t *cr, PangoContext *context);
subroutine pango_cairo_update_context(cr, context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: context
end subroutine

!  void pango_cairo_context_set_font_options (PangoContext *context, const cairo_font_options_t *options);
subroutine pango_cairo_context_set_font_options(context, options) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: options
end subroutine

! const cairo_font_options_t *pango_cairo_context_get_font_options (PangoContext *context);
function pango_cairo_context_get_font_options(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_cairo_context_get_font_options
  type(c_ptr), value :: context
end function

!  void pango_cairo_context_set_resolution (PangoContext *context, double dpi);
subroutine pango_cairo_context_set_resolution(context, dpi) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: context
  real(c_double), value :: dpi
end subroutine

! double pango_cairo_context_get_resolution (PangoContext *context);
function pango_cairo_context_get_resolution(context) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: pango_cairo_context_get_resolution
  type(c_ptr), value :: context
end function

!  void pango_cairo_context_set_shape_renderer (PangoContext *context, PangoCairoShapeRendererFunc func, gpointer data, GDestroyNotify dnotify);
subroutine pango_cairo_context_set_shape_renderer(context, func, data, dnotify) &
      &bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: context
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: dnotify
end subroutine

! PangoCairoShapeRendererFunc pango_cairo_context_get_shape_renderer (PangoContext *context, gpointer *data);
function pango_cairo_context_get_shape_renderer(context, data) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr) :: pango_cairo_context_get_shape_renderer
  type(c_ptr), value :: context
  type(c_ptr), value :: data
end function

!  PangoContext *pango_cairo_create_context (cairo_t *cr);
function pango_cairo_create_context(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_cairo_create_context
  type(c_ptr), value :: cr
end function

! PangoLayout *pango_cairo_create_layout (cairo_t *cr);
function pango_cairo_create_layout(cr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_cairo_create_layout
  type(c_ptr), value :: cr
end function

! void pango_cairo_update_layout (cairo_t *cr, PangoLayout *layout);
subroutine pango_cairo_update_layout(cr, layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: layout
end subroutine

!  void pango_cairo_show_glyph_string (cairo_t *cr, PangoFont *font, PangoGlyphString *glyphs);
subroutine pango_cairo_show_glyph_string(cr, font, glyphs) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: font
  type(c_ptr), value :: glyphs
end subroutine

! void pango_cairo_show_glyph_item (cairo_t *cr, const char *text, PangoGlyphItem *glyph_item);
subroutine pango_cairo_show_glyph_item(cr, text, glyph_item) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: cr
  character(kind=c_char), dimension(*) :: text
  type(c_ptr), value :: glyph_item
end subroutine

! void pango_cairo_show_layout_line (cairo_t *cr, PangoLayoutLine *line);
subroutine pango_cairo_show_layout_line(cr, line) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: line
end subroutine

! void pango_cairo_show_layout (cairo_t *cr, PangoLayout *layout);
subroutine pango_cairo_show_layout(cr, layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: layout
end subroutine

!  void pango_cairo_show_error_underline (cairo_t *cr, double x, double y, double width, double height);
subroutine pango_cairo_show_error_underline(cr, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: x
  real(c_double), value :: y
  real(c_double), value :: width
  real(c_double), value :: height
end subroutine

!  void pango_cairo_glyph_string_path (cairo_t *cr, PangoFont *font, PangoGlyphString *glyphs);
subroutine pango_cairo_glyph_string_path(cr, font, glyphs) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: font
  type(c_ptr), value :: glyphs
end subroutine

! void pango_cairo_layout_line_path (cairo_t *cr, PangoLayoutLine *line);
subroutine pango_cairo_layout_line_path(cr, line) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: line
end subroutine

! void pango_cairo_layout_path (cairo_t *cr, PangoLayout *layout);
subroutine pango_cairo_layout_path(cr, layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cr
  type(c_ptr), value :: layout
end subroutine

!  void pango_cairo_error_underline_path (cairo_t *cr, double x, double y, double width, double height);
subroutine pango_cairo_error_underline_path(cr, x, y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: cr
  real(c_double), value :: x
  real(c_double), value :: y
  real(c_double), value :: width
  real(c_double), value :: height
end subroutine

!   char ** pango_split_file_list (const char *str);
function pango_split_file_list(str) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: pango_split_file_list
  character(kind=c_char), dimension(*) :: str
end function

!  char *pango_trim_string (const char *str);
function pango_trim_string(str) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: pango_trim_string
  character(kind=c_char), dimension(*) :: str
end function

! gint pango_read_line (FILE *stream, GString *str);
function pango_read_line(stream, str) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_read_line
  type(c_ptr), value :: stream
  type(c_ptr), value :: str
end function

! gboolean pango_skip_space (const char **pos);
function pango_skip_space(pos) bind(c) 
  use iso_c_binding, only: c_bool, c_char
  logical(c_bool) :: pango_skip_space
  character(kind=c_char), dimension(*) :: pos
end function

! gboolean pango_scan_word (const char **pos, GString *out);
function pango_scan_word(pos, out) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_ptr
  logical(c_bool) :: pango_scan_word
  character(kind=c_char), dimension(*) :: pos
  type(c_ptr), value :: out
end function

! gboolean pango_scan_string (const char **pos, GString *out);
function pango_scan_string(pos, out) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_ptr
  logical(c_bool) :: pango_scan_string
  character(kind=c_char), dimension(*) :: pos
  type(c_ptr), value :: out
end function

! gboolean pango_scan_int (const char **pos, int *out);
function pango_scan_int(pos, out) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_ptr
  logical(c_bool) :: pango_scan_int
  character(kind=c_char), dimension(*) :: pos
  type(c_ptr), value :: out
end function

!  char * pango_config_key_get (const char *key);
function pango_config_key_get(key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: pango_config_key_get
  character(kind=c_char), dimension(*) :: key
end function

! void pango_lookup_aliases (const char *fontname, char ***families, int *n_families);
subroutine pango_lookup_aliases(fontname, families, n_families) bind(c) 
  use iso_c_binding, only: c_char, c_ptr
  character(kind=c_char), dimension(*) :: fontname
  character(kind=c_char), dimension(*) :: families
  type(c_ptr), value :: n_families
end subroutine

!  gboolean pango_parse_enum (GType type, const char *str, int *value, gboolean warn, char **possible_values);
function pango_parse_enum(type, str, value, warn, possible_values) bind(c) 
  use iso_c_binding, only: c_bool, c_size_t, c_char, c_ptr
  logical(c_bool) :: pango_parse_enum
  integer(c_size_t), value :: type
  character(kind=c_char), dimension(*) :: str
  type(c_ptr), value :: value
  logical(c_bool), value :: warn
  character(kind=c_char), dimension(*) :: possible_values
end function

!  gboolean pango_parse_style (const char *str, PangoStyle *style, gboolean warn);
function pango_parse_style(str, style, warn) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_int
  logical(c_bool) :: pango_parse_style
  character(kind=c_char), dimension(*) :: str
  integer(c_int), value :: style
  logical(c_bool), value :: warn
end function

! gboolean pango_parse_variant (const char *str, PangoVariant *variant, gboolean warn);
function pango_parse_variant(str, variant, warn) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_int
  logical(c_bool) :: pango_parse_variant
  character(kind=c_char), dimension(*) :: str
  integer(c_int), value :: variant
  logical(c_bool), value :: warn
end function

! gboolean pango_parse_weight (const char *str, PangoWeight *weight, gboolean warn);
function pango_parse_weight(str, weight, warn) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_int
  logical(c_bool) :: pango_parse_weight
  character(kind=c_char), dimension(*) :: str
  integer(c_int), value :: weight
  logical(c_bool), value :: warn
end function

! gboolean pango_parse_stretch (const char *str, PangoStretch *stretch, gboolean warn);
function pango_parse_stretch(str, stretch, warn) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_int
  logical(c_bool) :: pango_parse_stretch
  character(kind=c_char), dimension(*) :: str
  integer(c_int), value :: stretch
  logical(c_bool), value :: warn
end function

!  G_CONST_RETURN char * pango_get_sysconf_subdirectory (void) G_GNUC_PURE;
function pango_get_sysconf_subdirectory() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_get_sysconf_subdirectory
end function

!  G_CONST_RETURN char * pango_get_lib_subdirectory (void) G_GNUC_PURE;
function pango_get_lib_subdirectory() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_get_lib_subdirectory
end function

!  void pango_quantize_line_geometry (int *thickness, int *position);
subroutine pango_quantize_line_geometry(thickness, position) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: thickness
  type(c_ptr), value :: position
end subroutine

!  guint8 * pango_log2vis_get_embedding_levels (const gchar *text, int length, PangoDirection *pbase_dir);
function pango_log2vis_get_embedding_levels(text, length, pbase_dir) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: pango_log2vis_get_embedding_levels
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: length
  integer(c_int), value :: pbase_dir
end function

!  gboolean pango_is_zero_width (gunichar ch) G_GNUC_CONST;
function pango_is_zero_width(ch) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t
  logical(c_bool) :: pango_is_zero_width
  integer(c_int32_t), value :: ch
end function

!  int pango_version (void) G_GNUC_CONST;
function pango_version() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: pango_version
end function

!  G_CONST_RETURN char * pango_version_string (void) G_GNUC_CONST;
function pango_version_string() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_version_string
end function

!  G_CONST_RETURN char * pango_version_check (int required_major, int required_minor, int required_micro) G_GNUC_CONST;
function pango_version_check(required_major, required_minor, required_micro) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_version_check
  integer(c_int), value :: required_major
  integer(c_int), value :: required_minor
  integer(c_int), value :: required_micro
end function

!   GType pango_language_get_type (void) G_GNUC_CONST;
function pango_language_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_language_get_type
end function

! PangoLanguage *pango_language_from_string (const char *language);
function pango_language_from_string(language) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: pango_language_from_string
  character(kind=c_char), dimension(*) :: language
end function

!  G_CONST_RETURN char *pango_language_to_string (PangoLanguage *language) G_GNUC_CONST;
function pango_language_to_string(language) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_language_to_string
  type(c_ptr), value :: language
end function

!  G_CONST_RETURN char *pango_language_get_sample_string (PangoLanguage *language) G_GNUC_CONST;
function pango_language_get_sample_string(language) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_language_get_sample_string
  type(c_ptr), value :: language
end function

! PangoLanguage *pango_language_get_default (void) G_GNUC_CONST;
function pango_language_get_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_language_get_default
end function

!  gboolean pango_language_matches (PangoLanguage *language, const char *range_list) G_GNUC_PURE;
function pango_language_matches(language, range_list) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: pango_language_matches
  type(c_ptr), value :: language
  character(kind=c_char), dimension(*) :: range_list
end function

!  gboolean pango_language_includes_script (PangoLanguage *language, PangoScript script) G_GNUC_PURE;
function pango_language_includes_script(language, script) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: pango_language_includes_script
  type(c_ptr), value :: language
  integer(c_int), value :: script
end function

! G_CONST_RETURN PangoScript *pango_language_get_scripts (PangoLanguage *language, int *num_scripts);
function pango_language_get_scripts(language, num_scripts) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_language_get_scripts
  type(c_ptr), value :: language
  type(c_ptr), value :: num_scripts
end function

!   GType pango_ot_info_get_type (void) G_GNUC_CONST;
function pango_ot_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_ot_info_get_type
end function

!  GType pango_ot_ruleset_get_type (void) G_GNUC_CONST;
function pango_ot_ruleset_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_ot_ruleset_get_type
end function

!  PangoOTInfo *pango_ot_info_get (FT_Face face);
function pango_ot_info_get(face) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_ot_info_get
  type(c_ptr), value :: face
end function

!  gboolean pango_ot_info_find_script (PangoOTInfo *info, PangoOTTableType table_type, PangoOTTag script_tag, guint *script_index);
function pango_ot_info_find_script(info, table_type, script_tag, script_index) b&
      &ind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int, c_int32_t
  logical(c_bool) :: pango_ot_info_find_script
  type(c_ptr), value :: info
  integer(c_int), value :: table_type
  integer(c_int32_t), value :: script_tag
  type(c_ptr), value :: script_index
end function

! gboolean pango_ot_info_find_language (PangoOTInfo *info, PangoOTTableType table_type, guint script_index, PangoOTTag language_tag, guint *language_index, guint *required_feature_index);
function pango_ot_info_find_language(info, table_type, script_index, language_ta&
      &g, language_index, required_feature_index) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int, c_int32_t
  logical(c_bool) :: pango_ot_info_find_language
  type(c_ptr), value :: info
  integer(c_int), value :: table_type
  integer(c_int), value :: script_index
  integer(c_int32_t), value :: language_tag
  type(c_ptr), value :: language_index
  type(c_ptr), value :: required_feature_index
end function

! gboolean pango_ot_info_find_feature (PangoOTInfo *info, PangoOTTableType table_type, PangoOTTag feature_tag, guint script_index, guint language_index, guint *feature_index);
function pango_ot_info_find_feature(info, table_type, feature_tag, script_index,&
      & language_index, feature_index) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int, c_int32_t
  logical(c_bool) :: pango_ot_info_find_feature
  type(c_ptr), value :: info
  integer(c_int), value :: table_type
  integer(c_int32_t), value :: feature_tag
  integer(c_int), value :: script_index
  integer(c_int), value :: language_index
  type(c_ptr), value :: feature_index
end function

!  PangoOTTag *pango_ot_info_list_scripts (PangoOTInfo *info, PangoOTTableType table_type);
function pango_ot_info_list_scripts(info, table_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_ot_info_list_scripts
  type(c_ptr), value :: info
  integer(c_int), value :: table_type
end function

! PangoOTTag *pango_ot_info_list_languages (PangoOTInfo *info, PangoOTTableType table_type, guint script_index, PangoOTTag language_tag);
function pango_ot_info_list_languages(info, table_type, script_index, language_t&
      &ag) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int32_t
  type(c_ptr) :: pango_ot_info_list_languages
  type(c_ptr), value :: info
  integer(c_int), value :: table_type
  integer(c_int), value :: script_index
  integer(c_int32_t), value :: language_tag
end function

! PangoOTTag *pango_ot_info_list_features (PangoOTInfo *info, PangoOTTableType table_type, PangoOTTag tag, guint script_index, guint language_index);
function pango_ot_info_list_features(info, table_type, tag, script_index, langua&
      &ge_index) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int32_t
  type(c_ptr) :: pango_ot_info_list_features
  type(c_ptr), value :: info
  integer(c_int), value :: table_type
  integer(c_int32_t), value :: tag
  integer(c_int), value :: script_index
  integer(c_int), value :: language_index
end function

!  PangoOTBuffer *pango_ot_buffer_new (PangoFcFont *font);
function pango_ot_buffer_new(font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_ot_buffer_new
  type(c_ptr), value :: font
end function

! void pango_ot_buffer_destroy (PangoOTBuffer *buffer);
subroutine pango_ot_buffer_destroy(buffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
end subroutine

! void pango_ot_buffer_clear (PangoOTBuffer *buffer);
subroutine pango_ot_buffer_clear(buffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
end subroutine

! void pango_ot_buffer_set_rtl (PangoOTBuffer *buffer, gboolean rtl);
subroutine pango_ot_buffer_set_rtl(buffer, rtl) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: buffer
  logical(c_bool), value :: rtl
end subroutine

! void pango_ot_buffer_add_glyph (PangoOTBuffer *buffer, guint glyph, guint properties, guint cluster);
subroutine pango_ot_buffer_add_glyph(buffer, glyph, properties, cluster) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: buffer
  integer(c_int), value :: glyph
  integer(c_int), value :: properties
  integer(c_int), value :: cluster
end subroutine

! void pango_ot_buffer_get_glyphs (const PangoOTBuffer *buffer, PangoOTGlyph **glyphs, int *n_glyphs);
subroutine pango_ot_buffer_get_glyphs(buffer, glyphs, n_glyphs) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: glyphs
  type(c_ptr), value :: n_glyphs
end subroutine

! void pango_ot_buffer_output (const PangoOTBuffer *buffer, PangoGlyphString *glyphs);
subroutine pango_ot_buffer_output(buffer, glyphs) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: buffer
  type(c_ptr), value :: glyphs
end subroutine

!  void pango_ot_buffer_set_zero_width_marks (PangoOTBuffer *buffer, gboolean zero_width_marks);
subroutine pango_ot_buffer_set_zero_width_marks(buffer, zero_width_marks) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: buffer
  logical(c_bool), value :: zero_width_marks
end subroutine

!  const PangoOTRuleset *pango_ot_ruleset_get_for_description (PangoOTInfo *info, const PangoOTRulesetDescription *desc);
function pango_ot_ruleset_get_for_description(info, desc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_ot_ruleset_get_for_description
  type(c_ptr), value :: info
  type(c_ptr), value :: desc
end function

! PangoOTRuleset *pango_ot_ruleset_new (PangoOTInfo *info);
function pango_ot_ruleset_new(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_ot_ruleset_new
  type(c_ptr), value :: info
end function

! PangoOTRuleset *pango_ot_ruleset_new_for (PangoOTInfo *info, PangoScript script, PangoLanguage *language);
function pango_ot_ruleset_new_for(info, script, language) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_ot_ruleset_new_for
  type(c_ptr), value :: info
  integer(c_int), value :: script
  type(c_ptr), value :: language
end function

! PangoOTRuleset *pango_ot_ruleset_new_from_description (PangoOTInfo *info, const PangoOTRulesetDescription *desc);
function pango_ot_ruleset_new_from_description(info, desc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_ot_ruleset_new_from_description
  type(c_ptr), value :: info
  type(c_ptr), value :: desc
end function

! void pango_ot_ruleset_add_feature (PangoOTRuleset *ruleset, PangoOTTableType table_type, guint feature_index, gulong property_bit);
subroutine pango_ot_ruleset_add_feature(ruleset, table_type, feature_index, prop&
      &erty_bit) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_long
  type(c_ptr), value :: ruleset
  integer(c_int), value :: table_type
  integer(c_int), value :: feature_index
  integer(c_long), value :: property_bit
end subroutine

! gboolean pango_ot_ruleset_maybe_add_feature (PangoOTRuleset *ruleset, PangoOTTableType table_type, PangoOTTag feature_tag, gulong property_bit);
function pango_ot_ruleset_maybe_add_feature(ruleset, table_type, feature_tag, pr&
      &operty_bit) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int, c_int32_t, c_long
  logical(c_bool) :: pango_ot_ruleset_maybe_add_feature
  type(c_ptr), value :: ruleset
  integer(c_int), value :: table_type
  integer(c_int32_t), value :: feature_tag
  integer(c_long), value :: property_bit
end function

! guint pango_ot_ruleset_maybe_add_features (PangoOTRuleset *ruleset, PangoOTTableType table_type, const PangoOTFeatureMap *features, guint n_features);
function pango_ot_ruleset_maybe_add_features(ruleset, table_type, features, n_fe&
      &atures) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_ot_ruleset_maybe_add_features
  type(c_ptr), value :: ruleset
  integer(c_int), value :: table_type
  type(c_ptr), value :: features
  integer(c_int), value :: n_features
end function

! guint pango_ot_ruleset_get_feature_count (const PangoOTRuleset *ruleset, guint *n_gsub_features, guint *n_gpos_features);
function pango_ot_ruleset_get_feature_count(ruleset, n_gsub_features, n_gpos_fea&
      &tures) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_ot_ruleset_get_feature_count
  type(c_ptr), value :: ruleset
  type(c_ptr), value :: n_gsub_features
  type(c_ptr), value :: n_gpos_features
end function

! void pango_ot_ruleset_substitute (const PangoOTRuleset *ruleset, PangoOTBuffer *buffer);
subroutine pango_ot_ruleset_substitute(ruleset, buffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ruleset
  type(c_ptr), value :: buffer
end subroutine

! void pango_ot_ruleset_position (const PangoOTRuleset *ruleset, PangoOTBuffer *buffer);
subroutine pango_ot_ruleset_position(ruleset, buffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: ruleset
  type(c_ptr), value :: buffer
end subroutine

! PangoScript pango_ot_tag_to_script (PangoOTTag script_tag) G_GNUC_CONST;
function pango_ot_tag_to_script(script_tag) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: pango_ot_tag_to_script
  integer(c_int32_t), value :: script_tag
end function

! PangoOTTag pango_ot_tag_from_script (PangoScript script) G_GNUC_CONST;
function pango_ot_tag_from_script(script) bind(c) 
  use iso_c_binding, only: c_int32_t, c_int
  integer(c_int32_t) :: pango_ot_tag_from_script
  integer(c_int), value :: script
end function

! PangoLanguage *pango_ot_tag_to_language (PangoOTTag language_tag) G_GNUC_CONST;
function pango_ot_tag_to_language(language_tag) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: pango_ot_tag_to_language
  integer(c_int32_t), value :: language_tag
end function

! PangoOTTag pango_ot_tag_from_language (PangoLanguage *language) G_GNUC_CONST;
function pango_ot_tag_from_language(language) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: pango_ot_tag_from_language
  type(c_ptr), value :: language
end function

!  guint pango_ot_ruleset_description_hash (const PangoOTRulesetDescription *desc) G_GNUC_PURE;
function pango_ot_ruleset_description_hash(desc) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_ot_ruleset_description_hash
  type(c_ptr), value :: desc
end function

! gboolean pango_ot_ruleset_description_equal (const PangoOTRulesetDescription *desc1, const PangoOTRulesetDescription *desc2) G_GNUC_PURE;
function pango_ot_ruleset_description_equal(desc1, desc2) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_ot_ruleset_description_equal
  type(c_ptr), value :: desc1
  type(c_ptr), value :: desc2
end function

! PangoOTRulesetDescription *pango_ot_ruleset_description_copy (const PangoOTRulesetDescription *desc);
function pango_ot_ruleset_description_copy(desc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_ot_ruleset_description_copy
  type(c_ptr), value :: desc
end function

! void pango_ot_ruleset_description_free (PangoOTRulesetDescription *desc);
subroutine pango_ot_ruleset_description_free(desc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: desc
end subroutine

!   PangoCoverage * pango_coverage_new (void);
function pango_coverage_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_coverage_new
end function

! PangoCoverage * pango_coverage_ref (PangoCoverage *coverage);
function pango_coverage_ref(coverage) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_coverage_ref
  type(c_ptr), value :: coverage
end function

! void pango_coverage_unref (PangoCoverage *coverage);
subroutine pango_coverage_unref(coverage) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: coverage
end subroutine

! PangoCoverage * pango_coverage_copy (PangoCoverage *coverage);
function pango_coverage_copy(coverage) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_coverage_copy
  type(c_ptr), value :: coverage
end function

! PangoCoverageLevel pango_coverage_get (PangoCoverage *coverage, int index_);
function pango_coverage_get(coverage, index_) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_coverage_get
  type(c_ptr), value :: coverage
  integer(c_int), value :: index_
end function

! void pango_coverage_set (PangoCoverage *coverage, int index_, PangoCoverageLevel level);
subroutine pango_coverage_set(coverage, index_, level) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: coverage
  integer(c_int), value :: index_
  integer(c_int), value :: level
end subroutine

! void pango_coverage_max (PangoCoverage *coverage, PangoCoverage *other);
subroutine pango_coverage_max(coverage, other) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: coverage
  type(c_ptr), value :: other
end subroutine

!  void pango_coverage_to_bytes (PangoCoverage *coverage, guchar **bytes, int *n_bytes);
subroutine pango_coverage_to_bytes(coverage, bytes, n_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: coverage
  character(kind=c_char), dimension(*) :: bytes
  type(c_ptr), value :: n_bytes
end subroutine

! PangoCoverage *pango_coverage_from_bytes (guchar *bytes, int n_bytes);
function pango_coverage_from_bytes(bytes, n_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: pango_coverage_from_bytes
  character(kind=c_char), dimension(*) :: bytes
  integer(c_int), value :: n_bytes
end function

!   GType pango_fontset_get_type (void) G_GNUC_CONST;
function pango_fontset_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_fontset_get_type
end function

!  PangoFont * pango_fontset_get_font (PangoFontset *fontset, guint wc);
function pango_fontset_get_font(fontset, wc) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_fontset_get_font
  type(c_ptr), value :: fontset
  integer(c_int), value :: wc
end function

! PangoFontMetrics *pango_fontset_get_metrics (PangoFontset *fontset);
function pango_fontset_get_metrics(fontset) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_fontset_get_metrics
  type(c_ptr), value :: fontset
end function

! void pango_fontset_foreach (PangoFontset *fontset, PangoFontsetForeachFunc func, gpointer data);
subroutine pango_fontset_foreach(fontset, func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: fontset
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end subroutine

!  GType pango_fontset_simple_get_type (void) G_GNUC_CONST;
function pango_fontset_simple_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_fontset_simple_get_type
end function

!  PangoFontsetSimple * pango_fontset_simple_new (PangoLanguage *language);
function pango_fontset_simple_new(language) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_fontset_simple_new
  type(c_ptr), value :: language
end function

! void pango_fontset_simple_append (PangoFontsetSimple *fontset, PangoFont *font);
subroutine pango_fontset_simple_append(fontset, font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: fontset
  type(c_ptr), value :: font
end subroutine

! int pango_fontset_simple_size (PangoFontsetSimple *fontset);
function pango_fontset_simple_size(fontset) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_fontset_simple_size
  type(c_ptr), value :: fontset
end function

!   GType pango_renderer_get_type (void) G_GNUC_CONST;
function pango_renderer_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_renderer_get_type
end function

!  void pango_renderer_draw_layout (PangoRenderer *renderer, PangoLayout *layout, int x, int y);
subroutine pango_renderer_draw_layout(renderer, layout, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: renderer
  type(c_ptr), value :: layout
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void pango_renderer_draw_layout_line (PangoRenderer *renderer, PangoLayoutLine *line, int x, int y);
subroutine pango_renderer_draw_layout_line(renderer, line, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: renderer
  type(c_ptr), value :: line
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void pango_renderer_draw_glyphs (PangoRenderer *renderer, PangoFont *font, PangoGlyphString *glyphs, int x, int y);
subroutine pango_renderer_draw_glyphs(renderer, font, glyphs, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: renderer
  type(c_ptr), value :: font
  type(c_ptr), value :: glyphs
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void pango_renderer_draw_glyph_item (PangoRenderer *renderer, const char *text, PangoGlyphItem *glyph_item, int x, int y);
subroutine pango_renderer_draw_glyph_item(renderer, text, glyph_item, x, y) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: renderer
  character(kind=c_char), dimension(*) :: text
  type(c_ptr), value :: glyph_item
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void pango_renderer_draw_rectangle (PangoRenderer *renderer, PangoRenderPart part, int x, int y, int width, int height);
subroutine pango_renderer_draw_rectangle(renderer, part, x, y, width, height) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: renderer
  integer(c_int), value :: part
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void pango_renderer_draw_error_underline (PangoRenderer *renderer, int x, int y, int width, int height);
subroutine pango_renderer_draw_error_underline(renderer, x, y, width, height) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: renderer
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! void pango_renderer_draw_trapezoid (PangoRenderer *renderer, PangoRenderPart part, double y1_, double x11, double x21, double y2, double x12, double x22);
subroutine pango_renderer_draw_trapezoid(renderer, part, y1_, x11, x21, y2, x12,&
      & x22) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_double
  type(c_ptr), value :: renderer
  integer(c_int), value :: part
  real(c_double), value :: y1_
  real(c_double), value :: x11
  real(c_double), value :: x21
  real(c_double), value :: y2
  real(c_double), value :: x12
  real(c_double), value :: x22
end subroutine

! void pango_renderer_draw_glyph (PangoRenderer *renderer, PangoFont *font, PangoGlyph glyph, double x, double y);
subroutine pango_renderer_draw_glyph(renderer, font, glyph, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_double
  type(c_ptr), value :: renderer
  type(c_ptr), value :: font
  integer(c_int32_t), value :: glyph
  real(c_double), value :: x
  real(c_double), value :: y
end subroutine

!  void pango_renderer_activate (PangoRenderer *renderer);
subroutine pango_renderer_activate(renderer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: renderer
end subroutine

! void pango_renderer_deactivate (PangoRenderer *renderer);
subroutine pango_renderer_deactivate(renderer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: renderer
end subroutine

!  void pango_renderer_part_changed (PangoRenderer *renderer, PangoRenderPart part);
subroutine pango_renderer_part_changed(renderer, part) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: renderer
  integer(c_int), value :: part
end subroutine

!  void pango_renderer_set_color (PangoRenderer *renderer, PangoRenderPart part, const PangoColor *color);
subroutine pango_renderer_set_color(renderer, part, color) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: renderer
  integer(c_int), value :: part
  type(c_ptr), value :: color
end subroutine

! PangoColor *pango_renderer_get_color (PangoRenderer *renderer, PangoRenderPart part);
function pango_renderer_get_color(renderer, part) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_renderer_get_color
  type(c_ptr), value :: renderer
  integer(c_int), value :: part
end function

!  void pango_renderer_set_matrix (PangoRenderer *renderer, const PangoMatrix *matrix);
subroutine pango_renderer_set_matrix(renderer, matrix) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: renderer
  type(c_ptr), value :: matrix
end subroutine

! G_CONST_RETURN PangoMatrix *pango_renderer_get_matrix (PangoRenderer *renderer);
function pango_renderer_get_matrix(renderer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_renderer_get_matrix
  type(c_ptr), value :: renderer
end function

!  PangoLayout *pango_renderer_get_layout (PangoRenderer *renderer);
function pango_renderer_get_layout(renderer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_renderer_get_layout
  type(c_ptr), value :: renderer
end function

! PangoLayoutLine *pango_renderer_get_layout_line (PangoRenderer *renderer);
function pango_renderer_get_layout_line(renderer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_renderer_get_layout_line
  type(c_ptr), value :: renderer
end function

!   gboolean pango_fc_font_has_char (PangoFcFont *font, gunichar wc);
function pango_fc_font_has_char(font, wc) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int32_t
  logical(c_bool) :: pango_fc_font_has_char
  type(c_ptr), value :: font
  integer(c_int32_t), value :: wc
end function

! guint pango_fc_font_get_glyph (PangoFcFont *font, gunichar wc);
function pango_fc_font_get_glyph(font, wc) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int32_t
  integer(c_int) :: pango_fc_font_get_glyph
  type(c_ptr), value :: font
  integer(c_int32_t), value :: wc
end function

!  PangoGlyph pango_fc_font_get_unknown_glyph (PangoFcFont *font, gunichar wc);
function pango_fc_font_get_unknown_glyph(font, wc) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: pango_fc_font_get_unknown_glyph
  type(c_ptr), value :: font
  integer(c_int32_t), value :: wc
end function

!  void pango_fc_font_kern_glyphs (PangoFcFont *font, PangoGlyphString *glyphs);
subroutine pango_fc_font_kern_glyphs(font, glyphs) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: font
  type(c_ptr), value :: glyphs
end subroutine

!  GType pango_fc_font_get_type (void) G_GNUC_CONST;
function pango_fc_font_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_fc_font_get_type
end function

!  FT_Face pango_fc_font_lock_face (PangoFcFont *font);
function pango_fc_font_lock_face(font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_fc_font_lock_face
  type(c_ptr), value :: font
end function

! void pango_fc_font_unlock_face (PangoFcFont *font);
subroutine pango_fc_font_unlock_face(font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: font
end subroutine

!   GType pango_engine_get_type (void) G_GNUC_CONST;
function pango_engine_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_engine_get_type
end function

!  GType pango_engine_lang_get_type (void) G_GNUC_CONST;
function pango_engine_lang_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_engine_lang_get_type
end function

!  GType pango_engine_shape_get_type (void) G_GNUC_CONST;
function pango_engine_shape_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_engine_shape_get_type
end function

!  void script_engine_list (PangoEngineInfo **engines, int *n_engines);
subroutine script_engine_list(engines, n_engines) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: engines
  type(c_ptr), value :: n_engines
end subroutine

!  void script_engine_init (GTypeModule *module);
subroutine script_engine_init(module) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: module
end subroutine

!  void script_engine_exit (void);
subroutine script_engine_exit() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  PangoEngine *script_engine_create (const char *id);
function script_engine_create(id) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: script_engine_create
  character(kind=c_char), dimension(*) :: id
end function

!   void pango_ft2_render (FT_Bitmap *bitmap, PangoFont *font, PangoGlyphString *glyphs, gint x, gint y);
subroutine pango_ft2_render(bitmap, font, glyphs, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: bitmap
  type(c_ptr), value :: font
  type(c_ptr), value :: glyphs
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void pango_ft2_render_transformed (FT_Bitmap *bitmap, const PangoMatrix *matrix, PangoFont *font, PangoGlyphString *glyphs, int x, int y);
subroutine pango_ft2_render_transformed(bitmap, matrix, font, glyphs, x, y) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: bitmap
  type(c_ptr), value :: matrix
  type(c_ptr), value :: font
  type(c_ptr), value :: glyphs
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

!  void pango_ft2_render_layout_line (FT_Bitmap *bitmap, PangoLayoutLine *line, int x, int y);
subroutine pango_ft2_render_layout_line(bitmap, line, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: bitmap
  type(c_ptr), value :: line
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void pango_ft2_render_layout_line_subpixel (FT_Bitmap *bitmap, PangoLayoutLine *line, int x, int y);
subroutine pango_ft2_render_layout_line_subpixel(bitmap, line, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: bitmap
  type(c_ptr), value :: line
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void pango_ft2_render_layout (FT_Bitmap *bitmap, PangoLayout *layout, int x, int y);
subroutine pango_ft2_render_layout(bitmap, layout, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: bitmap
  type(c_ptr), value :: layout
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void pango_ft2_render_layout_subpixel (FT_Bitmap *bitmap, PangoLayout *layout, int x, int y);
subroutine pango_ft2_render_layout_subpixel(bitmap, layout, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: bitmap
  type(c_ptr), value :: layout
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

!  GType pango_ft2_font_map_get_type (void) G_GNUC_CONST;
function pango_ft2_font_map_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_ft2_font_map_get_type
end function

!  PangoFontMap *pango_ft2_font_map_new (void);
function pango_ft2_font_map_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_ft2_font_map_new
end function

! void pango_ft2_font_map_set_resolution (PangoFT2FontMap *fontmap, double dpi_x, double dpi_y);
subroutine pango_ft2_font_map_set_resolution(fontmap, dpi_x, dpi_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: fontmap
  real(c_double), value :: dpi_x
  real(c_double), value :: dpi_y
end subroutine

! void pango_ft2_font_map_set_default_substitute (PangoFT2FontMap *fontmap, PangoFT2SubstituteFunc func, gpointer data, GDestroyNotify notify);
subroutine pango_ft2_font_map_set_default_substitute(fontmap, func, data, notify&
      &) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: fontmap
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end subroutine

! void pango_ft2_font_map_substitute_changed (PangoFT2FontMap *fontmap);
subroutine pango_ft2_font_map_substitute_changed(fontmap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: fontmap
end subroutine

!  PangoContext *pango_ft2_font_map_create_context (PangoFT2FontMap *fontmap);
function pango_ft2_font_map_create_context(fontmap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_ft2_font_map_create_context
  type(c_ptr), value :: fontmap
end function

!  PangoContext *pango_ft2_get_context (double dpi_x, double dpi_y);
function pango_ft2_get_context(dpi_x, dpi_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr) :: pango_ft2_get_context
  real(c_double), value :: dpi_x
  real(c_double), value :: dpi_y
end function

! PangoFontMap *pango_ft2_font_map_for_display (void);
function pango_ft2_font_map_for_display() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_ft2_font_map_for_display
end function

! void pango_ft2_shutdown_display (void);
subroutine pango_ft2_shutdown_display() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  PangoGlyph pango_ft2_get_unknown_glyph (PangoFont *font);
function pango_ft2_get_unknown_glyph(font) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: pango_ft2_get_unknown_glyph
  type(c_ptr), value :: font
end function

! int pango_ft2_font_get_kerning (PangoFont *font, PangoGlyph left, PangoGlyph right);
function pango_ft2_font_get_kerning(font, left, right) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int32_t
  integer(c_int) :: pango_ft2_font_get_kerning
  type(c_ptr), value :: font
  integer(c_int32_t), value :: left
  integer(c_int32_t), value :: right
end function

! FT_Face pango_ft2_font_get_face (PangoFont *font);
function pango_ft2_font_get_face(font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_ft2_font_get_face
  type(c_ptr), value :: font
end function

! PangoCoverage *pango_ft2_font_get_coverage (PangoFont *font, PangoLanguage *language);
function pango_ft2_font_get_coverage(font, language) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_ft2_font_get_coverage
  type(c_ptr), value :: font
  type(c_ptr), value :: language
end function

!   PangoMap * pango_find_map (PangoLanguage *language, guint engine_type_id, guint render_type_id);
function pango_find_map(language, engine_type_id, render_type_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_find_map
  type(c_ptr), value :: language
  integer(c_int), value :: engine_type_id
  integer(c_int), value :: render_type_id
end function

! PangoEngine * pango_map_get_engine (PangoMap *map, PangoScript script);
function pango_map_get_engine(map, script) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_map_get_engine
  type(c_ptr), value :: map
  integer(c_int), value :: script
end function

! void pango_map_get_engines (PangoMap *map, PangoScript script, GSList **exact_engines, GSList **fallback_engines);
subroutine pango_map_get_engines(map, script, exact_engines, fallback_engines) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: map
  integer(c_int), value :: script
  type(c_ptr), value :: exact_engines
  type(c_ptr), value :: fallback_engines
end subroutine

! void pango_module_register (PangoIncludedModule *module);
subroutine pango_module_register(module) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: module
end subroutine

!   PangoContext * pango_x_get_context (Display *display);
function pango_x_get_context(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_x_get_context
  type(c_ptr), value :: display
end function

! void pango_x_context_set_funcs (PangoContext *context, PangoGetGCFunc get_gc_func, PangoFreeGCFunc free_gc_func);
subroutine pango_x_context_set_funcs(context, get_gc_func, free_gc_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: context
  type(c_funptr), value :: get_gc_func
  type(c_funptr), value :: free_gc_func
end subroutine

!  PangoFont * pango_x_load_font (Display *display, const gchar *spec);
function pango_x_load_font(display, spec) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: pango_x_load_font
  type(c_ptr), value :: display
  character(kind=c_char), dimension(*) :: spec
end function

! void pango_x_render (Display *display, Drawable d, GC gc, PangoFont *font, PangoGlyphString *glyphs, gint x, gint y);
subroutine pango_x_render(display, d, gc, font, glyphs, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_long, c_int
  type(c_ptr), value :: display
  integer(c_long), value :: d
  type(c_ptr), value :: gc
  type(c_ptr), value :: font
  type(c_ptr), value :: glyphs
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void pango_x_render_layout_line (Display *display, Drawable drawable, GC gc, PangoLayoutLine *line, int x, int y);
subroutine pango_x_render_layout_line(display, drawable, gc, line, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_long, c_int
  type(c_ptr), value :: display
  integer(c_long), value :: drawable
  type(c_ptr), value :: gc
  type(c_ptr), value :: line
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void pango_x_render_layout (Display *display, Drawable drawable, GC gc, PangoLayout *layout, int x, int y);
subroutine pango_x_render_layout(display, drawable, gc, layout, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_long, c_int
  type(c_ptr), value :: display
  integer(c_long), value :: drawable
  type(c_ptr), value :: gc
  type(c_ptr), value :: layout
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

!  int pango_x_list_subfonts (PangoFont *font, char **charsets, int n_charsets, PangoXSubfont **subfont_ids, int **subfont_charsets);
function pango_x_list_subfonts(font, charsets, n_charsets, subfont_ids, subfont_&
      &charsets) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: pango_x_list_subfonts
  type(c_ptr), value :: font
  character(kind=c_char), dimension(*) :: charsets
  integer(c_int), value :: n_charsets
  type(c_ptr), value :: subfont_ids
  type(c_ptr), value :: subfont_charsets
end function

! gboolean pango_x_has_glyph (PangoFont *font, PangoGlyph glyph);
function pango_x_has_glyph(font, glyph) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int32_t
  logical(c_bool) :: pango_x_has_glyph
  type(c_ptr), value :: font
  integer(c_int32_t), value :: glyph
end function

! PangoGlyph pango_x_get_unknown_glyph (PangoFont *font);
function pango_x_get_unknown_glyph(font) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: pango_x_get_unknown_glyph
  type(c_ptr), value :: font
end function

!  PangoGlyph pango_x_font_get_unknown_glyph (PangoFont *font, gunichar wc);
function pango_x_font_get_unknown_glyph(font, wc) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: pango_x_font_get_unknown_glyph
  type(c_ptr), value :: font
  integer(c_int32_t), value :: wc
end function

!  PangoXFontCache *pango_x_font_cache_new (Display *display);
function pango_x_font_cache_new(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_x_font_cache_new
  type(c_ptr), value :: display
end function

! void pango_x_font_cache_free (PangoXFontCache *cache);
subroutine pango_x_font_cache_free(cache) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cache
end subroutine

!  XFontStruct * pango_x_font_cache_load (PangoXFontCache *cache, const char *xlfd);
function pango_x_font_cache_load(cache, xlfd) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: pango_x_font_cache_load
  type(c_ptr), value :: cache
  character(kind=c_char), dimension(*) :: xlfd
end function

! void pango_x_font_cache_unload (PangoXFontCache *cache, XFontStruct *fs);
subroutine pango_x_font_cache_unload(cache, fs) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cache
  type(c_ptr), value :: fs
end subroutine

!  PangoFontMap * pango_x_font_map_for_display (Display *display);
function pango_x_font_map_for_display(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_x_font_map_for_display
  type(c_ptr), value :: display
end function

! void pango_x_shutdown_display (Display *display);
subroutine pango_x_shutdown_display(display) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: display
end subroutine

! PangoXFontCache *pango_x_font_map_get_font_cache (PangoFontMap *font_map);
function pango_x_font_map_get_font_cache(font_map) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_x_font_map_get_font_cache
  type(c_ptr), value :: font_map
end function

!  char *pango_x_font_subfont_xlfd (PangoFont *font, PangoXSubfont subfont_id);
function pango_x_font_subfont_xlfd(font, subfont_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int16_t
  type(c_ptr) :: pango_x_font_subfont_xlfd
  type(c_ptr), value :: font
  integer(c_int16_t), value :: subfont_id
end function

!  gboolean pango_x_find_first_subfont (PangoFont *font, char **charsets, int n_charsets, PangoXSubfont *rfont);
function pango_x_find_first_subfont(font, charsets, n_charsets, rfont) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_int
  logical(c_bool) :: pango_x_find_first_subfont
  type(c_ptr), value :: font
  character(kind=c_char), dimension(*) :: charsets
  integer(c_int), value :: n_charsets
  type(c_ptr), value :: rfont
end function

!  void pango_x_fallback_shape (PangoFont *font, PangoGlyphString *glyphs, const char *text, int n_chars);
subroutine pango_x_fallback_shape(font, glyphs, text, n_chars) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: font
  type(c_ptr), value :: glyphs
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: n_chars
end subroutine

!  gboolean pango_x_apply_ligatures (PangoFont *font, PangoXSubfont subfont, gunichar **glyphs, int *n_glyphs, int **clusters);
function pango_x_apply_ligatures(font, subfont, glyphs, n_glyphs, clusters) bind&
      &(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int16_t, c_char
  logical(c_bool) :: pango_x_apply_ligatures
  type(c_ptr), value :: font
  integer(c_int16_t), value :: subfont
  character(kind=c_char), dimension(*) :: glyphs
  type(c_ptr), value :: n_glyphs
  type(c_ptr), value :: clusters
end function

!   GType pango_matrix_get_type (void) G_GNUC_CONST;
function pango_matrix_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_matrix_get_type
end function

!  PangoMatrix *pango_matrix_copy (const PangoMatrix *matrix);
function pango_matrix_copy(matrix) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_matrix_copy
  type(c_ptr), value :: matrix
end function

! void pango_matrix_free (PangoMatrix *matrix);
subroutine pango_matrix_free(matrix) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: matrix
end subroutine

!  void pango_matrix_translate (PangoMatrix *matrix, double tx, double ty);
subroutine pango_matrix_translate(matrix, tx, ty) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: matrix
  real(c_double), value :: tx
  real(c_double), value :: ty
end subroutine

! void pango_matrix_scale (PangoMatrix *matrix, double scale_x, double scale_y);
subroutine pango_matrix_scale(matrix, scale_x, scale_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: matrix
  real(c_double), value :: scale_x
  real(c_double), value :: scale_y
end subroutine

! void pango_matrix_rotate (PangoMatrix *matrix, double degrees);
subroutine pango_matrix_rotate(matrix, degrees) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: matrix
  real(c_double), value :: degrees
end subroutine

! void pango_matrix_concat (PangoMatrix *matrix, const PangoMatrix *new_matrix);
subroutine pango_matrix_concat(matrix, new_matrix) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: matrix
  type(c_ptr), value :: new_matrix
end subroutine

! void pango_matrix_transform_point (const PangoMatrix *matrix, double *x, double *y);
subroutine pango_matrix_transform_point(matrix, x, y) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: matrix
  type(c_ptr), value :: x
  type(c_ptr), value :: y
end subroutine

! void pango_matrix_transform_distance (const PangoMatrix *matrix, double *dx, double *dy);
subroutine pango_matrix_transform_distance(matrix, dx, dy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: matrix
  type(c_ptr), value :: dx
  type(c_ptr), value :: dy
end subroutine

! void pango_matrix_transform_rectangle (const PangoMatrix *matrix, PangoRectangle *rect);
subroutine pango_matrix_transform_rectangle(matrix, rect) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: matrix
  type(c_ptr), value :: rect
end subroutine

! void pango_matrix_transform_pixel_rectangle (const PangoMatrix *matrix, PangoRectangle *rect);
subroutine pango_matrix_transform_pixel_rectangle(matrix, rect) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: matrix
  type(c_ptr), value :: rect
end subroutine

! double pango_matrix_get_font_scale_factor (const PangoMatrix *matrix) G_GNUC_PURE;
function pango_matrix_get_font_scale_factor(matrix) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: pango_matrix_get_font_scale_factor
  type(c_ptr), value :: matrix
end function

!   PangoScript pango_script_for_unichar (gunichar ch) G_GNUC_CONST;
function pango_script_for_unichar(ch) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: pango_script_for_unichar
  integer(c_int32_t), value :: ch
end function

!  PangoScriptIter *pango_script_iter_new (const char *text, int length);
function pango_script_iter_new(text, length) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: pango_script_iter_new
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: length
end function

! void pango_script_iter_get_range (PangoScriptIter *iter, G_CONST_RETURN char **start, G_CONST_RETURN char **end, PangoScript *script);
subroutine pango_script_iter_get_range(iter, start, end, script) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int), value :: iter
  character(kind=c_char), dimension(*) :: start
  character(kind=c_char), dimension(*) :: end
  integer(c_int), value :: script
end subroutine

! gboolean pango_script_iter_next (PangoScriptIter *iter);
function pango_script_iter_next(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_int
  logical(c_bool) :: pango_script_iter_next
  integer(c_int), value :: iter
end function

! void pango_script_iter_free (PangoScriptIter *iter);
subroutine pango_script_iter_free(iter) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: iter
end subroutine

!  PangoLanguage *pango_script_get_sample_language (PangoScript script) G_GNUC_PURE;
function pango_script_get_sample_language(script) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_script_get_sample_language
  integer(c_int), value :: script
end function

!   GType pango_font_description_get_type (void) G_GNUC_CONST;
function pango_font_description_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_font_description_get_type
end function

! PangoFontDescription *pango_font_description_new (void);
function pango_font_description_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_description_new
end function

! PangoFontDescription *pango_font_description_copy (const PangoFontDescription *desc);
function pango_font_description_copy(desc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_description_copy
  type(c_ptr), value :: desc
end function

! PangoFontDescription *pango_font_description_copy_static (const PangoFontDescription *desc);
function pango_font_description_copy_static(desc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_description_copy_static
  type(c_ptr), value :: desc
end function

! guint pango_font_description_hash (const PangoFontDescription *desc) G_GNUC_PURE;
function pango_font_description_hash(desc) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_font_description_hash
  type(c_ptr), value :: desc
end function

! gboolean pango_font_description_equal (const PangoFontDescription *desc1, const PangoFontDescription *desc2) G_GNUC_PURE;
function pango_font_description_equal(desc1, desc2) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_font_description_equal
  type(c_ptr), value :: desc1
  type(c_ptr), value :: desc2
end function

! void pango_font_description_free (PangoFontDescription *desc);
subroutine pango_font_description_free(desc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: desc
end subroutine

! void pango_font_descriptions_free (PangoFontDescription **descs, int n_descs);
subroutine pango_font_descriptions_free(descs, n_descs) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: descs
  integer(c_int), value :: n_descs
end subroutine

!  void pango_font_description_set_family (PangoFontDescription *desc, const char *family);
subroutine pango_font_description_set_family(desc, family) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: desc
  character(kind=c_char), dimension(*) :: family
end subroutine

! void pango_font_description_set_family_static (PangoFontDescription *desc, const char *family);
subroutine pango_font_description_set_family_static(desc, family) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: desc
  character(kind=c_char), dimension(*) :: family
end subroutine

! G_CONST_RETURN char *pango_font_description_get_family (const PangoFontDescription *desc) G_GNUC_PURE;
function pango_font_description_get_family(desc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_description_get_family
  type(c_ptr), value :: desc
end function

! void pango_font_description_set_style (PangoFontDescription *desc, PangoStyle style);
subroutine pango_font_description_set_style(desc, style) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: desc
  integer(c_int), value :: style
end subroutine

! PangoStyle pango_font_description_get_style (const PangoFontDescription *desc) G_GNUC_PURE;
function pango_font_description_get_style(desc) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_font_description_get_style
  type(c_ptr), value :: desc
end function

! void pango_font_description_set_variant (PangoFontDescription *desc, PangoVariant variant);
subroutine pango_font_description_set_variant(desc, variant) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: desc
  integer(c_int), value :: variant
end subroutine

! PangoVariant pango_font_description_get_variant (const PangoFontDescription *desc) G_GNUC_PURE;
function pango_font_description_get_variant(desc) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_font_description_get_variant
  type(c_ptr), value :: desc
end function

! void pango_font_description_set_weight (PangoFontDescription *desc, PangoWeight weight);
subroutine pango_font_description_set_weight(desc, weight) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: desc
  integer(c_int), value :: weight
end subroutine

! PangoWeight pango_font_description_get_weight (const PangoFontDescription *desc) G_GNUC_PURE;
function pango_font_description_get_weight(desc) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_font_description_get_weight
  type(c_ptr), value :: desc
end function

! void pango_font_description_set_stretch (PangoFontDescription *desc, PangoStretch stretch);
subroutine pango_font_description_set_stretch(desc, stretch) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: desc
  integer(c_int), value :: stretch
end subroutine

! PangoStretch pango_font_description_get_stretch (const PangoFontDescription *desc) G_GNUC_PURE;
function pango_font_description_get_stretch(desc) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_font_description_get_stretch
  type(c_ptr), value :: desc
end function

! void pango_font_description_set_size (PangoFontDescription *desc, gint size);
subroutine pango_font_description_set_size(desc, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: desc
  integer(c_int), value :: size
end subroutine

! gint pango_font_description_get_size (const PangoFontDescription *desc) G_GNUC_PURE;
function pango_font_description_get_size(desc) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_font_description_get_size
  type(c_ptr), value :: desc
end function

! void pango_font_description_set_absolute_size (PangoFontDescription *desc, double size);
subroutine pango_font_description_set_absolute_size(desc, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: desc
  real(c_double), value :: size
end subroutine

! gboolean pango_font_description_get_size_is_absolute (const PangoFontDescription *desc) G_GNUC_PURE;
function pango_font_description_get_size_is_absolute(desc) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_font_description_get_size_is_absolute
  type(c_ptr), value :: desc
end function

! void pango_font_description_set_gravity (PangoFontDescription *desc, PangoGravity gravity);
subroutine pango_font_description_set_gravity(desc, gravity) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: desc
  integer(c_int), value :: gravity
end subroutine

! PangoGravity pango_font_description_get_gravity (const PangoFontDescription *desc) G_GNUC_PURE;
function pango_font_description_get_gravity(desc) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_font_description_get_gravity
  type(c_ptr), value :: desc
end function

!  PangoFontMask pango_font_description_get_set_fields (const PangoFontDescription *desc) G_GNUC_PURE;
function pango_font_description_get_set_fields(desc) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_font_description_get_set_fields
  type(c_ptr), value :: desc
end function

! void pango_font_description_unset_fields (PangoFontDescription *desc, PangoFontMask to_unset);
subroutine pango_font_description_unset_fields(desc, to_unset) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: desc
  integer(c_int), value :: to_unset
end subroutine

!  void pango_font_description_merge (PangoFontDescription *desc, const PangoFontDescription *desc_to_merge, gboolean replace_existing);
subroutine pango_font_description_merge(desc, desc_to_merge, replace_existing) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: desc
  type(c_ptr), value :: desc_to_merge
  logical(c_bool), value :: replace_existing
end subroutine

! void pango_font_description_merge_static (PangoFontDescription *desc, const PangoFontDescription *desc_to_merge, gboolean replace_existing);
subroutine pango_font_description_merge_static(desc, desc_to_merge, replace_exis&
      &ting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: desc
  type(c_ptr), value :: desc_to_merge
  logical(c_bool), value :: replace_existing
end subroutine

!  gboolean pango_font_description_better_match (const PangoFontDescription *desc, const PangoFontDescription *old_match, const PangoFontDescription *new_match) G_GNUC_PURE;
function pango_font_description_better_match(desc, old_match, new_match) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_font_description_better_match
  type(c_ptr), value :: desc
  type(c_ptr), value :: old_match
  type(c_ptr), value :: new_match
end function

!  PangoFontDescription *pango_font_description_from_string (const char *str);
function pango_font_description_from_string(str) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: pango_font_description_from_string
  character(kind=c_char), dimension(*) :: str
end function

! char * pango_font_description_to_string (const PangoFontDescription *desc);
function pango_font_description_to_string(desc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_description_to_string
  type(c_ptr), value :: desc
end function

! char * pango_font_description_to_filename (const PangoFontDescription *desc);
function pango_font_description_to_filename(desc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_description_to_filename
  type(c_ptr), value :: desc
end function

!  GType pango_font_metrics_get_type (void) G_GNUC_CONST;
function pango_font_metrics_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_font_metrics_get_type
end function

! PangoFontMetrics *pango_font_metrics_ref (PangoFontMetrics *metrics);
function pango_font_metrics_ref(metrics) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_metrics_ref
  type(c_ptr), value :: metrics
end function

! void pango_font_metrics_unref (PangoFontMetrics *metrics);
subroutine pango_font_metrics_unref(metrics) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: metrics
end subroutine

! int pango_font_metrics_get_ascent (PangoFontMetrics *metrics) G_GNUC_PURE;
function pango_font_metrics_get_ascent(metrics) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_font_metrics_get_ascent
  type(c_ptr), value :: metrics
end function

! int pango_font_metrics_get_descent (PangoFontMetrics *metrics) G_GNUC_PURE;
function pango_font_metrics_get_descent(metrics) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_font_metrics_get_descent
  type(c_ptr), value :: metrics
end function

! int pango_font_metrics_get_approximate_char_width (PangoFontMetrics *metrics) G_GNUC_PURE;
function pango_font_metrics_get_approximate_char_width(metrics) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_font_metrics_get_approximate_char_width
  type(c_ptr), value :: metrics
end function

! int pango_font_metrics_get_approximate_digit_width (PangoFontMetrics *metrics) G_GNUC_PURE;
function pango_font_metrics_get_approximate_digit_width(metrics) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_font_metrics_get_approximate_digit_width
  type(c_ptr), value :: metrics
end function

! int pango_font_metrics_get_underline_position (PangoFontMetrics *metrics) G_GNUC_PURE;
function pango_font_metrics_get_underline_position(metrics) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_font_metrics_get_underline_position
  type(c_ptr), value :: metrics
end function

! int pango_font_metrics_get_underline_thickness (PangoFontMetrics *metrics) G_GNUC_PURE;
function pango_font_metrics_get_underline_thickness(metrics) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_font_metrics_get_underline_thickness
  type(c_ptr), value :: metrics
end function

! int pango_font_metrics_get_strikethrough_position (PangoFontMetrics *metrics) G_GNUC_PURE;
function pango_font_metrics_get_strikethrough_position(metrics) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_font_metrics_get_strikethrough_position
  type(c_ptr), value :: metrics
end function

! int pango_font_metrics_get_strikethrough_thickness (PangoFontMetrics *metrics) G_GNUC_PURE;
function pango_font_metrics_get_strikethrough_thickness(metrics) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_font_metrics_get_strikethrough_thickness
  type(c_ptr), value :: metrics
end function

!  PangoFontMetrics *pango_font_metrics_new (void);
function pango_font_metrics_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_metrics_new
end function

!  GType pango_font_family_get_type (void) G_GNUC_CONST;
function pango_font_family_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_font_family_get_type
end function

!  void pango_font_family_list_faces (PangoFontFamily *family, PangoFontFace ***faces, int *n_faces);
subroutine pango_font_family_list_faces(family, faces, n_faces) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: family
  type(c_ptr), value :: faces
  type(c_ptr), value :: n_faces
end subroutine

! G_CONST_RETURN char *pango_font_family_get_name (PangoFontFamily *family) G_GNUC_PURE;
function pango_font_family_get_name(family) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_family_get_name
  type(c_ptr), value :: family
end function

! gboolean pango_font_family_is_monospace (PangoFontFamily *family) G_GNUC_PURE;
function pango_font_family_is_monospace(family) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_font_family_is_monospace
  type(c_ptr), value :: family
end function

!  GType pango_font_face_get_type (void) G_GNUC_CONST;
function pango_font_face_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_font_face_get_type
end function

!  PangoFontDescription *pango_font_face_describe (PangoFontFace *face);
function pango_font_face_describe(face) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_face_describe
  type(c_ptr), value :: face
end function

! G_CONST_RETURN char *pango_font_face_get_face_name (PangoFontFace *face) G_GNUC_PURE;
function pango_font_face_get_face_name(face) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_face_get_face_name
  type(c_ptr), value :: face
end function

! void pango_font_face_list_sizes (PangoFontFace *face, int **sizes, int *n_sizes);
subroutine pango_font_face_list_sizes(face, sizes, n_sizes) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: face
  type(c_ptr), value :: sizes
  type(c_ptr), value :: n_sizes
end subroutine

! gboolean pango_font_face_is_synthesized (PangoFontFace *face) G_GNUC_PURE;
function pango_font_face_is_synthesized(face) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_font_face_is_synthesized
  type(c_ptr), value :: face
end function

!  GType pango_font_get_type (void) G_GNUC_CONST;
function pango_font_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_font_get_type
end function

!  PangoFontDescription *pango_font_describe (PangoFont *font);
function pango_font_describe(font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_describe
  type(c_ptr), value :: font
end function

! PangoFontDescription *pango_font_describe_with_absolute_size (PangoFont *font);
function pango_font_describe_with_absolute_size(font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_describe_with_absolute_size
  type(c_ptr), value :: font
end function

! PangoCoverage * pango_font_get_coverage (PangoFont *font, PangoLanguage *language);
function pango_font_get_coverage(font, language) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_get_coverage
  type(c_ptr), value :: font
  type(c_ptr), value :: language
end function

! PangoEngineShape * pango_font_find_shaper (PangoFont *font, PangoLanguage *language, guint32 ch);
function pango_font_find_shaper(font, language, ch) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: pango_font_find_shaper
  type(c_ptr), value :: font
  type(c_ptr), value :: language
  integer(c_int32_t), value :: ch
end function

! PangoFontMetrics * pango_font_get_metrics (PangoFont *font, PangoLanguage *language);
function pango_font_get_metrics(font, language) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_get_metrics
  type(c_ptr), value :: font
  type(c_ptr), value :: language
end function

! void pango_font_get_glyph_extents (PangoFont *font, PangoGlyph glyph, PangoRectangle *ink_rect, PangoRectangle *logical_rect);
subroutine pango_font_get_glyph_extents(font, glyph, ink_rect, logical_rect) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: font
  integer(c_int32_t), value :: glyph
  type(c_ptr), value :: ink_rect
  type(c_ptr), value :: logical_rect
end subroutine

! PangoFontMap *pango_font_get_font_map (PangoFont *font);
function pango_font_get_font_map(font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_get_font_map
  type(c_ptr), value :: font
end function

!   PangoBidiType pango_bidi_type_for_unichar (gunichar ch) G_GNUC_CONST;
function pango_bidi_type_for_unichar(ch) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: pango_bidi_type_for_unichar
  integer(c_int32_t), value :: ch
end function

!  PangoDirection pango_unichar_direction (gunichar ch) G_GNUC_CONST;
function pango_unichar_direction(ch) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: pango_unichar_direction
  integer(c_int32_t), value :: ch
end function

! PangoDirection pango_find_base_dir (const gchar *text, gint length);
function pango_find_base_dir(text, length) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: pango_find_base_dir
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: length
end function

!  gboolean pango_get_mirror_char (gunichar ch, gunichar *mirrored_ch);
function pango_get_mirror_char(ch, mirrored_ch) bind(c) 
  use iso_c_binding, only: c_bool, c_int32_t, c_char
  logical(c_bool) :: pango_get_mirror_char
  integer(c_int32_t), value :: ch
  character(kind=c_char), dimension(*) :: mirrored_ch
end function

!   GType pango_glyph_item_get_type (void) G_GNUC_CONST;
function pango_glyph_item_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_glyph_item_get_type
end function

!  PangoGlyphItem *pango_glyph_item_split (PangoGlyphItem *orig, const char *text, int split_index);
function pango_glyph_item_split(orig, text, split_index) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: pango_glyph_item_split
  type(c_ptr), value :: orig
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: split_index
end function

! PangoGlyphItem *pango_glyph_item_copy (PangoGlyphItem *orig);
function pango_glyph_item_copy(orig) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_glyph_item_copy
  type(c_ptr), value :: orig
end function

! void pango_glyph_item_free (PangoGlyphItem *glyph_item);
subroutine pango_glyph_item_free(glyph_item) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: glyph_item
end subroutine

! GSList * pango_glyph_item_apply_attrs (PangoGlyphItem *glyph_item, const char *text, PangoAttrList *list);
function pango_glyph_item_apply_attrs(glyph_item, text, list) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: pango_glyph_item_apply_attrs
  type(c_ptr), value :: glyph_item
  character(kind=c_char), dimension(*) :: text
  type(c_ptr), value :: list
end function

! void pango_glyph_item_letter_space (PangoGlyphItem *glyph_item, const char *text, PangoLogAttr *log_attrs, int letter_spacing);
subroutine pango_glyph_item_letter_space(glyph_item, text, log_attrs, letter_spa&
      &cing) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: glyph_item
  character(kind=c_char), dimension(*) :: text
  type(c_ptr), value :: log_attrs
  integer(c_int), value :: letter_spacing
end subroutine

! void pango_glyph_item_get_logical_widths (PangoGlyphItem *glyph_item, const char *text, int *logical_widths);
subroutine pango_glyph_item_get_logical_widths(glyph_item, text, logical_widths)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: glyph_item
  character(kind=c_char), dimension(*) :: text
  type(c_ptr), value :: logical_widths
end subroutine

!  GType pango_glyph_item_iter_get_type (void) G_GNUC_CONST;
function pango_glyph_item_iter_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_glyph_item_iter_get_type
end function

! PangoGlyphItemIter *pango_glyph_item_iter_copy (PangoGlyphItemIter *orig);
function pango_glyph_item_iter_copy(orig) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_glyph_item_iter_copy
  type(c_ptr), value :: orig
end function

! void pango_glyph_item_iter_free (PangoGlyphItemIter *iter);
subroutine pango_glyph_item_iter_free(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
end subroutine

!  gboolean pango_glyph_item_iter_init_start (PangoGlyphItemIter *iter, PangoGlyphItem *glyph_item, const char *text);
function pango_glyph_item_iter_init_start(iter, glyph_item, text) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: pango_glyph_item_iter_init_start
  type(c_ptr), value :: iter
  type(c_ptr), value :: glyph_item
  character(kind=c_char), dimension(*) :: text
end function

! gboolean pango_glyph_item_iter_init_end (PangoGlyphItemIter *iter, PangoGlyphItem *glyph_item, const char *text);
function pango_glyph_item_iter_init_end(iter, glyph_item, text) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: pango_glyph_item_iter_init_end
  type(c_ptr), value :: iter
  type(c_ptr), value :: glyph_item
  character(kind=c_char), dimension(*) :: text
end function

! gboolean pango_glyph_item_iter_next_cluster (PangoGlyphItemIter *iter);
function pango_glyph_item_iter_next_cluster(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_glyph_item_iter_next_cluster
  type(c_ptr), value :: iter
end function

! gboolean pango_glyph_item_iter_prev_cluster (PangoGlyphItemIter *iter);
function pango_glyph_item_iter_prev_cluster(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_glyph_item_iter_prev_cluster
  type(c_ptr), value :: iter
end function

!   GType pango_xft_renderer_get_type (void) G_GNUC_CONST;
function pango_xft_renderer_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_xft_renderer_get_type
end function

!  PangoRenderer *pango_xft_renderer_new (Display *display, int screen);
function pango_xft_renderer_new(display, screen) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_xft_renderer_new
  type(c_ptr), value :: display
  integer(c_int), value :: screen
end function

! void pango_xft_renderer_set_draw (PangoXftRenderer *xftrenderer, XftDraw *draw);
subroutine pango_xft_renderer_set_draw(xftrenderer, draw) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: xftrenderer
  type(c_ptr), value :: draw
end subroutine

! void pango_xft_renderer_set_default_color (PangoXftRenderer *xftrenderer, PangoColor *default_color);
subroutine pango_xft_renderer_set_default_color(xftrenderer, default_color) bind&
      &(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: xftrenderer
  type(c_ptr), value :: default_color
end subroutine

!  void pango_xft_render (XftDraw *draw, XftColor *color, PangoFont *font, PangoGlyphString *glyphs, gint x, gint y);
subroutine pango_xft_render(draw, color, font, glyphs, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: draw
  type(c_ptr), value :: color
  type(c_ptr), value :: font
  type(c_ptr), value :: glyphs
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void pango_xft_picture_render (Display *display, Picture src_picture, Picture dest_picture, PangoFont *font, PangoGlyphString *glyphs, gint x, gint y);
subroutine pango_xft_picture_render(display, src_picture, dest_picture, font, gl&
      &yphs, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_long, c_int
  type(c_ptr), value :: display
  integer(c_long), value :: src_picture
  integer(c_long), value :: dest_picture
  type(c_ptr), value :: font
  type(c_ptr), value :: glyphs
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void pango_xft_render_transformed (XftDraw *draw, XftColor *color, PangoMatrix *matrix, PangoFont *font, PangoGlyphString *glyphs, int x, int y);
subroutine pango_xft_render_transformed(draw, color, matrix, font, glyphs, x, y)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: draw
  type(c_ptr), value :: color
  type(c_ptr), value :: matrix
  type(c_ptr), value :: font
  type(c_ptr), value :: glyphs
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void pango_xft_render_layout_line (XftDraw *draw, XftColor *color, PangoLayoutLine *line, int x, int y);
subroutine pango_xft_render_layout_line(draw, color, line, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: draw
  type(c_ptr), value :: color
  type(c_ptr), value :: line
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

! void pango_xft_render_layout (XftDraw *draw, XftColor *color, PangoLayout *layout, int x, int y);
subroutine pango_xft_render_layout(draw, color, layout, x, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: draw
  type(c_ptr), value :: color
  type(c_ptr), value :: layout
  integer(c_int), value :: x
  integer(c_int), value :: y
end subroutine

!   int pango_units_from_double (double d) G_GNUC_CONST;
function pango_units_from_double(d) bind(c) 
  use iso_c_binding, only: c_int, c_double
  integer(c_int) :: pango_units_from_double
  real(c_double), value :: d
end function

! double pango_units_to_double (int i) G_GNUC_CONST;
function pango_units_to_double(i) bind(c) 
  use iso_c_binding, only: c_double, c_int
  real(c_double) :: pango_units_to_double
  integer(c_int), value :: i
end function

!  void pango_extents_to_pixels (PangoRectangle *inclusive, PangoRectangle *nearest);
subroutine pango_extents_to_pixels(inclusive, nearest) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: inclusive
  type(c_ptr), value :: nearest
end subroutine

!   GType pango_font_map_get_type (void) G_GNUC_CONST;
function pango_font_map_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_font_map_get_type
end function

! PangoContext * pango_font_map_create_context (PangoFontMap *fontmap);
function pango_font_map_create_context(fontmap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_map_create_context
  type(c_ptr), value :: fontmap
end function

! PangoFont * pango_font_map_load_font (PangoFontMap *fontmap, PangoContext *context, const PangoFontDescription *desc);
function pango_font_map_load_font(fontmap, context, desc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_map_load_font
  type(c_ptr), value :: fontmap
  type(c_ptr), value :: context
  type(c_ptr), value :: desc
end function

! PangoFontset *pango_font_map_load_fontset (PangoFontMap *fontmap, PangoContext *context, const PangoFontDescription *desc, PangoLanguage *language);
function pango_font_map_load_fontset(fontmap, context, desc, language) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_map_load_fontset
  type(c_ptr), value :: fontmap
  type(c_ptr), value :: context
  type(c_ptr), value :: desc
  type(c_ptr), value :: language
end function

! void pango_font_map_list_families (PangoFontMap *fontmap, PangoFontFamily ***families, int *n_families);
subroutine pango_font_map_list_families(fontmap, families, n_families) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: fontmap
  type(c_ptr), value :: families
  type(c_ptr), value :: n_families
end subroutine

!  const char *pango_font_map_get_shape_engine_type (PangoFontMap *fontmap);
function pango_font_map_get_shape_engine_type(fontmap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_font_map_get_shape_engine_type
  type(c_ptr), value :: fontmap
end function

!   GType pango_attr_type_get_type (void);
function pango_attr_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_attr_type_get_type
end function

!  GType pango_underline_get_type (void);
function pango_underline_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_underline_get_type
end function

!  GType pango_bidi_type_get_type (void);
function pango_bidi_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_bidi_type_get_type
end function

!  GType pango_direction_get_type (void);
function pango_direction_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_direction_get_type
end function

!  GType pango_coverage_level_get_type (void);
function pango_coverage_level_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_coverage_level_get_type
end function

!  GType pango_style_get_type (void);
function pango_style_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_style_get_type
end function

!  GType pango_variant_get_type (void);
function pango_variant_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_variant_get_type
end function

!  GType pango_weight_get_type (void);
function pango_weight_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_weight_get_type
end function

!  GType pango_stretch_get_type (void);
function pango_stretch_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_stretch_get_type
end function

!  GType pango_font_mask_get_type (void);
function pango_font_mask_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_font_mask_get_type
end function

!  GType pango_gravity_get_type (void);
function pango_gravity_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_gravity_get_type
end function

!  GType pango_gravity_hint_get_type (void);
function pango_gravity_hint_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_gravity_hint_get_type
end function

!  GType pango_alignment_get_type (void);
function pango_alignment_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_alignment_get_type
end function

!  GType pango_wrap_mode_get_type (void);
function pango_wrap_mode_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_wrap_mode_get_type
end function

!  GType pango_ellipsize_mode_get_type (void);
function pango_ellipsize_mode_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_ellipsize_mode_get_type
end function

!  GType pango_render_part_get_type (void);
function pango_render_part_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_render_part_get_type
end function

!  GType pango_script_get_type (void);
function pango_script_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_script_get_type
end function

!  GType pango_tab_align_get_type (void);
function pango_tab_align_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_tab_align_get_type
end function

!   PangoGlyphString *pango_glyph_string_new (void);
function pango_glyph_string_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_glyph_string_new
end function

! void pango_glyph_string_set_size (PangoGlyphString *string, gint new_len);
subroutine pango_glyph_string_set_size(string, new_len) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: string
  integer(c_int), value :: new_len
end subroutine

! GType pango_glyph_string_get_type (void) G_GNUC_CONST;
function pango_glyph_string_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_glyph_string_get_type
end function

! PangoGlyphString *pango_glyph_string_copy (PangoGlyphString *string);
function pango_glyph_string_copy(string) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_glyph_string_copy
  type(c_ptr), value :: string
end function

! void pango_glyph_string_free (PangoGlyphString *string);
subroutine pango_glyph_string_free(string) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: string
end subroutine

! void pango_glyph_string_extents (PangoGlyphString *glyphs, PangoFont *font, PangoRectangle *ink_rect, PangoRectangle *logical_rect);
subroutine pango_glyph_string_extents(glyphs, font, ink_rect, logical_rect) bind&
      &(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: glyphs
  type(c_ptr), value :: font
  type(c_ptr), value :: ink_rect
  type(c_ptr), value :: logical_rect
end subroutine

! int pango_glyph_string_get_width(PangoGlyphString *glyphs);
function pango_glyph_string_get_width(glyphs) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_glyph_string_get_width
  type(c_ptr), value :: glyphs
end function

!  void pango_glyph_string_extents_range (PangoGlyphString *glyphs, int start, int end, PangoFont *font, PangoRectangle *ink_rect, PangoRectangle *logical_rect);
subroutine pango_glyph_string_extents_range(glyphs, start, end, font, ink_rect, &
      &logical_rect) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: glyphs
  integer(c_int), value :: start
  integer(c_int), value :: end
  type(c_ptr), value :: font
  type(c_ptr), value :: ink_rect
  type(c_ptr), value :: logical_rect
end subroutine

!  void pango_glyph_string_get_logical_widths (PangoGlyphString *glyphs, const char *text, int length, int embedding_level, int *logical_widths);
subroutine pango_glyph_string_get_logical_widths(glyphs, text, length, embedding&
      &_level, logical_widths) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: glyphs
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: length
  integer(c_int), value :: embedding_level
  type(c_ptr), value :: logical_widths
end subroutine

!  void pango_glyph_string_index_to_x (PangoGlyphString *glyphs, char *text, int length, PangoAnalysis *analysis, int index_, gboolean trailing, int *x_pos);
subroutine pango_glyph_string_index_to_x(glyphs, text, length, analysis, index_,&
      & trailing, x_pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_bool
  type(c_ptr), value :: glyphs
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: length
  type(c_ptr), value :: analysis
  integer(c_int), value :: index_
  logical(c_bool), value :: trailing
  type(c_ptr), value :: x_pos
end subroutine

! void pango_glyph_string_x_to_index (PangoGlyphString *glyphs, char *text, int length, PangoAnalysis *analysis, int x_pos, int *index_, int *trailing);
subroutine pango_glyph_string_x_to_index(glyphs, text, length, analysis, x_pos, &
      &index_, trailing) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: glyphs
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: length
  type(c_ptr), value :: analysis
  integer(c_int), value :: x_pos
  type(c_ptr), value :: index_
  type(c_ptr), value :: trailing
end subroutine

!  void pango_shape (const gchar *text, gint length, const PangoAnalysis *analysis, PangoGlyphString *glyphs);
subroutine pango_shape(text, length, analysis, glyphs) bind(c) 
  use iso_c_binding, only: c_char, c_int, c_ptr
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: length
  type(c_ptr), value :: analysis
  type(c_ptr), value :: glyphs
end subroutine

!  GList *pango_reorder_items (GList *logical_items);
function pango_reorder_items(logical_items) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_reorder_items
  type(c_ptr), value :: logical_items
end function

!   GType pango_context_get_type (void) G_GNUC_CONST;
function pango_context_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_context_get_type
end function

!  PangoContext *pango_context_new (void);
function pango_context_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_context_new
end function

! void pango_context_set_font_map (PangoContext *context, PangoFontMap *font_map);
subroutine pango_context_set_font_map(context, font_map) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: font_map
end subroutine

! PangoFontMap *pango_context_get_font_map (PangoContext *context);
function pango_context_get_font_map(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_context_get_font_map
  type(c_ptr), value :: context
end function

!  void pango_context_list_families (PangoContext *context, PangoFontFamily ***families, int *n_families);
subroutine pango_context_list_families(context, families, n_families) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: families
  type(c_ptr), value :: n_families
end subroutine

! PangoFont * pango_context_load_font (PangoContext *context, const PangoFontDescription *desc);
function pango_context_load_font(context, desc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_context_load_font
  type(c_ptr), value :: context
  type(c_ptr), value :: desc
end function

! PangoFontset *pango_context_load_fontset (PangoContext *context, const PangoFontDescription *desc, PangoLanguage *language);
function pango_context_load_fontset(context, desc, language) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_context_load_fontset
  type(c_ptr), value :: context
  type(c_ptr), value :: desc
  type(c_ptr), value :: language
end function

!  PangoFontMetrics *pango_context_get_metrics (PangoContext *context, const PangoFontDescription *desc, PangoLanguage *language);
function pango_context_get_metrics(context, desc, language) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_context_get_metrics
  type(c_ptr), value :: context
  type(c_ptr), value :: desc
  type(c_ptr), value :: language
end function

!  void pango_context_set_font_description (PangoContext *context, const PangoFontDescription *desc);
subroutine pango_context_set_font_description(context, desc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: desc
end subroutine

! PangoFontDescription * pango_context_get_font_description (PangoContext *context);
function pango_context_get_font_description(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_context_get_font_description
  type(c_ptr), value :: context
end function

! PangoLanguage *pango_context_get_language (PangoContext *context);
function pango_context_get_language(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_context_get_language
  type(c_ptr), value :: context
end function

! void pango_context_set_language (PangoContext *context, PangoLanguage *language);
subroutine pango_context_set_language(context, language) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: language
end subroutine

! void pango_context_set_base_dir (PangoContext *context, PangoDirection direction);
subroutine pango_context_set_base_dir(context, direction) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: context
  integer(c_int), value :: direction
end subroutine

! PangoDirection pango_context_get_base_dir (PangoContext *context);
function pango_context_get_base_dir(context) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_context_get_base_dir
  type(c_ptr), value :: context
end function

! void pango_context_set_base_gravity (PangoContext *context, PangoGravity gravity);
subroutine pango_context_set_base_gravity(context, gravity) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: context
  integer(c_int), value :: gravity
end subroutine

! PangoGravity pango_context_get_base_gravity (PangoContext *context);
function pango_context_get_base_gravity(context) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_context_get_base_gravity
  type(c_ptr), value :: context
end function

! PangoGravity pango_context_get_gravity (PangoContext *context);
function pango_context_get_gravity(context) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_context_get_gravity
  type(c_ptr), value :: context
end function

! void pango_context_set_gravity_hint (PangoContext *context, PangoGravityHint hint);
subroutine pango_context_set_gravity_hint(context, hint) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: context
  integer(c_int), value :: hint
end subroutine

! PangoGravityHint pango_context_get_gravity_hint (PangoContext *context);
function pango_context_get_gravity_hint(context) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_context_get_gravity_hint
  type(c_ptr), value :: context
end function

!  void pango_context_set_matrix (PangoContext *context, const PangoMatrix *matrix);
subroutine pango_context_set_matrix(context, matrix) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: matrix
end subroutine

! G_CONST_RETURN PangoMatrix *pango_context_get_matrix (PangoContext *context);
function pango_context_get_matrix(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_context_get_matrix
  type(c_ptr), value :: context
end function

!  GList *pango_itemize (PangoContext *context, const char *text, int start_index, int length, PangoAttrList *attrs, PangoAttrIterator *cached_iter);
function pango_itemize(context, text, start_index, length, attrs, cached_iter) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: pango_itemize
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: start_index
  integer(c_int), value :: length
  type(c_ptr), value :: attrs
  type(c_ptr), value :: cached_iter
end function

! GList *pango_itemize_with_base_dir (PangoContext *context, PangoDirection base_dir, const char *text, int start_index, int length, PangoAttrList *attrs, PangoAttrIterator *cached_iter);
function pango_itemize_with_base_dir(context, base_dir, text, start_index, lengt&
      &h, attrs, cached_iter) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr) :: pango_itemize_with_base_dir
  type(c_ptr), value :: context
  integer(c_int), value :: base_dir
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: start_index
  integer(c_int), value :: length
  type(c_ptr), value :: attrs
  type(c_ptr), value :: cached_iter
end function

!   void pango_break (const gchar *text, int length, PangoAnalysis *analysis, PangoLogAttr *attrs, int attrs_len);
subroutine pango_break(text, length, analysis, attrs, attrs_len) bind(c) 
  use iso_c_binding, only: c_char, c_int, c_ptr
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: length
  type(c_ptr), value :: analysis
  type(c_ptr), value :: attrs
  integer(c_int), value :: attrs_len
end subroutine

!  void pango_find_paragraph_boundary (const gchar *text, gint length, gint *paragraph_delimiter_index, gint *next_paragraph_start);
subroutine pango_find_paragraph_boundary(text, length, paragraph_delimiter_index&
      &, next_paragraph_start) bind(c) 
  use iso_c_binding, only: c_char, c_int, c_ptr
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: length
  type(c_ptr), value :: paragraph_delimiter_index
  type(c_ptr), value :: next_paragraph_start
end subroutine

!  void pango_get_log_attrs (const char *text, int length, int level, PangoLanguage *language, PangoLogAttr *log_attrs, int attrs_len);
subroutine pango_get_log_attrs(text, length, level, language, log_attrs, attrs_l&
      &en) bind(c) 
  use iso_c_binding, only: c_char, c_int, c_ptr
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: length
  integer(c_int), value :: level
  type(c_ptr), value :: language
  type(c_ptr), value :: log_attrs
  integer(c_int), value :: attrs_len
end subroutine

!  void pango_default_break (const gchar *text, int length, PangoAnalysis *analysis, PangoLogAttr *attrs, int attrs_len);
subroutine pango_default_break(text, length, analysis, attrs, attrs_len) bind(c) 
  use iso_c_binding, only: c_char, c_int, c_ptr
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: length
  type(c_ptr), value :: analysis
  type(c_ptr), value :: attrs
  integer(c_int), value :: attrs_len
end subroutine

!   PangoFontMap *pango_xft_get_font_map (Display *display, int screen);
function pango_xft_get_font_map(display, screen) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_xft_get_font_map
  type(c_ptr), value :: display
  integer(c_int), value :: screen
end function

!  PangoContext *pango_xft_get_context (Display *display, int screen);
function pango_xft_get_context(display, screen) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_xft_get_context
  type(c_ptr), value :: display
  integer(c_int), value :: screen
end function

!  void pango_xft_shutdown_display (Display *display, int screen);
subroutine pango_xft_shutdown_display(display, screen) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: display
  integer(c_int), value :: screen
end subroutine

!  void pango_xft_set_default_substitute (Display *display, int screen, PangoXftSubstituteFunc func, gpointer data, GDestroyNotify notify);
subroutine pango_xft_set_default_substitute(display, screen, func, data, notify)&
      & bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: display
  integer(c_int), value :: screen
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end subroutine

! void pango_xft_substitute_changed (Display *display, int screen);
subroutine pango_xft_substitute_changed(display, screen) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: display
  integer(c_int), value :: screen
end subroutine

!  GType pango_xft_font_map_get_type (void) G_GNUC_CONST;
function pango_xft_font_map_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_xft_font_map_get_type
end function

!  GType pango_xft_font_get_type (void) G_GNUC_CONST;
function pango_xft_font_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_xft_font_get_type
end function

!  XftFont * pango_xft_font_get_font (PangoFont *font);
function pango_xft_font_get_font(font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_xft_font_get_font
  type(c_ptr), value :: font
end function

! Display * pango_xft_font_get_display (PangoFont *font);
function pango_xft_font_get_display(font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_xft_font_get_display
  type(c_ptr), value :: font
end function

!  FT_Face pango_xft_font_lock_face (PangoFont *font);
function pango_xft_font_lock_face(font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_xft_font_lock_face
  type(c_ptr), value :: font
end function

! void pango_xft_font_unlock_face (PangoFont *font);
subroutine pango_xft_font_unlock_face(font) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: font
end subroutine

! guint pango_xft_font_get_glyph (PangoFont *font, gunichar wc);
function pango_xft_font_get_glyph(font, wc) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int32_t
  integer(c_int) :: pango_xft_font_get_glyph
  type(c_ptr), value :: font
  integer(c_int32_t), value :: wc
end function

! gboolean pango_xft_font_has_char (PangoFont *font, gunichar wc);
function pango_xft_font_has_char(font, wc) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int32_t
  logical(c_bool) :: pango_xft_font_has_char
  type(c_ptr), value :: font
  integer(c_int32_t), value :: wc
end function

! PangoGlyph pango_xft_font_get_unknown_glyph (PangoFont *font, gunichar wc);
function pango_xft_font_get_unknown_glyph(font, wc) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: pango_xft_font_get_unknown_glyph
  type(c_ptr), value :: font
  integer(c_int32_t), value :: wc
end function

!   PangoTabArray *pango_tab_array_new (gint initial_size, gboolean positions_in_pixels);
function pango_tab_array_new(initial_size, positions_in_pixels) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr) :: pango_tab_array_new
  integer(c_int), value :: initial_size
  logical(c_bool), value :: positions_in_pixels
end function

! GType pango_tab_array_get_type (void) G_GNUC_CONST;
function pango_tab_array_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_tab_array_get_type
end function

! PangoTabArray *pango_tab_array_copy (PangoTabArray *src);
function pango_tab_array_copy(src) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_tab_array_copy
  type(c_ptr), value :: src
end function

! void pango_tab_array_free (PangoTabArray *tab_array);
subroutine pango_tab_array_free(tab_array) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tab_array
end subroutine

! gint pango_tab_array_get_size (PangoTabArray *tab_array);
function pango_tab_array_get_size(tab_array) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_tab_array_get_size
  type(c_ptr), value :: tab_array
end function

! void pango_tab_array_resize (PangoTabArray *tab_array, gint new_size);
subroutine pango_tab_array_resize(tab_array, new_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tab_array
  integer(c_int), value :: new_size
end subroutine

! void pango_tab_array_set_tab (PangoTabArray *tab_array, gint tab_index, PangoTabAlign alignment, gint location);
subroutine pango_tab_array_set_tab(tab_array, tab_index, alignment, location) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tab_array
  integer(c_int), value :: tab_index
  integer(c_int), value :: alignment
  integer(c_int), value :: location
end subroutine

! void pango_tab_array_get_tab (PangoTabArray *tab_array, gint tab_index, PangoTabAlign *alignment, gint *location);
subroutine pango_tab_array_get_tab(tab_array, tab_index, alignment, location) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tab_array
  integer(c_int), value :: tab_index
  integer(c_int), value :: alignment
  type(c_ptr), value :: location
end subroutine

! void pango_tab_array_get_tabs (PangoTabArray *tab_array, PangoTabAlign **alignments, gint **locations);
subroutine pango_tab_array_get_tabs(tab_array, alignments, locations) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tab_array
  integer(c_int), value :: alignments
  type(c_ptr), value :: locations
end subroutine

!  gboolean pango_tab_array_get_positions_in_pixels (PangoTabArray *tab_array);
function pango_tab_array_get_positions_in_pixels(tab_array) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_tab_array_get_positions_in_pixels
  type(c_ptr), value :: tab_array
end function

!   GType pango_color_get_type (void) G_GNUC_CONST;
function pango_color_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_color_get_type
end function

!  PangoColor *pango_color_copy (const PangoColor *src);
function pango_color_copy(src) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_color_copy
  type(c_ptr), value :: src
end function

! void pango_color_free (PangoColor *color);
subroutine pango_color_free(color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: color
end subroutine

! gboolean pango_color_parse (PangoColor *color, const char *spec);
function pango_color_parse(color, spec) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: pango_color_parse
  type(c_ptr), value :: color
  character(kind=c_char), dimension(*) :: spec
end function

! gchar *pango_color_to_string(const PangoColor *color);
function pango_color_to_string(color) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_color_to_string
  type(c_ptr), value :: color
end function

!  PangoAttrType pango_attr_type_register (const gchar *name);
function pango_attr_type_register(name) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: pango_attr_type_register
  character(kind=c_char), dimension(*) :: name
end function

! G_CONST_RETURN char * pango_attr_type_get_name (PangoAttrType type) G_GNUC_CONST;
function pango_attr_type_get_name(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_attr_type_get_name
  integer(c_int), value :: type
end function

!  void pango_attribute_init (PangoAttribute *attr, const PangoAttrClass *klass);
subroutine pango_attribute_init(attr, klass) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: attr
  type(c_ptr), value :: klass
end subroutine

! PangoAttribute * pango_attribute_copy (const PangoAttribute *attr);
function pango_attribute_copy(attr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_attribute_copy
  type(c_ptr), value :: attr
end function

! void pango_attribute_destroy (PangoAttribute *attr);
subroutine pango_attribute_destroy(attr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: attr
end subroutine

! gboolean pango_attribute_equal (const PangoAttribute *attr1, const PangoAttribute *attr2) G_GNUC_PURE;
function pango_attribute_equal(attr1, attr2) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_attribute_equal
  type(c_ptr), value :: attr1
  type(c_ptr), value :: attr2
end function

!  PangoAttribute *pango_attr_language_new (PangoLanguage *language);
function pango_attr_language_new(language) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_attr_language_new
  type(c_ptr), value :: language
end function

! PangoAttribute *pango_attr_family_new (const char *family);
function pango_attr_family_new(family) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: pango_attr_family_new
  character(kind=c_char), dimension(*) :: family
end function

! PangoAttribute *pango_attr_foreground_new (guint16 red, guint16 green, guint16 blue);
function pango_attr_foreground_new(red, green, blue) bind(c) 
  use iso_c_binding, only: c_ptr, c_int16_t
  type(c_ptr) :: pango_attr_foreground_new
  integer(c_int16_t), value :: red
  integer(c_int16_t), value :: green
  integer(c_int16_t), value :: blue
end function

! PangoAttribute *pango_attr_background_new (guint16 red, guint16 green, guint16 blue);
function pango_attr_background_new(red, green, blue) bind(c) 
  use iso_c_binding, only: c_ptr, c_int16_t
  type(c_ptr) :: pango_attr_background_new
  integer(c_int16_t), value :: red
  integer(c_int16_t), value :: green
  integer(c_int16_t), value :: blue
end function

! PangoAttribute *pango_attr_size_new (int size);
function pango_attr_size_new(size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_attr_size_new
  integer(c_int), value :: size
end function

! PangoAttribute *pango_attr_size_new_absolute (int size);
function pango_attr_size_new_absolute(size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_attr_size_new_absolute
  integer(c_int), value :: size
end function

! PangoAttribute *pango_attr_style_new (PangoStyle style);
function pango_attr_style_new(style) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_attr_style_new
  integer(c_int), value :: style
end function

! PangoAttribute *pango_attr_weight_new (PangoWeight weight);
function pango_attr_weight_new(weight) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_attr_weight_new
  integer(c_int), value :: weight
end function

! PangoAttribute *pango_attr_variant_new (PangoVariant variant);
function pango_attr_variant_new(variant) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_attr_variant_new
  integer(c_int), value :: variant
end function

! PangoAttribute *pango_attr_stretch_new (PangoStretch stretch);
function pango_attr_stretch_new(stretch) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_attr_stretch_new
  integer(c_int), value :: stretch
end function

! PangoAttribute *pango_attr_font_desc_new (const PangoFontDescription *desc);
function pango_attr_font_desc_new(desc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_attr_font_desc_new
  type(c_ptr), value :: desc
end function

!  PangoAttribute *pango_attr_underline_new (PangoUnderline underline);
function pango_attr_underline_new(underline) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_attr_underline_new
  integer(c_int), value :: underline
end function

! PangoAttribute *pango_attr_underline_color_new (guint16 red, guint16 green, guint16 blue);
function pango_attr_underline_color_new(red, green, blue) bind(c) 
  use iso_c_binding, only: c_ptr, c_int16_t
  type(c_ptr) :: pango_attr_underline_color_new
  integer(c_int16_t), value :: red
  integer(c_int16_t), value :: green
  integer(c_int16_t), value :: blue
end function

! PangoAttribute *pango_attr_strikethrough_new (gboolean strikethrough);
function pango_attr_strikethrough_new(strikethrough) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: pango_attr_strikethrough_new
  logical(c_bool), value :: strikethrough
end function

! PangoAttribute *pango_attr_strikethrough_color_new (guint16 red, guint16 green, guint16 blue);
function pango_attr_strikethrough_color_new(red, green, blue) bind(c) 
  use iso_c_binding, only: c_ptr, c_int16_t
  type(c_ptr) :: pango_attr_strikethrough_color_new
  integer(c_int16_t), value :: red
  integer(c_int16_t), value :: green
  integer(c_int16_t), value :: blue
end function

!  PangoAttribute *pango_attr_rise_new (int rise);
function pango_attr_rise_new(rise) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_attr_rise_new
  integer(c_int), value :: rise
end function

! PangoAttribute *pango_attr_scale_new (double scale_factor);
function pango_attr_scale_new(scale_factor) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr) :: pango_attr_scale_new
  real(c_double), value :: scale_factor
end function

! PangoAttribute *pango_attr_fallback_new (gboolean enable_fallback);
function pango_attr_fallback_new(enable_fallback) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: pango_attr_fallback_new
  logical(c_bool), value :: enable_fallback
end function

! PangoAttribute *pango_attr_letter_spacing_new (int letter_spacing);
function pango_attr_letter_spacing_new(letter_spacing) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_attr_letter_spacing_new
  integer(c_int), value :: letter_spacing
end function

!  PangoAttribute *pango_attr_shape_new (const PangoRectangle *ink_rect, const PangoRectangle *logical_rect);
function pango_attr_shape_new(ink_rect, logical_rect) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_attr_shape_new
  type(c_ptr), value :: ink_rect
  type(c_ptr), value :: logical_rect
end function

! PangoAttribute *pango_attr_shape_new_with_data (const PangoRectangle *ink_rect, const PangoRectangle *logical_rect, gpointer data, PangoAttrDataCopyFunc copy_func, GDestroyNotify destroy_func);
function pango_attr_shape_new_with_data(ink_rect, logical_rect, data, copy_func,&
      & destroy_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: pango_attr_shape_new_with_data
  type(c_ptr), value :: ink_rect
  type(c_ptr), value :: logical_rect
  type(c_ptr), value :: data
  type(c_funptr), value :: copy_func
  type(c_funptr), value :: destroy_func
end function

!  PangoAttribute *pango_attr_gravity_new (PangoGravity gravity);
function pango_attr_gravity_new(gravity) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_attr_gravity_new
  integer(c_int), value :: gravity
end function

! PangoAttribute *pango_attr_gravity_hint_new (PangoGravityHint hint);
function pango_attr_gravity_hint_new(hint) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_attr_gravity_hint_new
  integer(c_int), value :: hint
end function

!  GType pango_attr_list_get_type (void) G_GNUC_CONST;
function pango_attr_list_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_attr_list_get_type
end function

! PangoAttrList * pango_attr_list_new (void);
function pango_attr_list_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_attr_list_new
end function

! PangoAttrList * pango_attr_list_ref (PangoAttrList *list);
function pango_attr_list_ref(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_attr_list_ref
  type(c_ptr), value :: list
end function

! void pango_attr_list_unref (PangoAttrList *list);
subroutine pango_attr_list_unref(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

! PangoAttrList * pango_attr_list_copy (PangoAttrList *list);
function pango_attr_list_copy(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_attr_list_copy
  type(c_ptr), value :: list
end function

! void pango_attr_list_insert (PangoAttrList *list, PangoAttribute *attr);
subroutine pango_attr_list_insert(list, attr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
  type(c_ptr), value :: attr
end subroutine

! void pango_attr_list_insert_before (PangoAttrList *list, PangoAttribute *attr);
subroutine pango_attr_list_insert_before(list, attr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
  type(c_ptr), value :: attr
end subroutine

! void pango_attr_list_change (PangoAttrList *list, PangoAttribute *attr);
subroutine pango_attr_list_change(list, attr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
  type(c_ptr), value :: attr
end subroutine

! void pango_attr_list_splice (PangoAttrList *list, PangoAttrList *other, gint pos, gint len);
subroutine pango_attr_list_splice(list, other, pos, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: list
  type(c_ptr), value :: other
  integer(c_int), value :: pos
  integer(c_int), value :: len
end subroutine

!  PangoAttrList *pango_attr_list_filter (PangoAttrList *list, PangoAttrFilterFunc func, gpointer data);
function pango_attr_list_filter(list, func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: pango_attr_list_filter
  type(c_ptr), value :: list
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end function

!  PangoAttrIterator *pango_attr_list_get_iterator (PangoAttrList *list);
function pango_attr_list_get_iterator(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_attr_list_get_iterator
  type(c_ptr), value :: list
end function

!  void pango_attr_iterator_range (PangoAttrIterator *iterator, gint *start, gint *end);
subroutine pango_attr_iterator_range(iterator, start, end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iterator
  type(c_ptr), value :: start
  type(c_ptr), value :: end
end subroutine

! gboolean pango_attr_iterator_next (PangoAttrIterator *iterator);
function pango_attr_iterator_next(iterator) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_attr_iterator_next
  type(c_ptr), value :: iterator
end function

! PangoAttrIterator *pango_attr_iterator_copy (PangoAttrIterator *iterator);
function pango_attr_iterator_copy(iterator) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_attr_iterator_copy
  type(c_ptr), value :: iterator
end function

! void pango_attr_iterator_destroy (PangoAttrIterator *iterator);
subroutine pango_attr_iterator_destroy(iterator) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iterator
end subroutine

! PangoAttribute * pango_attr_iterator_get (PangoAttrIterator *iterator, PangoAttrType type);
function pango_attr_iterator_get(iterator, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_attr_iterator_get
  type(c_ptr), value :: iterator
  integer(c_int), value :: type
end function

! void pango_attr_iterator_get_font (PangoAttrIterator *iterator, PangoFontDescription *desc, PangoLanguage **language, GSList **extra_attrs);
subroutine pango_attr_iterator_get_font(iterator, desc, language, extra_attrs) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iterator
  type(c_ptr), value :: desc
  type(c_ptr), value :: language
  type(c_ptr), value :: extra_attrs
end subroutine

! GSList * pango_attr_iterator_get_attrs (PangoAttrIterator *iterator);
function pango_attr_iterator_get_attrs(iterator) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_attr_iterator_get_attrs
  type(c_ptr), value :: iterator
end function

!  gboolean pango_parse_markup (const char *markup_text, int length, gunichar accel_marker, PangoAttrList **attr_list, char **text, gunichar *accel_char, GError **error);
function pango_parse_markup(markup_text, length, accel_marker, attr_list, text, &
      &accel_char, error) bind(c) 
  use iso_c_binding, only: c_bool, c_char, c_int, c_int32_t, c_ptr
  logical(c_bool) :: pango_parse_markup
  character(kind=c_char), dimension(*) :: markup_text
  integer(c_int), value :: length
  integer(c_int32_t), value :: accel_marker
  type(c_ptr), value :: attr_list
  character(kind=c_char), dimension(*) :: text
  character(kind=c_char), dimension(*) :: accel_char
  type(c_ptr), value :: error
end function

!   GType pango_fc_decoder_get_type (void) G_GNUC_CONST;
function pango_fc_decoder_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_fc_decoder_get_type
end function

!  FcCharSet *pango_fc_decoder_get_charset (PangoFcDecoder *decoder, PangoFcFont *fcfont);
function pango_fc_decoder_get_charset(decoder, fcfont) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_fc_decoder_get_charset
  type(c_ptr), value :: decoder
  type(c_ptr), value :: fcfont
end function

!  PangoGlyph pango_fc_decoder_get_glyph (PangoFcDecoder *decoder, PangoFcFont *fcfont, guint32 wc);
function pango_fc_decoder_get_glyph(decoder, fcfont, wc) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: pango_fc_decoder_get_glyph
  type(c_ptr), value :: decoder
  type(c_ptr), value :: fcfont
  integer(c_int32_t), value :: wc
end function

!   GType pango_layout_get_type (void) G_GNUC_CONST;
function pango_layout_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_layout_get_type
end function

! PangoLayout *pango_layout_new (PangoContext *context);
function pango_layout_new(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_layout_new
  type(c_ptr), value :: context
end function

! PangoLayout *pango_layout_copy (PangoLayout *src);
function pango_layout_copy(src) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_layout_copy
  type(c_ptr), value :: src
end function

!  PangoContext *pango_layout_get_context (PangoLayout *layout);
function pango_layout_get_context(layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_layout_get_context
  type(c_ptr), value :: layout
end function

!  void pango_layout_set_attributes (PangoLayout *layout, PangoAttrList *attrs);
subroutine pango_layout_set_attributes(layout, attrs) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: attrs
end subroutine

! PangoAttrList *pango_layout_get_attributes (PangoLayout *layout);
function pango_layout_get_attributes(layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_layout_get_attributes
  type(c_ptr), value :: layout
end function

!  void pango_layout_set_text (PangoLayout *layout, const char *text, int length);
subroutine pango_layout_set_text(layout, text, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: layout
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: length
end subroutine

! const char *pango_layout_get_text (PangoLayout *layout);
function pango_layout_get_text(layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_layout_get_text
  type(c_ptr), value :: layout
end function

!  void pango_layout_set_markup (PangoLayout *layout, const char *markup, int length);
subroutine pango_layout_set_markup(layout, markup, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: layout
  character(kind=c_char), dimension(*) :: markup
  integer(c_int), value :: length
end subroutine

!  void pango_layout_set_markup_with_accel (PangoLayout *layout, const char *markup, int length, gunichar accel_marker, gunichar *accel_char);
subroutine pango_layout_set_markup_with_accel(layout, markup, length, accel_mark&
      &er, accel_char) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_int32_t
  type(c_ptr), value :: layout
  character(kind=c_char), dimension(*) :: markup
  integer(c_int), value :: length
  integer(c_int32_t), value :: accel_marker
  character(kind=c_char), dimension(*) :: accel_char
end subroutine

!  void pango_layout_set_font_description (PangoLayout *layout, const PangoFontDescription *desc);
subroutine pango_layout_set_font_description(layout, desc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: desc
end subroutine

!  G_CONST_RETURN PangoFontDescription *pango_layout_get_font_description (PangoLayout *layout);
function pango_layout_get_font_description(layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_layout_get_font_description
  type(c_ptr), value :: layout
end function

!  void pango_layout_set_width (PangoLayout *layout, int width);
subroutine pango_layout_set_width(layout, width) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  integer(c_int), value :: width
end subroutine

! int pango_layout_get_width (PangoLayout *layout);
function pango_layout_get_width(layout) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_layout_get_width
  type(c_ptr), value :: layout
end function

! void pango_layout_set_height (PangoLayout *layout, int height);
subroutine pango_layout_set_height(layout, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  integer(c_int), value :: height
end subroutine

! int pango_layout_get_height (PangoLayout *layout);
function pango_layout_get_height(layout) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_layout_get_height
  type(c_ptr), value :: layout
end function

! void pango_layout_set_wrap (PangoLayout *layout, PangoWrapMode wrap);
subroutine pango_layout_set_wrap(layout, wrap) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  integer(c_int), value :: wrap
end subroutine

! PangoWrapMode pango_layout_get_wrap (PangoLayout *layout);
function pango_layout_get_wrap(layout) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_layout_get_wrap
  type(c_ptr), value :: layout
end function

! gboolean pango_layout_is_wrapped (PangoLayout *layout);
function pango_layout_is_wrapped(layout) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_layout_is_wrapped
  type(c_ptr), value :: layout
end function

! void pango_layout_set_indent (PangoLayout *layout, int indent);
subroutine pango_layout_set_indent(layout, indent) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  integer(c_int), value :: indent
end subroutine

! int pango_layout_get_indent (PangoLayout *layout);
function pango_layout_get_indent(layout) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_layout_get_indent
  type(c_ptr), value :: layout
end function

! void pango_layout_set_spacing (PangoLayout *layout, int spacing);
subroutine pango_layout_set_spacing(layout, spacing) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  integer(c_int), value :: spacing
end subroutine

! int pango_layout_get_spacing (PangoLayout *layout);
function pango_layout_get_spacing(layout) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_layout_get_spacing
  type(c_ptr), value :: layout
end function

! void pango_layout_set_justify (PangoLayout *layout, gboolean justify);
subroutine pango_layout_set_justify(layout, justify) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: layout
  logical(c_bool), value :: justify
end subroutine

! gboolean pango_layout_get_justify (PangoLayout *layout);
function pango_layout_get_justify(layout) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_layout_get_justify
  type(c_ptr), value :: layout
end function

! void pango_layout_set_auto_dir (PangoLayout *layout, gboolean auto_dir);
subroutine pango_layout_set_auto_dir(layout, auto_dir) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: layout
  logical(c_bool), value :: auto_dir
end subroutine

! gboolean pango_layout_get_auto_dir (PangoLayout *layout);
function pango_layout_get_auto_dir(layout) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_layout_get_auto_dir
  type(c_ptr), value :: layout
end function

! void pango_layout_set_alignment (PangoLayout *layout, PangoAlignment alignment);
subroutine pango_layout_set_alignment(layout, alignment) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  integer(c_int), value :: alignment
end subroutine

! PangoAlignment pango_layout_get_alignment (PangoLayout *layout);
function pango_layout_get_alignment(layout) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_layout_get_alignment
  type(c_ptr), value :: layout
end function

!  void pango_layout_set_tabs (PangoLayout *layout, PangoTabArray *tabs);
subroutine pango_layout_set_tabs(layout, tabs) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: tabs
end subroutine

!  PangoTabArray* pango_layout_get_tabs (PangoLayout *layout);
function pango_layout_get_tabs(layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_layout_get_tabs
  type(c_ptr), value :: layout
end function

!  void pango_layout_set_single_paragraph_mode (PangoLayout *layout, gboolean setting);
subroutine pango_layout_set_single_paragraph_mode(layout, setting) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: layout
  logical(c_bool), value :: setting
end subroutine

! gboolean pango_layout_get_single_paragraph_mode (PangoLayout *layout);
function pango_layout_get_single_paragraph_mode(layout) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_layout_get_single_paragraph_mode
  type(c_ptr), value :: layout
end function

!  void pango_layout_set_ellipsize (PangoLayout *layout, PangoEllipsizeMode ellipsize);
subroutine pango_layout_set_ellipsize(layout, ellipsize) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  integer(c_int), value :: ellipsize
end subroutine

! PangoEllipsizeMode pango_layout_get_ellipsize (PangoLayout *layout);
function pango_layout_get_ellipsize(layout) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_layout_get_ellipsize
  type(c_ptr), value :: layout
end function

! gboolean pango_layout_is_ellipsized (PangoLayout *layout);
function pango_layout_is_ellipsized(layout) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_layout_is_ellipsized
  type(c_ptr), value :: layout
end function

!  int pango_layout_get_unknown_glyphs_count (PangoLayout *layout);
function pango_layout_get_unknown_glyphs_count(layout) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_layout_get_unknown_glyphs_count
  type(c_ptr), value :: layout
end function

!  void pango_layout_context_changed (PangoLayout *layout);
subroutine pango_layout_context_changed(layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
end subroutine

!  void pango_layout_get_log_attrs (PangoLayout *layout, PangoLogAttr **attrs, gint *n_attrs);
subroutine pango_layout_get_log_attrs(layout, attrs, n_attrs) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: attrs
  type(c_ptr), value :: n_attrs
end subroutine

!  void pango_layout_index_to_pos (PangoLayout *layout, int index_, PangoRectangle *pos);
subroutine pango_layout_index_to_pos(layout, index_, pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  integer(c_int), value :: index_
  type(c_ptr), value :: pos
end subroutine

! void pango_layout_index_to_line_x (PangoLayout *layout, int index_, gboolean trailing, int *line, int *x_pos);
subroutine pango_layout_index_to_line_x(layout, index_, trailing, line, x_pos) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr), value :: layout
  integer(c_int), value :: index_
  logical(c_bool), value :: trailing
  type(c_ptr), value :: line
  type(c_ptr), value :: x_pos
end subroutine

! void pango_layout_get_cursor_pos (PangoLayout *layout, int index_, PangoRectangle *strong_pos, PangoRectangle *weak_pos);
subroutine pango_layout_get_cursor_pos(layout, index_, strong_pos, weak_pos) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: layout
  integer(c_int), value :: index_
  type(c_ptr), value :: strong_pos
  type(c_ptr), value :: weak_pos
end subroutine

! void pango_layout_move_cursor_visually (PangoLayout *layout, gboolean strong, int old_index, int old_trailing, int direction, int *new_index, int *new_trailing);
subroutine pango_layout_move_cursor_visually(layout, strong, old_index, old_trai&
      &ling, direction, new_index, new_trailing) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_int
  type(c_ptr), value :: layout
  logical(c_bool), value :: strong
  integer(c_int), value :: old_index
  integer(c_int), value :: old_trailing
  integer(c_int), value :: direction
  type(c_ptr), value :: new_index
  type(c_ptr), value :: new_trailing
end subroutine

! gboolean pango_layout_xy_to_index (PangoLayout *layout, int x, int y, int *index_, int *trailing);
function pango_layout_xy_to_index(layout, x, y, index_, trailing) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: pango_layout_xy_to_index
  type(c_ptr), value :: layout
  integer(c_int), value :: x
  integer(c_int), value :: y
  type(c_ptr), value :: index_
  type(c_ptr), value :: trailing
end function

! void pango_layout_get_extents (PangoLayout *layout, PangoRectangle *ink_rect, PangoRectangle *logical_rect);
subroutine pango_layout_get_extents(layout, ink_rect, logical_rect) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: ink_rect
  type(c_ptr), value :: logical_rect
end subroutine

! void pango_layout_get_pixel_extents (PangoLayout *layout, PangoRectangle *ink_rect, PangoRectangle *logical_rect);
subroutine pango_layout_get_pixel_extents(layout, ink_rect, logical_rect) bind(c&
      &) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: ink_rect
  type(c_ptr), value :: logical_rect
end subroutine

! void pango_layout_get_size (PangoLayout *layout, int *width, int *height);
subroutine pango_layout_get_size(layout, width, height) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: width
  type(c_ptr), value :: height
end subroutine

! void pango_layout_get_pixel_size (PangoLayout *layout, int *width, int *height);
subroutine pango_layout_get_pixel_size(layout, width, height) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout
  type(c_ptr), value :: width
  type(c_ptr), value :: height
end subroutine

! int pango_layout_get_baseline (PangoLayout *layout);
function pango_layout_get_baseline(layout) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_layout_get_baseline
  type(c_ptr), value :: layout
end function

!  int pango_layout_get_line_count (PangoLayout *layout);
function pango_layout_get_line_count(layout) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_layout_get_line_count
  type(c_ptr), value :: layout
end function

! PangoLayoutLine *pango_layout_get_line (PangoLayout *layout, int line);
function pango_layout_get_line(layout, line) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_layout_get_line
  type(c_ptr), value :: layout
  integer(c_int), value :: line
end function

! PangoLayoutLine *pango_layout_get_line_readonly (PangoLayout *layout, int line);
function pango_layout_get_line_readonly(layout, line) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: pango_layout_get_line_readonly
  type(c_ptr), value :: layout
  integer(c_int), value :: line
end function

! GSList * pango_layout_get_lines (PangoLayout *layout);
function pango_layout_get_lines(layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_layout_get_lines
  type(c_ptr), value :: layout
end function

! GSList * pango_layout_get_lines_readonly (PangoLayout *layout);
function pango_layout_get_lines_readonly(layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_layout_get_lines_readonly
  type(c_ptr), value :: layout
end function

!  GType pango_layout_line_get_type (void) G_GNUC_CONST;
function pango_layout_line_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_layout_line_get_type
end function

!  PangoLayoutLine *pango_layout_line_ref (PangoLayoutLine *line);
function pango_layout_line_ref(line) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_layout_line_ref
  type(c_ptr), value :: line
end function

! void pango_layout_line_unref (PangoLayoutLine *line);
subroutine pango_layout_line_unref(line) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: line
end subroutine

!  gboolean pango_layout_line_x_to_index (PangoLayoutLine *line, int x_pos, int *index_, int *trailing);
function pango_layout_line_x_to_index(line, x_pos, index_, trailing) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: pango_layout_line_x_to_index
  type(c_ptr), value :: line
  integer(c_int), value :: x_pos
  type(c_ptr), value :: index_
  type(c_ptr), value :: trailing
end function

! void pango_layout_line_index_to_x (PangoLayoutLine *line, int index_, gboolean trailing, int *x_pos);
subroutine pango_layout_line_index_to_x(line, index_, trailing, x_pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr), value :: line
  integer(c_int), value :: index_
  logical(c_bool), value :: trailing
  type(c_ptr), value :: x_pos
end subroutine

! void pango_layout_line_get_x_ranges (PangoLayoutLine *line, int start_index, int end_index, int **ranges, int *n_ranges);
subroutine pango_layout_line_get_x_ranges(line, start_index, end_index, ranges, &
      &n_ranges) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: line
  integer(c_int), value :: start_index
  integer(c_int), value :: end_index
  type(c_ptr), value :: ranges
  type(c_ptr), value :: n_ranges
end subroutine

! void pango_layout_line_get_extents (PangoLayoutLine *line, PangoRectangle *ink_rect, PangoRectangle *logical_rect);
subroutine pango_layout_line_get_extents(line, ink_rect, logical_rect) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: line
  type(c_ptr), value :: ink_rect
  type(c_ptr), value :: logical_rect
end subroutine

! void pango_layout_line_get_pixel_extents (PangoLayoutLine *layout_line, PangoRectangle *ink_rect, PangoRectangle *logical_rect);
subroutine pango_layout_line_get_pixel_extents(layout_line, ink_rect, logical_re&
      &ct) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: layout_line
  type(c_ptr), value :: ink_rect
  type(c_ptr), value :: logical_rect
end subroutine

!  GType pango_layout_iter_get_type (void) G_GNUC_CONST;
function pango_layout_iter_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: pango_layout_iter_get_type
end function

!  PangoLayoutIter *pango_layout_get_iter (PangoLayout *layout);
function pango_layout_get_iter(layout) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_layout_get_iter
  type(c_ptr), value :: layout
end function

! PangoLayoutIter *pango_layout_iter_copy (PangoLayoutIter *iter);
function pango_layout_iter_copy(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_layout_iter_copy
  type(c_ptr), value :: iter
end function

! void pango_layout_iter_free (PangoLayoutIter *iter);
subroutine pango_layout_iter_free(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
end subroutine

!  int pango_layout_iter_get_index (PangoLayoutIter *iter);
function pango_layout_iter_get_index(iter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_layout_iter_get_index
  type(c_ptr), value :: iter
end function

! PangoLayoutRun *pango_layout_iter_get_run (PangoLayoutIter *iter);
function pango_layout_iter_get_run(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_layout_iter_get_run
  type(c_ptr), value :: iter
end function

! PangoLayoutRun *pango_layout_iter_get_run_readonly (PangoLayoutIter *iter);
function pango_layout_iter_get_run_readonly(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_layout_iter_get_run_readonly
  type(c_ptr), value :: iter
end function

! PangoLayoutLine *pango_layout_iter_get_line (PangoLayoutIter *iter);
function pango_layout_iter_get_line(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_layout_iter_get_line
  type(c_ptr), value :: iter
end function

! PangoLayoutLine *pango_layout_iter_get_line_readonly (PangoLayoutIter *iter);
function pango_layout_iter_get_line_readonly(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_layout_iter_get_line_readonly
  type(c_ptr), value :: iter
end function

! gboolean pango_layout_iter_at_last_line (PangoLayoutIter *iter);
function pango_layout_iter_at_last_line(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_layout_iter_at_last_line
  type(c_ptr), value :: iter
end function

! PangoLayout *pango_layout_iter_get_layout (PangoLayoutIter *iter);
function pango_layout_iter_get_layout(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: pango_layout_iter_get_layout
  type(c_ptr), value :: iter
end function

!  gboolean pango_layout_iter_next_char (PangoLayoutIter *iter);
function pango_layout_iter_next_char(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_layout_iter_next_char
  type(c_ptr), value :: iter
end function

! gboolean pango_layout_iter_next_cluster (PangoLayoutIter *iter);
function pango_layout_iter_next_cluster(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_layout_iter_next_cluster
  type(c_ptr), value :: iter
end function

! gboolean pango_layout_iter_next_run (PangoLayoutIter *iter);
function pango_layout_iter_next_run(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_layout_iter_next_run
  type(c_ptr), value :: iter
end function

! gboolean pango_layout_iter_next_line (PangoLayoutIter *iter);
function pango_layout_iter_next_line(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: pango_layout_iter_next_line
  type(c_ptr), value :: iter
end function

!  void pango_layout_iter_get_char_extents (PangoLayoutIter *iter, PangoRectangle *logical_rect);
subroutine pango_layout_iter_get_char_extents(iter, logical_rect) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
  type(c_ptr), value :: logical_rect
end subroutine

! void pango_layout_iter_get_cluster_extents (PangoLayoutIter *iter, PangoRectangle *ink_rect, PangoRectangle *logical_rect);
subroutine pango_layout_iter_get_cluster_extents(iter, ink_rect, logical_rect) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
  type(c_ptr), value :: ink_rect
  type(c_ptr), value :: logical_rect
end subroutine

! void pango_layout_iter_get_run_extents (PangoLayoutIter *iter, PangoRectangle *ink_rect, PangoRectangle *logical_rect);
subroutine pango_layout_iter_get_run_extents(iter, ink_rect, logical_rect) bind(&
      &c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
  type(c_ptr), value :: ink_rect
  type(c_ptr), value :: logical_rect
end subroutine

! void pango_layout_iter_get_line_extents (PangoLayoutIter *iter, PangoRectangle *ink_rect, PangoRectangle *logical_rect);
subroutine pango_layout_iter_get_line_extents(iter, ink_rect, logical_rect) bind&
      &(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
  type(c_ptr), value :: ink_rect
  type(c_ptr), value :: logical_rect
end subroutine

!  void pango_layout_iter_get_line_yrange (PangoLayoutIter *iter, int *y0_, int *y1_);
subroutine pango_layout_iter_get_line_yrange(iter, y0_, y1_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
  type(c_ptr), value :: y0_
  type(c_ptr), value :: y1_
end subroutine

! void pango_layout_iter_get_layout_extents (PangoLayoutIter *iter, PangoRectangle *ink_rect, PangoRectangle *logical_rect);
subroutine pango_layout_iter_get_layout_extents(iter, ink_rect, logical_rect) bi&
      &nd(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
  type(c_ptr), value :: ink_rect
  type(c_ptr), value :: logical_rect
end subroutine

! int pango_layout_iter_get_baseline (PangoLayoutIter *iter);
function pango_layout_iter_get_baseline(iter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: pango_layout_iter_get_baseline
  type(c_ptr), value :: iter
end function

!     void gdk_pixbuf_xlib_init (Display *display, int screen_num);
subroutine gdk_pixbuf_xlib_init(display, screen_num) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: display
  integer(c_int), value :: screen_num
end subroutine

!  void gdk_pixbuf_xlib_init_with_depth (Display *display, int screen_num, int prefDepth);
subroutine gdk_pixbuf_xlib_init_with_depth(display, screen_num, prefDepth) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: display
  integer(c_int), value :: screen_num
  integer(c_int), value :: prefDepth
end subroutine

!    void gdk_pixbuf_xlib_render_threshold_alpha (GdkPixbuf *pixbuf, Pixmap bitmap, int src_x, int src_y, int dest_x, int dest_y, int width, int height, int alpha_threshold);
subroutine gdk_pixbuf_xlib_render_threshold_alpha(pixbuf, bitmap, src_x, src_y, &
      &dest_x, dest_y, width, height, alpha_threshold) bind(c) 
  use iso_c_binding, only: c_ptr, c_long, c_int
  type(c_ptr), value :: pixbuf
  integer(c_long), value :: bitmap
  integer(c_int), value :: src_x
  integer(c_int), value :: src_y
  integer(c_int), value :: dest_x
  integer(c_int), value :: dest_y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: alpha_threshold
end subroutine

!  void gdk_pixbuf_xlib_render_to_drawable (GdkPixbuf *pixbuf, Drawable drawable, GC gc, int src_x, int src_y, int dest_x, int dest_y, int width, int height, XlibRgbDither dither, int x_dither, int y_dither);
subroutine gdk_pixbuf_xlib_render_to_drawable(pixbuf, drawable, gc, src_x, src_y&
      &, dest_x, dest_y, width, height, dither, x_dither, y_dither) bind(c) 
  use iso_c_binding, only: c_ptr, c_long, c_int
  type(c_ptr), value :: pixbuf
  integer(c_long), value :: drawable
  type(c_ptr), value :: gc
  integer(c_int), value :: src_x
  integer(c_int), value :: src_y
  integer(c_int), value :: dest_x
  integer(c_int), value :: dest_y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: dither
  integer(c_int), value :: x_dither
  integer(c_int), value :: y_dither
end subroutine

!  void gdk_pixbuf_xlib_render_to_drawable_alpha (GdkPixbuf *pixbuf, Drawable drawable, int src_x, int src_y, int dest_x, int dest_y, int width, int height, GdkPixbufAlphaMode alpha_mode, int alpha_threshold, XlibRgbDither dither, int x_dither, int y_dither);
subroutine gdk_pixbuf_xlib_render_to_drawable_alpha(pixbuf, drawable, src_x, src&
      &_y, dest_x, dest_y, width, height, alpha_mode, alpha_threshold, dither, x&
      &_dither, y_dither) bind(c) 
  use iso_c_binding, only: c_ptr, c_long, c_int
  type(c_ptr), value :: pixbuf
  integer(c_long), value :: drawable
  integer(c_int), value :: src_x
  integer(c_int), value :: src_y
  integer(c_int), value :: dest_x
  integer(c_int), value :: dest_y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: alpha_mode
  integer(c_int), value :: alpha_threshold
  integer(c_int), value :: dither
  integer(c_int), value :: x_dither
  integer(c_int), value :: y_dither
end subroutine

!  void gdk_pixbuf_xlib_render_pixmap_and_mask (GdkPixbuf *pixbuf, Pixmap *pixmap_return, Pixmap *mask_return, int alpha_threshold);
subroutine gdk_pixbuf_xlib_render_pixmap_and_mask(pixbuf, pixmap_return, mask_re&
      &turn, alpha_threshold) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: pixbuf
  type(c_ptr), value :: pixmap_return
  type(c_ptr), value :: mask_return
  integer(c_int), value :: alpha_threshold
end subroutine

!    GdkPixbuf *gdk_pixbuf_xlib_get_from_drawable (GdkPixbuf *dest, Drawable src, Colormap cmap, Visual *visual, int src_x, int src_y, int dest_x, int dest_y, int width, int height);
function gdk_pixbuf_xlib_get_from_drawable(dest, src, cmap, visual, src_x, src_y&
      &, dest_x, dest_y, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_long, c_int
  type(c_ptr) :: gdk_pixbuf_xlib_get_from_drawable
  type(c_ptr), value :: dest
  integer(c_long), value :: src
  integer(c_long), value :: cmap
  type(c_ptr), value :: visual
  integer(c_int), value :: src_x
  integer(c_int), value :: src_y
  integer(c_int), value :: dest_x
  integer(c_int), value :: dest_y
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

!   void xlib_rgb_init (Display *display, Screen *screen);
subroutine xlib_rgb_init(display, screen) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: display
  type(c_ptr), value :: screen
end subroutine

! void xlib_rgb_init_with_depth (Display *display, Screen *screen, int prefDepth);
subroutine xlib_rgb_init_with_depth(display, screen, prefDepth) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: display
  type(c_ptr), value :: screen
  integer(c_int), value :: prefDepth
end subroutine

!  unsigned long xlib_rgb_xpixel_from_rgb (guint32 rgb);
function xlib_rgb_xpixel_from_rgb(rgb) bind(c) 
  use iso_c_binding, only: c_long, c_int32_t
  integer(c_long) :: xlib_rgb_xpixel_from_rgb
  integer(c_int32_t), value :: rgb
end function

!  void xlib_rgb_gc_set_foreground (GC gc, guint32 rgb);
subroutine xlib_rgb_gc_set_foreground(gc, rgb) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: gc
  integer(c_int32_t), value :: rgb
end subroutine

!  void xlib_rgb_gc_set_background (GC gc, guint32 rgb);
subroutine xlib_rgb_gc_set_background(gc, rgb) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: gc
  integer(c_int32_t), value :: rgb
end subroutine

!  void xlib_draw_rgb_image (Drawable drawable, GC gc, int x, int y, int width, int height, XlibRgbDither dith, unsigned char *rgb_buf, int rowstride);
subroutine xlib_draw_rgb_image(drawable, gc, x, y, width, height, dith, rgb_buf,&
      & rowstride) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_int
  integer(c_long), value :: drawable
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: dith
  type(c_ptr), value :: rgb_buf
  integer(c_int), value :: rowstride
end subroutine

!  void xlib_draw_rgb_image_dithalign (Drawable drawable, GC gc, int x, int y, int width, int height, XlibRgbDither dith, unsigned char *rgb_buf, int rowstride, int xdith, int ydith);
subroutine xlib_draw_rgb_image_dithalign(drawable, gc, x, y, width, height, dith&
      &, rgb_buf, rowstride, xdith, ydith) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_int
  integer(c_long), value :: drawable
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: dith
  type(c_ptr), value :: rgb_buf
  integer(c_int), value :: rowstride
  integer(c_int), value :: xdith
  integer(c_int), value :: ydith
end subroutine

!  void xlib_draw_rgb_32_image (Drawable drawable, GC gc, int x, int y, int width, int height, XlibRgbDither dith, unsigned char *buf, int rowstride);
subroutine xlib_draw_rgb_32_image(drawable, gc, x, y, width, height, dith, buf, &
      &rowstride) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_int
  integer(c_long), value :: drawable
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: dith
  type(c_ptr), value :: buf
  integer(c_int), value :: rowstride
end subroutine

!  void xlib_draw_gray_image (Drawable drawable, GC gc, int x, int y, int width, int height, XlibRgbDither dith, unsigned char *buf, int rowstride);
subroutine xlib_draw_gray_image(drawable, gc, x, y, width, height, dith, buf, ro&
      &wstride) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_int
  integer(c_long), value :: drawable
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: dith
  type(c_ptr), value :: buf
  integer(c_int), value :: rowstride
end subroutine

!  XlibRgbCmap * xlib_rgb_cmap_new (guint32 *colors, int n_colors);
function xlib_rgb_cmap_new(colors, n_colors) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: xlib_rgb_cmap_new
  type(c_ptr), value :: colors
  integer(c_int), value :: n_colors
end function

!  void xlib_rgb_cmap_free (XlibRgbCmap *cmap);
subroutine xlib_rgb_cmap_free(cmap) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cmap
end subroutine

!  void xlib_draw_indexed_image (Drawable drawable, GC gc, int x, int y, int width, int height, XlibRgbDither dith, unsigned char *buf, int rowstride, XlibRgbCmap *cmap);
subroutine xlib_draw_indexed_image(drawable, gc, x, y, width, height, dith, buf,&
      & rowstride, cmap) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_int
  integer(c_long), value :: drawable
  type(c_ptr), value :: gc
  integer(c_int), value :: x
  integer(c_int), value :: y
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: dith
  type(c_ptr), value :: buf
  integer(c_int), value :: rowstride
  type(c_ptr), value :: cmap
end subroutine

!  Bool xlib_rgb_ditherable (void);
function xlib_rgb_ditherable() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: xlib_rgb_ditherable
end function

!  void xlib_rgb_set_verbose (Bool verbose);
subroutine xlib_rgb_set_verbose(verbose) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: verbose
end subroutine

!  void xlib_rgb_set_install (Bool install);
subroutine xlib_rgb_set_install(install) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: install
end subroutine

!  void xlib_rgb_set_min_colors (int min_colors);
subroutine xlib_rgb_set_min_colors(min_colors) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: min_colors
end subroutine

!  Colormap xlib_rgb_get_cmap (void);
function xlib_rgb_get_cmap() bind(c) 
  use iso_c_binding, only: c_long
  integer(c_long) :: xlib_rgb_get_cmap
end function

!  Visual * xlib_rgb_get_visual (void);
function xlib_rgb_get_visual() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: xlib_rgb_get_visual
end function

!  XVisualInfo * xlib_rgb_get_visual_info (void);
function xlib_rgb_get_visual_info() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: xlib_rgb_get_visual_info
end function

!  int xlib_rgb_get_depth (void);
function xlib_rgb_get_depth() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: xlib_rgb_get_depth
end function

!  Display * xlib_rgb_get_display (void);
function xlib_rgb_get_display() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: xlib_rgb_get_display
end function

!  Screen * xlib_rgb_get_screen (void);
function xlib_rgb_get_screen() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: xlib_rgb_get_screen
end function

!   GType gdk_pixbuf_simple_anim_get_type (void) G_GNUC_CONST;
function gdk_pixbuf_simple_anim_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_pixbuf_simple_anim_get_type
end function

! GType gdk_pixbuf_simple_anim_iter_get_type (void) G_GNUC_CONST;
function gdk_pixbuf_simple_anim_iter_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_pixbuf_simple_anim_iter_get_type
end function

!  GdkPixbufSimpleAnim *gdk_pixbuf_simple_anim_new (gint width, gint height, gfloat rate);
function gdk_pixbuf_simple_anim_new(width, height, rate) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_float
  type(c_ptr) :: gdk_pixbuf_simple_anim_new
  integer(c_int), value :: width
  integer(c_int), value :: height
  real(c_float), value :: rate
end function

! void gdk_pixbuf_simple_anim_add_frame (GdkPixbufSimpleAnim *animation, GdkPixbuf *pixbuf);
subroutine gdk_pixbuf_simple_anim_add_frame(animation, pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: animation
  type(c_ptr), value :: pixbuf
end subroutine

! void gdk_pixbuf_simple_anim_set_loop (GdkPixbufSimpleAnim *animation, gboolean loop);
subroutine gdk_pixbuf_simple_anim_set_loop(animation, loop) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: animation
  logical(c_bool), value :: loop
end subroutine

! gboolean gdk_pixbuf_simple_anim_get_loop (GdkPixbufSimpleAnim *animation);
function gdk_pixbuf_simple_anim_get_loop(animation) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_pixbuf_simple_anim_get_loop
  type(c_ptr), value :: animation
end function

!   GType gdk_pixbuf_alpha_mode_get_type (void) G_GNUC_CONST;
function gdk_pixbuf_alpha_mode_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_pixbuf_alpha_mode_get_type
end function

!  GType gdk_colorspace_get_type (void) G_GNUC_CONST;
function gdk_colorspace_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_colorspace_get_type
end function

!  GType gdk_pixbuf_error_get_type (void) G_GNUC_CONST;
function gdk_pixbuf_error_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_pixbuf_error_get_type
end function

!  GType gdk_interp_type_get_type (void) G_GNUC_CONST;
function gdk_interp_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_interp_type_get_type
end function

!  GType gdk_pixbuf_rotation_get_type (void) G_GNUC_CONST;
function gdk_pixbuf_rotation_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_pixbuf_rotation_get_type
end function

!   GType gdk_pixbuf_loader_get_type (void) G_GNUC_CONST;
function gdk_pixbuf_loader_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_pixbuf_loader_get_type
end function

! GdkPixbufLoader * gdk_pixbuf_loader_new (void);
function gdk_pixbuf_loader_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_loader_new
end function

! GdkPixbufLoader * gdk_pixbuf_loader_new_with_type (const char *image_type, GError **error);
function gdk_pixbuf_loader_new_with_type(image_type, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_pixbuf_loader_new_with_type
  character(kind=c_char), dimension(*) :: image_type
  type(c_ptr), value :: error
end function

! GdkPixbufLoader * gdk_pixbuf_loader_new_with_mime_type (const char *mime_type, GError **error);
function gdk_pixbuf_loader_new_with_mime_type(mime_type, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_pixbuf_loader_new_with_mime_type
  character(kind=c_char), dimension(*) :: mime_type
  type(c_ptr), value :: error
end function

! void gdk_pixbuf_loader_set_size (GdkPixbufLoader *loader, int width, int height);
subroutine gdk_pixbuf_loader_set_size(loader, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: loader
  integer(c_int), value :: width
  integer(c_int), value :: height
end subroutine

! gboolean gdk_pixbuf_loader_write (GdkPixbufLoader *loader, const guchar *buf, gsize count, GError **error);
function gdk_pixbuf_loader_write(loader, buf, count, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char, c_size_t
  logical(c_bool) :: gdk_pixbuf_loader_write
  type(c_ptr), value :: loader
  character(kind=c_char), dimension(*) :: buf
  integer(c_size_t), value :: count
  type(c_ptr), value :: error
end function

! GdkPixbuf * gdk_pixbuf_loader_get_pixbuf (GdkPixbufLoader *loader);
function gdk_pixbuf_loader_get_pixbuf(loader) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_loader_get_pixbuf
  type(c_ptr), value :: loader
end function

! GdkPixbufAnimation * gdk_pixbuf_loader_get_animation (GdkPixbufLoader *loader);
function gdk_pixbuf_loader_get_animation(loader) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_loader_get_animation
  type(c_ptr), value :: loader
end function

! gboolean gdk_pixbuf_loader_close (GdkPixbufLoader *loader, GError **error);
function gdk_pixbuf_loader_close(loader, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_pixbuf_loader_close
  type(c_ptr), value :: loader
  type(c_ptr), value :: error
end function

! GdkPixbufFormat *gdk_pixbuf_loader_get_format (GdkPixbufLoader *loader);
function gdk_pixbuf_loader_get_format(loader) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_loader_get_format
  type(c_ptr), value :: loader
end function

!   guint8* gdk_pixdata_serialize (const GdkPixdata *pixdata, guint *stream_length_p);
function gdk_pixdata_serialize(pixdata, stream_length_p) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixdata_serialize
  type(c_ptr), value :: pixdata
  type(c_ptr), value :: stream_length_p
end function

! gboolean gdk_pixdata_deserialize (GdkPixdata *pixdata, guint stream_length, const guint8 *stream, GError **error);
function gdk_pixdata_deserialize(pixdata, stream_length, stream, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_int
  logical(c_bool) :: gdk_pixdata_deserialize
  type(c_ptr), value :: pixdata
  integer(c_int), value :: stream_length
  type(c_ptr), value :: stream
  type(c_ptr), value :: error
end function

! gpointer gdk_pixdata_from_pixbuf (GdkPixdata *pixdata, const GdkPixbuf *pixbuf, gboolean use_rle);
function gdk_pixdata_from_pixbuf(pixdata, pixbuf, use_rle) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: gdk_pixdata_from_pixbuf
  type(c_ptr), value :: pixdata
  type(c_ptr), value :: pixbuf
  logical(c_bool), value :: use_rle
end function

! GdkPixbuf* gdk_pixbuf_from_pixdata (const GdkPixdata *pixdata, gboolean copy_pixels, GError **error);
function gdk_pixbuf_from_pixdata(pixdata, copy_pixels, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: gdk_pixbuf_from_pixdata
  type(c_ptr), value :: pixdata
  logical(c_bool), value :: copy_pixels
  type(c_ptr), value :: error
end function

!    GString* gdk_pixdata_to_csource (GdkPixdata *pixdata, const gchar *name, GdkPixdataDumpType dump_type);
function gdk_pixdata_to_csource(pixdata, name, dump_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: gdk_pixdata_to_csource
  type(c_ptr), value :: pixdata
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: dump_type
end function

!   GQuark gdk_pixbuf_error_quark (void);
function gdk_pixbuf_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: gdk_pixbuf_error_quark
end function

!    GType gdk_pixbuf_get_type (void) G_GNUC_CONST;
function gdk_pixbuf_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_pixbuf_get_type
end function

!  GdkPixbuf *gdk_pixbuf_ref (GdkPixbuf *pixbuf);
function gdk_pixbuf_ref(pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_ref
  type(c_ptr), value :: pixbuf
end function

! void gdk_pixbuf_unref (GdkPixbuf *pixbuf);
subroutine gdk_pixbuf_unref(pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pixbuf
end subroutine

!  GdkColorspace gdk_pixbuf_get_colorspace (const GdkPixbuf *pixbuf);
function gdk_pixbuf_get_colorspace(pixbuf) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_pixbuf_get_colorspace
  type(c_ptr), value :: pixbuf
end function

! int gdk_pixbuf_get_n_channels (const GdkPixbuf *pixbuf);
function gdk_pixbuf_get_n_channels(pixbuf) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_pixbuf_get_n_channels
  type(c_ptr), value :: pixbuf
end function

! gboolean gdk_pixbuf_get_has_alpha (const GdkPixbuf *pixbuf);
function gdk_pixbuf_get_has_alpha(pixbuf) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_pixbuf_get_has_alpha
  type(c_ptr), value :: pixbuf
end function

! int gdk_pixbuf_get_bits_per_sample (const GdkPixbuf *pixbuf);
function gdk_pixbuf_get_bits_per_sample(pixbuf) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_pixbuf_get_bits_per_sample
  type(c_ptr), value :: pixbuf
end function

! guchar *gdk_pixbuf_get_pixels (const GdkPixbuf *pixbuf);
function gdk_pixbuf_get_pixels(pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_get_pixels
  type(c_ptr), value :: pixbuf
end function

! int gdk_pixbuf_get_width (const GdkPixbuf *pixbuf);
function gdk_pixbuf_get_width(pixbuf) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_pixbuf_get_width
  type(c_ptr), value :: pixbuf
end function

! int gdk_pixbuf_get_height (const GdkPixbuf *pixbuf);
function gdk_pixbuf_get_height(pixbuf) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_pixbuf_get_height
  type(c_ptr), value :: pixbuf
end function

! int gdk_pixbuf_get_rowstride (const GdkPixbuf *pixbuf);
function gdk_pixbuf_get_rowstride(pixbuf) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_pixbuf_get_rowstride
  type(c_ptr), value :: pixbuf
end function

!    GdkPixbuf *gdk_pixbuf_new (GdkColorspace colorspace, gboolean has_alpha, int bits_per_sample, int width, int height);
function gdk_pixbuf_new(colorspace, has_alpha, bits_per_sample, width, height) b&
      &ind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr) :: gdk_pixbuf_new
  integer(c_int), value :: colorspace
  logical(c_bool), value :: has_alpha
  integer(c_int), value :: bits_per_sample
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

!  GdkPixbuf *gdk_pixbuf_copy (const GdkPixbuf *pixbuf);
function gdk_pixbuf_copy(pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_copy
  type(c_ptr), value :: pixbuf
end function

!  GdkPixbuf *gdk_pixbuf_new_subpixbuf (GdkPixbuf *src_pixbuf, int src_x, int src_y, int width, int height);
function gdk_pixbuf_new_subpixbuf(src_pixbuf, src_x, src_y, width, height) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_pixbuf_new_subpixbuf
  type(c_ptr), value :: src_pixbuf
  integer(c_int), value :: src_x
  integer(c_int), value :: src_y
  integer(c_int), value :: width
  integer(c_int), value :: height
end function

!  GdkPixbuf *gdk_pixbuf_new_from_file (const char *filename, GError **error);
function gdk_pixbuf_new_from_file(filename, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_pixbuf_new_from_file
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: error
end function

! GdkPixbuf *gdk_pixbuf_new_from_file_at_size (const char *filename, int width, int height, GError **error);
function gdk_pixbuf_new_from_file_at_size(filename, width, height, error) bind(c&
      &) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: gdk_pixbuf_new_from_file_at_size
  character(kind=c_char), dimension(*) :: filename
  integer(c_int), value :: width
  integer(c_int), value :: height
  type(c_ptr), value :: error
end function

! GdkPixbuf *gdk_pixbuf_new_from_file_at_scale (const char *filename, int width, int height, gboolean preserve_aspect_ratio, GError **error);
function gdk_pixbuf_new_from_file_at_scale(filename, width, height, preserve_asp&
      &ect_ratio, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_bool
  type(c_ptr) :: gdk_pixbuf_new_from_file_at_scale
  character(kind=c_char), dimension(*) :: filename
  integer(c_int), value :: width
  integer(c_int), value :: height
  logical(c_bool), value :: preserve_aspect_ratio
  type(c_ptr), value :: error
end function

!  GdkPixbuf *gdk_pixbuf_new_from_data (const guchar *data, GdkColorspace colorspace, gboolean has_alpha, int bits_per_sample, int width, int height, int rowstride, GdkPixbufDestroyNotify destroy_fn, gpointer destroy_fn_data);
function gdk_pixbuf_new_from_data(data, colorspace, has_alpha, bits_per_sample, &
      &width, height, rowstride, destroy_fn, destroy_fn_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_bool, c_funptr
  type(c_ptr) :: gdk_pixbuf_new_from_data
  character(kind=c_char), dimension(*) :: data
  integer(c_int), value :: colorspace
  logical(c_bool), value :: has_alpha
  integer(c_int), value :: bits_per_sample
  integer(c_int), value :: width
  integer(c_int), value :: height
  integer(c_int), value :: rowstride
  type(c_funptr), value :: destroy_fn
  type(c_ptr), value :: destroy_fn_data
end function

!  GdkPixbuf *gdk_pixbuf_new_from_xpm_data (const char **data);
function gdk_pixbuf_new_from_xpm_data(data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_pixbuf_new_from_xpm_data
  character(kind=c_char), dimension(*) :: data
end function

! GdkPixbuf* gdk_pixbuf_new_from_inline (gint data_length, const guint8 *data, gboolean copy_pixels, GError **error);
function gdk_pixbuf_new_from_inline(data_length, data, copy_pixels, error) bind(&
      &c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr) :: gdk_pixbuf_new_from_inline
  integer(c_int), value :: data_length
  type(c_ptr), value :: data
  logical(c_bool), value :: copy_pixels
  type(c_ptr), value :: error
end function

!   void gdk_pixbuf_fill (GdkPixbuf *pixbuf, guint32 pixel);
subroutine gdk_pixbuf_fill(pixbuf, pixel) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: pixbuf
  integer(c_int32_t), value :: pixel
end subroutine

!  gboolean gdk_pixbuf_savev (GdkPixbuf *pixbuf, const char *filename, const char *type, char **option_keys, char **option_values, GError **error);
function gdk_pixbuf_savev(pixbuf, filename, type, option_keys, option_values, er&
      &ror) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gdk_pixbuf_savev
  type(c_ptr), value :: pixbuf
  character(kind=c_char), dimension(*) :: filename
  character(kind=c_char), dimension(*) :: type
  character(kind=c_char), dimension(*) :: option_keys
  character(kind=c_char), dimension(*) :: option_values
  type(c_ptr), value :: error
end function

!  gboolean gdk_pixbuf_save_to_callbackv (GdkPixbuf *pixbuf, GdkPixbufSaveFunc save_func, gpointer user_data, const char *type, char **option_keys, char **option_values, GError **error);
function gdk_pixbuf_save_to_callbackv(pixbuf, save_func, user_data, type, option&
      &_keys, option_values, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_funptr, c_char
  logical(c_bool) :: gdk_pixbuf_save_to_callbackv
  type(c_ptr), value :: pixbuf
  type(c_funptr), value :: save_func
  type(c_ptr), value :: user_data
  character(kind=c_char), dimension(*) :: type
  character(kind=c_char), dimension(*) :: option_keys
  character(kind=c_char), dimension(*) :: option_values
  type(c_ptr), value :: error
end function

!  gboolean gdk_pixbuf_save_to_bufferv (GdkPixbuf *pixbuf, gchar **buffer, gsize *buffer_size, const char *type, char **option_keys, char **option_values, GError **error);
function gdk_pixbuf_save_to_bufferv(pixbuf, buffer, buffer_size, type, option_ke&
      &ys, option_values, error) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gdk_pixbuf_save_to_bufferv
  type(c_ptr), value :: pixbuf
  character(kind=c_char), dimension(*) :: buffer
  type(c_ptr), value :: buffer_size
  character(kind=c_char), dimension(*) :: type
  character(kind=c_char), dimension(*) :: option_keys
  character(kind=c_char), dimension(*) :: option_values
  type(c_ptr), value :: error
end function

!  GdkPixbuf *gdk_pixbuf_new_from_stream (GInputStream *stream, GCancellable *cancellable, GError **error);
function gdk_pixbuf_new_from_stream(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_new_from_stream
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  GdkPixbuf *gdk_pixbuf_new_from_stream_at_scale (GInputStream *stream, gint width, gint height, gboolean preserve_aspect_ratio, GCancellable *cancellable, GError **error);
function gdk_pixbuf_new_from_stream_at_scale(stream, width, height, preserve_asp&
      &ect_ratio, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_bool
  type(c_ptr) :: gdk_pixbuf_new_from_stream_at_scale
  type(c_ptr), value :: stream
  integer(c_int), value :: width
  integer(c_int), value :: height
  logical(c_bool), value :: preserve_aspect_ratio
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  GdkPixbuf *gdk_pixbuf_add_alpha (const GdkPixbuf *pixbuf, gboolean substitute_color, guchar r, guchar g, guchar b);
function gdk_pixbuf_add_alpha(pixbuf, substitute_color, r, g, b) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool, c_char
  type(c_ptr) :: gdk_pixbuf_add_alpha
  type(c_ptr), value :: pixbuf
  logical(c_bool), value :: substitute_color
  character(c_char), value :: r
  character(c_char), value :: g
  character(c_char), value :: b
end function

!  void gdk_pixbuf_copy_area (const GdkPixbuf *src_pixbuf, int src_x, int src_y, int width, int height, GdkPixbuf *dest_pixbuf, int dest_x, int dest_y);
subroutine gdk_pixbuf_copy_area(src_pixbuf, src_x, src_y, width, height, dest_pi&
      &xbuf, dest_x, dest_y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: src_pixbuf
  integer(c_int), value :: src_x
  integer(c_int), value :: src_y
  integer(c_int), value :: width
  integer(c_int), value :: height
  type(c_ptr), value :: dest_pixbuf
  integer(c_int), value :: dest_x
  integer(c_int), value :: dest_y
end subroutine

!  void gdk_pixbuf_saturate_and_pixelate (const GdkPixbuf *src, GdkPixbuf *dest, gfloat saturation, gboolean pixelate);
subroutine gdk_pixbuf_saturate_and_pixelate(src, dest, saturation, pixelate) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_float, c_bool
  type(c_ptr), value :: src
  type(c_ptr), value :: dest
  real(c_float), value :: saturation
  logical(c_bool), value :: pixelate
end subroutine

!  GdkPixbuf *gdk_pixbuf_apply_embedded_orientation (GdkPixbuf *src);
function gdk_pixbuf_apply_embedded_orientation(src) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_apply_embedded_orientation
  type(c_ptr), value :: src
end function

!  G_CONST_RETURN gchar * gdk_pixbuf_get_option (GdkPixbuf *pixbuf, const gchar *key);
function gdk_pixbuf_get_option(pixbuf, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_pixbuf_get_option
  type(c_ptr), value :: pixbuf
  character(kind=c_char), dimension(*) :: key
end function

!    GType gdk_pixbuf_format_get_type (void) G_GNUC_CONST;
function gdk_pixbuf_format_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_pixbuf_format_get_type
end function

!  GSList *gdk_pixbuf_get_formats (void);
function gdk_pixbuf_get_formats() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_get_formats
end function

! gchar *gdk_pixbuf_format_get_name (GdkPixbufFormat *format);
function gdk_pixbuf_format_get_name(format) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_format_get_name
  type(c_ptr), value :: format
end function

! gchar *gdk_pixbuf_format_get_description (GdkPixbufFormat *format);
function gdk_pixbuf_format_get_description(format) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_format_get_description
  type(c_ptr), value :: format
end function

! gchar **gdk_pixbuf_format_get_mime_types (GdkPixbufFormat *format);
function gdk_pixbuf_format_get_mime_types(format) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_format_get_mime_types
  type(c_ptr), value :: format
end function

! gchar **gdk_pixbuf_format_get_extensions (GdkPixbufFormat *format);
function gdk_pixbuf_format_get_extensions(format) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_format_get_extensions
  type(c_ptr), value :: format
end function

! gboolean gdk_pixbuf_format_is_writable (GdkPixbufFormat *format);
function gdk_pixbuf_format_is_writable(format) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_pixbuf_format_is_writable
  type(c_ptr), value :: format
end function

! gboolean gdk_pixbuf_format_is_scalable (GdkPixbufFormat *format);
function gdk_pixbuf_format_is_scalable(format) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_pixbuf_format_is_scalable
  type(c_ptr), value :: format
end function

! gboolean gdk_pixbuf_format_is_disabled (GdkPixbufFormat *format);
function gdk_pixbuf_format_is_disabled(format) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_pixbuf_format_is_disabled
  type(c_ptr), value :: format
end function

! void gdk_pixbuf_format_set_disabled (GdkPixbufFormat *format, gboolean disabled);
subroutine gdk_pixbuf_format_set_disabled(format, disabled) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr), value :: format
  logical(c_bool), value :: disabled
end subroutine

! gchar *gdk_pixbuf_format_get_license (GdkPixbufFormat *format);
function gdk_pixbuf_format_get_license(format) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_format_get_license
  type(c_ptr), value :: format
end function

!  GdkPixbufFormat *gdk_pixbuf_get_file_info (const gchar *filename, gint *width, gint *height);
function gdk_pixbuf_get_file_info(filename, width, height) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_pixbuf_get_file_info
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: width
  type(c_ptr), value :: height
end function

!  GdkPixbufFormat *gdk_pixbuf_format_copy (const GdkPixbufFormat *format);
function gdk_pixbuf_format_copy(format) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_format_copy
  type(c_ptr), value :: format
end function

! void gdk_pixbuf_format_free (GdkPixbufFormat *format);
subroutine gdk_pixbuf_format_free(format) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: format
end subroutine

!    gboolean gdk_pixbuf_set_option (GdkPixbuf *pixbuf, const gchar *key, const gchar *value);
function gdk_pixbuf_set_option(pixbuf, key, value) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr, c_char
  logical(c_bool) :: gdk_pixbuf_set_option
  type(c_ptr), value :: pixbuf
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: value
end function

!   GType gdk_pixbuf_animation_get_type (void) G_GNUC_CONST;
function gdk_pixbuf_animation_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_pixbuf_animation_get_type
end function

!  GdkPixbufAnimation *gdk_pixbuf_animation_new_from_file (const char *filename, GError **error);
function gdk_pixbuf_animation_new_from_file(filename, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: gdk_pixbuf_animation_new_from_file
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: error
end function

!  GdkPixbufAnimation *gdk_pixbuf_animation_ref (GdkPixbufAnimation *animation);
function gdk_pixbuf_animation_ref(animation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_animation_ref
  type(c_ptr), value :: animation
end function

! void gdk_pixbuf_animation_unref (GdkPixbufAnimation *animation);
subroutine gdk_pixbuf_animation_unref(animation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: animation
end subroutine

!  int gdk_pixbuf_animation_get_width (GdkPixbufAnimation *animation);
function gdk_pixbuf_animation_get_width(animation) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_pixbuf_animation_get_width
  type(c_ptr), value :: animation
end function

! int gdk_pixbuf_animation_get_height (GdkPixbufAnimation *animation);
function gdk_pixbuf_animation_get_height(animation) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_pixbuf_animation_get_height
  type(c_ptr), value :: animation
end function

! gboolean gdk_pixbuf_animation_is_static_image (GdkPixbufAnimation *animation);
function gdk_pixbuf_animation_is_static_image(animation) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_pixbuf_animation_is_static_image
  type(c_ptr), value :: animation
end function

! GdkPixbuf *gdk_pixbuf_animation_get_static_image (GdkPixbufAnimation *animation);
function gdk_pixbuf_animation_get_static_image(animation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_animation_get_static_image
  type(c_ptr), value :: animation
end function

!  GdkPixbufAnimationIter *gdk_pixbuf_animation_get_iter (GdkPixbufAnimation *animation, const GTimeVal *start_time);
function gdk_pixbuf_animation_get_iter(animation, start_time) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_animation_get_iter
  type(c_ptr), value :: animation
  type(c_ptr), value :: start_time
end function

! GType gdk_pixbuf_animation_iter_get_type (void) G_GNUC_CONST;
function gdk_pixbuf_animation_iter_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_pixbuf_animation_iter_get_type
end function

! int gdk_pixbuf_animation_iter_get_delay_time (GdkPixbufAnimationIter *iter);
function gdk_pixbuf_animation_iter_get_delay_time(iter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: gdk_pixbuf_animation_iter_get_delay_time
  type(c_ptr), value :: iter
end function

! GdkPixbuf *gdk_pixbuf_animation_iter_get_pixbuf (GdkPixbufAnimationIter *iter);
function gdk_pixbuf_animation_iter_get_pixbuf(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_animation_iter_get_pixbuf
  type(c_ptr), value :: iter
end function

! gboolean gdk_pixbuf_animation_iter_on_currently_loading_frame (GdkPixbufAnimationIter *iter);
function gdk_pixbuf_animation_iter_on_currently_loading_frame(iter) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_pixbuf_animation_iter_on_currently_loading_frame
  type(c_ptr), value :: iter
end function

! gboolean gdk_pixbuf_animation_iter_advance (GdkPixbufAnimationIter *iter, const GTimeVal *current_time);
function gdk_pixbuf_animation_iter_advance(iter, current_time) bind(c) 
  use iso_c_binding, only: c_bool, c_ptr
  logical(c_bool) :: gdk_pixbuf_animation_iter_advance
  type(c_ptr), value :: iter
  type(c_ptr), value :: current_time
end function

!        GType gdk_pixbuf_non_anim_get_type (void) G_GNUC_CONST;
function gdk_pixbuf_non_anim_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: gdk_pixbuf_non_anim_get_type
end function

! GdkPixbufAnimation* gdk_pixbuf_non_anim_new (GdkPixbuf *pixbuf);
function gdk_pixbuf_non_anim_new(pixbuf) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: gdk_pixbuf_non_anim_new
  type(c_ptr), value :: pixbuf
end function

!   void gdk_pixbuf_scale (const GdkPixbuf *src, GdkPixbuf *dest, int dest_x, int dest_y, int dest_width, int dest_height, double offset_x, double offset_y, double scale_x, double scale_y, GdkInterpType interp_type);
subroutine gdk_pixbuf_scale(src, dest, dest_x, dest_y, dest_width, dest_height, &
      &offset_x, offset_y, scale_x, scale_y, interp_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_double
  type(c_ptr), value :: src
  type(c_ptr), value :: dest
  integer(c_int), value :: dest_x
  integer(c_int), value :: dest_y
  integer(c_int), value :: dest_width
  integer(c_int), value :: dest_height
  real(c_double), value :: offset_x
  real(c_double), value :: offset_y
  real(c_double), value :: scale_x
  real(c_double), value :: scale_y
  integer(c_int), value :: interp_type
end subroutine

! void gdk_pixbuf_composite (const GdkPixbuf *src, GdkPixbuf *dest, int dest_x, int dest_y, int dest_width, int dest_height, double offset_x, double offset_y, double scale_x, double scale_y, GdkInterpType interp_type, int overall_alpha);
subroutine gdk_pixbuf_composite(src, dest, dest_x, dest_y, dest_width, dest_heig&
      &ht, offset_x, offset_y, scale_x, scale_y, interp_type, overall_alpha) bin&
      &d(c) 
  use iso_c_binding, only: c_ptr, c_int, c_double
  type(c_ptr), value :: src
  type(c_ptr), value :: dest
  integer(c_int), value :: dest_x
  integer(c_int), value :: dest_y
  integer(c_int), value :: dest_width
  integer(c_int), value :: dest_height
  real(c_double), value :: offset_x
  real(c_double), value :: offset_y
  real(c_double), value :: scale_x
  real(c_double), value :: scale_y
  integer(c_int), value :: interp_type
  integer(c_int), value :: overall_alpha
end subroutine

! void gdk_pixbuf_composite_color (const GdkPixbuf *src, GdkPixbuf *dest, int dest_x, int dest_y, int dest_width, int dest_height, double offset_x, double offset_y, double scale_x, double scale_y, GdkInterpType interp_type, int overall_alpha, int check_x, int check_y, int check_size, guint32 color1, guint32 color2);
subroutine gdk_pixbuf_composite_color(src, dest, dest_x, dest_y, dest_width, des&
      &t_height, offset_x, offset_y, scale_x, scale_y, interp_type, overall_alph&
      &a, check_x, check_y, check_size, color1, color2) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_double, c_int32_t
  type(c_ptr), value :: src
  type(c_ptr), value :: dest
  integer(c_int), value :: dest_x
  integer(c_int), value :: dest_y
  integer(c_int), value :: dest_width
  integer(c_int), value :: dest_height
  real(c_double), value :: offset_x
  real(c_double), value :: offset_y
  real(c_double), value :: scale_x
  real(c_double), value :: scale_y
  integer(c_int), value :: interp_type
  integer(c_int), value :: overall_alpha
  integer(c_int), value :: check_x
  integer(c_int), value :: check_y
  integer(c_int), value :: check_size
  integer(c_int32_t), value :: color1
  integer(c_int32_t), value :: color2
end subroutine

!  GdkPixbuf *gdk_pixbuf_scale_simple (const GdkPixbuf *src, int dest_width, int dest_height, GdkInterpType interp_type);
function gdk_pixbuf_scale_simple(src, dest_width, dest_height, interp_type) bind&
      &(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_pixbuf_scale_simple
  type(c_ptr), value :: src
  integer(c_int), value :: dest_width
  integer(c_int), value :: dest_height
  integer(c_int), value :: interp_type
end function

!  GdkPixbuf *gdk_pixbuf_composite_color_simple (const GdkPixbuf *src, int dest_width, int dest_height, GdkInterpType interp_type, int overall_alpha, int check_size, guint32 color1, guint32 color2);
function gdk_pixbuf_composite_color_simple(src, dest_width, dest_height, interp_&
      &type, overall_alpha, check_size, color1, color2) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int32_t
  type(c_ptr) :: gdk_pixbuf_composite_color_simple
  type(c_ptr), value :: src
  integer(c_int), value :: dest_width
  integer(c_int), value :: dest_height
  integer(c_int), value :: interp_type
  integer(c_int), value :: overall_alpha
  integer(c_int), value :: check_size
  integer(c_int32_t), value :: color1
  integer(c_int32_t), value :: color2
end function

!  GdkPixbuf *gdk_pixbuf_rotate_simple (const GdkPixbuf *src, GdkPixbufRotation angle);
function gdk_pixbuf_rotate_simple(src, angle) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: gdk_pixbuf_rotate_simple
  type(c_ptr), value :: src
  integer(c_int), value :: angle
end function

! GdkPixbuf *gdk_pixbuf_flip (const GdkPixbuf *src, gboolean horizontal);
function gdk_pixbuf_flip(src, horizontal) bind(c) 
  use iso_c_binding, only: c_ptr, c_bool
  type(c_ptr) :: gdk_pixbuf_flip
  type(c_ptr), value :: src
  logical(c_bool), value :: horizontal
end function

